<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Linux - 标签 | ZephyrHe</title><link>https://hezephyr.github.io/tags/linux/</link><description>Linux - 标签 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Wed, 13 Mar 2024 10:31:42 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/tags/linux/" rel="self" type="application/rss+xml"/><item><title>Linux execve函数详解</title><link>https://hezephyr.github.io/posts/05.linux-execve%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 13 Mar 2024 10:31:42 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/05.linux-execve%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid><description><![CDATA[<h2 id="基本介绍" class="heading-element"><span>1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>描述</p>
<blockquote>
<p><code>execve()</code>执行由<code>pathname</code>引用的程序。这会导致当前由调用进程运行的程序被一个新程序替换，该新程序具有新初始化的堆栈、堆和（已初始化和未初始化）数据段。</p>
<p><code>pathname</code>必须是二进制可执行文件或以形式为<code>#!interpreter [optional-arg]</code>开头的脚本。</p>
<p><code>argv</code>是传递给新程序作为其命令行参数的字符串指针数组。按照惯例，这些字符串中第一个（即argv[0]）应包含与正在执行文件相关联的文件名。<font color="red">argv数组必须以NULL指针结尾</font>。（因此，在新程序中，argv[argc]将为NULL）。</p>
<p><code>envp</code>是传递给新程序环境变量的字符串指针数组。该数组包含了环境变量。每个环境变量都是一个 <code>char*</code> 指针，格式为 &ldquo;name=value&rdquo;。envp数组同样必须以NULL指针结尾。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char *envp[] = {
</span></span><span class="line"><span class="cl"> &#34;PATH=/bin&#34;,
</span></span><span class="line"><span class="cl"> &#34;HOME=/home/user&#34;,
</span></span><span class="line"><span class="cl"> &#34;USER=user&#34;,
</span></span><span class="line"><span class="cl"> NULL // 终止环境变量数组
</span></span><span class="line"><span class="cl">};</span></span></code></pre></td></tr></table>
</div>
</div><p><code>argv</code>和<code>envp</code>可以从新程序的主函数访问。例如我们编写的C程序，实际上是由操作系统通过<code>execve()</code>系统调用执行（这里是操作系统先执行<code>fork</code>系统调用，创建一个新的子进程，然后在新的子进程中，操作系统执行<code>execve()</code>系统调用），它会传递这些参数给新程序的主函数，即 main 函数。这些参数定义了新程序执行时的环境和命令行参数，在程序启动时由操作系统设置，并在整个程序执行期间保持不变。这使得程序能够根据传递给它的参数和环境变量来执行不同的任务或调整其行为。</p>
</blockquote>
</li>
<li>
<p>返回值</p>
<blockquote>
<p>成功时，<code>execve()</code> 不返回任何值，当 <code>execve</code> 成功替换当前进程的映像并开始执行新的程序时，原来的进程（即调用 execve 的进程）已经不再存在，因此无法返回任何值。</p>
<p>在出错时返回 -1，并设置适当的 <code>errno</code>。</p>
</blockquote>
</li>
<li>
<p>重点</p>
<blockquote>
<ol>
<li><code>execve</code>实际上就是将当前运行的状态机重置成另一个程序的初始状态</li>
<li>允许对新状态机设置参数 <code>argv</code> (v) 和环境变量 <code>envp</code> (e)</li>
<li>在程序启动时，操作系统首先执行 fork 系统调用，创建一个新的子进程。然后，操作系统在子进程中执行 execve 系统调用，以替换子进程的程序映像并开始执行新的程序。原来的父进程继续执行 fork 之后的代码。</li>
<li>在调用 execve 之前，确保释放所有不再需要的资源，如打开的文件描述符、锁等。</li>
<li>在调用 execve 之前，确保子进程已经处理了所有待处理的信号，除非你希望信号处理程序在新程序中执行。</li>
<li>如果 execve 失败，子进程通常应该终止。</li>
<li>在父进程中，通常会在 fork 之后立即调用 wait 或 waitpid 来等待子进程结束，以确保父进程不会过早退出，从而导致子进程的僵尸进程。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="execve实例" class="heading-element"><span>2 execve实例</span>
  <a href="#execve%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="自定义argv和envp" class="heading-element"><span>2.1 自定义argv和envp</span>
  <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89argv%e5%92%8cenvp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;/bin/bash&#34;</span><span class="p">,</span> <span class="s">&#34;-c&#34;</span><span class="p">,</span> <span class="s">&#34;env&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;HELLO=WORLD&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nf">execve</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello, World!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这段代码中，我们显式的设置了<code>argv</code>和<code>envp</code>，其中参数 <code>&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;env&quot;, NULL</code>，这里的参数实际上是在告诉 <code>bash</code> 执行一个命令（由 <code>-c</code> 后面的字符串指定），在这个例子中是 <code>env</code>，它打印当前的环境变量。</p>
<p>我们运行代码，得到如下输出：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313091345219.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313091345219.png?size=small" data-sub-html="<h2>image-20240313091345219</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313091345219.png" alt="image-20240313091345219" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313091345219.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313091345219.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313091345219.png?size=large 2x" data-title="image-20240313091345219" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果我们不传 <code>-c</code> 参数和随后的命令，即只传入 <code>&quot;/bin/bash&quot;, NULL</code> 作为参数，<code>bash</code> 会默认进入交互式模式。在这种模式下，它不会执行任何命令并立即退出，而是会等待用户输入，表现为进入了 shell 环境。</p>
<p>我们发现，打印的当前环境变量除了自定的<code>envp</code>，还有一些其他的输出。这是因为除了我们设定的环境变量外，还有一些系统或者 shell 默认的环境变量会被添加到新进程中，例如 <code>PWD</code> 表示当前工作目录，<code>SHLVL</code> 表示 shell 层级，<code>_</code> 是上一个执行的命令。这就是为什么我们会看到额外的环境变量出现在输出中。</p>
<h3 id="fork后再通过子进程执行execve" class="heading-element"><span>2.2 fork后再通过子进程执行execve</span>
  <a href="#fork%e5%90%8e%e5%86%8d%e9%80%9a%e8%bf%87%e5%ad%90%e8%bf%9b%e7%a8%8b%e6%89%a7%e8%a1%8cexecve" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;/bin/echo&#34;</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="nf">execve</span><span class="p">(</span><span class="s">&#34;/bin/echo&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 父进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">// 等待子进程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Child process finished.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// fork失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码演示了如何使用 <code>fork()</code> 系统调用创建一个新的子进程，然后在子进程中执行 <code>execve()</code> 系统调用。这是在 Unix-like 系统中常见的操作模式，因为 <code>execve()</code> 系统调用有一些关键的限制：</p>
<ul>
<li>一次机会：<code>execve()</code> 系统调用只能用于替换当前进程的映像一次。如果一个进程已经调用了 <code>execve()</code>，它就不能再调用 <code>fork()</code> 或再次执行 <code>execve()</code>。</li>
<li>无返回值：<code>execve()</code> 成功执行时，原来的进程映像被新程序映像替换，原来的进程不再存在，因此无法返回任何值。如果在 <code>execve()</code> 执行之前有任何返回值，那么这个返回值是在 <code>fork()</code> 调用之后，由父进程获得的。</li>
</ul>
<p>因此，在实际应用中，我们通常会先使用 <code>fork()</code> 创建一个子进程，然后在子进程中调用 <code>execve()</code> 执行新的程序。父进程在 <code>fork()</code> 之后会继续执行，并通过调用 <code>wait(NULL)</code> 来等待子进程结束。这样，父进程可以知道子进程已经成功执行了 <code>execve()</code>，并且可以继续执行其他任务或退出。</p>
<p>在多线程程序中，如果一个线程执行了 <code>fork()</code> 并尝试在子进程中执行 <code>execve()</code>，那么其他线程将继续执行，不受 <code>fork()</code> 和 <code>execve()</code> 的影响。只有调用 <code>fork()</code> 的线程会进入子进程，而其他线程则继续在父进程中运行。</p>
<p>得到的运行结果：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313102827423.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313102827423.png?size=small" data-sub-html="<h2>image-20240313102827423</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313102827423.png" alt="image-20240313102827423" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313102827423.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313102827423.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313102827423.png?size=large 2x" data-title="image-20240313102827423" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>Linux 系统调用函数fork、vfork、clone详解</title><link>https://hezephyr.github.io/posts/04.linux_fork%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link><pubDate>Tue, 12 Mar 2024 21:24:42 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.linux_fork%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid><description><![CDATA[<h2 id="fork" class="heading-element"><span>1 fork</span>
  <a href="#fork" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>1.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>描述</p>
<blockquote>
<p>fork用于创建一个子进程，它与父进程的唯一区别在于其PID和PPID，以及资源利用设置为0。<font color="red">文件锁和挂起信号</font>（指已经被内核发送给一个进程，但尚未被该进程处理的信号）不会被继承，其他和父进程几乎完全相同：<font color="red">会获得父进程的内存空间、栈、数据段、堆、打开的文件描述符、信号处理函数、进程优先级、环境变量等资源的副本。</font></p>
</blockquote>
</li>
<li>
<p>返回值</p>
<blockquote>
<p>成功时，在父进程中返回子进程的 PID，在子进程中返回 $0$。失败时，父进程返回 $-1$，不创建子进程，并适当设置 errno。</p>
<p>其中errno是一个全局变量，它用于表示最近一次系统调用或库函数调用产生的错误代码。当系统调用或库函数失败时，它们通常会设置 errno 以指示错误的原因。</p>
<p>以下是一些常见的 errno 错误代码及其含义：</p>
<ul>
<li>EAGAIN：资源暂时不可用，通常是因为达到了系统限制，如文件描述符或内存限制。</li>
<li>ENOMEM：内存不足，无法分配请求的资源。</li>
<li>EACCES：权限不足，无法访问某个资源。</li>
<li>EINTR：系统调用被信号中断。</li>
<li>EINVAL：无效的参数。</li>
</ul>
</blockquote>
</li>
<li>
<p>重点</p>
<blockquote>
<p>fork() 函数创建的子进程会从父进程复制执行顺序。具体来说，子进程会从父进程复制当前的执行上下文，包括指令指针（instruction pointer）和寄存器的状态。这意味着子进程将从 fork() 系统调用之后的指令开始执行，与父进程在 fork() 之后应该执行的指令完全相同。<font color="red">因此，fork() 之后通常会有一个基于返回值的分支结构，以区分父进程和子进程的执行路径。</font></p>
</blockquote>
</li>
</ul>
<h3 id="fork实例" class="heading-element"><span>1.2 fork实例</span>
  <a href="#fork%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>####.1多个fork返回值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid1</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid2</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid3</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span>  <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The PID of the current process is %d</span><span class="se">\n</span><span class="s"> Hello World from (%d, %d, %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">pid1</span><span class="p">,</span> <span class="n">pid2</span><span class="p">,</span> <span class="n">pid3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段程序包含了三个 fork() 调用，每个 fork() 都会创建一个新的子进程。由于每次 fork() 调用都会导致进程数翻倍，所以总共会有$2^3=8$个进程 （包括最初的父进程）。每个进程都会打印出它的进程 ID (pid) 以及三个 fork() 调用的返回值 (pid1, pid2, pid3)。</p>
<p>得到的输出结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=small" data-sub-html="<h2>image-20240312193151556</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png" alt="image-20240312193151556" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=large 2x" data-title="image-20240312193151556" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们画个状态机来理解它们的输出，假设最初的父进程PID为291871：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=small" data-sub-html="<h2>fork_information</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png" alt="fork_information" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=large 2x" data-title="fork_information" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h4 id="c语言-fork与输出" class="heading-element"><span>1.2.1 C语言 fork与输出</span>
  <a href="#c%e8%af%ad%e8%a8%80-fork%e4%b8%8e%e8%be%93%e5%87%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码中，按我们的理解，第一次fork后有2个进程，然后一起执行printf输出，得到两个<code>Hello</code>，然后第二次fork后有4个进程，然后执行printf，得到四个<code>Hello</code>，则会有6个``Hello`，如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=small" data-sub-html="<h2>image-20240312200038027</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png" alt="image-20240312200038027" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=large 2x" data-title="image-20240312200038027" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>但是当我们将输出通过管道传给<code>cat</code>等命令时，会看到8个<code>Hello</code>：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=small" data-sub-html="<h2>image-20240312200714610</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png" alt="image-20240312200714610" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=large 2x" data-title="image-20240312200714610" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是因为标准输出一般是行缓冲的，碰到<code>\n</code>，缓冲区中的内容会被刷新，即输出到终端或文件中。这种缓冲方式的目的是为了提高效率，因为这样可以减少对磁盘 I/O 的调用次数。</p>
<p>如果标准输出被重定向到管道，它可能不再是行缓冲的，而是变为全缓冲的。这意味着缓冲区可能会在填满时刷新，而不是在每次遇到换行符时刷新。如果缓冲区足够大，以至于可以容纳所有的 <code>Hello</code> 输出，那么fork的时候子进程也会复制缓冲区，导致最后每个进程中的缓冲区都有2个<code>Hello</code>，最后输出为8个。</p>
<p>如果为了确保缓冲区在需要的时候被刷新，可以在 printf 调用之后显式地调用 <code>fflush(stdout)</code> 来刷新标准输出缓冲区。这样可以确保所有的输出都被立即写入，而不会受到缓冲行为的影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=small" data-sub-html="<h2>image-20240312201140424</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png" alt="image-20240312201140424" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=large 2x" data-title="image-20240312201140424" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h4 id="fork-" class="heading-element"><span>1.2.2 fork 💣</span>
  <a href="#fork-" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码会无限循环地调用 fork() 函数，每次循环都会创建一个新进程。由于每次 fork() 调用都会成功创建一个新进程，而且这个新进程又会立即进入下一次循环并再次调用 fork()，因此进程的数量会以指数速度增长，很快就会耗尽系统的可用资源。</p>
<p><font color="red">绝对不要在任何生产环境或您没有权限的任何系统上运行fork炸弹。</font></p>
<h2 id="vfork" class="heading-element"><span>2 vfork</span>
  <a href="#vfork" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>2.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>描述</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">pid_t</span> <span class="nf">vfork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>vfork()</code> 系统调用用于创建一个子进程，与 <code>fork()</code> 类似，但它使用父进程的地址空间，而不是复制父进程的地址空间。<font color="red"><code>vfork()</code> 调用后，父进程会阻塞，直到子进程调用 <code>exec</code> 函数或执行了 exit 函数。</font>这是因为子进程需要独占父进程的地址空间，以确保数据一致性。一。<font color="red">在子进程调用 <code>exec</code> 函数或执行了 <code>exit</code> 函数之后，子进程将获得自己的内存空间。</font></p>
</li>
<li>
<p>返回值</p>
<p>和<code>fork</code>一致</p>
</li>
<li>
<p>重点</p>
<blockquote>
<ol>
<li><code>vfork()</code> 创建的子进程会继承父进程的环境，但不会继承父进程的堆栈。</li>
<li>在子进程执行这些<code>exec</code>或<code>exit</code>操作之前，父进程和子进程可能会访问相同的内存地址，这可能导致数据竞争和不一致。</li>
<li>在 <code>vfork()</code> 调用成功后，子进程应该立即调用 <code>exec</code> 函数或执行 <code>exit</code> 函数。如果在子进程中修改除了用于存储从 <code>vfork()</code> 返回值的 <code>pid_t</code> 类型变量之外的任何数据，或者从调用 <code>vfork()</code> 的函数返回，或在成功调用 <code>_exit()</code> 或 <code>exec()</code> 函数族中的一个函数之前调用其他任何函数，则行为是未定义的。这可能会导致程序崩溃或表现出不可预测的行为。
因此，使用 <code>vfork()</code> 时，必须确保子进程在调用 <code>exec</code> 函数或执行 <code>exit</code> 函数之前不执行任何可能影响共享内存的操作。</li>
<li><code>vfork()</code> 系统调用会阻塞父进程，直到子进程完成 <code>exec</code> 调用或 <code>exit</code> 调用。父进程不需要显式调用 <code>wait()</code> 或 <code>waitpid()</code> 来等待子进程结束。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="验证vfork共享内存" class="heading-element"><span>2.2 验证vfork共享内存</span>
  <a href="#%e9%aa%8c%e8%af%81vfork%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在父进程中分配内存并初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用vfork创建子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">vfork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;vfork error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Child process: PID = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 修改内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;/bin/echo&#34;</span><span class="p">,</span> <span class="s">&#34;Hello, Linux!&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 执行exec函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">execve</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 父进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Parent process: PID = %d, child&#39;s PID = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 验证内存内容是否被子进程修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory corruption detected at index %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory is consistent</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个程序的目的是验证在 <code>vfork()</code> 之后，子进程和父进程是否共享内存。首先在父进程中分配一块内存 ，并将其初始化为字符<code> ‘A’</code>。然后，父进程调用 <code>vfork()</code> 创建一个子进程。在子进程中，程序试图将内容修改为字符 <code>‘B’</code>，并执行 <code>execve()</code>。在父进程中，程序检查缓冲区的内容是否被修改为字符 <code>‘B’</code>，以验证内存是否被正确共享。</p>
<p>程序运行结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=small" data-sub-html="<h2>image-20240313132239776</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png" alt="image-20240313132239776" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=large 2x" data-title="image-20240313132239776" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="clone" class="heading-element"><span>3 clone</span>
  <a href="#clone" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-2" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>描述</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define _GNU_SOURCE
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">clone</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">child_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">                 <span class="cm">/* pid_t *parent_tid, void *tls, pid_t *child_tid */</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>clone</code>与<code>fork</code>类似，是用于创建新进程的系统调用，但<code>clone</code>提供了更精确的控制，可以确定在调用进程（父进程）和子进程之间共享哪些执行上下文的部分。例如，调用者可以控制两个进程是否共享虚拟地址空间、文件描述符表和信号处理程序表。这些系统调用还允许将新的子进程放置在单独的命名空间中。</p>
</li>
<li>
<p>参数</p>
<blockquote>
<ul>
<li>
<p><code>fn</code>是指向新进程要执行的函数的指针，这个函数接受一个 void* 参数，并返回一个 int 类型的值，这个返回值将被 clone 系统调用捕获，并作为子进程的退出状态；</p>
</li>
<li>
<p><code>child_stack</code>是新进程的堆栈地址，由于子进程和调用进程可能共享内存，因此子进程不可能与调用进程在同一堆栈中执行。调用进程必须为子堆栈设置内存空间，并将指向该空间的指针传递给<code>clone()</code>。</p>
</li>
<li>
<p><code>flags</code>可以设置新进程的属性（通过二进制位设置），包括是否与原进程共享地址空间（CLONE_VM）、是否共享文件描述符表（CLONE_FILES）、是否共享信号处理器（CLONE_SIGHAND）等等；</p>
<p><code>int flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS;</code></p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">标志</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">CLONE_PARENT</td>
          <td style="text-align: center">创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_FS</td>
          <td style="text-align: center">子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_FILES</td>
          <td style="text-align: center">子进程与父进程共享相同的文件描述符（file descriptor）表</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_NEWNS</td>
          <td style="text-align: center">在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_SIGHAND</td>
          <td style="text-align: center">子进程与父进程共享相同的信号处理（signal handler）表</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_PTRACE</td>
          <td style="text-align: center">若父进程被trace，子进程也被trace</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_VFORK</td>
          <td style="text-align: center">父进程被挂起，直至子进程释放虚拟内存资源</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_VM</td>
          <td style="text-align: center">子进程与父进程运行于相同的内存空间</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_PID</td>
          <td style="text-align: center">子进程在创建时PID与父进程一致</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_THREAD</td>
          <td style="text-align: center">Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>arg</code>是传递给新进程的参数；</p>
</li>
<li>
<p>可选参数，包括 <code>pid_t *parent_tid</code>等。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>返回值</p>
<blockquote>
<p>成功时，在父进程中返回子进程的 PID。失败时，父进程返回 $-1$，不创建子进程，并适当设置 <code>errno</code>。</p>
</blockquote>
</li>
<li>
<p>重点</p>
<blockquote>
<ol>
<li><code>clone</code> 可以创建新的进程或线程，Linux创建线程使用的系统调用就是<code>clone</code>。而 <code>fork</code> 和<code>vfork</code>只能创建进程。这意味着 <code>clone</code> 可以在单个进程中创建多个线程，而 <code>fork</code> 则总是创建一个新的进程。</li>
<li><code>clone</code> 提供比 <code>fork</code> 和 <code>vfork</code> 更多的选项，可以指定子进程或线程的堆栈、信号处理、权限等。</li>
<li><code>clone</code> 的使用比 <code>fork</code> 和 <code>vfork</code> 更复杂，需要正确设置 flags、child_stack、parent_pidptr、ptr、stack_size 和 tls 等参数。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="clone使用" class="heading-element"><span>3.2 clone使用</span>
  <a href="#clone%e4%bd%bf%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define _GNU_SOURCE
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define STACK_SIZE (1024 * 1024) </span><span class="cm">/* Stack size for cloned child */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 宏，简化错误处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define ERREXIT(msg) { perror(msg); exit(EXIT_FAILURE); }
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 安全分配内存函数，分配失败报告错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define CHECKALLOC(ptr, msg)  ({ void *p = ptr; if (p == NULL) {ERREXIT(msg);} p;})
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 子进程函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * params: 接受一个void *类型参数，但是没有被使用过，后面的声明是用于告诉编译器这个参数是未被使用的
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">childFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;child: start&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;child: terminate&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Child terminates now */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Start of stack buffer */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">**</span><span class="n">stacks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Child process&#39;s pids */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="o">*</span><span class="n">pids</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">nproc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 接受两个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;Wrong way to execute the program:</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;</span><span class="se">\t\t</span><span class="s">./waitpid nProcesses</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;example:</span><span class="se">\t</span><span class="s">./waitpid 2&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化nproc，表示要创建的子进程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nproc</span> <span class="o">=</span> <span class="nf">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="cm">/* Process count */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stacks</span> <span class="o">=</span> <span class="nf">CHECKALLOC</span><span class="p">(</span><span class="nf">malloc</span><span class="p">(</span><span class="n">nproc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)),</span> <span class="s">&#34;malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pids</span> <span class="o">=</span> <span class="nf">CHECKALLOC</span><span class="p">(</span><span class="nf">malloc</span><span class="p">(</span><span class="n">nproc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">)),</span> <span class="s">&#34;malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">stackTop</span><span class="p">;</span> <span class="cm">/* End of stack buffer */</span>
</span></span><span class="line"><span class="cl">        <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">CHECKALLOC</span><span class="p">(</span><span class="nf">malloc</span><span class="p">(</span><span class="n">STACK_SIZE</span><span class="p">),</span> <span class="s">&#34;stack malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 得到栈顶位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stackTop</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">STACK_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 创建子进程
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 第一个标志表示在子进程清除线程组ID（TID），目的是为了避免子进程与父进程或其他子进程的线程组ID冲突
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 第二个表示告诉在子进程中设置线程ID，目的是为了允许父进程在子进程中追踪线程
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 告诉 clone 系统调用在子进程中重新安装信号处理程序，目的是为了允许子进程捕获和处理信号，而不是传递给父进程。
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">clone</span><span class="p">(</span><span class="n">childFunc</span><span class="p">,</span> <span class="n">stackTop</span><span class="p">,</span> <span class="n">CLONE_CHILD_CLEARTID</span> <span class="o">|</span> <span class="n">CLONE_CHILD_SETTID</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ERREXIT</span><span class="p">(</span><span class="s">&#34;clone&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;clone() returned %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 第一个参数为子进程id，第二个参数表示不关心子进程的退出状态，第三个参数表示等待任何子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">waitpid</span><span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ERREXIT</span><span class="p">(</span><span class="s">&#34;waitpid&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child %ld has terminated</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 回收内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">stacks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">pids</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>运行：<code>gcc clone-example.c &amp;&amp; ./a.out 5</code>，其中5为<code>nproc</code>，表示要创建的进程数。</p>
<p>运行结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=small" data-sub-html="<h2>image-20240313212733984</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png" alt="image-20240313212733984" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=large 2x" data-title="image-20240313212733984" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>Linux用户和用户组教程</title><link>https://hezephyr.github.io/posts/03.linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E6%95%99%E7%A8%8B/</link><pubDate>Tue, 24 May 2022 10:27:01 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E6%95%99%E7%A8%8B/</guid><description><![CDATA[<h2 id="用户和用户组介绍" class="heading-element"><span>1 用户和用户组介绍</span>
  <a href="#%e7%94%a8%e6%88%b7%e5%92%8c%e7%94%a8%e6%88%b7%e7%bb%84%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="用户" class="heading-element"><span>1.1 用户</span>
  <a href="#%e7%94%a8%e6%88%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>任何操作系统都存在“用户”的概念，Linux也不例外。Linux系统是一个多用户多任务的分时操作系统，<font color="red">即Linux系统支持多个用户在同一时间内登录，不同用户可以执行不同的任务，并且互不影响。</font>每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。</p>
<p>在Linux中，用户分为两大类、三小类：分别为<strong>系统管理员</strong>（一般为root）和<strong>普通用户</strong> 。普通用户中，又划分为两类，分别为系统用户和登录用户。</p>
<ul>
<li><strong>系统管理员</strong>：即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。</li>
<li><strong>普通用户</strong>
<ul>
<li>登录用户：为管理员手动添加的用户，<font color="red">默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如/etc、/var/log等），但没有创建、修改、删除等权限。</font></li>
<li>系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。
Tips：在部署某些服务是，也可以手动添加某些系统用户。</li>
</ul>
</li>
</ul>
<p>Linux系统使用UID（User ID）来标识不同用户，说白了，其实Linux并不认识你的用户名称，它只认识用户名对应的UID。其中UID是16bit的二进制数字，所以换算成十进制，UID的范围是0~65535，Linux根据用户类别，对UID划分做了规定：</p>
<ul>
<li>0（系统管理员）：，当UID是0时，代表这个用户为超级管理员，所以当你想要其他的用户也有root权限时，将该用户的UID改为0即可。<font color="red">但一般来说，用户的UID应当是独一无二的，其他用户不应当有相同的UID数值，只有UID等于0时可以例外。</font></li>
<li>1<del>499（系统账号）：该范围内的UID是保留给系统使用的 ID，其实 1</del>65534 之间的账号并没有不同， 也就是除了 0 之外，其它的 UID 并没有不一样，预设 500 以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 DNS 服务器的启动服务『 named 』为例，这个程序的预设所有人 named 的账号 UID 是 25 ，当你自定义的账号也是 25 时，会造成系统冲突！为了杜绝这样的问题，养成好习惯，保留 500 以前的 UID 给系统使用！<font color="red"> 一般来说， 1到99 会保留给系统预设的账号，另外 100~499 则保留给一些服务来使用。</font></li>
<li>500~65535（登录用户）：给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到 4294967295 (2^32-1) 这么大的 UID 号码。</li>
</ul>
<h3 id="用户组" class="heading-element"><span>1.2 用户组</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？</p>
<p>显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。<font color="red">将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。</font></p>
<p>Linux对用户组也有三种划分方式：</p>
<ul>
<li>
<p>第一种组类别</p>
<ul>
<li>管理员组</li>
<li>普通用户组（包括系统用户组和登录用户组）</li>
</ul>
</li>
<li>
<p>第二种组类别</p>
<ul>
<li>用户的基本组（主组）：用户必须有且只能有一个基本组。</li>
<li>用户的附加组  （附属组）：用户可以有0个、1个或多个附加组。</li>
</ul>
<p>基本组和附加组就比如，每个人有一个用来安家的房子（基本组），还可以有N个用于投资的房子（附属组）。</p>
</li>
<li>
<p>第三种组类别</p>
<ul>
<li>私有组：每新建一个用户，如果不指定-g参数，都会自动创建一个和用户名同名的组，且组内只包含用户本身。</li>
</ul>
<ul>
<li>公共组：组内可包含多个用户。</li>
</ul>
</li>
</ul>
<p>Linux系统也是使用GID（Group ID）来标识不同组。用户和用户组的对应关系有以下 4 种：</p>
<ol>
<li>一对一：一个用户可以存在一个组中，是组中的唯一成员；</li>
<li>一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；</li>
<li>多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；</li>
<li>多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。</li>
</ol>
<p>下图形象的表示了用户和用户组的4种对应关系。
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2ab64ef22dfa44d29b2760570e2a8870-20231125214644832.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2ab64ef22dfa44d29b2760570e2a8870-20231125214644832.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2ab64ef22dfa44d29b2760570e2a8870-20231125214644832.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2ab64ef22dfa44d29b2760570e2a8870-20231125214644832.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2ab64ef22dfa44d29b2760570e2a8870-20231125214644832.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2ab64ef22dfa44d29b2760570e2a8870-20231125214644832.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">注意：每一个用户组也有一个口令，当我们将用户添加到指定组时需要该用户组的密码。</font></p>
<h3 id="文件权限" class="heading-element"><span>1.3 文件权限</span>
  <a href="#%e6%96%87%e4%bb%b6%e6%9d%83%e9%99%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，如何区分不同用户对文件的权限成了不可避免的问题。例如，小 A 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 B 也可以读取小 A 的个人文件，这是不合理的，不同用户对不同文件所拥有的权限应该不尽相同。</p>
<p>因此，Linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 Linux 作为多用户系统的可行性。<font color="red">从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——<strong>文件所有者</strong>、<strong>用户组成员</strong>、<strong>其他人</strong>。每一个对象对某一个文件的持有权限是不同的。</font></p>
<h4 id="文件所有者user" class="heading-element"><span>1.3.1 文件所有者（User）</span>
  <a href="#%e6%96%87%e4%bb%b6%e6%89%80%e6%9c%89%e8%80%85user" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。**这也是 Linux 系统能够保护用户隐私的最关键的原因。**在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。</p>
<p>如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。</p>
<h4 id="用户组成员group" class="heading-element"><span>1.3.2 用户组成员（Group）</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%bb%84%e6%88%90%e5%91%98group" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。<font color="red">用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。</font></p>
<p>用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。</p>
<p>需要注意的是，<strong>一个用户可在多个用户组中</strong>。</p>
<h4 id="其他人others" class="heading-element"><span>1.3.3 其他人（Others）</span>
  <a href="#%e5%85%b6%e4%bb%96%e4%ba%baothers" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。</p>
<h3 id="超级管理员root" class="heading-element"><span>1.4 超级管理员（root）</span>
  <a href="#%e8%b6%85%e7%ba%a7%e7%ae%a1%e7%90%86%e5%91%98root" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于Linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。</p>
<h3 id="aaa基础" class="heading-element"><span>1.5 AAA基础</span>
  <a href="#aaa%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>AAA指的是Authentication、Authorization、Accounting，即认证、授权和审计。</p>
<ul>
<li>认证：验证用户是否可以获得权限，是AAA的第一步，即验证身份；</li>
<li>授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；</li>
<li>审计：记录用户的操作情况，在Linux中，日志就是审计的一种手段。</li>
</ul>
<p>Linux的用户和组管理可以说是基于AAA进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是</p>
<p>授权；最后，用户的操作历史会记录在日志中，这是审计。</p>
<h2 id="用户和用户组文件" class="heading-element"><span>2 用户和用户组文件</span>
  <a href="#%e7%94%a8%e6%88%b7%e5%92%8c%e7%94%a8%e6%88%b7%e7%bb%84%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="用户账号文件-etcpasswd" class="heading-element"><span>2.1 用户账号文件— /etc/passwd</span>
  <a href="#%e7%94%a8%e6%88%b7%e8%b4%a6%e5%8f%b7%e6%96%87%e4%bb%b6-etcpasswd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>/etc/passwd</code>文件是Linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户ID（UID）、默认的用户组ID（GID）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号&rsquo;:&lsquo;分割。格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">username:password:uid:gid:userinfo:home:shell</span></span></code></pre></td></tr></table>
</div>
</div><p>具体含义如表所示。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">username</td>
          <td style="text-align: center">登录名</td>
      </tr>
      <tr>
          <td style="text-align: center">password</td>
          <td style="text-align: center">加密的用户口令</td>
      </tr>
      <tr>
          <td style="text-align: center">uid</td>
          <td style="text-align: center">用户ID</td>
      </tr>
      <tr>
          <td style="text-align: center">gid</td>
          <td style="text-align: center">用户组ID</td>
      </tr>
      <tr>
          <td style="text-align: center">userinfo</td>
          <td style="text-align: center">用户信息</td>
      </tr>
      <tr>
          <td style="text-align: center">home</td>
          <td style="text-align: center">分配给用户的主目录</td>
      </tr>
      <tr>
          <td style="text-align: center">shell</td>
          <td style="text-align: center">用户登录后将执行的shell（若为空格泽默认为“/bin/sh”）</td>
      </tr>
  </tbody>
</table>
<p>其中关于用户主目录，每个用户都需要保存专属于自己的配置文件及其他文档，这是以免用户间相互干扰。除root账户外（root账户的主目录为&quot;/root&quot;），大多数Linux默认将用户主目录安置在&quot;/home&quot;目录下，并把每个用户的主目录命名为其上机使用的登录名。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/842dc2752e8996482acbbf0c83c50545.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/842dc2752e8996482acbbf0c83c50545.png?size=small" data-sub-html="<h2>image-20220503204800893</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/842dc2752e8996482acbbf0c83c50545.png" alt="image-20220503204800893" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/842dc2752e8996482acbbf0c83c50545.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/842dc2752e8996482acbbf0c83c50545.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/842dc2752e8996482acbbf0c83c50545.png?size=large 2x" data-title="image-20220503204800893" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如图，acs的登录主目录为&quot;/home/acs&quot;。通常，“~”被指向当前用户的登录子目录。</p>
<p><font color="red">注意：用户主目录被安排在“/home”下完全是认为决定的。系统并不关心我们到底把用户主目录安排在什么地方，因为每个用户的位置是在账号文件中定义说明的。所以，用户可以自行调整，灵活使用</font></p>
<p>关于shell，Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。当用户登录进入系统时，会启动一个Shell程序，默认是bash。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用bash为默认的登录Shell，即这个字段的值为/bin/bash。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>我们通过查看<code>/etc/passwd</code>文件，可以得到如下完整的系统账号文件。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/62794c219ba89bdea97a4871ac63f61e.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/62794c219ba89bdea97a4871ac63f61e.png?size=small" data-sub-html="<h2>image-20220503205339447</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/62794c219ba89bdea97a4871ac63f61e.png" alt="image-20220503205339447" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/62794c219ba89bdea97a4871ac63f61e.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/62794c219ba89bdea97a4871ac63f61e.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/62794c219ba89bdea97a4871ac63f61e.png?size=large 2x" data-title="image-20220503205339447" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们发现，第二列都为x。我们可以继续往下看。</p>
<h3 id="用户影子文件etcshadow" class="heading-element"><span>2.2 用户影子文件—/etc/shadow</span>
  <a href="#%e7%94%a8%e6%88%b7%e5%bd%b1%e5%ad%90%e6%96%87%e4%bb%b6etcshadow" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>实际上，Linxu使用不可逆的加密算法（如MD5）来加密口令，由于加密算法是不可逆的，所以黑客从密文是得不到明文的。但<code>/etc/passwd</code>文件时全局可读的，且加密的算法是公开的，如果在passwd中显示密文，黑客据此可以破解口令。Linux系统目前广泛采用了“shadow（影子）文件”机制。将加密的口令转移到“/etc/shadow”文件中。<code>/etc/shadow</code>文件只为root超级用户可读，而相应的<code>etc/passwd</code>文件的密文域泽显示为一个x，从而最大限度地减少了密文泄露的机会。x表示该账户需要密码才能登录，为空时，账户无须密码即可登录。</p>
<p>和<code>/etc/passwd</code>类似，<code>/etc/shadow</code>文件中每条记录用冒号“：”分隔，形成9个域，格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">username:password:lastchg:min:max:warn:inactive:expire:flag</span></span></code></pre></td></tr></table>
</div>
</div><table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">username</td>
          <td style="text-align: center">用户登陆名</td>
      </tr>
      <tr>
          <td style="text-align: center">password</td>
          <td style="text-align: center">加密的用户口令</td>
      </tr>
      <tr>
          <td style="text-align: center">lastchg</td>
          <td style="text-align: center">表示从1970年1月1日起到上次修改口令所经过的天数</td>
      </tr>
      <tr>
          <td style="text-align: center">min</td>
          <td style="text-align: center">表示两次修改口令之间至少经过的天数</td>
      </tr>
      <tr>
          <td style="text-align: center">max</td>
          <td style="text-align: center">表示口令还会有效的最大天数，如果是99999则表示永不过期</td>
      </tr>
      <tr>
          <td style="text-align: center">warn</td>
          <td style="text-align: center">表示口令失效前多少天内系统向用户发出警告</td>
      </tr>
      <tr>
          <td style="text-align: center">inactive</td>
          <td style="text-align: center">表示禁止登录前用户名还有效的天数</td>
      </tr>
      <tr>
          <td style="text-align: center">expire</td>
          <td style="text-align: center">表示用户被禁止登录的时间</td>
      </tr>
      <tr>
          <td style="text-align: center">flag</td>
          <td style="text-align: center">保留域，暂未使用</td>
      </tr>
  </tbody>
</table>
<p>下图为系统中实际影子文件的例子。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/6d4cb873977925e048a456514530a915-20231125214650485.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/6d4cb873977925e048a456514530a915-20231125214650485.png?size=small" data-sub-html="<h2>image-20220503210639011</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/6d4cb873977925e048a456514530a915-20231125214650485.png" alt="image-20220503210639011" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/6d4cb873977925e048a456514530a915-20231125214650485.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/6d4cb873977925e048a456514530a915-20231125214650485.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/6d4cb873977925e048a456514530a915-20231125214650485.png?size=large 2x" data-title="image-20220503210639011" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="创建用户的默认设置文件etclogindefs" class="heading-element"><span>2.3 创建用户的默认设置文件—/etc/login.defs</span>
  <a href="#%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7%e7%9a%84%e9%bb%98%e8%ae%a4%e8%ae%be%e7%bd%ae%e6%96%87%e4%bb%b6etclogindefs" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等。</p>
<p><font color="red">需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。</font></p>
<p>其中设置项含义如下表所示。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">设置项</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">MAIL_DIR /var/spool/mail</td>
          <td style="text-align: center">创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是 /var/spool/mail/lamp。</td>
      </tr>
      <tr>
          <td style="text-align: center">PASS_MAX_DAYS 99999</td>
          <td style="text-align: center">密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。</td>
      </tr>
      <tr>
          <td style="text-align: center">PASS_MIN_DAYS 0</td>
          <td style="text-align: center">表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。</td>
      </tr>
      <tr>
          <td style="text-align: center">PASS_MIN_LEN 5</td>
          <td style="text-align: center">指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。</td>
      </tr>
      <tr>
          <td style="text-align: center">PASS_WARN_AGE 7</td>
          <td style="text-align: center">指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。</td>
      </tr>
      <tr>
          <td style="text-align: center">UID_MIN 500</td>
          <td style="text-align: center">指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的 UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID 没有使用。</td>
      </tr>
      <tr>
          <td style="text-align: center">UID_MAX 60000</td>
          <td style="text-align: center">指定用户最大的 UID 为 60000。</td>
      </tr>
      <tr>
          <td style="text-align: center">GID_MIN 500</td>
          <td style="text-align: center">指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。</td>
      </tr>
      <tr>
          <td style="text-align: center">GID_MAX 60000</td>
          <td style="text-align: center">用户 GID 最大为 60000。</td>
      </tr>
      <tr>
          <td style="text-align: center">CREATE_HOME yes</td>
          <td style="text-align: center">指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。</td>
      </tr>
      <tr>
          <td style="text-align: center">UMASK 077</td>
          <td style="text-align: center">用户主目录的权限默认设置为 077。</td>
      </tr>
      <tr>
          <td style="text-align: center">USERGROUPS_ENAB yes</td>
          <td style="text-align: center">指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。</td>
      </tr>
      <tr>
          <td style="text-align: center">ENCRYPT_METHOD SHA512</td>
          <td style="text-align: center">指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5 加密。</td>
      </tr>
  </tbody>
</table>
<p>如果我们想修改默认配置即可修改配置项的值即可。</p>
<h3 id="用户组账号文件etcgroup" class="heading-element"><span>2.4 用户组账号文件—/etc/group</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%bb%84%e8%b4%a6%e5%8f%b7%e6%96%87%e4%bb%b6etcgroup" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们知道，<code>/etc/passwd</code>文件中包含着每个用户的用户组ID（GID），但如果我们需要找一个用户组中的所有用户，通过<code>/etc/passwd</code>难免有些复杂，需要从头到尾寻找同组用户。而<code>/etc/group</code>文件包含关于用户组信息，GID被映射到用户分组的名称及同一分组中的其他成员，这样找同组用户以及配置用户组就方便了许多。<code>/etc/group</code>文件对用户组的许可权限的控制并不是必要的，这是因为Linux系统用来自于<code>/etc/passwd</code>文件的UID、GID来决定文件存取权限。即使<code>/etc/group</code>文件不存在于系统中，具有相同的GID用户也能以用户组的许可权限共享文件。</p>
<p><code>/etc/group</code>文件记录格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">group_name:group_password:group_id:group_members</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，各个域的含义如下表。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">域</th>
          <th style="text-align: left">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">group_name</td>
          <td style="text-align: left">用户组名</td>
      </tr>
      <tr>
          <td style="text-align: left">group_password</td>
          <td style="text-align: left">加密后的用户组口令</td>
      </tr>
      <tr>
          <td style="text-align: left">group_id</td>
          <td style="text-align: left">用户组ID（GID）</td>
      </tr>
      <tr>
          <td style="text-align: left">group_members</td>
          <td style="text-align: left">以逗号分隔的成员用户清单</td>
      </tr>
  </tbody>
</table>
<p>以下是一个<code>/etc/group</code>文件的实例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea98544d0c79f65fa03cec6026358ae3-20231125214657037.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea98544d0c79f65fa03cec6026358ae3-20231125214657037.png?size=small" data-sub-html="<h2>image-20220503212923479</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea98544d0c79f65fa03cec6026358ae3-20231125214657037.png" alt="image-20220503212923479" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea98544d0c79f65fa03cec6026358ae3-20231125214657037.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea98544d0c79f65fa03cec6026358ae3-20231125214657037.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea98544d0c79f65fa03cec6026358ae3-20231125214657037.png?size=large 2x" data-title="image-20220503212923479" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="用户组影子文件etcgshadow" class="heading-element"><span>2.5 用户组影子文件—/etc/gshadow</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%bb%84%e5%bd%b1%e5%ad%90%e6%96%87%e4%bb%b6etcgshadow" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>和用户账号文件passwd一样，为了应对黑客对其进行的暴力攻击，用户组文件也采用一种将组口令与组的其他信息相分离的安全机制——gshadow。<code>/etc/shadow</code>文件记录格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">group_name:group_password:group_members</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，各个域的含义如下表。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">group_name</td>
          <td style="text-align: center">用户组名</td>
      </tr>
      <tr>
          <td style="text-align: center">group_password</td>
          <td style="text-align: center">加密后的用户组口令</td>
      </tr>
      <tr>
          <td style="text-align: center">group_members</td>
          <td style="text-align: center">以逗号分隔的成员用户清单</td>
      </tr>
  </tbody>
</table>
<h2 id="用户和用户组管理" class="heading-element"><span>3 用户和用户组管理</span>
  <a href="#%e7%94%a8%e6%88%b7%e5%92%8c%e7%94%a8%e6%88%b7%e7%bb%84%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="用户管理" class="heading-element"><span>3.1 用户管理</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="使用useradd命令添加用户" class="heading-element"><span>3.1.1 使用useradd命令添加用户</span>
  <a href="#%e4%bd%bf%e7%94%a8useradd%e5%91%bd%e4%bb%a4%e6%b7%bb%e5%8a%a0%e7%94%a8%e6%88%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>Linux使用useradd命令添加用户或更新新创建用户的默认信息。其命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">useradd [option] username</span></span></code></pre></td></tr></table>
</div>
</div><p>可使用的选项如下：</p>
<ul>
<li><code>-c comment</code>：描述新用户账号，通常为用户全名。</li>
<li><code>-d home_dir</code>：设置用户主目录。默认值为用户的登录名，并放在&quot;/home&quot;目录下。</li>
<li><code>-g group</code>：指定用户所属的基本组。</li>
<li><code>-G group</code>：指定用户所属的附加组。</li>
<li><code>-u uid</code>：设置用户的ID。</li>
<li><code>-s shell类型</code>：设定用户使用的登录shell类型。</li>
<li><code>-k dir</code>：设置框架目录，创建用户时该目录下的文件都被复制到主目录。</li>
<li><code>-e expire_date</code>：设置账号过期时间。</li>
<li><code>-f inactivity</code>：设置口令失效时间。</li>
<li><code>-n</code>：不为用户创建私有用户组。</li>
<li><code>-p password</code>：为新建用户指定登录密码。此处的 password 是对应登录密码经 MD5 加密后所得到的密码值，不是真实密码原文，因此在实际应用中，该参数选项使用较少，通常单独使用 passwd 命令来为用户设置登录密码。</li>
<li><code>-r</code>：创建一个用户 ID 小于 500 的系统账户，默认不创建对应的主目录。</li>
<li><code>-m</code>：若主目录不存在，则创建它。通常与<code>-r</code>结合，可为系统用户主目录。</li>
<li><code>-M</code>：不创建主目录。</li>
</ul>
<p>实例1：创建一个普通用户，名为hzf，其中uid为6666，用户主目录指定在/hzf/。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">useradd -u <span class="m">6666</span> -d /hzf/ hzf</span></span></code></pre></td></tr></table>
</div>
</div><p>实例2：创建一个系统账户，名为mysystem，其中为系统用户创建主目录，指定密码为12345678</p>
<blockquote>
<p>首先需要加密密码串，这里使用md5sum工具。</p>
<p>利用md5sum加密字符串的方法</p>
<p># md5sum     //然后回车</p>
<p>12345678      //输入12345678，然后按两次ctrl+d。</p>
<p>这个时候就会得到一串密文。</p>
<p>使用以下命令即可创建该系统用户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">useradd -r -m -p 1234567825d55ad283aa400af464c76d713c07ad mysystem</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<p>查看<code>/etc/passwd</code>即可看到我们创建得用户信息。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/99982b32e60cffbb552501758e033046.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/99982b32e60cffbb552501758e033046.png?size=small" data-sub-html="<h2>image-20220504142637032</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/99982b32e60cffbb552501758e033046.png" alt="image-20220504142637032" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/99982b32e60cffbb552501758e033046.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/99982b32e60cffbb552501758e033046.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/99982b32e60cffbb552501758e033046.png?size=large 2x" data-title="image-20220504142637032" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h4 id="使用usermod命令修改用户信息" class="heading-element"><span>3.1.2 使用usermod命令修改用户信息</span>
  <a href="#%e4%bd%bf%e7%94%a8usermod%e5%91%bd%e4%bb%a4%e4%bf%ae%e6%94%b9%e7%94%a8%e6%88%b7%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>对于已创建好的用户，可使用 usermod 命令来修改和设置账户的各项属性，包括登录名，主目录，用户组，登录 shell 等，该命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">usermod [option] username</span></span></code></pre></td></tr></table>
</div>
</div><p>常用的选项包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样，可以为用户指定新的资源值。</p>
<p>另外，有些系统还可以使用<code>-l</code>修改用户名。用法为：<code>usermod -l newusername</code></p>
<p>使用<code>-L</code>可以锁定用户账号，临时禁止用户登录。用法为：<code>usermod -L username</code>，Linux锁定用户，是通过在密码文件 shadow 的密码字段前加 “！” 来标识该用户被锁定。</p>
<p>但如果我们是用root用户登录，再用<code>su</code>命令切换到被锁定的账号是可以进去的。</p>
<p>使用<code>-U</code>可以解锁用户账号。用法为：<code>usermod -U username</code>。</p>
<h4 id="使用userdel命令删除用户" class="heading-element"><span>3.1.3 使用userdel命令删除用户</span>
  <a href="#%e4%bd%bf%e7%94%a8userdel%e5%91%bd%e4%bb%a4%e5%88%a0%e9%99%a4%e7%94%a8%e6%88%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>要删除用户，可以使用userdel命令删除，命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">userdel [-r] username</span></span></code></pre></td></tr></table>
</div>
</div><p>其中<code>-r</code>参数可选，若带上参数，表示在删除账户的同时，一并删除用户的主目录。</p>
<h4 id="使用passwd命令管理用户口令" class="heading-element"><span>3.1.4 使用passwd命令管理用户口令</span>
  <a href="#%e4%bd%bf%e7%94%a8passwd%e5%91%bd%e4%bb%a4%e7%ae%a1%e7%90%86%e7%94%a8%e6%88%b7%e5%8f%a3%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">passwd [option] username</span></span></code></pre></td></tr></table>
</div>
</div><p>可使用的选项如下：</p>
<ul>
<li><code>-l</code>：锁定口令，即禁用账号。</li>
<li><code>-u</code>：口令解锁。</li>
<li><code>-d</code>：使账号无口令。这样，下次登录的时候，系统就不再允许该用户登录了。</li>
<li><code>-f</code>：强迫用户下次登陆时修改口令。</li>
</ul>
<p>如果不指定用户名，则表示修改自己的口令。</p>
<h3 id="用户组管理" class="heading-element"><span>3.2 用户组管理</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%bb%84%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="使用groupadd命令创建用户组" class="heading-element"><span>3.2.1 使用groupadd命令创建用户组</span>
  <a href="#%e4%bd%bf%e7%94%a8groupadd%e5%91%bd%e4%bb%a4%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>增加一个新的用户组使用groupadd命令。命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">groupadd <span class="o">[</span>option<span class="o">]</span> groupname</span></span></code></pre></td></tr></table>
</div>
</div><p>可使用的选项如下：</p>
<ul>
<li><code>-r</code>：表示创建系统用户组，该类用户组的 GID 值小于 500；若没有 - r 参数，则创建普通用户组，其 GID 值大于或等于 500。</li>
<li><code>-g gid</code>：指定新用户组的标识号GID。</li>
<li><code>-o</code>：一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>如果没有指定选择参数，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<h4 id="使用groupmod修改" class="heading-element"><span>3.2.2 使用groupmod修改</span>
  <a href="#%e4%bd%bf%e7%94%a8groupmod%e4%bf%ae%e6%94%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>修改用户组的属性使用groupmod命令。命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">groupmod <span class="o">[</span>option<span class="o">]</span> groupname</span></span></code></pre></td></tr></table>
</div>
</div><p>可使用的选项如下：</p>
<ul>
<li><code>-g gid</code>：为用户组指定新的组标识号。</li>
<li><code>-o</code>：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li><code>-n newgroupname</code>： 将用户组的名字改为新名字</li>
</ul>
<h4 id="使用groupdel命令删除用户组" class="heading-element"><span>3.2.3 使用groupdel命令删除用户组</span>
  <a href="#%e4%bd%bf%e7%94%a8groupdel%e5%91%bd%e4%bb%a4%e5%88%a0%e9%99%a4%e7%94%a8%e6%88%b7%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>使用groupdel命令可以删除用户组。命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">groupdel groupname</span></span></code></pre></td></tr></table>
</div>
</div><p><font color="red">在删除用户组时，被删除的用户组不能是某个账户的私有用户组，否则将无法删除，若要删除，则应先删除引用该私有用户组的账户，然后再删除用户组。</font></p>
<h4 id="使用gpasswd命令管理用户组" class="heading-element"><span>3.2.4 使用gpasswd命令管理用户组</span>
  <a href="#%e4%bd%bf%e7%94%a8gpasswd%e5%91%bd%e4%bb%a4%e7%ae%a1%e7%90%86%e7%94%a8%e6%88%b7%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>为了避免系统管理员（root）太忙碌，无法及时管理群组，我们可以使用 gpasswd 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。gpasswd命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gpasswd <span class="o">[</span>option<span class="o">]</span> groupname</span></span></code></pre></td></tr></table>
</div>
</div><p>可选择的选项如下：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">选项</th>
          <th style="text-align: center">功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"></td>
          <td style="text-align: center">选项为空时，表示给群组设置密码，仅 root 用户可用。</td>
      </tr>
      <tr>
          <td style="text-align: center">-A user1,&hellip;</td>
          <td style="text-align: center">将群组的控制权交给 user1,&hellip; 等用户管理，也就是说，设置 user1,&hellip; 等用户为群组的管理员，仅 root 用户可用。</td>
      </tr>
      <tr>
          <td style="text-align: center">-M user1,&hellip;</td>
          <td style="text-align: center">将 user1,&hellip; 加入到此群组中，仅 root 用户可用。</td>
      </tr>
      <tr>
          <td style="text-align: center">-r</td>
          <td style="text-align: center">移除群组的密码，仅 root 用户可用。</td>
      </tr>
      <tr>
          <td style="text-align: center">-R</td>
          <td style="text-align: center">让群组的密码失效，仅 root 用户可用。</td>
      </tr>
      <tr>
          <td style="text-align: center">-a user</td>
          <td style="text-align: center">将 user 用户加入到群组中。</td>
      </tr>
      <tr>
          <td style="text-align: center">-d user</td>
          <td style="text-align: center">将 user 用户从群组中移除。</td>
      </tr>
  </tbody>
</table>
<p>实例如下。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/bba82a11cf576dfbe9b1b405c7fa91ab-20231125214704213.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/bba82a11cf576dfbe9b1b405c7fa91ab-20231125214704213.png?size=small" data-sub-html="<h2>image-20220504165806305</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/bba82a11cf576dfbe9b1b405c7fa91ab-20231125214704213.png" alt="image-20220504165806305" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/bba82a11cf576dfbe9b1b405c7fa91ab-20231125214704213.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/bba82a11cf576dfbe9b1b405c7fa91ab-20231125214704213.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/bba82a11cf576dfbe9b1b405c7fa91ab-20231125214704213.png?size=large 2x" data-title="image-20220504165806305" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h4 id="使用newgrp命令切换用户的有效组" class="heading-element"><span>3.2.5 使用newgrp命令切换用户的有效组</span>
  <a href="#%e4%bd%bf%e7%94%a8newgrp%e5%91%bd%e4%bb%a4%e5%88%87%e6%8d%a2%e7%94%a8%e6%88%b7%e7%9a%84%e6%9c%89%e6%95%88%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？</p>
<p>当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。此命令基本格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">newgrp groupname</span></span></code></pre></td></tr></table>
</div>
</div><p>newgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。</p>
<h2 id="其他相关命令" class="heading-element"><span>4 其他相关命令</span>
  <a href="#%e5%85%b6%e4%bb%96%e7%9b%b8%e5%85%b3%e5%91%bd%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="id命令查看用户的uid和gid" class="heading-element"><span>4.1 id命令查看用户的UID和GID</span>
  <a href="#id%e5%91%bd%e4%bb%a4%e6%9f%a5%e7%9c%8b%e7%94%a8%e6%88%b7%e7%9a%84uid%e5%92%8cgid" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>id 命令可以查询用户的UID、GID 和附加组的信息。命令比较简单，格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">id username</span></span></code></pre></td></tr></table>
</div>
</div><p>实例如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/e7235be54ea1e48c59c3689b2856f75c.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/e7235be54ea1e48c59c3689b2856f75c.png?size=small" data-sub-html="<h2>image-20220504161152456</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/e7235be54ea1e48c59c3689b2856f75c.png" alt="image-20220504161152456" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/e7235be54ea1e48c59c3689b2856f75c.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/e7235be54ea1e48c59c3689b2856f75c.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/e7235be54ea1e48c59c3689b2856f75c.png?size=large 2x" data-title="image-20220504161152456" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="su命令临时切换用户身份" class="heading-element"><span>4.2 su命令临时切换用户身份</span>
  <a href="#su%e5%91%bd%e4%bb%a4%e4%b8%b4%e6%97%b6%e5%88%87%e6%8d%a2%e7%94%a8%e6%88%b7%e8%ba%ab%e4%bb%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>su 是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为 root 用户、从 root 用户切换为普通用户以及普通用户之间的切换。</p>
<p><font color="red">普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。</font></p>
<p>su命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">su <span class="o">[</span>option<span class="o">]</span> username</span></span></code></pre></td></tr></table>
</div>
</div><p>可使用的选项如下：</p>
<ul>
<li><code>-l或-</code>：带这个参数就好像是重新 login 为该使用者一样，大部份环境参数都是以该使用者为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root。</li>
<li><code>-c &lt;command&gt;</code> ：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</li>
<li><code>-s &lt;shell&gt;</code>： 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者shell</li>
<li><code>-h</code>：显示说明文件。</li>
<li><code>-V</code>：显示版本资讯。</li>
<li><code>-m或-p</code>：执行su时不改变工作环境。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8015a145aca6fb66062f3a9d8973ed72.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8015a145aca6fb66062f3a9d8973ed72.png?size=small" data-sub-html="<h2>image-20220504162626296</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8015a145aca6fb66062f3a9d8973ed72.png" alt="image-20220504162626296" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8015a145aca6fb66062f3a9d8973ed72.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8015a145aca6fb66062f3a9d8973ed72.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8015a145aca6fb66062f3a9d8973ed72.png?size=large 2x" data-title="image-20220504162626296" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="whoami和who-am-i命令" class="heading-element"><span>4.3 whoami和who am i命令</span>
  <a href="#whoami%e5%92%8cwho-am-i%e5%91%bd%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>whoami 命令和 who am i 命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。</p>
<p>我们可以看一下操作实例来感受区别：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/608b588d94af27af4ad729454707411b.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/608b588d94af27af4ad729454707411b.png?size=small" data-sub-html="<h2>image-20220504163557031</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/608b588d94af27af4ad729454707411b.png" alt="image-20220504163557031" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/608b588d94af27af4ad729454707411b.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/608b588d94af27af4ad729454707411b.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/608b588d94af27af4ad729454707411b.png?size=large 2x" data-title="image-20220504163557031" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在未切换用户身份之前，whoami 和 who am i 命令的输出是一样的，但使用 su 命令切换用户身份后，使用 whoami 命令打印的是切换后的用户名，而 who am i 命令打印的仍旧是登陆系统时所用的用户名。</p>
<h3 id="users和groups命令" class="heading-element"><span>4.4 users和groups命令</span>
  <a href="#users%e5%92%8cgroups%e5%91%bd%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>users命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">users <span class="o">[</span>option<span class="o">]</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果没有参数，则显示当前登录系统的所有用户的用户列表。每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。</li>
<li><code>--help</code>：显示命令的帮助信息。</li>
<li><code>--version</code>：显示命令的版本信息。</li>
</ul>
<p>groups命令格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">groups <span class="o">[</span>option<span class="o">]</span> <span class="o">[</span>groupname<span class="o">]</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果没有参数，查看当前登录用户的组内成员。如果指定了groupname，则显示该group的成员。</li>
<li><code>--help</code>：显示命令的帮助信息。</li>
<li><code>--version</code>：显示命令的版本信息。</li>
</ul>
<h2 id="高级操作示例" class="heading-element"><span>5 高级操作示例</span>
  <a href="#%e9%ab%98%e7%ba%a7%e6%93%8d%e4%bd%9c%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="通过更改用户和组的配置文件直接添加或修改用户和组" class="heading-element"><span>5.1 通过更改用户和组的配置文件，直接添加或修改用户和组</span>
  <a href="#%e9%80%9a%e8%bf%87%e6%9b%b4%e6%94%b9%e7%94%a8%e6%88%b7%e5%92%8c%e7%bb%84%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e7%9b%b4%e6%8e%a5%e6%b7%bb%e5%8a%a0%e6%88%96%e4%bf%ae%e6%94%b9%e7%94%a8%e6%88%b7%e5%92%8c%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了更深入了解用户和组的相关配置文件，可以手动更改配置文件以达到命令的执行效果。</p>
<p>首先我们需要了解Linux中的/etc/skel目录。skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的主目录，并且将用户属主与用户组调整为与此主目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。</p>
<p>注意：</p>
<ul>
<li>如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。</li>
<li>如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时使用<code>-k</code>指定新的框架目录。</li>
<li>如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录。修改SKEL变量的值即可。原来为<code>SKEL=/etc/skel</code>。</li>
</ul>
<p>实际操作步骤如下：</p>
<ol>
<li>
<p>编辑/etc/group文件，添加组test，其中GID为1500。</p>
<p><code>echo 'test:x:1500' &gt;&gt; /etc/group</code></p>
</li>
<li>
<p>创建用户的主目录。</p>
<p>我们需要将框架目录中的文件放到主目录中。同时还需要修改好主目录对其他用户都没有任何访问权限。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/3d9ce011a1404b37a0688da4860e9456.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/3d9ce011a1404b37a0688da4860e9456.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/3d9ce011a1404b37a0688da4860e9456.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/3d9ce011a1404b37a0688da4860e9456.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/3d9ce011a1404b37a0688da4860e9456.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/3d9ce011a1404b37a0688da4860e9456.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>编辑/etc/passwd文件，添加用户test，UID为1500，其中基本组ID为test组的GID，其家目录为/home/test。</p>
<p><code>echo 'test:x:1500:1500::/home/test:/bin/bash' &gt;&gt; /etc/passwd</code></p>
</li>
<li>
<p>修改/home/test目录及其内部所有文件的属主为test，属组为test。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/505e991a41cc9c3b49b6fb662b94eae5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/505e991a41cc9c3b49b6fb662b94eae5.png?size=small" data-sub-html="<h2>image-20220504191453653</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/505e991a41cc9c3b49b6fb662b94eae5.png" alt="image-20220504191453653" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/505e991a41cc9c3b49b6fb662b94eae5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/505e991a41cc9c3b49b6fb662b94eae5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/505e991a41cc9c3b49b6fb662b94eae5.png?size=large 2x" data-title="image-20220504191453653" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>修改test用户的密码并尝试登录。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/699e451be8c44c7c8b38179abae26fec.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/699e451be8c44c7c8b38179abae26fec.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/699e451be8c44c7c8b38179abae26fec.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/699e451be8c44c7c8b38179abae26fec.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/699e451be8c44c7c8b38179abae26fec.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/699e451be8c44c7c8b38179abae26fec.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ol>
<h3 id="linux批量添加用户" class="heading-element"><span>5.2 Linux批量添加用户</span>
  <a href="#linux%e6%89%b9%e9%87%8f%e6%b7%bb%e5%8a%a0%e7%94%a8%e6%88%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们可以使用useradd+passwd命令配合shell脚本来实现该功能。</p>
<p>首先我们将需要创建的用户名写入一个文本文件，其中每行代表一个用户名：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/c197c4ecea8d4a52815a3671c2db21e4.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/c197c4ecea8d4a52815a3671c2db21e4.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/c197c4ecea8d4a52815a3671c2db21e4.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/c197c4ecea8d4a52815a3671c2db21e4.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/c197c4ecea8d4a52815a3671c2db21e4.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/c197c4ecea8d4a52815a3671c2db21e4.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>然后实际上我们的思路就是提取出文件中的用户名然后自动执行useradd命令，再执行passwd自动填入初始密码。编写的shell脚本文件如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#! /bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> username in <span class="k">$(</span>more username.txt<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> -n <span class="nv">$username</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">then</span>
</span></span><span class="line"><span class="cl">        useradd -m <span class="nv">$username</span> <span class="c1"># 执行useradd命令</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="nv">$username</span><span class="s2">&#34;123456&#34;</span> <span class="p">|</span> passwd --stdin <span class="nv">$username</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;User </span><span class="nv">$username</span><span class="s2">&#39;s password is changed!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;The username is null!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/34bdf7a7e0714f0aa3ce0e831f11a6eb.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/34bdf7a7e0714f0aa3ce0e831f11a6eb.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/34bdf7a7e0714f0aa3ce0e831f11a6eb.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/34bdf7a7e0714f0aa3ce0e831f11a6eb.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/34bdf7a7e0714f0aa3ce0e831f11a6eb.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/34bdf7a7e0714f0aa3ce0e831f11a6eb.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>测试登录，登录成功！</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/a825fa4fb9da3a81cf4bf2cf6eeea224-20231125214638090.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/a825fa4fb9da3a81cf4bf2cf6eeea224-20231125214638090.png?size=small" data-sub-html="<h2>image-20220504193147760</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/a825fa4fb9da3a81cf4bf2cf6eeea224-20231125214638090.png" alt="image-20220504193147760" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/a825fa4fb9da3a81cf4bf2cf6eeea224-20231125214638090.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/a825fa4fb9da3a81cf4bf2cf6eeea224-20231125214638090.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/a825fa4fb9da3a81cf4bf2cf6eeea224-20231125214638090.png?size=large 2x" data-title="image-20220504193147760" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>解决Linux系统centos7的开机报错：Welcome to emergency mode</title><link>https://hezephyr.github.io/posts/03.%E8%A7%A3%E5%86%B3linux%E7%B3%BB%E7%BB%9Fcentos7%E7%9A%84%E5%BC%80%E6%9C%BA%E6%8A%A5%E9%94%99welcome-to-emergency-mode/</link><pubDate>Tue, 26 Apr 2022 22:44:36 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E8%A7%A3%E5%86%B3linux%E7%B3%BB%E7%BB%9Fcentos7%E7%9A%84%E5%BC%80%E6%9C%BA%E6%8A%A5%E9%94%99welcome-to-emergency-mode/</guid><description><![CDATA[<p>开机后报错如下：
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/031ebd8bcd3c4a969d0a383834b72cb6.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/031ebd8bcd3c4a969d0a383834b72cb6.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/031ebd8bcd3c4a969d0a383834b72cb6.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/031ebd8bcd3c4a969d0a383834b72cb6.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/031ebd8bcd3c4a969d0a383834b72cb6.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/031ebd8bcd3c4a969d0a383834b72cb6.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
报这个错误多数情况下是因为/etc/fstab文件的错误。注意一下是不是加载了外部硬盘、存储器或者是网络共享空间，在重启时没有加载上导致的。
我就是因为在上次编辑了/etc/fstab文件想实现自动挂载，但重启并没有挂载成功导致的。</p>
<p>所以我们需要恢复/etc/fstab文件，处理方法如下：</p>
<ol>
<li>
<p>先输入密码登录root账户；</p>
</li>
<li>
<p>输入<code>vim /etc/fstab</code>编辑，注释或者修改自己增加的内容；
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_19%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20240709224518670.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_19%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20240709224518670.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_19%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20240709224518670.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_19%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20240709224518670.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_19%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20240709224518670.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_19%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20240709224518670.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
这里我挂载defaults写成default了，所以会出错，所以我这里直接更改后就没有问题了。</p>
</li>
<li>
<p>保存并退出；</p>
</li>
<li>
<p>输入<code>reboot</code>重启即可恢复正常。</p>
</li>
</ol>
]]></description></item><item><title>Linux常用命令、管道、环境变量</title><link>https://hezephyr.github.io/posts/01.linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%A1%E9%81%93%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%A1%E9%81%93%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description><![CDATA[<h2 id="linux常用命令" class="heading-element"><span>1 Linux常用命令</span>
  <a href="#linux%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="系统状况" class="heading-element"><span>1.1 系统状况</span>
  <a href="#%e7%b3%bb%e7%bb%9f%e7%8a%b6%e5%86%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>top</code>：查看所有进程的信息（Linux的任务管理器）。</p>
<ul>
<li>打开后输入<code>M</code>：按使用内存排序；</li>
<li>打开后输入<code>P</code>：按使用CPU排序；</li>
<li>打开后输入<code>q</code>：退出。</li>
</ul>
<p><code>df -h</code>：查看硬盘使用情况。
<code>free -h</code>：查看内存使用情况。
<code>du -sh</code>：查看当前目录占用的硬盘空间。
<code>ps aux</code>：查看所有进程。
<code>kill -9 pid</code>：杀死编号为<code>pid</code>的进程。
<code>kill -s SIGTERM pid</code>：传递某个具体的信号。
<code>netstat -nt</code>：查看所有网络连接。
<code>w</code>：列出当前登录的用户。
<code>ping www.baidu.com</code>：测试网络连接，检查是否联网。</p>
<h3 id="文件权限" class="heading-element"><span>1.2 文件权限</span>
  <a href="#%e6%96%87%e4%bb%b6%e6%9d%83%e9%99%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>chmod</code>：修改文件权限</p>
<ul>
<li><code>chmod +x filename</code>：给<code>filename</code>添加可执行权限；</li>
<li><code>chmod -x filename</code>：去掉<code>filename</code>的可执行权限；</li>
<li><code>chmod abc filename</code>:其中a，b，c各为一个数字，表示User、Group以及Other的权限。r=4，w=2，x=1，为读，写，可执行。
如设置所有人对该文件都可读可写可执行，则设置<code>chmod 777 filename</code>。</li>
</ul>
<h3 id="文件检索" class="heading-element"><span>1.3 文件检索</span>
  <a href="#%e6%96%87%e4%bb%b6%e6%a3%80%e7%b4%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>find &lt;path&gt;(文件路径) -name '*.py'</code>：搜索path路径下的所有<code>py</code>文件。
<code>grep xxx</code>：从<code>stdin</code>中读入若干行数据，如果某行中包含<code>xxx</code>，则输出该行，否则忽略该行。
<code>wc</code>：统计行数、单词数、字节数。</p>
<ul>
<li>既可以从<code>stdin</code>中直接读取内容，也可以在命令行参数中传入文件名列表。</li>
<li><code>wc -l</code>：统计行数。</li>
<li><code>wc -w</code>：统计单词数。</li>
<li><code>wc -c</code>：统计字节数。</li>
</ul>
<p><code>tree</code>：展示当前目录的文件结构。</p>
<ul>
<li><code>tree path</code>：展示某个目录的文件结构。</li>
<li><code>tree -a</code>：显示隐藏文件。</li>
</ul>
<p><code>ag xxx</code>：搜索当前目录下的所有文件，检索<code>xxx</code>字符串。
<code>cut</code>：分割一行内容。</p>
<ul>
<li>从<code>stdin</code>中读入多行数据。</li>
<li><code>echo $PATH | cut -d ':' -f 3, 5</code>：输出<code>PATH</code>用<code>:</code>分割后的第3、5列数据。</li>
<li><code>echo $PATH | cut -d ':' -f 3-5</code>：输出<code>PATH</code>用<code>:</code>分割后的第3-5列数据。</li>
<li><code>echo $PATH | cut -c 3, 5</code>：输出<code>PATH</code>的第3、5个字符。</li>
<li><code>echo $PATH | cut -c 3-5</code>：输出<code>PATH</code>的第3-5个字符。</li>
</ul>
<p><code>sort</code>：将每行内容按字典序排序。</p>
<ul>
<li>可以从<code>stdin</code>中读取多行数据。</li>
<li>可以从命令行参数中读取文件名列表。</li>
</ul>
<p><code>xargs</code>：将<code>stdin</code>中的数据用空格或回车分割成命令行参数，作为其他命令使用。</p>
<ul>
<li><code>find . -name '*.py' | xargs cat | wc -l</code>：统计当前目录下所有python文件的总行数。</li>
</ul>
<h3 id="查看文件内容" class="heading-element"><span>1.4 查看文件内容</span>
  <a href="#%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>more</code>：浏览文件内容。</p>
<ul>
<li>回车或空格：下一行。</li>
<li><code>b</code>：上一页。</li>
<li><code>q</code>：退出。</li>
</ul>
<p><code>less</code>：和<code>more</code>类似，功能更全。</p>
<ul>
<li>回车：下一行。</li>
<li><code>y</code>：上一行。</li>
<li><code>Page Down</code>：下一页。</li>
<li><code>Page Up</code>：上一页。</li>
<li><code>q</code>：退出。</li>
</ul>
<p><code>head -3 xxx</code>：显示<code>xxx</code>的前3行内容。</p>
<ul>
<li>同时支持从<code>stdin</code>读入内容。</li>
</ul>
<p><code>tail -3 xxx</code>：显示<code>xxx</code>末尾3行内容。</p>
<ul>
<li>同时支持从<code>stdin</code>读入内容。</li>
</ul>
<h3 id="用户相关" class="heading-element"><span>1.5 用户相关</span>
  <a href="#%e7%94%a8%e6%88%b7%e7%9b%b8%e5%85%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>history</code>：展示当前用户的历史操作。内容存放在<code>~/bash_history</code>中。</p>
<h3 id="工具" class="heading-element"><span>1.6 工具</span>
  <a href="#%e5%b7%a5%e5%85%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>md5Sum</code>：计算<code>md5</code>的哈希值。</p>
<ul>
<li>也可以从<code>stdin</code>中读入内容，也可以在命令行参数中传入文件名列表。</li>
</ul>
<p><code>time command</code>：统计<code>command</code>命令的执行时间。
<code>ipython3</code>：交互式python环境。可以当作计算器，或者批量管理文件。
<code>i command</code>：<code>!</code>表示执行<code>shell</code>脚本命令。
<code>watch -n 0.1 command</code>：每隔0.1s就执行一次<code>command</code>命令。
<code>tar</code>：压缩文件。</p>
<ul>
<li><code>tar -zcvf xxx.tar.gz /path</code>：压缩。</li>
<li><code>tar -zxvf xxx.tar.gz </code>：解压缩。</li>
</ul>
<p><code>diff xxx yyy</code>：查看文件<code>xxx</code>和<code>yyy</code>的不同点。</p>
<h3 id="安装软件" class="heading-element"><span>1.7 安装软件</span>
  <a href="#%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>sudo command</code>：以<code>root</code>身份运行<code>command</code>命令。
<code>apt-get install xxx</code>：安装<code>xxx</code>软件。
<code>pip install xxx --user --upgrade</code>：安装python包。</p>
<h2 id="管道" class="heading-element"><span>2 管道</span>
  <a href="#%e7%ae%a1%e9%81%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="管道命令" class="heading-element"><span>2.1 管道命令</span>
  <a href="#%e7%ae%a1%e9%81%93%e5%91%bd%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>管道命令操作符是<code>|</code>，,它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后传递给下一个命令，作为标准的输入。
下图为管道命令的输出说明：
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBAdW5pcXVlX3B1cnN1aXQ%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16-20231125214459645.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
【指令1】正确输出，作为【指令2】的输入，然后【指令2】的输出作为【指令3】的输入 ，【指令3】输出就会直接显示在屏幕上面了。
通过管道之后，我们发现【指令1】和【指令2】的正确输出不显示在屏幕上面，只显示指令3的输出。</p>
<p>其类似于之前学习的文件重定向，可以将前面一个命令的<code>stdout</code>重定向下一个命令的<code>stdin</code>。但与文件重定向有很大区别：文件重定向左边为命令，右边为文件；管道左右两边均为命令，左边有<code>stdout</code>，右边有<code>stdin</code>。</p>
<p>值得注意的点：</p>
<ul>
<li>管道命令仅能处理<code>stdout</code>，忽略<code>stderr</code>。</li>
<li>管道右边的命令必须能接受<code>stdin</code>。</li>
<li>多个管道命令可以串联。</li>
</ul>
<h3 id="实例" class="heading-element"><span>2.2 实例</span>
  <a href="#%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>统计当前目录下所有python文件的总行数
统计总行数，在前面常用命令学习中，我们已经会了：<code>wc -l</code>，统计当前目录所有的python文件，也易得为：<code>find . -name '*.py'</code>。那么我们需要解决的问题则是将所有python文件选出来得到其内容再统计。我们则可能会这样：<code>find . -name '*.py' | cat | wc -l</code>。但<code>find . -name '*.py'</code>得到的是字符串，我们还需要利用<code>xargs</code>将字符串分割作为命令行参数，这样即可达到效果。
即：<code>find . -name '*.py' | xargs cat | wc -l</code>。</li>
</ul>
<h2 id="环境变量" class="heading-element"><span>3 环境变量</span>
  <a href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="概念" class="heading-element"><span>3.1 概念</span>
  <a href="#%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Linux系统中会用很多环境变量来记录配置信息。环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p>
<h3 id="查看环境变量" class="heading-element"><span>3.2 查看环境变量</span>
  <a href="#%e6%9f%a5%e7%9c%8b%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>列出当前环境下的所有环境变量：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="n">env</span> <span class="c"># 显示当前用户的变量；</span>
</span></span><span class="line"><span class="cl"><span class="nb">set </span><span class="c"># 显示当前shell的变量，包含当前用户的变量；</span>
</span></span><span class="line"><span class="cl"><span class="n">export</span> <span class="c"># 显示当前导出成用户变量的shell变量。</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>输出某个环境变量的值：<code>echo $PATH</code></li>
</ul>
<h3 id="修改环境变量" class="heading-element"><span>3.3 修改环境变量</span>
  <a href="#%e4%bf%ae%e6%94%b9%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>修改环境变量我们可以先将修改命令放到<code>~/.bashrc</code>文件中。修改完之后需执行<code>source ~/.bashrc</code>，来将修改应用到当前的<code>bash</code>环境下。</p>
<p>为何将修改命令放到<code>~/.bashrc</code>，就可以确保修改会影响未来所有的环境呢？</p>
<ul>
<li>每次启动<code>bash</code>，都会先执行<code>~/.bashrc</code>。</li>
<li>每次<code>ssh</code>登录远程服务器，都会启动一个<code>bash</code>命令行给我们。</li>
<li>每次<code>tmux</code>新开一个<code>pane</code>，都会启动一个<code>bash</code>命令行给我们。</li>
<li>未来所有的新开环境都会加载我们修改的内容。</li>
</ul>
<h3 id="常见环境变量" class="heading-element"><span>3.4 常见环境变量</span>
  <a href="#%e5%b8%b8%e8%a7%81%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>HOME</code>：用户的家目录
<code>PATH</code>：可执行文件（命令）的存储路径。路径与路径之间用<code>:</code>分隔。当某个可执行文件同时出现多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。
<code>LD_LIBRARY_PATH</code>：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。
<code>C_INCLUDE_PATH</code>：C语言的头文件路径，内容是以冒号分隔的路径列表。
<code>CPLUS_INCLUDE_PATH</code>：CPP的头文件路径，内容是以冒号分隔的路径列表。
<code>PYTHONPATH</code>：Python导入包的路径，内容是以冒号分隔的路径列表。
<code>JAVA_HOME</code>：jdk的安装目录。
<code>CLASSPATH</code>：存放Java导入类的路径，内容是以冒号分隔的路径列表。</p>
]]></description></item><item><title>Linux 系统调用函数fork、vfork、clone详解</title><link>https://hezephyr.github.io/posts/08.linux-forkvforkclone%E8%AF%A6%E8%A7%A3/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/08.linux-forkvforkclone%E8%AF%A6%E8%A7%A3/</guid><description><![CDATA[<h2 id="fork" class="heading-element"><span>1 fork</span>
  <a href="#fork" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>1.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>描述</p>
<blockquote>
<p>fork用于创建一个子进程，它与父进程的唯一区别在于其PID和PPID，以及资源利用设置为0。<font color="red">文件锁和挂起信号</font>（指已经被内核发送给一个进程，但尚未被该进程处理的信号）不会被继承，其他和父进程几乎完全相同：<font color="red">会获得父进程的内存空间、栈、数据段、堆、打开的文件描述符、信号处理函数、进程优先级、环境变量等资源的副本。</font></p>
</blockquote>
</li>
<li>
<p>返回值</p>
<blockquote>
<p>成功时，在父进程中返回子进程的 PID，在子进程中返回 $0$。失败时，父进程返回 $-1$，不创建子进程，并适当设置 errno。</p>
<p>其中errno是一个全局变量，它用于表示最近一次系统调用或库函数调用产生的错误代码。当系统调用或库函数失败时，它们通常会设置 errno 以指示错误的原因。</p>
<p>以下是一些常见的 errno 错误代码及其含义：</p>
<ul>
<li>EAGAIN：资源暂时不可用，通常是因为达到了系统限制，如文件描述符或内存限制。</li>
<li>ENOMEM：内存不足，无法分配请求的资源。</li>
<li>EACCES：权限不足，无法访问某个资源。</li>
<li>EINTR：系统调用被信号中断。</li>
<li>EINVAL：无效的参数。</li>
</ul>
</blockquote>
</li>
<li>
<p>重点</p>
<blockquote>
<p>fork() 函数创建的子进程会从父进程复制执行顺序。具体来说，子进程会从父进程复制当前的执行上下文，包括指令指针（instruction pointer）和寄存器的状态。这意味着子进程将从 fork() 系统调用之后的指令开始执行，与父进程在 fork() 之后应该执行的指令完全相同。<font color="red">因此，fork() 之后通常会有一个基于返回值的分支结构，以区分父进程和子进程的执行路径。</font></p>
</blockquote>
</li>
</ul>
<h3 id="fork实例" class="heading-element"><span>1.2 fork实例</span>
  <a href="#fork%e5%ae%9e%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>####.1多个fork返回值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid1</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid2</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid3</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span>  <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The PID of the current process is %d</span><span class="se">\n</span><span class="s"> Hello World from (%d, %d, %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">pid1</span><span class="p">,</span> <span class="n">pid2</span><span class="p">,</span> <span class="n">pid3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段程序包含了三个 fork() 调用，每个 fork() 都会创建一个新的子进程。由于每次 fork() 调用都会导致进程数翻倍，所以总共会有$2^3=8$个进程 （包括最初的父进程）。每个进程都会打印出它的进程 ID (pid) 以及三个 fork() 调用的返回值 (pid1, pid2, pid3)。</p>
<p>得到的输出结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=small" data-sub-html="<h2>image-20240312193151556</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png" alt="image-20240312193151556" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312193151556.png?size=large 2x" data-title="image-20240312193151556" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们画个状态机来理解它们的输出，假设最初的父进程PID为291871：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=small" data-sub-html="<h2>fork_information</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png" alt="fork_information" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/fork_information.png?size=large 2x" data-title="fork_information" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h4 id="c语言-fork与输出" class="heading-element"><span>1.2.1 C语言 fork与输出</span>
  <a href="#c%e8%af%ad%e8%a8%80-fork%e4%b8%8e%e8%be%93%e5%87%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码中，按我们的理解，第一次fork后有2个进程，然后一起执行printf输出，得到两个<code>Hello</code>，然后第二次fork后有4个进程，然后执行printf，得到四个<code>Hello</code>，则会有6个``Hello`，如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=small" data-sub-html="<h2>image-20240312200038027</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png" alt="image-20240312200038027" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200038027.png?size=large 2x" data-title="image-20240312200038027" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>但是当我们将输出通过管道传给<code>cat</code>等命令时，会看到8个<code>Hello</code>：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=small" data-sub-html="<h2>image-20240312200714610</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png" alt="image-20240312200714610" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312200714610.png?size=large 2x" data-title="image-20240312200714610" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是因为标准输出一般是行缓冲的，碰到<code>\n</code>，缓冲区中的内容会被刷新，即输出到终端或文件中。这种缓冲方式的目的是为了提高效率，因为这样可以减少对磁盘 I/O 的调用次数。</p>
<p>如果标准输出被重定向到管道，它可能不再是行缓冲的，而是变为全缓冲的。这意味着缓冲区可能会在填满时刷新，而不是在每次遇到换行符时刷新。如果缓冲区足够大，以至于可以容纳所有的 <code>Hello</code> 输出，那么fork的时候子进程也会复制缓冲区，导致最后每个进程中的缓冲区都有2个<code>Hello</code>，最后输出为8个。</p>
<p>如果为了确保缓冲区在需要的时候被刷新，可以在 printf 调用之后显式地调用 <code>fflush(stdout)</code> 来刷新标准输出缓冲区。这样可以确保所有的输出都被立即写入，而不会受到缓冲行为的影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=small" data-sub-html="<h2>image-20240312201140424</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png" alt="image-20240312201140424" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240312201140424.png?size=large 2x" data-title="image-20240312201140424" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h4 id="fork-" class="heading-element"><span>1.2.2 fork 💣</span>
  <a href="#fork-" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码会无限循环地调用 fork() 函数，每次循环都会创建一个新进程。由于每次 fork() 调用都会成功创建一个新进程，而且这个新进程又会立即进入下一次循环并再次调用 fork()，因此进程的数量会以指数速度增长，很快就会耗尽系统的可用资源。</p>
<p><font color="red">绝对不要在任何生产环境或您没有权限的任何系统上运行fork炸弹。</font></p>
<h2 id="vfork" class="heading-element"><span>2 vfork</span>
  <a href="#vfork" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>2.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>描述</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">pid_t</span> <span class="nf">vfork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>vfork()</code> 系统调用用于创建一个子进程，与 <code>fork()</code> 类似，但它使用父进程的地址空间，而不是复制父进程的地址空间。<font color="red"><code>vfork()</code> 调用后，父进程会阻塞，直到子进程调用 <code>exec</code> 函数或执行了 exit 函数。</font>这是因为子进程需要独占父进程的地址空间，以确保数据一致性。一。<font color="red">在子进程调用 <code>exec</code> 函数或执行了 <code>exit</code> 函数之后，子进程将获得自己的内存空间。</font></p>
</li>
<li>
<p>返回值</p>
<p>和<code>fork</code>一致</p>
</li>
<li>
<p>重点</p>
<blockquote>
<ol>
<li><code>vfork()</code> 创建的子进程会继承父进程的环境，但不会继承父进程的堆栈。</li>
<li>在子进程执行这些<code>exec</code>或<code>exit</code>操作之前，父进程和子进程可能会访问相同的内存地址，这可能导致数据竞争和不一致。</li>
<li>在 <code>vfork()</code> 调用成功后，子进程应该立即调用 <code>exec</code> 函数或执行 <code>exit</code> 函数。如果在子进程中修改除了用于存储从 <code>vfork()</code> 返回值的 <code>pid_t</code> 类型变量之外的任何数据，或者从调用 <code>vfork()</code> 的函数返回，或在成功调用 <code>_exit()</code> 或 <code>exec()</code> 函数族中的一个函数之前调用其他任何函数，则行为是未定义的。这可能会导致程序崩溃或表现出不可预测的行为。
因此，使用 <code>vfork()</code> 时，必须确保子进程在调用 <code>exec</code> 函数或执行 <code>exit</code> 函数之前不执行任何可能影响共享内存的操作。</li>
<li><code>vfork()</code> 系统调用会阻塞父进程，直到子进程完成 <code>exec</code> 调用或 <code>exit</code> 调用。父进程不需要显式调用 <code>wait()</code> 或 <code>waitpid()</code> 来等待子进程结束。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="验证vfork共享内存" class="heading-element"><span>2.2 验证vfork共享内存</span>
  <a href="#%e9%aa%8c%e8%af%81vfork%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在父进程中分配内存并初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用vfork创建子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">vfork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;vfork error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Child process: PID = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 修改内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;/bin/echo&#34;</span><span class="p">,</span> <span class="s">&#34;Hello, Linux!&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 执行exec函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">execve</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 父进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Parent process: PID = %d, child&#39;s PID = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 验证内存内容是否被子进程修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory corruption detected at index %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory is consistent</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个程序的目的是验证在 <code>vfork()</code> 之后，子进程和父进程是否共享内存。首先在父进程中分配一块内存 ，并将其初始化为字符<code> ‘A’</code>。然后，父进程调用 <code>vfork()</code> 创建一个子进程。在子进程中，程序试图将内容修改为字符 <code>‘B’</code>，并执行 <code>execve()</code>。在父进程中，程序检查缓冲区的内容是否被修改为字符 <code>‘B’</code>，以验证内存是否被正确共享。</p>
<p>程序运行结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=small" data-sub-html="<h2>image-20240313132239776</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png" alt="image-20240313132239776" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313132239776.png?size=large 2x" data-title="image-20240313132239776" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="clone" class="heading-element"><span>3 clone</span>
  <a href="#clone" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-2" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>描述</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define _GNU_SOURCE
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">clone</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">child_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">                 <span class="cm">/* pid_t *parent_tid, void *tls, pid_t *child_tid */</span> <span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>clone</code>与<code>fork</code>类似，是用于创建新进程的系统调用，但<code>clone</code>提供了更精确的控制，可以确定在调用进程（父进程）和子进程之间共享哪些执行上下文的部分。例如，调用者可以控制两个进程是否共享虚拟地址空间、文件描述符表和信号处理程序表。这些系统调用还允许将新的子进程放置在单独的命名空间中。</p>
</li>
<li>
<p>参数</p>
<blockquote>
<ul>
<li>
<p><code>fn</code>是指向新进程要执行的函数的指针，这个函数接受一个 void* 参数，并返回一个 int 类型的值，这个返回值将被 clone 系统调用捕获，并作为子进程的退出状态；</p>
</li>
<li>
<p><code>child_stack</code>是新进程的堆栈地址，由于子进程和调用进程可能共享内存，因此子进程不可能与调用进程在同一堆栈中执行。调用进程必须为子堆栈设置内存空间，并将指向该空间的指针传递给<code>clone()</code>。</p>
</li>
<li>
<p><code>flags</code>可以设置新进程的属性（通过二进制位设置），包括是否与原进程共享地址空间（CLONE_VM）、是否共享文件描述符表（CLONE_FILES）、是否共享信号处理器（CLONE_SIGHAND）等等；</p>
<p><code>int flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS;</code></p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">标志</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">CLONE_PARENT</td>
          <td style="text-align: center">创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_FS</td>
          <td style="text-align: center">子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_FILES</td>
          <td style="text-align: center">子进程与父进程共享相同的文件描述符（file descriptor）表</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_NEWNS</td>
          <td style="text-align: center">在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_SIGHAND</td>
          <td style="text-align: center">子进程与父进程共享相同的信号处理（signal handler）表</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_PTRACE</td>
          <td style="text-align: center">若父进程被trace，子进程也被trace</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_VFORK</td>
          <td style="text-align: center">父进程被挂起，直至子进程释放虚拟内存资源</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_VM</td>
          <td style="text-align: center">子进程与父进程运行于相同的内存空间</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_PID</td>
          <td style="text-align: center">子进程在创建时PID与父进程一致</td>
      </tr>
      <tr>
          <td style="text-align: center">CLONE_THREAD</td>
          <td style="text-align: center">Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><code>arg</code>是传递给新进程的参数；</p>
</li>
<li>
<p>可选参数，包括 <code>pid_t *parent_tid</code>等。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>返回值</p>
<blockquote>
<p>成功时，在父进程中返回子进程的 PID。失败时，父进程返回 $-1$，不创建子进程，并适当设置 <code>errno</code>。</p>
</blockquote>
</li>
<li>
<p>重点</p>
<blockquote>
<ol>
<li><code>clone</code> 可以创建新的进程或线程，Linux创建线程使用的系统调用就是<code>clone</code>。而 <code>fork</code> 和<code>vfork</code>只能创建进程。这意味着 <code>clone</code> 可以在单个进程中创建多个线程，而 <code>fork</code> 则总是创建一个新的进程。</li>
<li><code>clone</code> 提供比 <code>fork</code> 和 <code>vfork</code> 更多的选项，可以指定子进程或线程的堆栈、信号处理、权限等。</li>
<li><code>clone</code> 的使用比 <code>fork</code> 和 <code>vfork</code> 更复杂，需要正确设置 flags、child_stack、parent_pidptr、ptr、stack_size 和 tls 等参数。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="clone使用" class="heading-element"><span>3.2 clone使用</span>
  <a href="#clone%e4%bd%bf%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define _GNU_SOURCE
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define STACK_SIZE (1024 * 1024) </span><span class="cm">/* Stack size for cloned child */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 宏，简化错误处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define ERREXIT(msg) { perror(msg); exit(EXIT_FAILURE); }
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 安全分配内存函数，分配失败报告错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define CHECKALLOC(ptr, msg)  ({ void *p = ptr; if (p == NULL) {ERREXIT(msg);} p;})
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 子进程函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * params: 接受一个void *类型参数，但是没有被使用过，后面的声明是用于告诉编译器这个参数是未被使用的
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">childFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;child: start&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;child: terminate&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Child terminates now */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Start of stack buffer */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">**</span><span class="n">stacks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Child process&#39;s pids */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="o">*</span><span class="n">pids</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">nproc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 接受两个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;Wrong way to execute the program:</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;</span><span class="se">\t\t</span><span class="s">./waitpid nProcesses</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;example:</span><span class="se">\t</span><span class="s">./waitpid 2&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化nproc，表示要创建的子进程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nproc</span> <span class="o">=</span> <span class="nf">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="cm">/* Process count */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stacks</span> <span class="o">=</span> <span class="nf">CHECKALLOC</span><span class="p">(</span><span class="nf">malloc</span><span class="p">(</span><span class="n">nproc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)),</span> <span class="s">&#34;malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pids</span> <span class="o">=</span> <span class="nf">CHECKALLOC</span><span class="p">(</span><span class="nf">malloc</span><span class="p">(</span><span class="n">nproc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">)),</span> <span class="s">&#34;malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">stackTop</span><span class="p">;</span> <span class="cm">/* End of stack buffer */</span>
</span></span><span class="line"><span class="cl">        <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">CHECKALLOC</span><span class="p">(</span><span class="nf">malloc</span><span class="p">(</span><span class="n">STACK_SIZE</span><span class="p">),</span> <span class="s">&#34;stack malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 得到栈顶位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stackTop</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">STACK_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 创建子进程
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 第一个标志表示在子进程清除线程组ID（TID），目的是为了避免子进程与父进程或其他子进程的线程组ID冲突
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 第二个表示告诉在子进程中设置线程ID，目的是为了允许父进程在子进程中追踪线程
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 告诉 clone 系统调用在子进程中重新安装信号处理程序，目的是为了允许子进程捕获和处理信号，而不是传递给父进程。
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">clone</span><span class="p">(</span><span class="n">childFunc</span><span class="p">,</span> <span class="n">stackTop</span><span class="p">,</span> <span class="n">CLONE_CHILD_CLEARTID</span> <span class="o">|</span> <span class="n">CLONE_CHILD_SETTID</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ERREXIT</span><span class="p">(</span><span class="s">&#34;clone&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;clone() returned %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 第一个参数为子进程id，第二个参数表示不关心子进程的退出状态，第三个参数表示等待任何子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">waitpid</span><span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ERREXIT</span><span class="p">(</span><span class="s">&#34;waitpid&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child %ld has terminated</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 回收内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">stacks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">pids</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>运行：<code>gcc clone-example.c &amp;&amp; ./a.out 5</code>，其中5为<code>nproc</code>，表示要创建的进程数。</p>
<p>运行结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=small" data-sub-html="<h2>image-20240313212733984</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png" alt="image-20240313212733984" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240313212733984.png?size=large 2x" data-title="image-20240313212733984" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>Linux常用文件管理命令</title><link>https://hezephyr.github.io/posts/02.linux%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.linux%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</guid><description><![CDATA[<p>##. 通用基础知识</p>
<ul>
<li>
<p>查询指令命令<code>help</code>，通过<code>指令名 --help</code>或者<code>man 指令名</code>。</p>
<p>例如，我们需要查询<code>ls</code>这个指令的参数用法以及作用，即通过<code>ls --help</code>即可得到如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/f7b0cae87d70d287017f89c014a6c99d.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p><code>ctrl c</code>：取消命令，并且换行。</p>
</li>
<li>
<p><code>ctrl u</code>：清空本行命令</p>
</li>
<li>
<p><code>tab</code>：补全命令和文件名，如果补全不了就快速按两下<code>tab</code>键，可以显示备选项。</p>
</li>
</ul>
<p>##. 文件基础操作</p>
<ul>
<li>
<p><strong>注意事项</strong></p>
<ul>
<li>如果文件名或者文件夹名存在空格或者一些特殊字符，我们要进行转移表示，即通过转移字符<code>\</code>来实现。</li>
<li></li>
</ul>
</li>
<li>
<p>创建文件夹：<code>mkdir [-p][dirNmae]</code></p>
<p>其中<code>-p</code>确保目录名称一定存在，如果不存在就会创建一个。</p>
</li>
<li>
<p>创建文件：<code>touch [dirName + fileName]</code></p>
</li>
<li>
<p>显示当前目录下或者指定目录下的所有文件：<code>ls [参数][dirName]</code></p>
<p>其中显示的蓝色是文件夹，白色是普通文件，绿色是可执行文件，如图：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png" alt="https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png" srcset="https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png?size=small, https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/PicLibrary/main/img/image-20210818141132225.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>参数有：</p>
<ul>
<li><strong><code>-a</code>显示所有文件及目录 (. 开头的隐藏文件也会列出)</strong></li>
<li><strong><code>-l</code>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</strong></li>
<li><code>-r</code> 将文件以相反次序显示(原定依英文字母次序)</li>
<li><code>-t </code>将文件依建立时间之先后次序列出</li>
<li><code>-</code>A 同 <code>-a </code>，但不列出 &ldquo;.&rdquo; (目前目录) 及 &ldquo;..&rdquo; (父目录)</li>
<li><code>-F</code> 在列出的文件名称后加一符号；例如可执行档则加 &ldquo;*&rdquo;, 目录则加 &ldquo;/&rdquo;</li>
<li><code>-R</code> 若目录下有文件，则以下之文件亦皆依序列出</li>
</ul>
</li>
<li>
<p>显示目前所在的工作目录的绝对路径名称：<code>pwd</code></p>
</li>
<li>
<p>切换当前工作目录：<code>cd [dirName]</code></p>
<p>其中<code>dirName</code>可为绝对路径或相对路径，如果没有给出，默认返回家目录。<code>cd -</code>会返回之前的工作目录</p>
</li>
<li>
<p>删除文件或文件夹：<code>rm [dirName] [options]</code>，</p>
<p>其中选项包括：</p>
<pre><code>` -i` 删除前逐一询问确认。
</code></pre>
<p>　 <code>-f</code> 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</p>
<p>　 <code>-r</code> <strong>将目录及以下之档案亦逐一删除,递归所有的子目录,逐一询问。</strong></p>
<p>一般删除普通文件直接使用<code>rm [dirName]</code></p>
</li>
<li>
<p>创建编写文件：<code>vim [dirName]</code></p>
<p>创建好之后会自动进入文件，这个时候我们事写不动东西的，所以我们需要输入小写字母<code>i</code>（为insert的缩写）即可写入，写完之后如何保存？我们先需要按<code>ESC</code>键锁住文件，再输入<code>:wq</code>即可，这个命令就是保存并退出的意思。</p>
</li>
<li>
<p>查看文件：<code>cat [dirName]</code></p>
</li>
<li>
<p>复制文件：<code>cp [options] source dest</code></p>
<p>其中参数说明：</p>
<ul>
<li><code>-a</code>：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
<li><code>-d</code>：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</li>
<li><code>-f</code>：覆盖已经存在的目标文件而不给出提示。</li>
<li><code>-i</code>：与 <strong><code>-f</code></strong> 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 <strong>y</strong> 时目标文件将被覆盖。</li>
<li><code>-p</code>：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li><code>-r</code>：<strong>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。复制目录的时候一定要添加的参数</strong></li>
<li><code>-l</code>：不复制文件，只是生成链接文件。</li>
</ul>
<p>即<code>cp</code> = 复制+粘贴+重命名，我们可以看一个例子<code>cp a/tmp.txt b/tmp2.txt</code>，那么会从<code>a</code>中的</p>
<p><code>tmp.txt</code>复制到<code>b</code>中并重命名为<code>tmp2.txt</code>。</p>
</li>
<li>
<p>为文件或目录改名、或将文件或目录移入其它位置：<code>mv [options] source dest</code>。</p>
<p>如果需要重命名，就在后面加上新的文件名。</p>
<p>其中参数说明</p>
<ul>
<li><strong>-b</strong>: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li>
<li><strong>-i</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li>
<li><strong>-f</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li>
<li><strong>-n</strong>: 不要覆盖任何已存在的文件或目录。</li>
<li><strong>-u</strong>：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li>
</ul>
</li>
</ul>
<h2 id="编译运行cc文件" class="heading-element"><span>1 编译运行C/C++文件</span>
  <a href="#%e7%bc%96%e8%af%91%e8%bf%90%e8%a1%8ccc%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>编译</strong></p>
<p><code>g++ 文件名.cpp -o 文件名 -std=版本</code></p>
<p>例如:<code>g++ main.cpp -o main -std=c++11</code></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0c831c902b7d2c4769b8820ad28f357b-20231125214551602.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>值得注意的一点就是在<code>AC Terminal</code>里面是用不了万能头文件的。</p>
</li>
<li>
<p><strong>运行</strong></p>
<p><code>./文件名</code>，即可运行。</p>
</li>
</ul>
<h2 id="参考文献" class="heading-element"><span>2 参考文献</span>
  <a href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a href="https://www.acwing.com/activity/content/introduction/57/"target="_blank" rel="external nofollow noopener noreferrer">y总Linux基础课<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item></channel></rss>