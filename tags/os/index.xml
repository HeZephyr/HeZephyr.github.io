<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>OS - 标签 | ZephyrHe</title><link>https://hezephyr.github.io/tags/os/</link><description>OS - 标签 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Sat, 11 May 2024 21:38:23 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/tags/os/" rel="self" type="application/rss+xml"/><item><title>Andrew文件系统</title><link>https://hezephyr.github.io/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:38:23 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Andrew 文件系统是卡内基梅隆大学 (CMU) 于 1980 年代引入的。该项目由CMU著名教授 M. Satyanarayanan（简称“Satya”）领导，其主要目标很简单：<strong>扩展性</strong>。具体来说，如何设计一个分布式文件系统，使得服务器可以支持尽可能多的客户端？</p>
<p>有趣的是，设计和实现的许多方面都会影响可扩展性。最重要的是客户端和服务器之间的<strong>协议设计</strong>。例如，在 NFS 中，协议强制客户端定期检查服务器以确定缓存的内容是否已更改；由于每次检查都会占用服务器资源（包括CPU和网络带宽），因此频繁进行这样的检查将限制服务器可以响应的客户端数量，从而限制可扩展性。</p>
<p>AFS 与 NFS 的不同之处还在于，从一开始，合理的用户可见行为就是首要关注的问题。在 NFS 中，缓存一致性很难描述，因为它直接取决于低级实现细节，包括客户端缓存超时间隔。在AFS中，缓存一致性很简单且易于理解：当文件被打开时，客户端通常会从服务器接收到最新的一致副本。</p>
<p>我们将讨论两个版本的 AFS。第一个版本（我们称之为 AFSv1，但实际上最初的系统被称为 ITC 分布式文件系统有一些基本设计，但扩展性不尽如人意，这导致了重新设计和最终协议（我们称之为 AFSv2，或简称 AFS）。</p>
<h2 id="afsv1" class="heading-element"><span>2 AFSv1</span>
  <a href="#afsv1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>2.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">AFS 所有版本的基本原则之一是在访问文件的客户端计算机的本地磁盘上缓存整个文件。</font>当您 <code>open()</code> 文件时，将从服务器获取整个文件（如果存在）并将其存储在本地磁盘上的文件中。后续应用程序的<code>read()</code>和<code>write()</code>操作将被重定向到存储文件的本地文件系统；因此，这些操作不需要网络通信并且速度很快。最后，在 <code>close()</code> 时，文件（如果已被修改）被刷新回服务器。请注意与 NFS 的明显对比，NFS 缓存块（不是整个文件，尽管 NFS 当然可以缓存整个文件的每个块）并在客户端内存（而不是本地磁盘）中进行缓存。</p>
<p>让我们进一步了解细节。当客户端应用程序第一次调用 <code>open()</code> 时，AFS 客户端代码（AFS 设计者称之为 <strong>Venus</strong>）将向服务器发送一条 Fetch 协议消息。 Fetch 协议消息会将所需文件的整个路径名（例如，<code>/home/zfhe/notes.txt</code>）传递到文件服务器（他们称之为 <strong>Vice</strong> 的组），然后文件服务器将遍历路径名，找到所需的文件，并将整个文件发回给客户端。然后，客户端代码会将文件缓存在客户端的本地磁盘上（通过将其写入本地磁盘）。正如我们上面所说，后续的 <code>read()</code> 和 <code>write()</code> 系统调用在 AFS 中严格是本地的（不发生与服务器的通信）；它们只是重定向到文件的本地副本。由于 <code>read()</code> 和 <code>write()</code> 调用的行为就像对本地文件系统的调用一样，因此一旦访问了一个块，它也可能会缓存在客户端内存中。因此，AFS 还使用客户端内存来缓存其本地磁盘中的块副本。最后，完成后，AFS 客户端检查文件是否已被修改（即，它已被打开用于写入）；如果是，它将使用存储协议消息将新版本刷新回服务器，并将整个文件和路径名发送到服务器进行持久存储。</p>
<p>下次访问文件时，AFSv1 的效率会更高。具体来说，客户端代码首先联系服务器（使用 TestAuth 协议消息）以确定文件是否已更改。如果没有，客户端将使用本地缓存的副本，从而通过避免网络传输来提高性能。下面展示了AFSv1中的一些协议消息。请注意，该协议的早期版本仅缓存文件内容；例如，目录仅保存在服务器上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">TestAuth 		Test whether a file has changed
</span></span><span class="line"><span class="cl">				(used to validate cached entries)
</span></span><span class="line"><span class="cl">GetFileStat 	Get the stat info for a file
</span></span><span class="line"><span class="cl">				Fetch Fetch the contents of file
</span></span><span class="line"><span class="cl">Store 			Store this file on the server
</span></span><span class="line"><span class="cl">SetFileStat 	Set the stat info for a file
</span></span><span class="line"><span class="cl">ListDir 		List the contents of a directory</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存在的问题" class="heading-element"><span>2.2 存在的问题</span>
  <a href="#%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>AFS 第一个版本的一些关键问题促使设计人员重新考虑他们的文件系统。为了详细研究这些问题，AFS 的设计者花费了大量时间测量他们现有的原型，以找出问题所在。这样的实验是一件好事，因为测量是理解系统如何工作以及如何改进系统的关键；因此，获得具体、良好的数据是系统建设的必要组成部分。在他们的研究中，作者发现 AFSv1 的两个主要问题：</p>
<ul>
<li><strong>路径遍历成本太高</strong>：当执行 Fetch 或 Store 协议请求时，客户端将整个路径名（例如 <code>/home/zfhe/notes.txt</code>）传递给服务器。服务器为了访问该文件，必须执行完整的路径名遍历，首先在根目录中查找<code>home</code>，然后在<code>home</code>中查找<code>zfhe</code>，依此类推，一直沿着路径遍历，直到最后找到所需的文件。由于许多客户端同时访问服务器，AFS 的设计者发现服务器花费了大量的 CPU 时间只是沿着目录路径查找。</li>
<li><strong>客户端发出过多的TestAuth 协议消息</strong>：与NFS 及其过多的GETATTR 协议消息非常相似，，AFSv1 也产生了大量流量，用于通过 TestAuth 协议信息检查本地文件（或其状态信息）是否有效。因此，服务器要花费大量时间告诉客户端是否可以使用其缓存的文件副本。大多数情况下，答案是文件没有变化。</li>
</ul>
<p>AFSv1 实际上还存在两个问题：<strong>服务器之间的负载不均衡</strong>，并且<strong>服务器对每个客户端使用单独的进程，从而导致上下文切换和其他开销</strong>。通过引入<strong>卷</strong>解决了负载不均衡问题，管理员可以跨服务器移动卷以均衡负载； AFSv2 中通过使用线程而不是进程构建服务器来解决上下文切换问题。然而，我们在这里重点关注上面限制系统规模的两个主要协议问题。</p>
<p>上述两个问题限制了AFS的可扩展性；服务器CPU成为系统的瓶颈，每台服务器只能服务20个客户端而不至于过载。服务器接收到太多 TestAuth 消息，并且当它们接收到 Fetch 或 Store 消息时，会花费太多时间遍历目录层次结构。因此，AFS 设计者面临着一个问题：</p>
<blockquote>
<center>如何设计可扩展的文件协议 
</center>
<p>应如何重新设计协议以最大限度地减少服务器交互的数量，即如何减少 TestAuth 消息的数量？此外，他们如何设计协议以使这些服务器交互高效？通过解决这两个问题，新协议将产生更具可扩展性的 AFS 版本。</p>
</blockquote>
<h2 id="afsv2" class="heading-element"><span>3 AFSv2</span>
  <a href="#afsv2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>AFSv2 引入了<strong>回调</strong>的概念，以减少客户端/服务器交互的次数。<font color="red">回调只是服务器对客户端的一个承诺，即当客户端缓存的文件被修改时，服务器将通知客户端。</font>在系统中添加这种状态后，客户端就不再需要联系服务器来了解缓存文件是否仍然有效。相反，它会假定文件是有效的，直到服务器告诉它否则；请注意<strong>轮询</strong>与<strong>中断</strong>之间的类比。</p>
<p>AFSv2 还引入了**文件标识符（FID）**的概念（类似于 NFS <strong>文件句柄</strong>），而不是路径名来指定客户端感兴趣的文件。AFS 中的 FID 由一个卷标识符、一个文件标识符和一个 &ldquo;唯一标识符 &ldquo;组成（以便在删除文件时重复使用卷和文件标识符）。因此，客户端不再向服务器发送整个路径名，并让服务器遍历路径名以找到所需的文件，而是逐步遍历路径名，缓存结果，并希望减少对服务器的负载。</p>
<p>例如，如果客户端访问文件<code>/home/zfhe/notes.txt</code>，而 <code>home</code> 是挂载在 <code>/</code> 上的 AFS 目录（即 <code>/</code> 是本地根目录，但 <code>home</code> 及其子目录在 AFS 中），客户端将首先获取 <code>home</code> 的目录内容，将其放入本地磁盘缓存，并在 <code>home</code> 上设置回调。然后，客户机将取回 <code>zfhe</code> 目录，将其放入本地磁盘缓存，并在 <code>zfhe</code> 上设置回调。最后，客户端会获取<code>notes.txt</code>，将这个常规文件缓存到本地磁盘，并设置回调，最后向调用应用程序返回一个文件描述符。这个过程如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=small" data-sub-html="<h2>image-20240424210624267</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png" alt="image-20240424210624267" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=large 2x" data-title="image-20240424210624267" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>不过，与 NFS 的主要区别在于，每次获取目录或文件时，AFS 客户端都会与服务器建立回调，从而确保服务器会通知客户端其缓存状态的变化。这样做的好处显而易见：虽然对<code>/home/zfhe/notes.txt</code> 的首次访问会产生许多客户端-服务器信息（如上所述），但同时也会为所有目录以及<code>notes.txt</code> 文件建立回调，因此后续访问完全是本地操作，根本不需要与服务器交互。因此，在客户端缓存文件的常见情况下，AFS 的行为几乎与本地磁盘文件系统相同。如果访问一个文件不止一次，那么第二次访问的速度应该与本地访问文件的速度一样快。</p>
<h3 id="缓存一致性" class="heading-element"><span>3.2 缓存一致性</span>
  <a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<center>缓存一致性不是万能的
</center>
<p>在讨论分布式文件系统时，很多人都会提到文件系统提供的缓存一致性。然而，这种基本一致性并不能解决多个客户端访问文件的所有问题。例如，如果你正在建立一个代码库，有多个客户端执行代码的检入和检出，你就不能简单地依赖底层文件系统来为你完成所有工作；<font color="red">相反，你必须使用显式文件级锁定，以确保在发生这种并发访问时发生 &ldquo;正确 &ldquo;的事情。</font>事实上，任何真正关心并发更新的应用程序都会增加额外的机制来处理冲突。基本一致性主要适用于临时使用，也就是说，当用户登录到不同的客户端时，他们希望在客户端上显示其文件的合理版本。如果对这些协议抱有更高的期望，就会让自己陷入失败、失望和充满泪水的沮丧之中。</p>
</blockquote>
<p>当我们讨论 NFS 时，我们考虑了缓存一致性的两个方面：<strong>更新可见性</strong>和<strong>缓存陈旧性</strong>。</p>
<ul>
<li>对于更新可见性，问题是：服务器何时会使用新版本的文件进行更新？</li>
<li>对于缓存陈旧性，问题是：一旦服务器有了新版本，客户端多久才能看到新版本而不是旧的缓存副本？</li>
</ul>
<p>由于<strong>回调</strong>和<strong>全文件缓存</strong>，AFS 提供的缓存一致性很容易描述和理解。有两个重要的情况需要考虑：<font color="red">不同机器上的进程之间的一致性，以及同一机器上的进程之间的一致性。</font></p>
<p>在不同的计算机之间，AFS 使更新在服务器上可见，并在同一时间（即更新的文件关闭时）使缓存的副本失效。客户端打开一个文件，然后写入（可能重复）。当它最终关闭时，新文件将刷新到服务器（因此可见）。此时，服务器会“中断”任何具有缓存副本的客户端的回调；**中断是通过联系每个客户端并通知它对文件的回调不再有效来完成的。**此步骤确保客户端将不再读取文件的过时副本；这些客户端上的后续打开将需要从服务器重新获取文件的新版本（并且还将用于在文件的新版本上重新建立回调）。</p>
<p>AFS 对同一台机器上的进程之间的这种简单模型进行了例外处理。在这种情况下，对文件的写入对其他本地进程立即可见（即，进程不必等到文件关闭才能查看其最新更新）。这使得使用单台机器的行为完全符合您的预期，因为此行为基于典型的 UNIX 语义。只有当切换到不同的机器时，你才能检测到更通用的AFS一致性机制。</p>
<p>有一个有趣的跨机器案例值得进一步讨论。具体来说，在不同机器上的进程同时修改文件的罕见情况下，AFS 自然会采用所谓的“<strong>最后写入者获胜</strong>”方法（也许应该称为“<strong>最后关闭者获胜</strong>”）。具体来说，最后调用 <code>close()</code> 的客户端将最后更新服务器上的整个文件，因此将成为“获胜”文件，即保留在服务器上供其他人查看的文件。结果是一个由一个客户端或另一个客户端完整生成的文件。请注意与 NFS 等基于块的协议的区别：在 NFS 中，当每个客户端更新文件时，各个块的写入可能会被刷新到服务器，因此服务器上的最终文件可能是两个客户端更新的混合体。在许多情况下，这种混合文件输出没有多大意义，即想象一下 JPEG 图像被两个客户端分段修改；由此产生的写入组合不太可能构成有效的 JPEG。</p>
<p>下图中显示了其中一些不同场景的时间线。这些列显示了 $Client_1$ 上的两个进程（$P_1$ 和 $P_2$）及其缓存状态、$Client_2$ 上的一个进程 ($P_3$) 及其缓存状态以及服务器 (Server) 的行为，所有这些都在一个名为 $F$ 的文件上进行操作。对于服务器来说，图中只是显示了左边操作完成后的文件内容。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=small" data-sub-html="<h2>image-20240424212508074</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png" alt="image-20240424212508074" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=large 2x" data-title="image-20240424212508074" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="崩溃恢复" class="heading-element"><span>3.3 崩溃恢复</span>
  <a href="#%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>从上面的描述中，你可能会感觉到崩溃恢复比 NFS 更复杂。你是对的。例如，假设服务器 (S) 在短时间内无法与客户端(C1) 取得联系，比如客户端 C1 正在重启。当 C1 不可用时，S 可能已尝试向其发送一条或多条回调召回消息；例如，假设 C1 在本地磁盘上缓存了文件 F，然后 C2（另一个客户端）更新了 F，从而导致 S 向所有缓存该文件的客户端发送消息，要求它们从本地缓存中删除该文件。<font color="red">由于 C1 在重启时可能会错过这些关键信息，因此在重新加入系统时，C1 应将其所有缓存内容视为可疑内容。</font>因此，在下一次访问文件 F 时，C1 应首先询问服务器（通过 TestAuth 协议消息）其缓存的文件 F 副本是否仍然有效；如果有效，C1 可以使用它；如果无效，C1 应从服务器获取更新的版本。</p>
<p>服务器崩溃后的恢复也比较复杂。由此产生的问题是，回调是保存在内存中的；因此，当服务器重启时，它不知道哪台客户机拥有哪些文件。<font color="red">因此，服务器重启后，服务器的每个客户端都必须意识到服务器已经崩溃，并将其所有缓存内容视为可疑内容，并且（如上所述）在使用文件之前重新确定其有效性。</font></p>
<p>因此，服务器崩溃是一件大事，因为必须确保每个客户端都能及时意识到服务器崩溃，否则客户端就有可能访问过期文件。实现这种恢复的方法有很多，例如，当服务器重新启动并运行时，让服务器向每个客户端发送一条消息（说 &ldquo;不要相信你的缓存内容！&quot;），或者让客户端定期检查服务器是否还活着（即所谓的 &ldquo;心跳消息&rdquo;）。正如你所看到的，建立一个可扩展性更强、更合理的缓存模型是有代价的；在 NFS 中，客户端几乎不会注意到服务器崩溃。</p>
<h3 id="可扩展性和性能" class="heading-element"><span>3.4 可扩展性和性能</span>
  <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7%e5%92%8c%e6%80%a7%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>采用新协议后，对 AFSv2 进行了测量，发现其可扩展性远远超过原始版本。事实上，每台服务器可以支持大约 50 个客户端（而不是 20 个）。另一个好处是，客户端的性能往往非常接近本地性能，因为在普通情况下，所有文件访问都是本地的；文件读取通常会进入本地磁盘缓存（也可能进入本地内存）。只有在客户端创建新文件或写入现有文件时，才需要向服务器发送存储信息，从而用新内容更新文件。</p>
<p>我们还可以通过比较常见的文件系统访问情况和 NFS 来了解 AFS 的性能。下图显示了定性比较的结果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=small" data-sub-html="<h2>image-20240424213449188</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png" alt="image-20240424213449188" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=large 2x" data-title="image-20240424213449188" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，我们分析了不同大小文件的典型读写模式。小文件有 $N_s$ 个块；中等文件有 $N_m$ 个块；大文件有 $N_L$ 个块。我们假定，小型和中型文件适合放在客户端内存中；大型文件适合放在本地磁盘上，但不适合放在客户端内存中。</p>
<p>为便于分析，我们还假设，通过网络访问远程服务器的文件块需要 $L_{net}$ 时间单位。访问本地内存需要 $L_{mem}$，访问本地磁盘需要 $L_{disk}$。一般假设是$L_{net} &gt; L_{disk} &gt; L_{mem}$。</p>
<p>最后，我们假设对文件的首次访问不在任何缓存中发生。如果相关缓存有足够的容量容纳文件，我们假设对文件的后续访问（即 &ldquo;重读&rdquo;）会在缓存中命中。</p>
<p>图中各列显示了特定操作（如小文件顺序读取）在 NFS 或 AFS 上大致花费的时间。最右边一列显示的是 AFS 与 NFS 的比例。</p>
<p>我们得出以下结论。首先，在许多情况下，每个系统的性能大致相当。例如，在首次读取文件时（如工作负载 1、3、5），从远程服务器获取文件的时间占主导地位，而且在两个系统上的时间相似。在这种情况下，您可能会认为 AFS 的速度会慢一些，因为它必须将文件写入本地磁盘；但是，本地（客户端）文件系统缓存会对这些写入进行缓冲，因此上述成本很可能是隐性的。同样，你可能会认为 AFS 从本地缓存副本读取文件的速度会更慢，这也是因为 AFS 将缓存副本存储在磁盘上。然而，AFS 也能从本地文件系统缓存中获益；AFS 上的读取可能会在客户端内存缓存中进行，性能与 NFS 类似。</p>
<p>其次，在大文件顺序重读（工作负载 6）过程中出现了一个有趣的差异。由于 AFS 有一个很大的本地磁盘缓存，当文件再次被访问时，它会从本地磁盘缓存中访问文件。相比之下，NFS 只能缓存客户端内存中的数据块；因此，如果重新读取大文件（即大于本地内存的文件），NFS 客户端将不得不从远程服务器重新获取整个文件。因此，假设远程访问确实比本地磁盘慢，在这种情况下，AFS 比 NFS 快 $\frac{L_{net}}{L_{disk}}$ 的系数。我们还注意到，在这种情况下，NFS 会增加服务器负载，这也会对扩展性产生影响。</p>
<p>第三，我们注意到，顺序写入（新文件）在两个系统上的执行情况类似（工作负载 8、9）。在这种情况下，AFS 会将文件写入本地缓存副本；当文件关闭时，AFS 客户端会根据协议强制将文件写入服务器。NFS 会在客户端内存中缓冲写入，也许会因为客户端内存压力而强制将某些块写入服务器，但在文件关闭时肯定会将它们写入服务器，以保持 NFS 的关闭时刷新一致性。你可能会认为 AFS 的速度会更慢，因为它会将所有数据写入本地磁盘。但是，你要知道，<font color="red">它是在向本地文件系统写入数据；这些写入的数据首先提交到页面缓存，然后才（在后台）提交到磁盘，因此 AFS 可以利用客户端操作系统内存缓存基础架构的优势来提高性能。</font></p>
<p>第四，我们注意到 AFS 在顺序文件覆盖（工作负载 10）上的性能更差。到目前为止，我们假定写入的工作负载也在创建新文件；在这种情况下，文件存在，然后被覆盖写入。对于 AFS 来说，重写可能是一种特别糟糕的情况，因为客户端首先会完整地获取旧文件，然后再将其重写。与此相反，NFS 只需覆盖块，从而避免了最初的（无用的）读取。</p>
<p>最后，访问大文件中一小部分数据的工作负载在 NFS 上的表现要比 AFS 好得多（工作负载 7、11）。在这些情况下，AFS 协议会在打开文件时获取整个文件；但不幸的是，只会执行少量的读取或写入操作。更糟糕的是，<font color="red">如果文件被修改，整个文件都会被写回服务器，对性能的影响会加倍</font>。NFS 作为基于块的协议，执行的 I/O 与读取或写入的大小成正比。总之，我们看到 NFS 和 AFS 的假设不同，因此实现的性能结果也不同，这并不奇怪。这些差异是否重要，始终是一个工作负载问题。</p>
<blockquote>
<center>工作负载的重要性
</center>
<p>评估任何系统的一大挑战是<strong>工作负载的选择</strong>。由于计算机系统的使用方式多种多样，因此有多种工作负载可供选择。存储系统设计人员应如何确定哪些工作负载是重要的，以便做出合理的设计决策？</p>
<p>AFS 的设计者根据衡量文件系统使用方式的经验，做出了某些工作负载假设；特别是，他们假设大多数文件不经常共享，并且整体上按顺序访问。考虑到这些假设，AFS 设计就非常有意义了。</p>
<p>然而，这些假设并不总是正确的。例如，假设有一个应用程序定期将信息附加到日志中。这些小日志写入会将少量数据添加到现有的大文件中，这对于 AFS 来说是相当有问题的。还存在许多其他困难的工作负载，例如事务数据库中的随机更新。</p>
</blockquote>
<h2 id="afs其他改进" class="heading-element"><span>4 AFS：其他改进</span>
  <a href="#afs%e5%85%b6%e4%bb%96%e6%94%b9%e8%bf%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>就像我们在引入 Berkeley FFS（添加了符号链接和许多其他功能）时看到的那样，AFS 的设计者在构建系统时抓住了机会添加了许多功能，使系统更易于使用和管理。<font color="red">例如，AFS 为客户端提供了真正的全局命名空间，从而确保所有文件在所有客户端计算机上都以相同的方式命名。</font>相比之下，NFS 允许每个客户端以他们喜欢的任何方式安装 NFS 服务器，因此只有按照约定（以及大量的管理工作），文件才能在客户端之间以类似的方式命名。</p>
<p>AFS 还非常重视安全性，并采用了对用户进行身份验证的机制，并确保如果用户愿意，可以将一组文件保持私有。相比之下，NFS 多年来对安全性的支持相当原始。</p>
<p>AFS 还包括用于灵活的用户管理访问控制的设施。因此，在使用 AFS 时，用户可以很好地控制谁可以访问哪些文件。 NFS 与大多数 UNIX 文件系统一样，对此类共享的支持要少得多。</p>
<p>最后，如前所述，AFS 添加了一些工具，使系统管理员能够更简单地管理服务器。在系统管理方面，AFS 遥遥领先于该领域。</p>
]]></description></item><item><title>网络文件系统</title><link>https://hezephyr.github.io/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:37:27 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="基本的分布式文件系统" class="heading-element"><span>1 基本的分布式文件系统</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式客户端/服务器计算最早应用于分布式文件系统领域。在这种环境中，<strong>有多台客户机和一台（或几台）服务器</strong>；服务器将数据存储在磁盘上，客户机通过格式良好的协议信息请求数据。下图描述了基本设置。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Generic_Client_Server_System.png" alt="image-20240423230842288" style="zoom:50%;" />
<p>从图中可以看出，服务器拥有磁盘，客户端通过网络发送消息来访问这些磁盘上的目录和文件。我们为什么要费心这样的安排呢？ （即，为什么我们不让客户端使用他们的本地磁盘？）嗯，<font color="red">主要是这种设置允许在客户端之间轻松共享数据。</font>因此，如果您访问一台计算机（客户端 0）上的文件，然后使用另一台计算机（客户端 2），您将拥有相同的文件系统视图。您的数据自然会在这些不同的机器之间共享。第二个好处是<strong>集中管理</strong>；例如，备份文件可以从少数服务器计算机而不是多个客户端完成。另一个优势可能是安全性。将所有服务器放在上锁的机房中可以防止出现某些类型的问题。</p>
<p>因此关键问题是：</p>
<blockquote>
<p>如何构建分布式文件系统？需要考虑哪些关键方面？什么容易出错？我们可以从现有系统中学到什么？</p>
</blockquote>
<p>我们现在将研究简化的分布式文件系统的架构。一个简单的客户端/服务器分布式文件系统比我们迄今为止研究的文件系统具有更多的组件。在客户端，有一些客户端应用程序通过<strong>客户端文件系统</strong>访问文件和目录。客户端应用程序向客户端文件系统发出系统调用（例如 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>close()</code>、<code>mkdir()</code> 等），以便访问存储在服务器上的文件。因此，对于客户端应用程序来说，除了性能之外，文件系统似乎与本地（基于磁盘的）文件系统没有任何不同。这样，分布式文件系统提供了对文件的<strong>透明</strong>访问，这是一个显而易见的目标；毕竟，谁会愿意使用一个需要不同的应用程序接口或者使用起来很麻烦的文件系统呢？</p>
<p>客户端文件系统的作用是执行服务这些系统调用所需的操作。例如，如果客户端发出 <code>read()</code> 请求，客户端文件系统可能会向<strong>服务器端文件系统</strong>（或者通常称为<strong>文件服务器</strong>）发送消息以读取特定块；然后，文件服务器将从磁盘（或其自己的内存缓存）读取该块，并将包含请求数据的消息发送回客户端。然后，客户端文件系统会将数据复制到提供给 <code>read()</code> 系统调用的用户缓冲区中，从而完成请求。请注意，客户端上同一块的后续 <code>read()</code> 可能会缓存在客户端内存中，甚至缓存在客户端磁盘上；在最好的情况下，不需要产生网络流量。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=small" data-sub-html="<h2>image-20240423231648503</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png" alt="image-20240423231648503" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=large 2x" data-title="image-20240423231648503" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从这个简单的概述中，您应该了解到客户端/服务器分布式文件系统中有两个重要的软件部分：客户端文件系统和文件服务器。它们的行为共同决定了分布式文件系统的行为。现在是时候研究一个特定的系统了：Sun 的<strong>网络文件系统 (NFS)</strong>。</p>
<h2 id="网络文件系统nfs" class="heading-element"><span>2 网络文件系统（NFS）</span>
  <a href="#%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9fnfs" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Sun Microsystems 公司开发的分布式系统是最早也是相当成功的分布式系统之一，被称为 Sun 网络文件系统（或 NFS）。在定义 NFS 时，Sun 采用了一种不同寻常的方法：Sun 没有构建一个专有的封闭系统，而是开发了一个开放协议，简单地规定了客户机和服务器用于通信的确切信息格式。不同的团体可以开发自己的 NFS 服务器，从而在 NFS 市场上竞争，同时保持互操作性。这种做法取得了成功：如今有许多公司都在销售 NFS 服务器（包括 Oracle/Sun、NetApp、EMC、IBM 和其他公司），NFS 的广泛成功很可能归功于这种 &ldquo;开放市场 &ldquo;方法。</p>
<h3 id="重点简单快速的服务器崩溃恢复" class="heading-element"><span>2.1 重点：简单快速的服务器崩溃恢复</span>
  <a href="#%e9%87%8d%e7%82%b9%e7%ae%80%e5%8d%95%e5%bf%ab%e9%80%9f%e7%9a%84%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在本章中，我们将讨论经典的 NFS 协议（版本 2，又称 NFSv2），该协议是多年来的标准；在向 NFSv3 迁移时进行了一些小改动，在向 NFSv4 迁移时进行了更大规模的协议改动。然而，NFSv2 既精彩又令人沮丧，因此成为我们关注的焦点。在 NFSv2 中，协议设计的主要目标是简单快速地恢复服务器崩溃。在多客户端、单服务器的环境中，这一目标是非常合理的；服务器宕机（或不可用）的任何一分钟都会让所有客户端机器（及其用户）不高兴，并影响工作效率。因此，服务器垮了，整个系统也就垮了。</p>
<h4 id="快速崩溃恢复的关键无状态" class="heading-element"><span>2.1.1 快速崩溃恢复的关键：无状态</span>
  <a href="#%e5%bf%ab%e9%80%9f%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d%e7%9a%84%e5%85%b3%e9%94%ae%e6%97%a0%e7%8a%b6%e6%80%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>NFSv2 通过设计无状态协议实现了这一简单目标。根据设计，服务器不会跟踪每个客户端正在发生的任何事情。例如，服务器不知道哪些客户端正在缓存哪些数据块，也不知道每个客户端当前打开了哪些文件，更不知道文件的当前文件指针位置等。简而言之，服务器不会跟踪客户端正在做的任何事情；相反，协议的设计目的是在每个协议请求中提供完成请求所需的所有信息。</p>
<p>有状态（非无状态）协议的一个例子是 <code>open()</code> 系统调用。给定一个路径名，<code>open()</code> 返回一个文件描述符（整数）。该描述符将用于后续的 <code>read()</code> 或 <code>write()</code> 请求，以访问各种文件块，如下面这段代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">// get descriptor &#34;fd&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// read MAX bytes from foo (via fd)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// read MAX bytes from foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// read MAX bytes from foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">// close file
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在想象一下，客户端文件系统通过向服务器发送一条协议消息“打开文件‘foo’并给我返回一个描述符”来打开文件。然后，文件服务器在其本地打开该文件并将描述符发送回客户端。在后续读取中，客户端应用程序使用该描述符来调用 <code>read()</code> 系统调用；然后，客户端文件系统将消息中的描述符传递给文件服务器，表示“从我传递给您的描述符所引用的文件中读取一些字节”。</p>
<p>在这个例子中，文件描述符是客户端和服务器之间的一段<strong>共享状态</strong>（Ousterhout 称之为<strong>分布式状态</strong>）。正如我们上面所暗示的，共享状态使崩溃恢复变得复杂。想象一下，服务器在第一次读取完成后、客户端发出第二次读取之前崩溃了。服务器重新启动并运行后，客户端会发出第二次读取。不幸的是，服务器不知道 <code>fd</code> 引用的是哪个文件；该信息是短暂的（即在内存中），因此当服务器崩溃时就会丢失。为了处理这种情况，客户端和服务器必须参与某种<strong>恢复协议</strong>，客户端将确保在其内存中保留足够的信息，以便能够告诉服务器它需要知道什么（在这种情况下 ，该文件描述符 <code>fd</code> 引用文件 <code>foo</code>)</p>
<p>当您考虑有状态服务器必须处理客户端崩溃这一事实时，情况会变得更糟。例如，想象一下，一个客户端打开一个文件然后崩溃了。 <code>open()</code> 使用了服务器上的文件描述符；服务器如何知道可以关闭给定文件？在正常操作中，客户端最终会调用 <code>close()</code> ，从而通知服务器应该关闭文件。然而，当客户端崩溃时，服务器永远不会收到 <code>close()</code>，因此必须注意到客户端已崩溃才能关闭文件。</p>
<p>出于这些原因，NFS 的设计者决定采用无状态方法：每个客户端操作都包含完成请求所需的所有信息。不需要花哨的崩溃恢复；服务器刚刚重新开始运行，而客户端在最坏的情况下可能必须重试请求。</p>
<h4 id="nfsv2-协议" class="heading-element"><span>2.1.2 NFSv2 协议</span>
  <a href="#nfsv2-%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>由此，我们得出了 NFSv2 协议的定义。我们的问题陈述很简单：</p>
<blockquote>
<center>如何定义无状态文件协议
</center>
<p>如何定义网络协议以实现无状态操作？显然，像 <code>open()</code> 这样的有状态调用不能作为讨论的一部分（因为这需要服务器跟踪打开的文件）；但是，客户端应用程序会希望调用 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>close()</code> 和其他标准 API 调用来访问文件和目录。因此，作为一个细化的问题，我们该如何定义协议才能既无状态又支持 POSIX 文件系统 API 呢？</p>
</blockquote>
<p>理解 NFS 协议设计的关键之一是理解<strong>文件句柄</strong>。文件句柄用于唯一描述特定操作要操作的文件或目录；因此，许多协议请求都包含一个文件句柄。</p>
<p>你可以认为文件句柄有三个重要组成部分：<strong>卷标识符</strong>、<strong>inode号</strong>和生成号；这三者共同构成了客户端希望访问的文件或目录的唯一标识符。</p>
<ul>
<li>卷标识符告知服务器该请求指向哪个文件系统（一个 NFS 服务器可以导出多个文件系统）；</li>
<li>Inode号告诉服务器该请求访问的是该分区中的哪个文件。</li>
<li>最后，在重复使用inode号时需要使用生成号；每当重复使用一个inode号时，服务器就会递增生成号，以确保使用旧文件句柄的客户端不会意外访问新分配的文件。</li>
</ul>
<p>以下是协议中一些重要部分的摘要；完整的协议可从其他地方获得。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">NFSPROC_GETATTR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_SETATTR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_LOOKUP</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，要查找的文件/目录的名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：文件句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of file/directory to look up</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">file handle</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_READ</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄，偏移量，计数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：数据，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle, offset, count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">data, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_WRITE</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄，偏移量，计数，数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle, offset, count, data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_CREATE</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，文件名，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of file, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_REMOVE</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，要移除的文件名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of file to be removed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_MKDIR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，目录名，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：文件句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of directory, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">file handle</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_RMDIR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，要移除的目录名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of directory to be removed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_READDIR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录句柄，要读取的字节数，标识符</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：目录条目，标识符（以获取更多条目）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory handle, count of bytes to read, cookie</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">directory entries, cookie (to get more entries)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们简要介绍一下协议的重要组成部分。首先，LOOKUP 协议报文用于获取文件句柄，然后使用该句柄访问文件数据。客户端传递<strong>一个目录文件句柄和要查找的文件名</strong>，服务器会将该文件（或目录）的句柄及其属性传回客户端。</p>
<p>例如，假设客户端已经拥有文件系统根目录 (<code>/</code>) 的目录文件句柄（实际上，这可以通过 NFS <strong>挂载协议</strong>获得，这是客户端和服务器首次连接的方式；为简洁起见，我们在此不讨论挂载协议）。如果在客户端运行的应用程序打开文件 <code>/foo.txt</code>，客户端文件系统就会向服务器发送一个查找请求，将根文件句柄和文件名 <code>foo.txt</code> 传递给服务器；如果请求成功，就会返回 <code>foo.txt</code> 的文件句柄（和属性）。</p>
<p>如果你想知道，属性只是文件系统跟踪每个文件的元数据，包括文件创建时间、最后修改时间、大小、所有权和权限信息等字段，也就是在文件上调用 <code>stat()</code> 时会返回的信息。</p>
<p>一旦有了文件句柄，客户端就可以对文件发出 READ 和 WRITE 协议消息，分别读取或写入文件。读取协议消息要求传递文件句柄、文件偏移量和要读取的字节数。然后，服务器就能发出读取命令（毕竟，句柄会告诉服务器要从哪个卷和哪个 inode 读取，偏移量和字节数会告诉服务器要读取文件的哪个字节），并将数据返回给客户端（如果读取失败，则返回错误信息）。写入（WRITE）的处理方式与此类似，只是数据从客户端传递到服务器，并只返回一个成功代码。</p>
<p>最后一个有趣的协议信息是 GETATTR 请求；给定一个文件句柄后，它只需获取该文件的属性，包括文件的最后修改时间。在下文讨论缓存时，我们将看到该协议请求在 NFSv2 中的重要性。</p>
<h3 id="从协议到分布式文件系统" class="heading-element"><span>2.2 从协议到分布式文件系统</span>
  <a href="#%e4%bb%8e%e5%8d%8f%e8%ae%ae%e5%88%b0%e5%88%86%e5%b8%83%e5%bc%8f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>希望您现在已经了解如何将该协议转变为跨客户端文件系统和文件服务器的文件系统。<font color="red">客户端文件系统跟踪打开的文件，并且通常将应用程序请求转换为相关的协议消息集。服务器只是响应协议消息，每个消息都包含完成请求所需的所有信息。</font></p>
<p>例如，让我们考虑一个读取文件的简单应用程序。在下图中，我们显示了应用程序进行了哪些系统调用，以及客户端文件系统和文件服务器响应此类调用时执行的操作。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=small" data-sub-html="<h2>image-20240424131608950</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png" alt="image-20240424131608950" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=large 2x" data-title="image-20240424131608950" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>首先，注意客户端如何跟踪文件访问的所有相关状态，包括<strong>整数文件描述符</strong>到 <strong>NFS 文件句柄</strong>的映射以及当前文件指针。这使得客户端能够将每个读取请求（您可能已经注意到，没有明确指定要读取的偏移量）转换为格式正确的读取协议消息，该消息准确地告诉服务器要读取文件中的哪些字节。成功读取后，客户端更新当前文件位置；后续读取将使用相同的文件句柄但偏移量不同。</p>
<p>其次，您可能会注意到服务器交互发生的位置。当文件第一次打开时，客户端文件系统会发送一个LOOKUP请求消息。事实上，如果必须遍历长路径名（例如，<code>/home/zfhe/foo.txt</code>），客户端将发送三个 LOOKUP：一个在目录 <code>/</code> 中查找 <code>home</code>，一个在 <code>home</code> 中查找 <code>zfhe</code>，最后一个在 <code>zfhe</code> 中查找 <code>foo.txt</code>。</p>
<p>第三，您可能会注意每个服务器请求都包含完成请求所需的全部信息。这个设计要点对于从服务器故障中从容恢复至关重要，我们现在将详细讨论；它确保服务器不需要状态就能响应请求。</p>
<h3 id="使用幂等操作处理服务器故障" class="heading-element"><span>2.3 使用幂等操作处理服务器故障</span>
  <a href="#%e4%bd%bf%e7%94%a8%e5%b9%82%e7%ad%89%e6%93%8d%e4%bd%9c%e5%a4%84%e7%90%86%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%95%85%e9%9a%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端向服务器发送信息时，有时会收不到回复。造成这种无法回复的原因有很多。在某些情况下，信息可能被网络丢弃；网络确实会丢失信息，因此请求或回复都可能丢失，这样客户端就永远不会收到回复。</p>
<p>也有可能是服务器崩溃了，因此目前没有响应信息。一段时间后，服务器将重新启动并重新开始运行，但在此期间，所有请求都已丢失。在所有这些情况下，客户端都会遇到一个问题：当服务器未能及时回复时该怎么办？</p>
<p>在 NFSv2 中，客户端以一种单一、统一和优雅的方式处理所有这些故障：<font color="red">只需重试请求即可。</font>具体来说，在发送请求后，客户端会设置一个计时器，在指定时间段后关闭。如果在定时器关闭前收到了回复，定时器就会被取消，一切正常。但是，如果在收到任何回复之前计时器就关闭了，客户端就会认为请求没有被处理，并重新发送请求。如果服务器回复了，则一切正常，客户端也顺利地解决了问题。</p>
<p>客户端之所以能简单地重试请求（不管失败的原因是什么），是因为大多数 NFS 请求都有一个重要特性：它们都是<strong>幂等</strong>的。<font color="red">当多次执行该操作的效果等同于单次执行该操作的效果时，我们就称该操作为幂等操作。</font>例如，如果将一个值存储到内存位置三次，与存储一次的效果相同；因此，&ldquo;将值存储到内存 &ldquo;就是一个幂等操作。但是，如果将一个计数器递增三次，其结果与只递增一次的结果不同，因此 &ldquo;递增计数器 &ldquo;不是幂等操作。<font color="red">更一般地说，任何只读取数据的操作显然都是幂等的，而更新数据的操作则必须更仔细地考虑，以确定它是否具有这种特性。</font></p>
<p>NFS 崩溃恢复设计的核心是大多数常见操作的幂等性。LOOKUP 和 READ 请求具有微不足道的幂等性，因为它们只从文件服务器读取信息，而不更新信息。更有趣的是，WRITE 请求也是幂等的。例如，如果 WRITE 失败，客户端只需重试即可。<font color="red">WRITE 消息包含数据、计数和（重要的）要写入数据的准确偏移量。</font>因此，只要知道多次写入的结果与单次写入的结果相同，就可以重复写入。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=small" data-sub-html="<h2>image-20240424140254771</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png" alt="image-20240424140254771" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=large 2x" data-title="image-20240424140254771" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这样，客户端就能以统一的方式处理所有超时。</p>
<ul>
<li>如果只是丢失了 WRITE 请求（上述情况 1），客户端将重试，服务器将执行写入操作，一切正常。</li>
<li>同样的情况也会发生，如果在发送请求时服务器碰巧宕机，但在发送第二个请求时又恢复运行，那么一切都会如愿以偿（情况 2）。</li>
<li>最后，服务器可能会接收到写入请求，向磁盘发出写入操作，并发送回复。这个回复可能会丢失（情况 3），再次导致客户机重新发送请求。当服务器再次收到请求时，它只会做完全相同的事情：将数据写入磁盘并回复说已经写入。如果这次客户端收到了回复，那么一切又都正常了，这样客户端就以统一的方式处理了信息丢失和服务器故障。</li>
</ul>
<p>不过有些操作很难做到幂等。例如，当你试图创建一个已经存在的目录时，你会被告知 mkdir 请求失败。因此，在 NFS 中，如果文件服务器接收到 MKDIR 协议信息并成功执行，但却丢失了回复，那么客户端可能会重复该操作并遭遇失败，而实际上该操作一开始是成功的，只是在重试时失败了。因此，生活并不完美。</p>
<blockquote>
<center>TIP：幂等性非常强大 
</center>
<p>在构建可靠系统时，幂等性是一个有用的属性。当一个操作可以多次发出时，处理操作失败就容易得多；你可以重试。如果操作不是幂等的，生活就会变得更加困难。</p>
</blockquote>
<h2 id="提高性能客户端缓存" class="heading-element"><span>3 提高性能：客户端缓存</span>
  <a href="#%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bc%93%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>分布式文件系统的优点有很多，但通过网络发送所有读写请求可能会导致很大的性能问题：网络通常速度不快，尤其是与本地内存或磁盘相比。那么，又一个问题：如何提高分布式文件系统的性能？</p>
<p>答案是<strong>客户端缓存</strong>。 NFS 客户端文件系统将从服务器读取的文件数据（和元数据）缓存在客户端内存中。因此，虽然第一次访问的成本很高（即，它需要网络通信），但后续访问很快就会从客户端内存中得到服务。</p>
<p>高速缓存还充当写入的临时缓冲区。当客户端应用程序首次写入文件时，客户端会先将数据缓冲在客户端内存中（与从文件服务器读取的数据位于同一缓存中），然后再将数据写出到服务器。这种写入缓冲非常有用，因为它将应用程序 <code>write()</code> 延迟与实际写入性能解耦，即应用程序对 <code>write()</code> 的调用立即成功（并且只是将数据放入客户端文件系统的缓存中）；只有稍后数据才会被写出到文件服务器。</p>
<p>因此，NFS 客户端缓存数据并且性能通常很好，我们就完成了，对吗？不幸的是，不完全是。将缓存添加到具有多个客户端缓存的任何类型的系统中都会带来一个巨大且有趣的挑战，我们将其称为<strong>缓存一致性问题</strong>。</p>
<h3 id="缓存一致性问题" class="heading-element"><span>3.2 缓存一致性问题</span>
  <a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>缓存一致性问题最好用两个客户端和一个服务器来说明。假设客户端 C1 读取文件 F，并在其本地缓存中保留该文件的副本。现在想象一个不同的客户端 C2 覆盖文件 F，从而更改其内容；我们将文件的新版本称为 F（版本 2）或 F[v2]，将旧版本称为 F[v1]，这样我们就可以保持两者不同（当然，文件具有相同的名称，只是内容不同）。最后，还有第三个客户端 C3，它尚未访问文件 F。</p>
<p>您可能会看到即将出现的问题，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=small" data-sub-html="<h2>image-20240424142910926</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png" alt="image-20240424142910926" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=large 2x" data-title="image-20240424142910926" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>事实上，有两个子问题。</p>
<ul>
<li>第一个子问题是客户端 C2 在将其写入传播到服务器之前可能会在其缓存中缓冲一段时间；在这种情况下，虽然 F[v2] 位于 C2 的内存中，但来自另一个客户端（例如 C3）对 F 的任何访问都将获取文件的旧版本 (F[v1])。因此，通过在客户端缓冲写入，其他客户端可能会获得该文件的过时版本，这可能是不合需要的；事实上，想象一下这样的情况：您登录到机器 C2，更新 F，然后登录到 C3 并尝试读取文件，结果却得到旧副本！当然，这可能会令人沮丧。因此，我们将这方面的缓存一致性问题称为<font color="red">更新可见性</font>；一个客户端的更新何时对其他客户端可见？</li>
<li>缓存一致性的第二个子问题是<font color="red">陈旧的缓存</font>；在这种情况下，C2 最终将其写入刷新到文件服务器，因此服务器具有最新版本（F[v2]）。然而，C1 的缓存中仍然有 F[v1]；如果在 C1 上运行的程序读取文件 F，它将获得陈旧版本 (F[v1])，而不是最新副本 (F[v2])，这（通常）是不可取的。</li>
</ul>
<p>NFSv2 实现通过两种方式解决这些缓存一致性问题。</p>
<ul>
<li>首先，为了解决更新可见性，客户端实现有时称为“关闭时刷新”（也称为“关闭到打开”）一致性语义；具体来说，<font color="red">当客户端应用程序写入文件并随后关闭文件时，客户端会将所有更新（即缓存中的脏页）刷新到服务器</font>。通过关闭时刷新一致性，NFS 可确保后续从另一个节点打开时将看到最新的文件版本。</li>
<li>其次，为了解决陈旧缓存问题，NFSv2 客户端在使用其缓存内容之前首先检查文件是否已更改。具体来说，<font color="red">在使用缓存块之前，客户端文件系统将向服务器发出 GETATTR 请求以获取文件的属性。</font>重要的是，属性包括有关文件最后一次在服务器上修改的时间的信息；如果修改时间比文件被提取到客户端缓存的时间更新，则客户端会使该文件无效，从而将其从客户端缓存中删除，并确保后续读取将转到服务器并检索最新的文件的版本。另一方面，如果客户端发现它具有该文件的最新版本，它将继续使用缓存的内容，从而提高性能。</li>
</ul>
<p>当 Sun 的原始团队针对陈旧缓存问题实施此解决方案时，他们意识到了一个新问题：突然，NFS 服务器被 GETATTR 请求淹没。遵循的一个良好的工程原则是针对常见情况进行设计，并使其运行良好；在这里，尽管常见情况是仅从单个客户端访问文件（可能重复），**但客户端始终必须向服务器发送 GETATTR 请求以确保没有其他人更改该文件。**因此，客户端轰炸服务器，不断询问“有人更改了这个文件吗？”，而大多数时候没有人更改过。</p>
<p>为了（在某种程度上）解决这种情况，每个客户端都添加了属性缓存。客户端在访问文件之前仍然会验证文件，但大多数情况下只会查看属性缓存以获取属性。特定文件的属性在第一次访问该文件时被放置在缓存中，然后在一定时间（例如 3 秒）后超时。因此，在这三秒钟内，所有文件访问都将确定可以使用缓存的文件，从而在与服务器没有网络通信的情况下执行此操作。</p>
<h3 id="评估-nfs-缓存一致性" class="heading-element"><span>3.3 评估 NFS 缓存一致性</span>
  <a href="#%e8%af%84%e4%bc%b0-nfs-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>关于 NFS 缓存一致性的最后几句话。添加关闭时刷新行为是为了“有意义”，但引入了一定的性能问题。具体来说，如果在客户端上创建了临时或短暂的文件，然后很快将其删除，它仍然会被强制发送到服务器。更理想的实现可能会将这些短暂的文件保留在内存中，直到它们被删除，从而完全消除服务器交互，也许会提高性能。</p>
<p>更重要的是，在 NFS 中添加属性缓存使得人们很难理解或推断到底获得的文件版本是什么。有时你会得到最新版本；有时，您会得到旧版本，只是因为您的属性缓存尚未超时，因此客户端很乐意为您提供客户端内存中的内容。尽管这在大多数情况下都很好，但它偶尔会（而且仍然如此！）导致奇怪的行为。这样我们就描述了 NFS 客户端缓存的奇怪之处。它是一个有趣的例子，其中实现的细节用于定义用户可观察的语义，而不是相反。</p>
<h2 id="对服务器端写缓冲的影响" class="heading-element"><span>4 对服务器端写缓冲的影响</span>
  <a href="#%e5%af%b9%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e5%86%99%e7%bc%93%e5%86%b2%e7%9a%84%e5%bd%b1%e5%93%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>到目前为止，我们的重点一直放在客户端缓存上，这也是最有趣的问题所在。不过，NFS 服务器往往也是拥有大量内存的装备精良的机器，因此它们也有缓存问题。当从磁盘读取数据（和元数据）时，NFS 服务器会将其保存在内存中，随后对数据（和元数据）的读取将不会转到磁盘，这有可能（小幅）提高性能。</p>
<p>更有趣的是写缓冲。NFS 服务器在强制写入稳定存储（如磁盘或其他持久性设备）之前，绝对不会返回成功的 WRITE 协议请求。虽然它们可以在服务器内存中放置数据副本，但向客户端返回 WRITE 协议请求成功可能会导致不正确的行为。</p>
<p>答案就在于我们对客户端如何处理服务器故障的假设。想象一下客户端发出的以下写入序列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">a_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// fill first block with a’s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">b_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// fill second block with b’s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">c_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// fill third block with c’s
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些写入会先用 a 块、b 块和 c 块覆盖文件的三个块。因此，如果文件最初看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span><span class="line"><span class="cl">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
</span></span><span class="line"><span class="cl">zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可能期望这些写入后的最终结果是这样的，其中 x、y 和 z 将分别被 a、b 和 c 覆盖。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
</span></span><span class="line"><span class="cl">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
</span></span><span class="line"><span class="cl">cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，为了举例，我们假设这三个客户端写入作为三个不同的 WRITE 协议消息发送到服务器。假设服务器收到第一个 WRITE 消息并将其发送到磁盘，并且客户端通知其成功。现在假设第二次写入只是缓冲在内存中，并且服务器在将其强制写入磁盘之前也会向客户端报告其成功；不幸的是，服务器在将其写入磁盘之前崩溃了。服务器很快重启，收到第三个写请求，也成功了。</p>
<p>因此，对于客户端来说，所有请求都成功了，但令我们惊讶的是文件内容如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
</span></span><span class="line"><span class="cl">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy &lt;--- oops
</span></span><span class="line"><span class="cl">cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</span></span></code></pre></td></tr></table>
</div>
</div><p>因为服务器在将第二次写入提交到磁盘之前告诉客户端第二次写入成功，所以文件中会留下旧的块，这可能是灾难性的，具体取决于应用程序。</p>
<p>为了避免这个问题，NFS 服务器必须将每次写入提交到稳定（持久）存储，然后再通知客户端成功；这样做使客户端能够在写入期间检测到服务器故障，从而重试直到最终成功。这样做可以确保我们永远不会像上面的示例一样最终出现文件内容混合的情况。</p>
<p>这一要求在 NFS 服务器实现中引起的问题是，如果不小心的话，写入性能可能会成为主要的性能瓶颈。事实上，一些公司（例如 Network Appliance）的成立只是为了构建一个可以快速执行写入的 NFS 服务器；他们使用的一个技巧是首先将<strong>写入操作放入电池支持的内存中</strong>，从而能够快速回复写入请求，而不必担心丢失数据，并且无需立即写入磁盘；第二个技巧是使用专门设计的文件系统设计，以便在最终需要时快速写入磁盘。</p>
<h2 id="总结" class="heading-element"><span>5 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>在 NFS 中实现快速、简单的崩溃恢复这一主要目标的关键在于<strong>无状态协议的设计</strong>。崩溃后，服务器可以快速重新启动并再次开始服务请求；客户端只需<strong>重试</strong>请求，直到成功为止。</li>
<li>使请求具有<strong>幂等性</strong>是NFS 协议的一个核心方面。当多次执行某个操作的效果与执行一次相同时，该操作就是幂等的。在NFS中，幂等性使客户端能够无忧重试，并统一客户端丢失消息重传以及客户端处理服务器崩溃的方式。</li>
<li>性能问题决定了对<strong>客户端缓存</strong>和<strong>写缓冲</strong>的需求，但会带来<strong>缓存一致性问题</strong>。</li>
<li>NFS 实现提供了一种通过多种方式实现缓存一致性的工程解决方案：**关闭时刷新（关闭到打开）**方法可确保当文件关闭时，其内容被强制传输到服务器，从而使其他客户端能够观察到文件的更新。属性缓存减少了向服务器检查文件是否已更改的频率（通过 GETATTR 请求）。</li>
<li><font color="red">NFS 服务器必须在返回成功之前向持久介质提交写入；否则，可能会导致数据丢失。</font></li>
<li>为了支持NFS 集成到操作系统中，Sun 引入了<strong>VFS/Vnode</strong> 接口，使多个文件系统实现能够在同一操作系统中共存。</li>
</ul>
]]></description></item><item><title>分布式系统</title><link>https://hezephyr.github.io/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:36:36 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式系统改变了世界的面貌。当您的网络浏览器连接到地球上其他地方的网络服务器时，它正在参与看似简单形式的<strong>客户端/服务器</strong>（CS）分布式系统。然而，当您联系 Google 或 Facebook 等现代网络服务时，您不仅仅是在与一台机器进行交互。在幕后，这些复杂的服务是由大量（即数千台）机器构建的，每台机器相互协作以提供站点的特定服务。</p>
<p>构建分布式系统时会出现许多新的挑战。我们主要关注的是失败；<font color="red">机器、磁盘、网络和软件都会时不时地出现故障，因为我们不（并且可能永远不会）知道如何构建“完美”的组件和系统</font>。然而，当我们构建现代 Web 服务时，我们希望它对客户来说似乎永远不会失败；我们怎样才能完成这个任务呢？</p>
<blockquote>
<p>关键：如何构建在组件出现故障时仍能正常工作的系统？</p>
</blockquote>
<p>有趣的是，虽然失败是构建分布式系统的主要挑战，但它也代表着机遇。是的，机器会出故障；但一台机器发生故障并不意味着整个系统一定会发生故障。通过将一组机器集合在一起，我们可以构建一个似乎很少发生故障的系统，尽管它的组件经常发生故障。这一事实是分布式系统的核心魅力和价值，也是为什么它们成为您使用的几乎所有现代网络服务（包括 Google、Facebook 等）的基础。</p>
<blockquote>
<center>TIP：通信本质上是不可靠的 
</center>
<p>在几乎所有情况下，最好将通信视为一种本质上不可靠的活动。bit损坏、链路和机器瘫痪或无法工作，以及传入数据包缺乏缓冲空间，都会导致同样的结果：数据包有时无法到达目的地。<font color="red">要在这种不可靠的网络之上建立可靠的服务，我们必须考虑能够应对数据包丢失的技术。</font></p>
</blockquote>
<p>还存在其他重要问题。系统<strong>性能</strong>往往至关重要；由于网络将我们的分布式系统连接在一起，系统设计者往往必须仔细考虑如何完成既定任务，尽量减少发送信息的数量，并进一步提高通信效率（<strong>低延迟、高带宽</strong>）。</p>
<p>最后，<strong>安全</strong>也是一个必要的考虑因素。确保远程方的真实身份成为一个核心问题。此外，确保第三方无法监视或改变两个人之间正在进行的通信也是一个挑战。</p>
<p>在本介绍中，我们将讨论分布式系统中最基本的新问题：<strong>通信</strong>。也就是说，分布式系统中的机器应该如何相互通信？？我们将从最基本的可用原语（消息）开始，并在它们之上构建一些更高级别的原语。正如我们上面所说，故障将成为焦点：通信层应如何处理故障？</p>
<h2 id="通信基础" class="heading-element"><span>2 通信基础</span>
  <a href="#%e9%80%9a%e4%bf%a1%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">现代网络的核心原则是通信从根本上来说是不可靠的。</font>无论是在广域互联网中，还是在 Infiniband 等局域高速网络中，数据包经常会丢失、损坏或无法到达目的地。</p>
<p>造成数据包丢失或损坏的原因有很多。有时，在传输过程中，某些位会由于电气或其他类似问题而翻转。有时，系统中的某个元件（例如网络链路或数据包路由器甚至远程主机）会因某种原因损坏或无法正常工作；网络电缆确实会被意外切断，至少有时是这样。</p>
<p>然而，<font color="red">更根本的是由于网络交换机、路由器或端点内缺乏缓冲而导致的数据包丢失。</font>具体来说，即使我们可以保证所有链路正常工作，并且系统中的所有组件（交换机、路由器、终端主机）都按预期启动并运行，但由于以下原因，仍然有可能发生丢失。</p>
<p>想象一下一个数据包到达路由器；要处理数据包，必须将其放置在路由器内存中的某个位置。如果许多此类数据包同时到达，则路由器内的内存可能无法容纳所有数据包。此时路由器唯一的选择是丢弃一个或多个数据包。同样的行为也发生在终端主机上；当你向一台机器发送大量消息时，机器的资源很容易被淹没，从而再次出现丢包。</p>
<p>因此，数据包丢失是网络中的基础。那么问题就变成了：我们该如何应对？</p>
<h2 id="不可靠通信层" class="heading-element"><span>3 不可靠通信层</span>
  <a href="#%e4%b8%8d%e5%8f%af%e9%9d%a0%e9%80%9a%e4%bf%a1%e5%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>一种简单的方法是：我们不去处理它。因为某些应用程序知道如何处理数据包丢失，所以有时让它们与基本的不可靠消息传递层进行通信是有用的，这是人们经常听到的<strong>端到端</strong>论点的一个例子。<strong>UDP/IP</strong> 网络协议栈就是这种不可靠层的一个很好的例子，目前几乎所有的现代系统都有这种协议栈。使用 UDP 时，进程使用<strong>socket</strong> API 创建<strong>通信端点</strong>；其他机器（或同一机器）上的进程向原始进程发送 UDP 数据报（数据报是固定大小的报文，最大不超过某个最大值）。</p>
<blockquote>
<center>端到端论点
</center>
<p>端到端论点认为，系统的最高层，即通常位于 &ldquo;端 &ldquo;的应用程序，最终是分层系统中唯一能真正实现某些功能的地方。在具有<a href="https://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf"target="_blank" rel="external nofollow noopener noreferrer">里程碑意义的论文中<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，Saltzer 等人通过一个极好的例子论证了这一点：两台机器之间的可靠文件传输。<center>如果要将文件从机器 A 传输到机器 B，并确保最终到达机器 B 的字节与开始到达机器 A 的字节完全相同，就必须进行 &ldquo;端到端 &ldquo;检查；而网络或磁盘等较低级别的可靠机制则无法提供这种保证。</center></p>
<p>与此形成鲜明对比的是一种试图通过在系统较低层增加可靠性来解决可靠文件传输问题的方法。例如，我们建立了一个可靠的通信协议，并用它来建立可靠的文件传输。该通信协议保证发送方发送的每个字节都能被接收方按顺序接收，例如使用超时/重试、确认和序列号。不幸的是，使用这样的协议并不能实现可靠的文件传输；试想一下，在通信开始之前，发送方内存中的字节就已经损坏，或者接收方将数据写入磁盘时发生了什么不好的事情。在这种情况下，即使字节在网络上可靠地传输，我们的文件传输最终也是不可靠的。要建立可靠的文件传输，必须包括端到端的可靠性检查，例如，在整个传输完成后，读回接收方磁盘上的文件，计算校验和，并将校验和与发送方的文件进行比较。</p>
<p>这句格言的推论是，有时让下层提供额外功能确实可以提高系统性能或优化系统。因此，你不应该排除在系统中的较低层次使用这种机制；相反，你应该仔细考虑这种机制的效用，考虑到它在整个系统或应用程序中的最终用途。</p>
</blockquote>
<p>下面这两段代码显示了构建在 UDP/IP 之上的简单客户端和服务器。客户端可以向服务器发送消息，然后服务器做出响应。通过这么少量的代码，您就拥有了开始构建分布式系统所需的一切！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// client.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;udp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addrSend</span><span class="p">,</span> <span class="n">addrRecv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">UDP_Open</span><span class="p">(</span><span class="n">CLIENT_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_FillSockAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrSend</span><span class="p">,</span> <span class="s">&#34;localhost&#34;</span><span class="p">,</span> <span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client:: sending message [%s]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrSend</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Client:: Failed to send message</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client:: waiting for reply...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrRecv</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Client:: Failed to read message</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client:: read %d bytes (message: %s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//server.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;udp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">UDP_Open</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to create socket</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;server:: waiting for data...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;server:: read %d bytes (message: %s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">reply</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sprintf</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="s">&#34;goodbye world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;server:: reply</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>UDP 是不可靠通信层的一个很好的例子。而发送方从不会因此被告知数据包丢失。但是，这并不意味着 UDP 完全不防范任何故障。例如，UDP 包含一个校验和来检测某些形式的数据包损坏。</p>
<p>然而，由于许多应用程序只是想将数据发送到目的地而不担心数据包丢失，因此我们需要更多。具体来说，我们需要在不可靠的网络上进行可靠的通信。</p>
<h2 id="可靠的通信层" class="heading-element"><span>4 可靠的通信层</span>
  <a href="#%e5%8f%af%e9%9d%a0%e7%9a%84%e9%80%9a%e4%bf%a1%e5%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了构建可靠的通信层，我们需要一些新的机制和技术来处理丢包。让我们考虑一个简单的示例，其中客户端通过不可靠的连接向服务器发送消息。我们必须回答的第一个问题：发送者如何知道接收者确实收到了消息？</p>
<p>我们将使用的技术称为<strong>确认</strong>，简称 <code>ack</code>。想法很简单：发送者向接收者发送消息；然后接收者发回一条短消息以确认其收到。下图描述了该过程。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=small" data-sub-html="<h2>image-20240423123154950</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png" alt="image-20240423123154950" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=large 2x" data-title="image-20240423123154950" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当发送方收到消息的确认时，它就可以放心，接收方确实收到了原始消息。但是，如果发送方没有收到确认，该怎么办？</p>
<p>为了处理这种情况，我们需要一个额外的机制，称为<strong>超时</strong>。当发送者发送消息时，发送者现在设置一个计时器在一段时间后关闭。如果此时未收到确认，则发送方断定消息已丢失。然后，发送者只需<strong>重试</strong>发送，再次发送相同的消息，希望这次能够成功。为了使这种方法发挥作用，发送者必须保留消息的副本，以备需要再次发送时使用。<strong>超时和重试</strong>的结合导致一些人将这种方法称为<strong>超时/重试</strong>，下图显示了一个示例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=small" data-sub-html="<h2>image-20240423123849662</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png" alt="image-20240423123849662" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=large 2x" data-title="image-20240423123849662" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>不幸的是，这种形式的超时/重试还不够。下图显示了可能导致问题的数据包丢失示例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=small" data-sub-html="<h2>image-20240423123930417</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png" alt="image-20240423123930417" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=large 2x" data-title="image-20240423123930417" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，丢失的不是原始消息，而是确认消息。从发送方的角度来看，情况似乎是一样的：没有收到确认，因此需要超时和重试。但从接收者的角度来看，情况就大不一样了：现在同一条消息已经收到两次了！虽然在某些情况下这可能是可以的，但一般来说是不行的；想象一下当您下载文件并且在下载过程中重复额外的数据包时会发生什么。因此，当我们的目标是建立一个可靠的消息层时，我们通常还希望保证接收者<strong>只接收每条消息一次</strong>。</p>
<p>为了使接收方能够检测到重复的消息传输，发送方必须以某种独特的方式识别每条消息，并且接收方需要某种方式来跟踪它之前是否已经看过每条消息。当接收方看到重复传输时，它只是确认消息，但（关键）不会将消息传递给接收数据的应用程序。因此，发送方收到 <code>ack</code>，但消息不会被接收两次，从而保留了上述的恰好一次语义。有多种方法可以检测重复消息。例如，发送者可以为每条消息生成一个唯一的ID；接收者可以追踪它所见过的每一个ID。这种方法可行，但成本高昂，需要无限的内存来跟踪所有 ID。</p>
<p>有一种更简单的方法可以解决这个问题，只需要很少的内存，这种机制被称为<strong>序列计数器</strong>。使用序列计数器时，发送方和接收方商定一个计数器的起始值（如 $1$），由双方共同维护。每当发送一条信息时，计数器的当前值就会随信息一起发送；这个计数器值（$N$）就是信息的 ID。信息发送后，发送方会递增计数器值（到 $N + 1$）。</p>
<p>接收方使用其计数器值作为该发送方发来信息的 ID 的预期值。如果接收到的信息 ID（N）与接收者的计数器（也是 N）相匹配，接收者就会接收该信息并将其上传给应用程序；在这种情况下，接收者就会断定这是第一次收到该信息。然后，接收方递增计数器（到 $N + 1$），等待下一条信息。</p>
<p>如果丢失了应答，发送方将超时并重新发送信息 $N$。这一次，接收方的计数器更高（$N + 1$），因此接收方知道自己已经收到了这条信息。因此，它会接收信息，但不会将其上传给应用程序。通过这种简单的方式，序列计数器可用于避免重复。</p>
<p>最常用的可靠通信层被称为 TCP/IP，简称 TCP。TCP 比我们上面描述的要复杂得多，包括处理网络拥塞、多个未处理请求以及数百种其他小调整和优化的机制。</p>
<blockquote>
<center>TIP：小心设置超时值 
</center>
<p>正如您可能从讨论中猜到的那样，正确设置超时值是使用超时重试消息发送的一个重要方面。</p>
<ul>
<li>如果超时太小，发送方将不必要地重新发送消息，从而浪费发送方的CPU时间和网络资源。</li>
<li>如果超时太大，则发送方等待太长时间才能重新发送，从而降低发送方的感知性能。</li>
</ul>
<p>因此，从单个客户端和服务器的角度来看，“正确”值是等待足够长的时间来检测数据包丢失，但不再等待。</p>
<p>然而，正如我们将在以后的章节中看到的那样，分布式系统中通常不仅仅只有一个客户端和服务器。在许多客户端向单个服务器发送数据的情况下，服务器上的数据包丢失可能表明服务器过载。如果为真，客户端可能会以不同的自适应方式重试；例如，在第一次超时后，<strong>客户端可能会将其超时值增加到更高的值，可能是原始值的两倍</strong>。这种指数退避方案在早期的 Aloha 网络中首创并在早期以太网中采用，避免了因过度重发而导致资源过载的情况。稳健的系统努力避免这种性质的过载。</p>
</blockquote>
<h2 id="通信抽象" class="heading-element"><span>5 通信抽象</span>
  <a href="#%e9%80%9a%e4%bf%a1%e6%8a%bd%e8%b1%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>给定了基本的消息传递层，我们现在讨论本章中的下一个问题：在构建分布式系统时我们应该使用什么通信抽象？</p>
<p>多年来，系统界开发了许多方法。其中一项工作是将操作系统的抽象概念扩展到分布式环境中运行。例如，<strong>分布式共享内存（DSM）系统</strong>能让不同机器上的进程共享一个大型虚拟地址空间。这种抽象将分布式计算变成了类似于多线程应用程序的东西；<font color="red">唯一的区别是，这些线程运行在不同的机器上，而不是同一机器上的不同处理器上。</font></p>
<p>大多数 DSM 系统的工作方式是通过操作系统的虚拟内存系统。在一台机器上访问一个页面时，可能会发生两种情况。</p>
<ul>
<li>在第一种（最佳）情况下，页面已经在本地计算机上，因此可以快速获取数据。</li>
<li>第二种情况是，页面当前在其他机器上。页面故障发生后，页面故障处理程序会向其他机器发送信息，以获取页面，并将其安装到请求进程的页表中，然后继续执行。</li>
</ul>
<p>由于多种原因，这种方法目前并未得到广泛应用。DSM 面临的最大问题是如何<strong>处理故障</strong>。例如，设想一下，如果一台机器发生故障，那么这台机器上的页面会发生什么情况？如果分布式计算的数据结构遍布整个地址空间怎么办？在这种情况下，这些数据结构的一部分将突然不可用。当部分地址空间丢失时，处理故障是非常困难的；<strong>想象一下，在一个链表中，&ldquo;下一个 &ldquo;指针指向的地址空间部分已经消失。</strong></p>
<p>另一个问题是性能。在编写代码时，我们通常会假设访问内存的成本很低。在 DSM 系统中，有些访问是廉价的，但有些访问却会导致页面故障，并从远程机器上获取昂贵的数据。因此，这种 DSM 系统的程序员必须非常小心地组织计算，使其几乎不发生任何通信，这在很大程度上违背了这种方法的初衷。尽管在这一领域进行了大量研究，但几乎没有产生实际影响；如今，<font color="red">没有人使用 DSM 构建可靠的分布式系统</font>。</p>
<h2 id="远程过程调用-rpc" class="heading-element"><span>6 远程过程调用 (RPC)</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8-rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>操作系统抽象对于构建分布式系统来说是一个糟糕的选择，而<strong>编程语言（PL）抽象</strong>则更有意义。最主要的抽象基于**远程过程调用（简称 RPC）**的思想。</p>
<p><font color="red">远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单明了。</font>因此，对客户端来说，只需进行一次过程调用，一段时间后就会返回结果。服务器只需定义一些它希望导出的例程。RPC 系统一般由两部分组成：<strong>存根生成器（有时称为协议编译器）和运行时库</strong>。下面我们将详细介绍其中的每一部分。</p>
<h3 id="存根生成器" class="heading-element"><span>6.1 存根生成器</span>
  <a href="#%e5%ad%98%e6%a0%b9%e7%94%9f%e6%88%90%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>存根生成器的工作很简单：通过自动化来消除将函数参数和结果打包到消息中的一些痛苦。这样做会带来许多好处：通过设计可以避免手工编写此类代码时出现的简单错误；此外，存根编译器也许可以优化此类代码，从而提高性能。</p>
<p>这种编译器的输入只是服务器希望导出到客户端的一组调用。从概念上讲，它可能像这样简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>存根生成器采用这样的接口并生成一些不同的代码片段。</p>
<ul>
<li>对于客户端，生成一个<strong>客户端存根</strong>，其中包含接口中指定的各个功能；<font color="red">希望使用此 RPC 服务的客户端程序将与此客户端存根链接并调用它以进行 RPC。</font>在内部，客户端存根中的每个函数都执行执行远程过程调用所需的所有工作。对于客户端来说，代码只是显示为函数调用（例如，客户端调用 <code>func1(x)</code>）；在内部，<code>func1()</code> 的客户端存根中的代码执行以下操作：
<ul>
<li>**创建消息缓冲区。**消息缓冲区通常只是某个大小的连续字节数组。</li>
<li><strong>将所需信息打包到消息缓冲区中。<strong>该信息包括要调用的函数的某种标识符，以及函数需要的所有参数（例如，在上面的示例中，<code>func1</code> 是一个整数）。将所有这些信息放入单个连续缓冲区的过程有时称为参数的</strong>编组</strong>或消息的<strong>序列化</strong>。</li>
<li>**将消息发送到目标RPC 服务器。**与 RPC 服务器的通信以及使其正确运行所需的所有细节均由 <strong>RPC 运行时库</strong>处理，如下所述。</li>
<li>**等待回复。**由于函数调用通常是同步的，因此调用将等待其完成。</li>
<li><strong>解压返回代码和其他参数。<strong>如果函数仅返回单个返回码，则此过程很简单；然而，更复杂的函数可能会返回更复杂的结果（例如，列表），因此存根可能也需要解压这些结果。此步骤也称为</strong>解组或反序列化</strong>。</li>
<li><strong>返回调用者</strong>。最后，只需从客户端存根返回到客户端代码即可。</li>
</ul>
</li>
<li>对于服务器，也会生成代码。在服务器上采取的步骤如下：
<ul>
<li><strong>解压消息。<strong>此步骤称为</strong>解组或反序列化</strong>，<font color="red">从传入消息中取出信息，提取函数标识符和参数。</font></li>
<li><strong>调用实际函数</strong>。最后！我们已经到达了实际执行远程函数的阶段。 RPC 运行时调用 ID 指定的函数并传入所需的参数。</li>
<li>**将结果打包。**返回参数被打包回单个回复缓冲区。</li>
<li><strong>发送回复</strong>。回复最终发送给调用者。</li>
</ul>
</li>
</ul>
<p>存根编译器还需要考虑其他一些重要问题。</p>
<ul>
<li>
<p>首先是复杂参数，即如何打包和发送复杂的数据结构？例如，当调用 <code>write()</code> 系统调用时，需要传递三个参数：一个整数文件描述符、一个指向缓冲区的指针和一个表示要写入多少字节（从指针开始）的大小。如果一个 RPC 程序包传递了一个指针，它就需要知道如何解释该指针，并执行正确的操作。通常，这可以通过两种方式实现：一种是众所周知的类型（例如，用于传递给定大小的数据块的<code>buffer_t</code>，RPC 编译器可以理解），另一种是为数据结构注释更多信息，使编译器知道哪些字节需要序列化。</p>
</li>
<li>
<p>另一个重要问题是服务器的并发组织。简单的服务器只是在一个简单的循环中等待请求，并一次处理一个请求。但是，正如你可能已经猜到的那样，这样做的效率会非常低：<font color="red">如果一个 RPC 调用阻塞（例如，在 I/O 上），服务器资源就会被浪费</font>。</p>
<p>因此，大多数服务器都是以某种并发方式构建的。一种常见的组织方式是<strong>线程池</strong>。在这种组织结构中，服务器启动时会创建一组有限的线程；<font color="red">当消息到达时，它会被分派到这些工作线程中的一个，然后工作线程会执行 RPC 调用的工作，并最终回复</font>；在此期间，主线程会不断接收其他请求，并可能将其分派给其他工作线程。这种组织方式可以在服务器内实现并发执行，从而提高服务器的利用率；同时也会产生标准成本，主要是编程复杂度，因为 RPC 调用现在可能需要使用<strong>锁和其他同步原语</strong>，以确保其正确运行。</p>
</li>
</ul>
<h3 id="运行时库" class="heading-element"><span>6.2 运行时库</span>
  <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%ba%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>运行时库负责处理 RPC 系统中的大部分繁重工作；大部分性能和可靠性问题都由运行时库处理。下面我们将讨论构建这样一个运行时库所面临的一些主要挑战。</p>
<p>我们必须克服的首要挑战之一是如何定位远程服务。这个<strong>命名</strong>问题是分布式系统中的常见问题，在某种意义上超出了我们当前讨论的范围。最简单的方法是利用现有的命名系统，例如当前互联网协议提供的主机名和端口号。在这种系统中，客户端必须知道运行所需的 RPC 服务的机器的主机名或 IP 地址，以及它正在使用的端口号（端口号只是一种识别机器上正在进行的特定通信活动的方法，允许同时使用多个通信通道）。然后，协议套件必须提供一种机制，将数据包从系统中的任何其他机器路由到特定地址。</p>
<p><font color="red">一旦客户端知道应该与哪台服务器通信以获取特定的远程服务，下一个问题就是 RPC 应该基于哪种传输级协议。</font>具体来说，RPC 系统应该使用 TCP/IP 这样可靠的协议，还是建立在 UDP/IP 这样不可靠的通信层之上？</p>
<p>天真地认为，选择似乎很容易：显然，我们希望请求能可靠地传送到远程服务器，显然，我们希望能可靠地收到回复。因此，我们应该选择可靠的传输协议，如 TCP，对吗？</p>
<p>不幸的是，在可靠通信层之上构建 RPC 会导致性能严重低下。回想一下上文讨论的可靠通信层的工作原理：<strong>确认加超时/重试</strong>。因此，当客户端向服务器发送 RPC 请求时，服务器会以确认的方式作出响应，以便调用者知道请求已收到。同样，当服务器发送回复给客户端时，客户端也会发出确认响应，以便服务器知道它已收到。在可靠的通信层之上建立请求/响应协议（如 RPC），需要发送两条 &ldquo;额外 &ldquo;信息。</p>
<p>因此，<font color="red">许多 RPC 程序包都建立在不可靠的通信层（如 UDP）之上</font>。这样做可以提高 RPC 层的效率，但却增加了为 RPC 系统提供可靠性的责任。RPC 层通过使用超时/重试和确认来达到所需的责任水平，这一点与我们上面所描述的非常相似。通过使用某种形式的序列号，通信层可以保证每个 RPC 恰好发生一次（在无故障的情况下），或最多发生一次（在出现故障的情况下）。</p>
<h3 id="其他问题" class="heading-element"><span>6.3 其他问题</span>
  <a href="#%e5%85%b6%e4%bb%96%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>RPC 运行时还必须处理一些其他问题。例如，当远程调用需要很长时间才能完成时会发生什么？考虑到我们的超时机制，长时间运行的远程调用可能会对客户端显示为失败，从而触发重试，因此这里需要注意。一种解决方案是在未立即生成回复时使用显式确认（从接收方到发送方）；这让客户端知道服务器收到了请求。然后，经过一段时间后，客户端可以定期询问服务器是否仍在处理该请求；如果服务器一直说“是”，客户端应该很高兴并继续等待（毕竟，有时过程调用可能需要很长时间才能完成执行）。</p>
<p>运行时还必须处理带有大参数的过程调用，这些参数大于单个数据包所能容纳的参数。<font color="red">一些较低级别的网络协议提供此类发送方分段（将较大的数据包分解为一组较小的数据包）和接收方重组（将较小的部分分解为一个较大的逻辑整体）；如果没有，RPC 运行时可能必须自己实现此类功能。</font></p>
<p>许多系统处理的一个问题是字节排序问题。您可能知道，某些机器以所谓的大端顺序存储值，而其他机器则使用小端顺序。大端存储从最高有效位到最低有效位的字节（例如，整数），很像阿拉伯数字；小端则相反。两者都是存储数字信息的同等有效的方式；这里的问题是如何在不同字节序的机器之间进行通信。</p>
<p>RPC 包通常通过在其消息格式中提供明确定义的字节顺序来处理此问题。在Sun的RPC包中，<strong>XDR（外部数据表示）层</strong>提供了此功能。如果发送或接收消息的机器与 XDR 的字节顺序匹配，则消息将按预期发送和接收。但是，如果通信的机器具有不同的字节顺序，则必须转换消息中的每条信息。因此，字节顺序的差异可能会带来很小的性能成本。</p>
<p>最后一个问题是是否向客户端公开通信的异步特性，从而实现一些性能优化。具体来说，<font color="red">典型的 RPC 是同步进行的，即当客户端发出过程调用时，它必须等待过程调用返回才能继续。</font>由于等待时间可能很长，并且客户端可能还有其他工作要做，因此某些 RPC 包允许您异步调用 RPC。当发出异步RPC时，RPC包发送请求并立即返回；然后客户端可以自由地执行其他工作，例如调用其他 RPC 或其他有用的计算。客户端有时会希望看到异步 RPC 的结果；因此，它回调 RPC 层，告诉它等待未完成的 RPC 完成，此时可以访问返回参数。</p>
]]></description></item><item><title>数据完整性和保护</title><link>https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/</link><pubDate>Sat, 11 May 2024 21:35:46 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/</guid><description><![CDATA[<h2 id="磁盘故障模式" class="heading-element"><span>1 磁盘故障模式</span>
  <a href="#%e7%a3%81%e7%9b%98%e6%95%85%e9%9a%9c%e6%a8%a1%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。</p>
<p>但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分工作正常，但在成功访问一个或多个块时遇到问题。具体来说，有两种类型的单块故障很常见且值得考虑：<font color="red">静默扇区错误 (LSE) 和块损坏</font>。我们现在将更详细地讨论每一个。</p>
<p>当磁盘扇区（或扇区组）受到某种损坏时，就会出现 LSE。例如，如果磁盘磁头由于某种原因（<strong>磁头撞击</strong>，正常运行中不应该发生的情况）接触到磁盘表面，可能会损坏磁盘表面，导致位无法读取。宇宙射线也会使位翻转，导致内容错误。幸运的是，硬盘会使用<strong>磁盘内纠错码 (ECC)</strong> 来确定块中的磁盘位是否正确，并在某些情况下对其进行修复；如果位不正确，而硬盘又没有足够的信息来修复错误，则在请求读取时磁盘会返回错误信息。</p>
<p>还有一种情况是，磁盘块损坏的方式无法被磁盘本身检测到。例如，存在漏洞的磁盘固件可能会将块写入错误位置；在这种情况下，磁盘 ECC 显示块内容正常，但从客户端的角度来看，随后访问时会返回错误的块。同样，当数据块通过故障总线从主机传输到磁盘时，也可能会损坏数据块；磁盘会存储损坏的数据，但这些数据并不是客户想要的。这类故障特别隐蔽，因为它们是<strong>静默故障</strong>；磁盘在返回故障数据时不会显示问题。</p>
<p>Prabhakaran 等人将这种更现代的磁盘故障观点称为部分故障磁盘故障模型。在这种观点中，磁盘仍有可能全部失效（就像传统的故障-停止模型中的情况一样）；但是，磁盘也有可能看似正常工作，但有一个或多个区块变得不可访问（即 LSE）或包含错误的内容（即损坏）。因此，在访问看似正常工作的磁盘时，偶尔会在尝试读取或写入给定块时返回错误（<strong>非静默部分故障</strong>），偶尔也会简单地返回错误数据（<strong>静默部分故障</strong>）。</p>
<p>这两类故障都比较罕见，但究竟有多罕见呢？下图总结了两份 Bairavasundaram 研究报告的部分结论。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=small" data-sub-html="<h2>image-20240422202738169</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png" alt="image-20240422202738169" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=large 2x" data-title="image-20240422202738169" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该图显示了在研究过程中（约 3 年，超过 150 万台硬盘）至少出现过一次 LSE 或块损坏的硬盘百分比。该图将结果进一步细分为 &ldquo;廉价 &ldquo;硬盘（通常为 SATA 硬盘）和 &ldquo;昂贵 &ldquo;硬盘（通常为 SCSI 或光纤通道硬盘）。正如您所看到的，虽然购买更好的硬盘降低了这两类问题的发生频率（大约降低了一个数量级），但它们仍然经常发生，因此您需要仔细考虑如何在存储系统中处理它们。</p>
<p>关于 LSE 的一些其他发现包括：</p>
<ul>
<li>具有多个 LSE 的昂贵驱动器与较便宜的驱动器一样可能产生额外错误；</li>
<li>对于大多数驱动器，第二年的年错误率会增加；</li>
<li>LSE 数量随着磁盘大小的增加而增加；</li>
<li>大多数磁盘具有LSE 少于 50 个；</li>
<li>具有 LSE 的磁盘更有可能产生额外的 LSE；</li>
<li>存在大量的空间和时间局部性；</li>
<li>磁盘清理很有用（大多数 LSE 都是通过这种方式找到的） 。</li>
</ul>
<p>关于损坏的一些发现：</p>
<ul>
<li>同一驱动器类别中不同驱动器型号的损坏几率差异很大；</li>
<li>型号之间的老化影响不同；</li>
<li>工作负载和磁盘大小对损坏影响很小</li>
<li>大多数损坏的磁盘只有少数损坏；</li>
<li>损坏在磁盘内或 RAID 中的磁盘之间不是独立的；</li>
<li>存在空间局部性和一些时间局部性</li>
<li>与LSE 的相关性很弱</li>
</ul>
<p><font color="red">一个可靠的存储系统，需要有检测和恢复 LSE 和块损坏的机制</font></p>
<h2 id="处理静默扇区错误lse" class="heading-element"><span>2 处理静默扇区错误（LSE）</span>
  <a href="#%e5%a4%84%e7%90%86%e9%9d%99%e9%bb%98%e6%89%87%e5%8c%ba%e9%94%99%e8%af%aflse" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>考虑到这两种新的部分磁盘故障模式，我们现在应该尝试看看我们可以对它们做些什么。让我们首先解决两者中较容易的一个，即静默扇区错误。</p>
<blockquote>
<p>关键问题：存储系统应如何处理静默扇区错误？需要多少额外的机制来处理这种形式的部分故障？</p>
</blockquote>
<p>事实证明，静默扇区错误的处理相当简单，因为它们（根据定义）很容易检测到。当存储系统尝试访问块并且磁盘返回错误时，存储系统应该简单地使用它所拥有的任何冗余机制来返回正确的数据。例如，</p>
<ul>
<li>在镜像 RAID 中，系统应该访问备用副本；</li>
<li>在基于奇偶校验的 RAID-4 或 RAID-5 系统中，系统应从奇偶校验组中的其他块重建该块。</li>
</ul>
<p>因此，诸如 LSE 等容易检测到的问题可以通过标准冗余机制轻松恢复。</p>
<p>LSE的不断增多影响了多年来RAID设计。在RAID-4/5系统中，当整个磁盘故障和LSE同时发生时，会出现一个特别有趣的问题。具体而言，在整个磁盘失败时，RAID尝试通过读取奇偶校验组中所有其他磁盘并重新计算缺失值来<strong>重建</strong>该磁盘（比如说，到一个热备用上）。如果在重建过程中，在任何其他一块磁盘上遇到LSE，则会出现问题：无法成功完成重建。</p>
<p>为了解决这个问题，一些系统增加了额外的冗余度。例如，NetApp的<strong>RAID-DP</strong>相当于两块奇偶校验硬盘而不是一块。当在重建过程中发现LSE时，额外的奇偶校验有助于重构丢失的数据块。正如始终如此地存在成本那样，在每条条带保持两块奇偶校验硬盘更昂贵；然而，NetApp <strong>WAFL</strong>文件系统的日志结构化性质在许多情况下可以减轻这种成本。剩下的成本是空间方面，在第二个奇偶校验区块形式上需要额外一块硬盘。</p>
<h2 id="检测损坏校验和" class="heading-element"><span>3 检测损坏：校验和</span>
  <a href="#%e6%a3%80%e6%b5%8b%e6%8d%9f%e5%9d%8f%e6%a0%a1%e9%aa%8c%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们解决更具挑战性的问题，即通过数据损坏导致的静默故障。当数据损坏导致磁盘返回坏数据时，我们如何防止用户获得坏数据？</p>
<blockquote>
<p>关键问题：鉴于此类故障的隐匿性，存储系统可以采取哪些措施来检测何时发生损坏？需要什么技术？如何有效地实施它们？</p>
</blockquote>
<p>与静默扇区错误不同，损坏检测是一个关键问题。客户端如何知道某个块已经坏了？一旦知道某个特定块损坏，<strong>恢复就与以前相同</strong>：您需要该块的其他副本（希望是一个未损坏的副本！）。因此，我们在这里重点关注<strong>检测技术</strong>。</p>
<p>现代存储系统用于保持数据完整性的主要机制称为<strong>校验和</strong>。<font color="red">校验和只是一个函数的结果，该函数将一块数据（例如 4KB 块）作为输入，并根据所述数据计算函数，生成数据内容的小摘要（例如 4 或 8 字节），该摘要称为校验和。</font>这种计算的目标是使系统能够通过将校验和与数据一起存储来检测数据是否已被损坏或更改，然后在<strong>以后访问时确认数据的当前校验和与原始存储值相匹配</strong>。</p>
<h3 id="常用校验和函数" class="heading-element"><span>3.2 常用校验和函数</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>许多不同的函数用于计算校验和，它们的强度（即，它们在保护数据完整性方面的能力）和速度（即，它们的计算速度）各不相同。这里出现了系统中常见的权衡：通常，获得的保护越多，成本就越高。</p>
<p>有些人使用的一种简单的校验和函数是基于异或 (XOR) 的。对于基于 XOR 的校验和，校验和是通过对正在校验和的数据块的每个块进行异或来计算的，从而生成表示整个块的 XOR 的单个值。</p>
<p>为了更具体地说明这一点，假设我们正在 16 字节的块上计算 4 字节的校验和（这个块当然太小，不能真正成为磁盘扇区或块，但它将用于示例）。 16 个数据字节（十六进制）如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">365e c4cd ba14 8a92 ecef 2c3a 40be f666</span></span></code></pre></td></tr></table>
</div>
</div><p>如果用二进制表示，我们会得到以下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0011 0110 0101 1110 1100 0100 1100 1101
</span></span><span class="line"><span class="cl">1011 1010 0001 0100 1000 1010 1001 0010
</span></span><span class="line"><span class="cl">1110 1100 1110 1111 0010 1100 0011 1010
</span></span><span class="line"><span class="cl">0100 0000 1011 1110 1111 0110 0110 0110</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们以每行 4 个字节为一组排列数据，因此很容易看出校验和的结果：在每列上执行 XOR 即可得到最终的校验和值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0010 0000 0001 1011 1001 0100 0000 0011</span></span></code></pre></td></tr></table>
</div>
</div><p>结果（十六进制）为<code>0x201b9403</code>。 XOR 是一种合理的校验和方法，但有其局限性。例如，<font color="red">如果每个校验和单元中同一位置的两个位发生变化，则校验和将无法检测到损坏。</font>为此，人们研究了其他校验和函数。</p>
<p>另一种基本的校验函数是加法。这种方法的优点是速度快；计算时只需对每块数据执行 2 的补码加法，忽略溢出。它可以检测到数据的许多变化，但如果数据发生移位等情况，则效果不佳。</p>
<p>Fletcher校验和是一种略微复杂的算法，以John G. Fletcher的名字命名。它的计算非常简单，只需计算两个校验字节 $s_1$ 和 $s_2$。具体来说，假设数据块 $D$ 由字节 $d_1 \dots  d_n$ 组成；$s_1$ 的定义如下：$s_1 = (s_1 + d_i) \mod 255$（对所有 $d_i$ 进行计算）；$s_2$ 的定义如下：$s_2 = (s_2 + s_1) \mod 255$（同样对所有 $d_i$ 进行计算）。Fletcher 校验和与 CRC 几乎一样强（见下文），能检测出所有单bit、双bit错误和许多突发错误。</p>
<p>最后一种常用的校验和称为<strong>循环冗余校验（CRC）</strong>。假设要计算数据块 D 的校验和，只需将 D 视为一个大的二进制数（毕竟只是一串bit），然后除以一个约定的值（$k$）。除数的余数就是 CRC 的值。事实证明，我们可以相当高效地实现这种二进制模运算，因此 CRC 在网络中也很流行。</p>
<p>无论使用哪种方法，显而易见的是，没有完美的校验和：<font color="red">两个内容不相同的数据块有可能具有完全相同的校验和，这就是所谓的冲突。</font>这个事实应该是直观的：毕竟，计算校验和是把一个大的东西（如 4KB），生成一个小得多的摘要（如 4 或 8 字节）。因此，在选择一个好的校验和函数时，我们试图找到一个既能尽量减少冲突几率，又能保持计算简便的函数。</p>
<h3 id="校验和布局" class="heading-element"><span>3.3 校验和布局</span>
  <a href="#%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%b8%83%e5%b1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在您已经了解了如何计算校验和，接下来我们来分析如何在存储系统中使用校验和。我们必须解决的第一个问题是校验和的布局，即校验和应该如何存储在磁盘上？</p>
<p>最基本的方法只是存储每个磁盘扇区（或块）的校验和。给定一个数据块 D，让我们调用该数据的校验和 <code>C(D)</code>。因此，如果没有校验和，磁盘布局如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=small" data-sub-html="<h2>image-20240422211734250</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png" alt="image-20240422211734250" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=large 2x" data-title="image-20240422211734250" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>使用校验和时，布局会为每个块添加一个校验和：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=small" data-sub-html="<h2>image-20240422211817034</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png" alt="image-20240422211817034" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=large 2x" data-title="image-20240422211817034" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>由于校验和通常很小（如 8 字节），而磁盘只能以扇区大小的块（512 字节）或其倍数写入，因此出现的一个问题是如何实现上述布局。硬盘制造商采用的一种解决方案是用 520 字节扇区格式化硬盘；每个扇区额外的 8 字节可用于存储校验和。</p>
<p>对于不具备这种功能的磁盘，文件系统必须想办法将校验和存储到 512 字节的块中。其中一种方法如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=small" data-sub-html="<h2>image-20240422211938622</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png" alt="image-20240422211938622" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=large 2x" data-title="image-20240422211938622" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此方案中，$n$ 个校验和一起存储在一个扇区中，后面是 $n$ 个数据块，然后是下一个的 $n$ 个块的另一个校验和扇区，依此类推。这种方法的优点是可以在所有磁盘上工作，但效率可能较低；例如，如果文件系统想要覆盖块<code>D1</code>，则必须读入包含<code>C(D1)</code>的校验和扇区，更新其中的<code>C(D1)</code>，然后写出校验和扇区和新的数据块<code>D1</code>（因此，一次读取和两次写入）。早期的方法（每个扇区一个校验和）仅执行一次写入。</p>
<h3 id="使用校验和" class="heading-element"><span>3.4 使用校验和</span>
  <a href="#%e4%bd%bf%e7%94%a8%e6%a0%a1%e9%aa%8c%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在确定了校验和布局之后，我们就可以着手了解如何使用校验和了。读取数据块 D 时，客户端（即文件系统或存储控制器）也会从磁盘读取其校验和$C_s(D)$，我们称之为<strong>存储校验和</strong>（因此使用了下标 $C_s$）。然后，客户端对检索到的数据块 D 计算校验和，我们称之为<strong>计算校验和</strong> $C_c(D)$。此时，客户端会比较存储的校验和与计算的校验和；如果两者相等（即 $C_s(D) == C_c(D)$），则数据很可能没有损坏，因此可以安全地返回给用户。如果它们不匹配（即 $C_s(D) != C_c(D)$），这意味着数据在存储后发生了变化（因为存储的校验和反映的是数据当时的值）。在这种情况下，我们的校验和帮助我们检测到了数据损坏。</p>
<p>有了损坏，我们自然会问该如何处理？如果存储系统有冗余副本，答案很简单：尝试使用它。如果存储系统没有这样的副本，答案很可能是返回错误。不管是哪种情况，都要认识到损坏检测并不是灵丹妙药；如果没有其他办法获取未损坏的数据，那就只能走霉运了。</p>
<h2 id="一个新问题错误写入" class="heading-element"><span>4 一个新问题：错误写入</span>
  <a href="#%e4%b8%80%e4%b8%aa%e6%96%b0%e9%97%ae%e9%a2%98%e9%94%99%e8%af%af%e5%86%99%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>上述基本方案在一般的块损坏情况下效果很好。然而，现代磁盘有几种不同寻常的故障模式，需要不同的解决方案。</p>
<p>第一种故障模式称为<strong>误写</strong>。磁盘和 RAID 控制器会出现这种情况，它们会将数据正确写入磁盘，只是写错了位置。在单磁盘系统中，这意味着磁盘将数据块 $D_x$ 写入的地址不是 $x$，而是 $y$（从而 &ldquo;破坏 &ldquo;了 $D_y$）；此外，在多磁盘系统中，控制器也可能将 $D_{i,x}$ 写入的地址不是磁盘 $i$ 的 $x$，而是其他磁盘 $j$。因此关键问题是：</p>
<blockquote>
<p>存储系统或磁盘控制器应如何检测错误写入？校验和需要哪些附加功能？</p>
</blockquote>
<p>答案很简单：在每个校验和中增加一点信息。在这种情况下，增加一个**物理标识符（物理 ID）**是非常有用的。例如，如果现在存储的信息包含校验和 $C(D)$以及块的磁盘编号和扇区编号，那么客户端就很容易确定正确的信息是否存在于特定位置。具体来说，如果客户端读取的是磁盘 $10$ 上的块 $4$（$D_{10,4}$），则存储的信息应包括该磁盘编号和扇区偏移量，如下图所示。如果信息不匹配，就说明发生了错误写入，此时就会检测到损坏。下面是双磁盘系统中添加信息的示例。请注意，该图和之前的其他图一样，并不是按比例绘制的，因为校验和通常很小（如 8 字节），而数据块却大得多（如 4 KB 或更大）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=small" data-sub-html="<h2>image-20240422213501062</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png" alt="image-20240422213501062" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=large 2x" data-title="image-20240422213501062" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从磁盘上的格式可以看出，磁盘上现在有相当多的冗余信息：对于每个块，磁盘编号在每个数据块内重复出现，而相关块的偏移量也保留在数据块本身旁边。冗余信息的存在不足为奇，因为冗余是错误检测（在本例中）和恢复（在其他情况下）的关键。虽然完美的磁盘并不严格需要一点额外的信息，但如果出现问题，这些信息却能帮助检测出问题所在。</p>
<h2 id="最后一个问题写入丢失" class="heading-element"><span>5 最后一个问题：写入丢失</span>
  <a href="#%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98%e5%86%99%e5%85%a5%e4%b8%a2%e5%a4%b1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>不幸的是，错误写入并不是我们要解决的最后一个问题。具体来说，一些现代存储设备还存在一个称为<strong>写入丢失</strong>的问题，当设备通知上层写入已完成但实际上从未被持久化时，就会发生这种情况；因此，剩下的是块的旧内容而不是更新的新内容。</p>
<p>这里明显的问题是：上面的任何校验和策略（例如基本校验和或物理标识）是否有助于检测丢失的写入？不幸的是，答案是否定的：旧块可能有匹配的校验和，并且上面使用的物理 ID（磁盘号和块偏移量）也将是正确的。</p>
<p>因此，我们的最后一个关键问题是：</p>
<blockquote>
<p>存储系统或磁盘控制器应如何检测丢失的写入？校验和还需要哪些附加功能？</p>
</blockquote>
<p>有许多可能的解决方案可以帮助。一种经典方法是执行<strong>写入验证</strong>或<strong>写入后读取</strong>；通过在写入后立即读回数据，系统可以确保数据确实到达磁盘表面。然而，这种方法非常慢，<font color="red">完成写入所需的 I/O 数量会增加一倍</font>。</p>
<p>有些系统在系统的其他地方添加校验和来检测丢失的写入。例如，Sun 的 Zettabyte 文件系统 (ZFS) 在每个文件系统inode中包含一个校验和，并为文件中包含的每个块提供间接块。因此，即使对块本身的写入丢失，inode 内的校验和也不会与旧数据匹配。只有当对inode和数据的写入同时丢失时，这种方案才会失败，这是一种不太可能（但不幸的是，有可能！）的情况。</p>
<h2 id="扫描" class="heading-element"><span>6 扫描</span>
  <a href="#%e6%89%ab%e6%8f%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>说了这么多，你可能会问：这些校验和什么时候会被检查？当然，在应用程序访问数据时会进行一定量的校验，但大多数数据很少被访问，因此会保持未校验状态。对于可靠的存储系统来说，未校验的数据是有问题的，因为bit损坏最终会影响特定数据的所有副本。</p>
<p>为了解决这个问题，许多系统都采用了各种形式的磁盘扫描。通过定期读取系统中的每个块，并检查校验和是否仍然有效，磁盘系统可以降低某个数据项的所有副本损坏的几率。典型的系统每晚或每周安排一次扫描。</p>
<h2 id="校验和的开销" class="heading-element"><span>7 校验和的开销</span>
  <a href="#%e6%a0%a1%e9%aa%8c%e5%92%8c%e7%9a%84%e5%bc%80%e9%94%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在结束之前，我们现在讨论使用校验和进行数据保护的一些开销。正如计算机系统中常见的那样，有两种不同类型的开销：空间和时间。</p>
<p>空间开销有两种形式。</p>
<ul>
<li>第一个是<strong>在磁盘（或其他存储介质）本身上</strong>；每个存储的校验和都会占用磁盘空间，无法再用于存储用户数据。典型的比率可能是每 4 KB 数据块 8 字节校验和，磁盘空间开销为 0.19%。</li>
<li>第二种类型的空间开销来自<strong>系统的内存</strong>。访问数据时，内存中必须有空间用于存放校验和以及数据本身。但是，如果系统只是检查校验和，然后在完成后将其丢弃，则这种开销是短暂的，不必担心。只有当校验和保存在内存中（为了防止内存损坏的额外保护级别），这个小开销才会被观察到。</li>
</ul>
<p>虽然空间开销很小，但校验和引起的时间开销可能非常明显。至少，CPU 必须计算每个块的校验和，无论是在存储数据时（以确定存储的校验和的值）还是在访问数据时（再次计算校验和并将其与存储的校验和进行比较）。许多使用校验和（包括网络栈）的系统采用的一种<font color="red">减少 CPU 开销的方法是将数据复制和校验和合并为一项简化的活动；因为无论如何都需要复制（例如，将数据从内核页缓存复制到用户缓冲区），因此组合复制/校验和可能非常有效。</font></p>
<p>除了 CPU 开销之外，某些校验和方案还会产生额外的 I/O 开销，特别是当校验和与数据分开存储时（因此需要额外的 I/O 来访问它们），以及后台扫描所需的任何额外 I/O。前者可以通过设计来减少；后者可以进行调整，从而限制其影响，或许可以通过控制此类扫描活动的发生时间来实现（如半夜）。</p>
]]></description></item><item><title>基于闪存的SSD</title><link>https://hezephyr.github.io/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/</link><pubDate>Sat, 11 May 2024 21:34:54 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在硬盘驱动器占据主导地位数十年后，一种新型的持久存储设备最近在世界上占据了重要地位。这种设备一般被称为<strong>固态存储设备</strong>，它不像硬盘驱动器那样有机械或移动部件，而是由晶体管构成，就像内存和处理器一样。然而，与典型的随机存取存储器（如 DRAM）不同，这种固态存储设备（又称 SSD）在断电的情况下仍能保留信息，因此是持久存储数据的理想选择。</p>
<p>我们将重点讨论的技术是<strong>闪存</strong>（更具体地说，是基于 NAND 的闪存，它具有更好的成本效益，即每存储容量单位的成本较低。这使得 NAND 型闪存在大容量存储设备中得到广泛应用，如固态硬盘（SSD）和闪存卡等），它是由 Fujio Masuoka 在 20 世纪 80 年代发明的，。我们将看到，闪存具有一些独特的特性。</p>
<ul>
<li>例如，要写入闪存的某一大块（即一个<strong>闪存页</strong>），首先必须擦除更大的一块（即一个<strong>闪存块</strong>），而擦除的代价可能相当昂贵。</li>
<li>此外，过于频繁地写入页面会导致页面磨损。</li>
</ul>
<p>这两个特性使得构建基于闪存的固态硬盘成为一项有趣的挑战：</p>
<blockquote>
<p>如何构建基于闪存的固态硬盘 如何构建基于闪存的固态硬盘？如何处理擦除的昂贵特性？考虑到反复擦写会损耗设备，我们如何才能制造出使用寿命长的设备？技术进步的脚步会停止吗？或者不再令人惊叹？</p>
</blockquote>
<p>闪存芯片设计用于在单个晶体管中存储一个或多个bit；晶体管内捕获的电荷水平被映射为二进制值。在单层单元 (SLC) 闪存中，晶体管内仅存储单个位（即 1 或 0）；对于多层单元 (MLC) 闪存，两个位被编码为不同的电荷级别，例如，00、01、10 和 11 分别由低、稍低、稍高和高电平表示。甚至还有三层单元 (TLC) 闪存以及四层单元(QLC)闪存，每个单元编码 3 位、4位。如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=small" data-sub-html="<h2>image-20240420214539405</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png" alt="image-20240420214539405" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=large 2x" data-title="image-20240420214539405" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>总体而言，SLC芯片性能更高，但价格也更高。</p>
<h2 id="从bit到组平面" class="heading-element"><span>2 从bit到组/平面</span>
  <a href="#%e4%bb%8ebit%e5%88%b0%e7%bb%84%e5%b9%b3%e9%9d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如古希腊人所说，存储一个bit（或几个bit）并不能构成一个存储系统。因此，闪存芯片被组织成由大量单元组成的组或平面。</p>
<p>一个组以两种不同大小的单位进行访问：</p>
<ul>
<li><strong>块</strong>（有时称为<strong>擦除块</strong>），通常大小为 128 KB 或 256 KB；</li>
<li><strong>页</strong>，大小为几 KB（如 4KB）。</li>
</ul>
<p>每个存储组内有大量的块，每个块内又有大量的页。在考虑闪存时，你必须记住这个新术语，它不同于我们在磁盘和 RAID 中提到的块，也不同于我们在虚拟内存中提到的页。</p>
<p>下图显示了一个闪存平面的块和页的示例；在这个简单的示例中，有三个块，每个块包含四个页。我们将在下文中了解区分块和页的原因；事实证明，这种区分对于闪存操作（如读写）至关重要，对于设备的整体性能更是如此。你将了解到的最重要（也是最奇怪）的事情是，<font color="red">要写入块中的页面，首先必须擦除整个块</font>；这一棘手的细节使得构建基于闪存的固态硬盘成为一项有趣且值得挑战的任务，也是本章后半部分的主题。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=small" data-sub-html="<h2>image-20240420214355415</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks" alt="image-20240420214355415" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=large 2x" data-title="image-20240420214355415" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="基本闪存操作" class="heading-element"><span>3 基本闪存操作</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e9%97%aa%e5%ad%98%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="读取擦除和编程" class="heading-element"><span>3.1 读取、擦除和编程</span>
  <a href="#%e8%af%bb%e5%8f%96%e6%93%a6%e9%99%a4%e5%92%8c%e7%bc%96%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>鉴于这种闪存组织结构，闪存芯片可支持三种低级操作。<font color="red">读取命令用于从闪存中读取一个页面；擦除和编程同时用于写入。</font>详情如下：</p>
<ul>
<li><strong>读取（一页）</strong>：闪存芯片的客户端只需向设备指定读取命令和相应的页码，即可读取任何页面（如 2KB 或 4KB）。这种操作通常相当快，10 微秒左右，与设备上的位置无关，（或多或少）也与上一次请求的位置无关（与磁盘完全不同），能够均匀快速地访问任何位置意味着该设备是随机存取设备。</li>
<li><strong>擦除（一个块）</strong>：在写入闪存中的页面之前，设备的特性要求首先擦除页面所在的整个块。重要的是，擦除会破坏块中的内容（通过将每个位设置为 1）；因此，在执行擦除之前，必须确保块中任何您需要的数据都已复制到其他地方（内存或其他闪存块）。擦除命令耗时较长，需要几毫秒才能完成。完成后，整个块将被重置，每一页都可以进行编程。</li>
<li><strong>编程（一页）</strong>：擦除块后，可使用编程命令将页面中的部分 1 变为 0，并将页面中的所需内容写入闪存。对页面进行编程的成本比擦除块低，但比读取页面的成本高，在现代闪存芯片上通常需要 100 微秒左右。</li>
</ul>
<p>对闪存芯片的一种理解是，每个页面都有一个与之相关的状态。<font color="red">页面开始时处于<code>INVALID</code>状态。通过擦除页面所在的块，可以将页面（以及该块中的所有页面）的状态设置为<code>ERASED</code>状态</font>，从而重置块中每个页面的内容，而且（重要的是）还可以对它们进行编程。当你对一个页面进行编程时，它的状态将变为 <code>VALID</code>，这意味着它的内容已被设置并可被读取。读取不会影响这些状态（尽管你只能读取已编程的页面）。一旦页面被编程，更改其内容的唯一方法就是擦除页面所在的整个块。下面是一个 4页块中各种擦除和编程操作后状态转换的示例：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=small" data-sub-html="<h2>image-20240420221943937</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png" alt="image-20240420221943937" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=large 2x" data-title="image-20240420221943937" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="详细示例" class="heading-element"><span>3.2 详细示例</span>
  <a href="#%e8%af%a6%e7%bb%86%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于写入过程（即擦除和编程）非常不寻常，让我们通过一个详细的示例来确保其合理性。在这个例子中，假设我们在一个 4 页的块中有以下 4 个 8 位页面（尺寸都很小，但在本例中很有用）；每个页面都是<code>VALID</code>，因为每个页面之前都被编程过。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=small" data-sub-html="<h2>image-20240420222159745</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png" alt="image-20240420222159745" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=large 2x" data-title="image-20240420222159745" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设我们希望写入第 0 页，并用新内容填充它。要写入任何页，我们必须首先擦除整个块。假设我们这样做了，从而使块处于这种状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=small" data-sub-html="<h2>image-20240420222254944</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png" alt="image-20240420222254944" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=large 2x" data-title="image-20240420222254944" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在，我们可以继续对页面0进行编程，例如，用内容 <code>00000011</code> 来覆盖旧的第 0 页（内容 <code>00011000</code>）。这样，我们的程序块看起来就像这样了：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=small" data-sub-html="<h2>image-20240420222359099</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png" alt="image-20240420222359099" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=large 2x" data-title="image-20240420222359099" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在坏消息来了：第 1、2 和 3 页的内容已经全部丢失！因此，在覆盖块内的任何页面之前，我们必须先将我们关心的任何数据移动到其他位置（如内存或闪存上的其他位置）。擦除的性质将对我们如何设计基于闪存的固态硬盘产生重大影响，我们很快就会了解到这一点。</p>
<h3 id="总结" class="heading-element"><span>3.3 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>读取页面很简单：只需读取页面即可。闪存芯片在这方面做得很好，而且速度很快；就性能而言，它们有可能大大超过现代磁盘驱动器的随机读取性能，而现代磁盘驱动器由于机械寻道和旋转成本而速度较慢。</p>
<p>写入页面则比较麻烦；首先必须擦除整个块（注意先将我们关心的任何数据转移到另一个位置），然后对所需页面进行编程。这不仅成本高昂，而且频繁重复这种编程/擦除循环会导致闪存芯片最大的可靠性问题：<strong>磨损</strong>。<font color="red">在设计使用闪存的存储系统时，写入的性能和可靠性是重点</font>。我们很快就会了解到现代固态硬盘是如何解决这些问题的，尽管存在这些限制，但仍能提供出色的性能和可靠性。</p>
<h2 id="闪存性能和可靠性" class="heading-element"><span>4 闪存性能和可靠性</span>
  <a href="#%e9%97%aa%e5%ad%98%e6%80%a7%e8%83%bd%e5%92%8c%e5%8f%af%e9%9d%a0%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>因为我们有兴趣用原始闪存芯片构建存储设备，所以有必要了解它们的基本性能特征。下图粗略总结了 SLC、MLC 和 TLC 闪存（每个单元分别存储 1、2 和 3 位信息）的读取、编程和擦除的基本操作延迟。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=small" data-sub-html="<h2>image-20240420223008434</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png" alt="image-20240420223008434" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=large 2x" data-title="image-20240420223008434" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从表中可以看出，读取延迟非常好，只需 10 微秒即可完成。编程延迟更高且变化更大，SLC 低至 200 微秒，但当每个单元中装入更多位时，程序延迟会更高；为了获得良好的写入性能，您必须并行使用多个闪存芯片。最后，擦除非常昂贵，通常需要几毫秒。处理这种成本是现代闪存设计的核心。</p>
<p>现在让我们考虑一下闪存芯片的可靠性。与机械磁盘不同，机械磁盘可能会因多种原因而发生故障（包括可怕的物理磁头碰撞，即驱动器磁头实际上与记录表面接触），闪存芯片是纯硅，从这个意义上讲，需要担心的可靠性问题较少，主要担心的是<strong>磨损</strong>：<font coor="red">当闪存块被擦除和编程时，它会慢慢产生一点额外的电荷。随着时间的推移，随着额外电荷的积累，区分 0 和 1 变得越来越困难。当变得不可能时，该块就变得无法使用。</font></p>
<p>目前，块的典型寿命尚不清楚。制造商将基于 MLC 的模块评价为具有 10,000 次 P/E（编程/擦除）循环寿命；也就是说，每个块在失败之前可以被擦除和编程 10,000 次。基于 SLC 的芯片由于每个晶体管仅存储一位，因此具有较长的使用寿命，通常为 100,000 个 P/E 周期。然而，最近的研究表明，寿命比预期的要长得多。</p>
<p>闪存芯片内的另一个可靠性问题被称为<strong>干扰</strong>。当访问闪存中的特定页面时，相邻页面中的某些位可能会被翻转；这种位翻转被称为<strong>读取干扰或编程干扰</strong>，具体取决于页面是被读取还是被编程。</p>
<blockquote>
<center>向后兼容性的重要性
</center>
<p>向后兼容性始终是分层系统中需要考虑的问题。通过定义两个系统之间的稳定接口，可以在接口的每一侧实现创新，同时确保持续的互操作性。这种方法在许多领域都非常成功：操作系统为应用程序提供相对稳定的 API，磁盘为文件系统提供相同的基于块的接口，IP 网络堆栈中的每一层都为上一层提供固定不变的接口。</p>
<p>毫不奇怪，这种刚性可能有一个缺点，因为在一代中定义的接口可能不适用于下一代。在某些情况下，考虑完全重新设计整个系统可能会很有用。 Sun ZFS 文件系统 就是一个很好的例子；通过重新考虑文件系统和 RAID 的交互，ZFS 的创建者设想（然后实现）了一个更有效的集成整体。</p>
</blockquote>
<h2 id="从原始闪存到基于闪存的-ssd" class="heading-element"><span>5 从原始闪存到基于闪存的 SSD</span>
  <a href="#%e4%bb%8e%e5%8e%9f%e5%a7%8b%e9%97%aa%e5%ad%98%e5%88%b0%e5%9f%ba%e4%ba%8e%e9%97%aa%e5%ad%98%e7%9a%84-ssd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>鉴于我们对闪存芯片的基本了解，我们现在面临下一个任务：如何将一组基本的闪存芯片变成看起来像典型存储设备的东西。标准存储接口是一种简单的基于块的接口，在给定块地址的情况下，可以读取或写入大小为 512 字节（或更大）的<strong>块（扇区）</strong>。<font color="red">基于闪存的 SSD 的任务是在其内部的原始闪存芯片之上提供标准块接口</font>。</p>
<p><font color="red">在内部，SSD 由一定数量的闪存芯片（用于持久存储）组成。 SSD 还包含一定量的易失性（即非持久性）内存（例如 SRAM）</font>，这样的内存对于数据的缓存和缓冲以及映射表很有用，我们将在下面了解。最后，SSD 包含协调设备操作的控制逻辑。简化框图如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=small" data-sub-html="<h2>image-20240420224040136</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png" alt="image-20240420224040136" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=large 2x" data-title="image-20240420224040136" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该控制逻辑的基本功能之一是满足客户端的读写，根据需要将其转化为内部闪存操作。**闪存转换层（FTL）**正是提供了这种功能。 <font color="red">FTL 接受逻辑块（构成设备接口）上的读写请求，并将其转换为底层物理块和物理页（构成实际闪存设备）上的低级读取、擦除和编程命令。</font> FTL 应该以提供卓越的性能和高可靠性为目标来完成这项任务。</p>
<p>正如我们将看到的，卓越的性能可以通过技术的组合来实现。一个关键是<strong>并行</strong>利用多个闪存芯片；虽然我们不会进一步讨论这项技术，但可以说所有现代 SSD 都在内部使用多个芯片来获得更高的性能。另一个性能目标是<strong>减少写入放大</strong>，写入放大定义为 FTL 向闪存芯片发出的总写入流量（以字节为单位）除以客户端向 SSD 发出的总写入流量（以字节为单位）。正如我们将在下面看到的，简单的 FTL 构建方法将导致高写入放大和低性能。高可靠性将通过几种不同方法的组合来实现。如上所述，一个主要问题是磨损。如果单个块被频繁地擦除和编程，它将变得不可用；因此，FTL 应尝试尽可能均匀地跨闪存块分布写入，确保设备的所有块大致同时磨损；这样做称为<strong>磨损均衡</strong>，是任何现代 FTL 的重要组成部分。</p>
<p>另一个可靠性问题是编程干扰。为了最大限度地减少这种干扰，FTL 通常会按从低页到高页的顺序对擦除块内的页进行编程。这种顺序编程方法最大限度地减少了干扰并被广泛使用。</p>
<h2 id="ftl-组织结构" class="heading-element"><span>6 FTL 组织结构</span>
  <a href="#ftl-%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="直接映射" class="heading-element"><span>6.1 直接映射</span>
  <a href="#%e7%9b%b4%e6%8e%a5%e6%98%a0%e5%b0%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最简单的 FTL 组织结构我们称之为<strong>直接映射</strong>。在这种方法中，逻辑页 $N$ 的读取直接映射到物理页 $N$ 的读取。对逻辑页 N 的写入则更为复杂；FTL 首先要读入页面 $N$ 所在的整个块，然后擦除该块，最后对旧页面和新页面进行编程。</p>
<p>你可能已经猜到，直接映射 FTL 在性能和可靠性方面都存在很多问题。性能问题出现在每次写入时：设备必须读入整个数据块（成本高昂），擦除（成本相当高昂），然后编程（成本高昂）。最终结果是严重的写入放大（与块中的页数成正比），因此写入性能很差，甚至比典型硬盘的机械寻道和旋转延迟还要慢。</p>
<p>更糟糕的是这种方法的可靠性。如果文件系统元数据或用户文件数据被反复覆盖，同一数据块就会被一次又一次地擦除和编程，使其迅速损耗，并可能丢失数据。直接映射方法只是将磨损的控制权过多地交给了客户端工作负载；如果工作负载不能将写入负载均匀地分散到逻辑块中，那么包含常用数据的底层物理块就会很快磨损。出于可靠性和性能方面的考虑，直接映射 FTL 都不是一个好主意。</p>
<h3 id="日志结构的-ftl" class="heading-element"><span>6.2 日志结构的 FTL</span>
  <a href="#%e6%97%a5%e5%bf%97%e7%bb%93%e6%9e%84%e7%9a%84-ftl" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="基本原理" class="heading-element"><span>6.2.1 基本原理</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>由于这些原因，如今大多数 FTL 都是<strong>日志结构</strong>的，这一理念在存储设备（如我们现在看到的）和其上的文件系统（如我们将在<strong>日志结构文件系统</strong>一章中看到的）中都很有用。在写入逻辑块 $N$ 时，设备会将写入内容附加到当前正在写入的块中的下一个空闲位置；我们称这种写入方式为<strong>日志</strong>。为方便后续读取块 $N$，设备会保存一个<strong>映射表</strong>（在内存中，并以某种形式持久存在于设备上）；该表存储了系统中每个逻辑块的物理地址。</p>
<p>让我们举例说明基于日志的基本方法是如何工作的。对于客户端来说，设备看起来就像一个典型的磁盘，可以读写 512 字节的扇区（或扇区组）。为简单起见，假设客户端正在读取或写入 4KB 大小的块。让我们进一步假设SSD包含大量 16KB 大小的块，每个块分为 4 个 4KB 页面（但闪存块通常由更多页面组成）。</p>
<p>假设客户端发出以下操作序列：</p>
<ul>
<li>Write(100) with contents <code>a1</code></li>
<li>Write(101) with contents <code>a2</code></li>
<li>Write(2000) with contents <code>b1</code></li>
<li>Write(2001) with contents <code>b2</code></li>
</ul>
<p>SSD 客户端（如文件系统）使用这些<strong>逻辑块地址</strong>（如 100）来记忆信息的位置。</p>
<p>在内部，设备必须将这些块写入转化为原始硬件支持的擦除和编程操作，并以某种方式记录每个逻辑块地址在固态硬盘的哪个物理页面存储数据。假设固态硬盘的所有块目前都无效，因此必须先擦除这些块，然后才能对任何页面进行编程。这里显示的是固态硬盘的初始状态，所有页面都标记为<code>INVALID(i)</code>：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=small" data-sub-html="<h2>image-20240420225506248</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png" alt="image-20240420225506248" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=large 2x" data-title="image-20240420225506248" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当SSD收到第一个写入（逻辑块100）时，FTL决定将其写入物理块0，其中包含四个物理页：0、1、2和3。因为该块没有被擦除，所以我们还不能写入；设备必须首先向块 0 发出擦除命令。这样做会导致以下状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=small" data-sub-html="<h2>image-20240420225602726</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png" alt="image-20240420225602726" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=large 2x" data-title="image-20240420225602726" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在可以对 0 块进行编程了。大多数固态硬盘会按顺序（即从低到高）写入页面，从而减少与<strong>程序干扰</strong>有关的可靠性问题。然后，固态硬盘将逻辑块 100 写入物理页 0：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=small" data-sub-html="<h2>image-20240420225654860</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png" alt="image-20240420225654860" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=large 2x" data-title="image-20240420225654860" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>但如果客户要读取逻辑块 100 呢？如何找到它的位置？SSD必须将对逻辑块 100 的读取转换为对物理页 0 的读取。为了适应这种功能，当 FTL 将逻辑块 100 写入物理页 0 时，它会在<strong>内存映射表</strong>中记录这一事实。我们还将在图表中跟踪该映射表的状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=small" data-sub-html="<h2>image-20240420225849479</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png" alt="image-20240420225849479" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=large 2x" data-title="image-20240420225849479" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在您可以看到当客户端写入 SSD 时会发生什么。 SSD找到写入位置，通常只是选择下一个空闲页面；然后，它使用块的内容对该页进行编程，并将逻辑到物理的映射记录在其映射表中。后续读取只需使用该表将客户端提供的逻辑块地址<strong>转换</strong>为读取数据所需的物理页号。</p>
<p>现在让我们检查示例写入流中的其余写入：101、2000 和 2001。写入这些块后，设备的状态为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=small" data-sub-html="<h2>image-20240420230124321</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png" alt="image-20240420230124321" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=large 2x" data-title="image-20240420230124321" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>基于日志的方法从本质上提高了性能（只需偶尔擦除一次，完全避免了直接映射方法中代价高昂的读取-修改-写入），并大大提高了可靠性。FTL 现在可以在所有页面上分散写入，执行所谓的<strong>磨损均衡</strong>，延长设备的使用寿命；我们将在下文进一步讨论损耗均衡。</p>
<blockquote>
<center>FTL 映射信息持久性
</center>
<p>您可能想知道：如果设备断电会发生什么？内存映射表消失了吗？显然，此类信息不会真正丢失，否则该设备将无法充当持久存储设备。 SSD 必须具有某种恢复映射信息的方法。</p>
<p>最简单的做法是在每个页面上记录一些映射信息，即所谓的<strong>带外 (OOB) 区域</strong>。当设备断电并重新启动时，它必须通过扫描 OOB 区域并重建内存中的映射表。这种基本方法也有其问题；扫描大型 SSD 来查找所有必要的映射信息的速度很慢。为了克服这个限制，一些高端设备使用更复杂的日志记录和检查点技术来加速恢复。</p>
</blockquote>
<p>不幸的是，这种基本的日志结构方法有一些缺点。</p>
<ul>
<li>第一个是逻辑块的覆盖会导致我们称之为<strong>垃圾</strong>的东西，即驱动器周围的旧版本数据并占用空间。设备必须定期执行**垃圾回收（GC）**以找到所述块和可用空间以供将来写入；过多的垃圾回收会增加写入放大并降低性能。</li>
<li>二是内存映射表成本高；设备越大，此类表需要的内存就越多。我们现在依次讨论每一个。</li>
</ul>
<h4 id="垃圾回收" class="heading-element"><span>6.2.2 垃圾回收</span>
  <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>任何日志结构方法（例如此方法）的第一个成本是创建垃圾，因此必须执行垃圾回收（即死块回收）。让我们用之前例子来理解这一点。回想一下，逻辑块 100、101、2000 和 2001 已写入设备。</p>
<p>现在，我们假设再次写入块 100 和 101，内容为 <code>c1</code> 和 <code>c2</code>。写入操作将写入下一个空闲页（在本例中为物理页 4 和 5），并且映射表也会相应更新。请注意，设备必须首先擦除块 1 才能进行此类编程：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=small" data-sub-html="<h2>image-20240421130023025</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png" alt="image-20240421130023025" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=large 2x" data-title="image-20240421130023025" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们现在遇到的问题应该很明显：物理页 0 和 1 虽然标记为 <code>VALID</code>，但其中有垃圾，即旧版本的块 100 和 101。由于设备的日志结构特性，覆盖会产生垃圾块，设备必须回收这些垃圾块，以便为新的写入提供可用空间。</p>
<p>查找垃圾块（也称为死块）并将其回收以备将来使用的过程称为<strong>垃圾回收</strong>，它是所有现代固态硬盘的重要组成部分。基本过程很简单：找到包含一个或多个垃圾页的块，读入该块中的活（非垃圾）页，将这些活页写入日志，最后回收整个块用于写入。</p>
<p>下面我们举例说明。设备决定要回收上述 0 号块中的所有死页。块 0 有两个死块（第 0 页和第 1 页）和两个活块（第 2 页和第 3 页，分别包含块 2000 和 2001）。为此，设备将：</p>
<ul>
<li>从块 0 读取有效数据（第 2 页和第 3 页）</li>
<li>将有效数据写入日志末尾</li>
<li>擦除块 0（将其释放供以后使用）</li>
</ul>
<p>为了让垃圾回收程序发挥作用，每个块内必须有足够的信息，以便固态硬盘确定每个页面是有效还是无效。实现这一目的的一种自然方法是在每个块内的某个位置存储有关每个页面内存储了哪些逻辑块的信息。然后，设备就可以使用映射表来确定块中的每个页面是否保存有效数据。</p>
<p>在我们上面的示例中（垃圾回收之前），块 0 包含逻辑块 100、101、2000 和 2001。通过检查映射表（在垃圾收集之前，映射表包含 <code>100-&gt;4</code>、<code>101-&gt;5</code>、<code>2000-&gt;2</code>、<code>2001-&gt;3</code>），设备可以轻松确定固态硬盘块内的每个页面是否包含有效信息。例如，2000 和 2001 显然仍由映射指向；而 100 和 101 则不是，因此是垃圾回收的候选对象。在我们的示例中，当垃圾回收过程完成后，设备的状态为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=small" data-sub-html="<h2>image-20240421132028102</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png" alt="image-20240421132028102" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=large 2x" data-title="image-20240421132028102" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>可以看出，垃圾回收的成本很高，需要读取和重写有效数据。最理想的回收对象是只包含死页的块；在这种情况下，数据块可以立即被擦除并用于新数据，而无需进行昂贵的数据迁移。</p>
<p>为了降低 GC 成本，一些固态硬盘对设备进行了超额配置；通过增加额外的闪存容量，可以延迟清理并将其推至后台，或许可以在设备不太忙的时候进行。增加容量还能增加内部带宽，可用于清理，从而不影响客户端的感知带宽。许多现代硬盘都以这种方式进行超额配置，这是实现出色整体性能的关键之一。</p>
<blockquote>
<center>一种称为 TRIM 的新存储 API
</center>
<p>当我们想到硬盘驱动器时，我们通常只想到最基本的读写接口：读和写（通常还有某种<strong>缓存刷新</strong>命令，确保写入实际上已被持久化，但为了简单起见，有时我们会忽略这一点）。对于日志结构的 SSD，以及任何保持逻辑到物理块的灵活且不断变化的映射的设备，一个新的接口非常有用，称为<strong>修剪</strong>操作。</p>
<p>修剪操作采用一个地址（可能还有一个长度），并简单地通知设备该地址（和长度）指定的块已被删除；因此，设备不再需要跟踪有关给定地址范围的任何信息。<font color="red">对于标准硬盘驱动器，修剪并不是特别有用，因为驱动器具有块地址到特定盘片、磁道和扇区的静态映射。</font></p>
<p>然而，对于日志结构的 SSD，知道不再需要某个块非常有用，因为 SSD 可以从 FTL 中删除此信息，并在垃圾回收期间回收物理空间。</p>
<p>尽管我们有时将接口和实现视为独立的实体，但在这种情况下，我们看到实现塑造了接口。通过复杂的映射，了解不再需要哪些块可以更有效的实现。</p>
</blockquote>
<h4 id="映射表大小" class="heading-element"><span>6.2.3 映射表大小</span>
  <a href="#%e6%98%a0%e5%b0%84%e8%a1%a8%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>日志结构的第二个成本是可能会产生非常大的映射表，设备的每个 4 KB 页都有一个条目。例如，对于大型 1 TB SSD，每 4 KB 页一个 4 字节条目会导致设备需要 1 GB 内存，仅用于这些映射！因此，这种页级 FTL 方案是不切实际的。</p>
<h5 id="基于块的映射" class="heading-element"><span>6.2.3.1 基于块的映射</span>
  <a href="#%e5%9f%ba%e4%ba%8e%e5%9d%97%e7%9a%84%e6%98%a0%e5%b0%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>降低映射成本的一种方法是只为设备的每个块而不是每个页保留一个指针，从而将映射信息量减少 $\frac{Size_{block}}{ Size_{page}}$ 倍。<font color="red">这种<strong>块级 FTL</strong> 类似于在虚拟内存系统中具有更大的页面大小；在这种情况下，您可以为 VPN 使用更少的位，并在每个虚拟地址中使用更大的偏移量。</font></p>
<p>不幸的是，由于性能原因，在基于日志的 FTL 中使用基于块的映射效果不佳。当发生“小写入”（即小于物理块大小的写入）时，就会出现最大的问题。在这种情况下，FTL 必须从旧块中读取大量有效数据并将其复制到新块中（以及来自小写入的数据）。这种数据复制极大地增加了写放大，从而降低了性能。</p>
<p>为了更清楚地说明这个问题，我们来看一个例子。假设客户端之前写出了逻辑块 2000、2001、2002 和 2003（内容为 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>），并且它们位于物理块 1 内的物理页 4、5、6 和 7。对于每页映射，转换表必须记录这些逻辑块的四个映射：2000→4、2001→5、2002→6、2003→7。</p>
<p>相反，如果我们使用块级映射，FTL 只需要记录所有这些数据的单个地址转换。然而，地址映射与我们之前的示例略有不同。具体来说，我们认为设备的逻辑地址空间被分割成闪存中物理块大小的块。因此，<font color="red">逻辑块地址由两部分组成：块号和偏移量</font>。因为我们假设每个物理块中有四个逻辑块，所以逻辑地址的偏移部分需要 2 位；其余（最高有效）位形成块号。</p>
<p>逻辑块2000、2001、2002和2003都具有相同的块编号(500)，并且具有不同的偏移量(分别为0、1、2和3)。因此，通过块级映射，FTL 记录块 500 映射到块 1（从物理页 4 开始），如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=small" data-sub-html="<h2>image-20240421185518878</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png" alt="image-20240421185518878" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=large 2x" data-title="image-20240421185518878" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在基于块的 FTL 中，读取数据非常简单。首先，FTL 会从客户端提供的逻辑块地址中提取块号，方法是从地址的最高位取出。然后，FTL 在表中查找块号到物理页的映射。最后，FTL 将逻辑地址的偏移量与块的物理地址相加，计算出所需闪存页的地址。</p>
<p>例如，如果客户端发出对逻辑地址 2002 的读取，设备会提取逻辑块编号 (500)，在映射表中查找转换（查找 4），并将逻辑地址 (2) 的偏移量加到转换结果中 (4)，由此得到的物理页地址（6）就是数据所在的位置；然后，FTL 就可以向该物理地址发出读取指令，获取所需的数据（<code>c</code>）。</p>
<p>但如果客户向逻辑块 2002（内容为 <code>c'</code>）写入数据呢？在这种情况下，FTL 必须读入 2000、2001 和 2003，然后在新的位置写出所有四个逻辑块，并相应地更新映射表。如下图所示，逻辑块 1（数据原来所在的位置）可以被擦除并重新使用。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=small" data-sub-html="<h2>image-20240421190033073</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png" alt="image-20240421190033073" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=large 2x" data-title="image-20240421190033073" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从这个例子中可以看出，虽然块级映射大大减少了转换所需的内存量，但当写入的内容小于设备的物理块大小时，就会造成严重的性能问题；由于实际物理块可能是 256KB 或更大，这种写入可能会经常发生。因此，我们需要一个更好的解决方案。</p>
<h5 id="混合映射" class="heading-element"><span>6.2.3.2 混合映射</span>
  <a href="#%e6%b7%b7%e5%90%88%e6%98%a0%e5%b0%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>为了实现灵活的写入并降低映射成本，许多现代 FTL 采用混合映射技术。通过这种方法，FTL 会保留一些已擦除的块并将所有写入定向到它们；这些称为<strong>日志块</strong>。由于 FTL 希望能够将任何页写入日志块内的任何位置，而无需进行纯基于块的映射所需的所有复制，因此它会保留这些日志块的每页映射。</p>
<p>因此，FTL 在其内存中逻辑上有两种类型的映射表：我们称之为日志表的一小组每页映射，以及数据表中的一大组每块映射。当寻找特定的逻辑块时，FTL首先会查阅日志表；如果在那里找不到逻辑块的位置，FTL 将查阅数据表以找到其位置，然后访问所请求的数据。</p>
<p>混合映射策略的关键是保持较小的日志块数量。为了保持日志块的数量较少，FTL 必须定期检查日志块（每页都有一个指针）并将它们切换为只能由单个块指针指向的块。该切换是根据块的内容通过三种主要技术之一来完成的。</p>
<p>例如，假设 FTL 之前已写出逻辑页 1000、1001、1002 和 1003，并将它们放置在物理块 2 中（物理页 8、9、10、11）；假设写入1000、1001、1002和1003的内容分别为<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=small" data-sub-html="<h2>image-20240421192827944</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png" alt="image-20240421192827944" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=large 2x" data-title="image-20240421192827944" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设客户机以完全相同的顺序，在当前可用的日志块之一（例如物理块 0（物理页 0、1、2 和 3））中覆盖这些块（数据 <code>a'</code>、<code>b'</code>、<code>c'</code> 和 <code>d'</code>）。在这种情况下，FTL 将处于以下状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=small" data-sub-html="<h2>image-20240421192951355</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png" alt="image-20240421192951355" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=large 2x" data-title="image-20240421192951355" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>因为这些块的写入方式与以前完全相同，所以 FTL 可以执行所谓的切换合并。在这种情况下，日志块（0）现在成为块0、1、2和3的存储位置，并由单个块指针指向；旧块 (2) 现在已被擦除并用作日志块。在这种最佳情况下，所需的所有每页指针都被单个块指针替换。</p>
<p>这种切换合并是混合FTL的最佳情况。遗憾的是，有时 FTL 并不那么幸运。试想一下，我们有相同的初始条件（逻辑块 1000 &hellip; 1003 存储在物理块 2 中），但客户端覆盖了逻辑块 1000 和 1001。您认为在这种情况下会发生什么？为什么处理起来更具挑战性？</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=small" data-sub-html="<h2>image-20240421193357635</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png" alt="image-20240421193357635" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=large 2x" data-title="image-20240421193357635" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了重新组合该物理块的其他页面，从而能够仅通过单个块指针引用它们，FTL 执行所谓的<strong>部分合并</strong>。在此操作中，从物理块2读取逻辑块1002和1003，然后将其附加到日志中。 SSD的结果状态与上面的切换合并相同；然而，在这种情况下，FTL 必须执行额外的 I/O 才能实现其目标，从而增加了写放大。</p>
<p>FTL 遇到的最后一种情况称为<strong>完全合并</strong>，需要更多的工作。在这种情况下，FTL 必须将许多其他块中的页面汇集在一起以执行清理。例如，假设逻辑块 0、4、8 和 12 写入日志块 A。要将此日志块切换为块映射页，FTL 必须首先创建包含逻辑块 0、1、2 的数据块、 和 3，因此 FTL 必须从其他地方读取 1、2 和 3，然后一起写出 0、1、2 和 3。接下来，合并必须对逻辑块 4 执行相同的操作，找到 5、6 和 7 并将它们协调为单个物理块。必须对逻辑块 8 和 12 执行相同的操作，然后（最后）可以释放日志块 A。毫不奇怪，频繁的完全合并会严重损害性能，因此应尽可能避免。</p>
<h5 id="页面映射加缓存" class="heading-element"><span>6.2.3.3 页面映射加缓存</span>
  <a href="#%e9%a1%b5%e9%9d%a2%e6%98%a0%e5%b0%84%e5%8a%a0%e7%bc%93%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>鉴于上述混合方法的复杂性，其他人提出了更简单的方法来减少页面映射 FTL 的内存负载。最简单的方法可能是只在内存中缓存 FTL 的活动部分，从而减少所需的内存量。</p>
<p>这种方法效果不错。例如，如果给定的工作负载只访问一小部分页面，那么这些页面的转换就会存储在内存中的 FTL 中，这样性能就会非常出色，而不会产生高昂的内存成本。当然，这种方法也可能表现不佳。<font color="red">如果内存中无法包含必要的转换工作集，那么每次访问都需要额外读取闪存，以便在访问数据本身之前首先调入缺失的映射。</font>更糟糕的是，为了给新映射腾出空间，FTL 可能不得不剔除旧映射，如果该映射是脏映射（即尚未持续写入闪存），还将产生额外的写入。不过，在很多情况下，工作负载会显示出本地性，这种缓存方法既能减少内存开销，又能保持较高的性能。</p>
<h2 id="磨损均衡" class="heading-element"><span>7 磨损均衡</span>
  <a href="#%e7%a3%a8%e6%8d%9f%e5%9d%87%e8%a1%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后，现代 FTL 必须实现的一项相关背景活动是<strong>磨损均衡</strong>，如上所述。基本思想很简单：因为多个擦除/编程周期会磨损闪存块，所以 FTL 应尽力将工作均匀地分布到设备的所有块上。通过这种方式，所有块将大致在同一时间磨损，而不是一些“常用”块很快变得无法使用。</p>
<p>基本的日志结构方法在分散写入负载方面做得很好，垃圾回收也有帮助。然而，有时一个块会填充长期存在的数据，这些数据不会被覆盖；在这种情况下，垃圾回收永远不会回收该块，因此它不会收到其公平份额的写入负载。</p>
<p>为了解决这个问题，FTL 必须定期从这些块中读取所有有效数据，并将其重新写入其他地方，从而使该块可再次写入。这种磨损均衡过程会增加 SSD 的写入放大，从而降低性能，因为需要额外的 I/O 来确保所有块以大致相同的速率磨损。</p>
<h2 id="ssd性能与成本" class="heading-element"><span>8 SSD性能与成本</span>
  <a href="#ssd%e6%80%a7%e8%83%bd%e4%b8%8e%e6%88%90%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="性能" class="heading-element"><span>8.1 性能</span>
  <a href="#%e6%80%a7%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>与硬盘驱动器不同，基于闪存的 SSD 没有机械组件，实际上在很多方面与 DRAM 更相似，因为它们是“随机访问”设备。与磁盘驱动器相比，最大的性能差异是在执行随机读取和写入时实现的；虽然典型的磁盘驱动器每秒只能执行几百次随机 I/O，但 SSD 可以做得更好。在这里，我们使用现代 SSD 的一些数据来看看 SSD 的性能到底有多好；我们特别感兴趣的是 FTL 如何很好地隐藏原始芯片的性能问题。</p>
<p>下表显示了三种不同 SSD 和一种顶级硬盘的一些性能数据。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=small" data-sub-html="<h2>image-20240421194457078</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png" alt="image-20240421194457078" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=large 2x" data-title="image-20240421194457078" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>左边两列显示随机 I/O 性能，右边两列显示顺序I/O性能；前三行显示三种不同 SSD（来自Samsung、Seagate和Intel）的数据，最后一行显示硬盘驱动器（或 HDD）的性能，在本例中为Seagate高端驱动器。</p>
<p>我们可以从表中了解到一些有趣的事实。</p>
<ul>
<li>首先，也是最引人注目的，是 SSD 和独立硬盘之间随机 I/O 性能的差异。虽然 SSD 在随机 I/O 中获得数十甚至数百 MB/秒，但这种“高性能”硬盘的峰值仅为几 MB/秒（事实上，我们四舍五入为 2 MB/秒） 。</li>
<li>其次，您可以看到，就顺序I/O性能而言，差异要小得多；虽然 SSD 的性能更好，但如果您只需要顺序I/O性能，硬盘驱动器仍然是一个不错的选择。第三，可以看到SSD随机读性能不如SSD随机写性能。随机写入性能如此出人意料的好，得益于很多SSD的日志结构设计，将随机写入转化为顺序写入，提高了性能。</li>
<li>最后，由于 SSD 在顺序 I/O 和随机 I/O 之间表现出一些性能差异，因此如何为硬盘驱动器构建文件系统的许多技术仍然适用于 SSD；尽管顺序 I/O 和随机 I/O 之间的差异幅度较小，但仍有足够的差距需要仔细考虑如何设计文件系统以减少随机 I/O。</li>
</ul>
<h3 id="成本" class="heading-element"><span>8.2 成本</span>
  <a href="#%e6%88%90%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>正如我们在上面看到的，即使在执行顺序 I/O 时，SSD 的性能也大大超过了现代硬盘驱动器。那么，为什么 SSD 没有完全取代硬盘作为存储介质的选择呢？答案很简单：<strong>成本</strong>，或更具体地说，是<strong>每单位容量的成本</strong>。目前，250 GB 驱动器的 SSD 成本约为 150 美元；这样的 SSD 每 GB 成本为 60 美分。传统的硬盘驱动器存储 1 TB 的成本约为 50 美元，这意味着每 GB 成本为 5 美分。这两种存储介质的成本仍然存在10倍以上的差异。</p>
<p><font color="red">这些性能和成本差异决定了如何构建大规模存储系统。</font>如果性能是主要考虑因素，那么 SSD 是一个很好的选择，特别是在随机读取性能很重要的情况下。另一方面，如果您正在组装一个大型数据中心并希望存储大量信息，那么巨大的成本差异将促使您转向HDD。当然，混合方法是有意义的——一些存储系统同时配备了 SSD 和HDD，<font color="red">使用较少数量的 SSD 来存储更常用的“热”数据并提供高性能，同时存储其余的“冷”数据（较少使用）硬盘上的数据以节省成本。只要价格差距存在，硬盘就会一直存在。</font></p>
<h2 id="总结-1" class="heading-element"><span>9 总结</span>
  <a href="#%e6%80%bb%e7%bb%93-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><strong>闪存芯片</strong>由许多存储体组成，每个存储体都组织成<strong>擦除块</strong>（有时简称为块）。每个块进一步细分为一定数量的<strong>页面</strong>。</li>
<li>块很大（128KB–2MB）并包含许多页，而页相对较小（1KB–8KB）。</li>
<li>要从闪存读取，请发出<strong>带有地址和长度的读取命令</strong>；这允许客户读取一页或多页。</li>
<li>写入闪存更为复杂。首先，客户端必须擦除整个块（这会删除块内的所有信息）。然后，客户端可以对每个页面精确地<strong>编程</strong>一次，从而完成写入。</li>
<li>新的<strong>修剪</strong>操作可用于告诉设备何时不再需要特定块（或块范围）。</li>
<li>闪存可靠性主要由<strong>磨损</strong>决定；如果一个块被频繁地擦除和编程，它将变得不可用。</li>
<li>基于闪存的<strong>固态存储设备</strong>（SSD）的行为就像普通的基于块的读/写磁盘一样。通过使用<strong>闪存转换层</strong> (FTL)，它将客户端的读取和写入转换为对底层闪存芯片的读取、擦除和编程。</li>
<li>大多数FTL 都是<strong>日志结构</strong>的，这通过最小化擦除/编程周期来降低写入成本。内存中的转换层跟踪逻辑写入在物理介质中的位置。</li>
<li>日志结构FTL 的一个关键问题是垃圾回收的成本，这会导致写入放大。</li>
<li>另一个问题是映射表的大小，它可能会变得非常大。<font color="red">使用<strong>混合映射</strong>或仅缓存 FTL 的热门部分是可能的补救措施。</font></li>
<li>最后一个问题是<strong>磨损均衡</strong>。 FTL 必须偶尔从主要读取的块中迁移数据，以确保所述块也接收其擦除/编程负载份额。</li>
</ul>
]]></description></item><item><title>日志结构文件系统</title><link>https://hezephyr.github.io/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:33:51 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>20 世纪 90 年代初，伯克利分校的一个由 John Ousterhout 教授和研究生 Mendel Rosenblum 领导的小组开发了一种新的文件系统，称为<font color="red">日志结构文件系统</font>。他们这样做的动机基于以下观察：</p>
<ul>
<li><strong>系统内存不断增长</strong>：随着内存变大，内存中可以缓存更多数据。随着越来越多的数据被缓存，磁盘流量越来越多地由写入组成，因为读取由缓存提供服务。因此，文件系统的性能很大程度上取决于其写入性能。</li>
<li><strong>随机I/O 性能和顺序I/O 性能之间存在很大差距</strong>：多年来硬盘传输带宽大幅增加；随着更多的位被封装到驱动器的表面，访问所述位时的带宽增加。然而，寻道和旋转延迟成本却缓慢下降；让廉价的小型电机更快地旋转盘片或更快地移动磁盘臂是一项挑战。因此，如果您能够以顺序方式使用磁盘，那么与导致寻道和旋转的方法相比，您将获得相当大的性能优势。</li>
<li><strong>现有文件系统在许多常见工作负载上表现不佳</strong>：例如，FFS将执行大量写入来创建一个大小为一个块的新文件：一个用于新的inode，一个用于更新inode位图，一个用于包含该文件的目录数据块，一个用于更新目录inode，一个用于作为新文件一部分的新数据块，并且还需要对数据位图进行一次写入以标记数据块已被分配。因此，尽管 FFS 将所有这些块放置在同一块组内，但 FFS 需要进行许多短寻道和随后的旋转延迟，因此性能远低于峰值顺序带宽。</li>
<li><strong>文件系统不支持RAID</strong>：例如，RAID-4 和RAID-5 都存在<strong>小写入问题</strong>，即对单个块的逻辑写入会导致发生4 个物理I/O。现有文件系统不会尝试避免这种最坏情况的 RAID 写入行为。</li>
</ul>
<p>因此，理想的文件系统将关注写入性能，并尝试利用磁盘的顺序带宽。此外，它在常见工作负载上表现良好，这些工作负载不仅写出数据，而且还经常更新磁盘上的元数据结构。最后，它在 RAID 和单个磁盘上都能很好地工作。 Rosenblum 和 Ousterhout 推出的新型文件系统称为 <strong>LFS</strong>，是<strong>日志结构文件系统</strong>的缩写。当写入磁盘时，LFS 首先将所有更新（包括元数据！）缓冲在内存段中；当该段已满时，它会通过一次长的、顺序的传输写入未使用的磁盘部分。 LFS 永远不会覆盖现有数据，而是始终将段写入空闲位置。由于段很大，因此磁盘（或 RAID）可以得到有效利用，文件系统的性能也接近顶峰。</p>
<blockquote>
<center>关键：如何使所有写入顺序写入？
</center>
<p>文件系统如何将所有写入转换为顺序写入？对于读取，此任务是不可能的，因为要读取的所需块可能位于磁盘上的任何位置。然而，对于写入，文件系统总是有一个选择，而我们希望利用的正是这个选择。</p>
</blockquote>
<h2 id="按顺序写入磁盘" class="heading-element"><span>2 按顺序写入磁盘</span>
  <a href="#%e6%8c%89%e9%a1%ba%e5%ba%8f%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>因此，我们面临的第一个挑战是：<font color="red">如何将文件系统状态的所有更新转化为一系列对磁盘的顺序写入？</font>为了更好地理解这一点，让我们举一个简单的例子。假设我们正在向文件写入一个数据块 D。将数据块写入磁盘可能会导致以下磁盘布局，D 被写入磁盘地址 A0：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=small" data-sub-html="<h2>image-20240420101924372</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png" alt="image-20240420101924372" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=large 2x" data-title="image-20240420101924372" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>然而，当用户写入数据块时，写入磁盘的不仅是数据，还有其他需要更新的元数据。在这种情况下，我们也把文件的 inode (I) 写入磁盘，并让它指向数据块 D。写入磁盘后，数据块和 inode 的如下图所示（<strong>注意</strong>，inode 看起来和数据块一样大，但一般情况下并非如此；在大多数系统中，数据块的大小为 4 KB，而 inode 则小得多，约为 128 字节）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=small" data-sub-html="<h2>image-20240420102116005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png" alt="image-20240420102116005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=large 2x" data-title="image-20240420102116005" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这种简单地将所有更新（如数据块、inodes 等）按顺序写入磁盘的基本思想是 LFS 的核心。理解了这一点，你就掌握了基本思想。但正如所有复杂的系统一样，细节决定成败。</p>
<h2 id="顺序有效地写入" class="heading-element"><span>3 顺序有效地写入</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e6%9c%89%e6%95%88%e5%9c%b0%e5%86%99%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>不幸的是，顺序写入磁盘（单独）不足以保证高效写入。例如，想象一下，如果我们在时间 $T$ 向地址 $A$ 写入一个块。然后我们等待一会儿，并在时间 $T + \delta$ 的地址 $A + 1$（按顺序排列的下一个块地址）写入磁盘。不幸的是，在第一次和第二次写入之间，磁盘发生了旋转；当您发出第二次写入时，它将在提交之前等待大部分旋转（具体来说，如果旋转需要时间 $T_{rotation}$，则磁盘将等待 $T_{rotation}-\delta$，然后才能将第二次写入提交到磁盘表面）。因此，您可以看到，仅仅按顺序写入磁盘不足以实现峰值性能；相反，您必须向驱动器<font color="red">发出大量连续写入（或一次大型写入）才能获得良好的写入性能</font>。</p>
<p>为了实现这一目标，LFS 使用一种称为<strong>写入缓冲</strong>的古老技术。在写入磁盘之前，LFS 会跟踪内存中的更新；当它收到足够数量的更新时，它会立即将它们全部写入磁盘，从而确保磁盘的有效使用。</p>
<p>LFS 一次写入的大块更新被称为一个段。尽管这个术语在计算机系统中被滥用，但在这里它只是指 LFS 用来分组写入的一个相对较大的块。因此，当写入磁盘时，LFS 将更新缓冲在内存中的段中，然后将该段全部写入磁盘。只要段足够大，这些写入就会高效。</p>
<p>下面是一个示例，其中 LFS 将两组更新缓冲到一个小段中；实际的段更大（几MB）。第一个更新是对文件 <code>j</code> 的四个块写入；第二个是向文件 <code>k</code> 添加一个块。然后，LFS 将七个块的整个段一次性提交到磁盘。这些块的最终磁盘布局如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=small" data-sub-html="<h2>image-20240420103434967</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png" alt="image-20240420103434967" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=large 2x" data-title="image-20240420103434967" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="缓冲多大" class="heading-element"><span>4 缓冲多大</span>
  <a href="#%e7%bc%93%e5%86%b2%e5%a4%9a%e5%a4%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>这就提出了以下问题：在写入磁盘之前，LFS 应该缓冲多少个更新？当然，答案取决于磁盘本身，特别是定位开销与传输速率相比有多高。</p>
<p>例如，假设每次写入之前的定位（即旋转和寻道开销）大约需要 $T_{position}$秒。进一步假设磁盘传输速率为$R_{peak}\text{ MB/s}$。在这样的磁盘上运行时，LFS 在写入之前应该缓冲多少？</p>
<p>思考这个问题的方法是，每次写入时，您都会付出固定的定位成本开销。因此，您需要写多少才能摊销该成本？你写的越多越好（显然），并且你越接近达到峰值带宽。</p>
<p>为了获得具体的答案，我们假设我们正在写 $D\text{ MB}$。写这块数据的时间（$T_{write}$）是定位时间$T_{position}$加上传输时间$\frac{D}{R_{peak}}$，或者：
$$
T_{write}=T_{position}+\frac{D}{R_{peak}}
$$
因此，有效写入率（$R_{effective}$）就是写入的数据量除以写入的总时间：
$$
R_{effective}=\frac{D}{T_{write}}=\frac{D}{T_{position}+\frac{D}{R_{peak}}}
$$
我们感兴趣的是让有效率 ($R_{effective}$) 接近峰值率。具体来说，我们希望有效速率是峰值速率的某个分数 $F$，其中 $0 &lt; F &lt; 1$（典型的 F 可能是 $0.9$，或峰值速率的 $90%$）。在数学形式上，这意味着我们需要$R_{effective}=F\times R_{peak}$ 。</p>
<p>至此，我们可以求解$D$：
$$
R_{effective}=\frac{D}{T_{write}}=\frac{D}{T_{position}+\frac{D}{R_{peak}}}
$$</p>
<p>$$
D=F\times R_{peak}\times(T_{position}+\frac{D}{R_{peak}})
$$</p>
<p>$$
D=(F\times R_{peak}\times T_{position})+(F\times R_{peak}\times \frac{D}{R_{peak}})
$$</p>
<p>$$
D=\frac{F}{1-F}\times R_{peak}\times T_{position}
$$</p>
<p>举个例子，磁盘的定位时间为$10\text{ ms}$，峰值传输率为$100\text{ MB/s}$；假设我们想要峰值的 $90%$ 的有效带宽 ($F = 0.9$)。在本例中，$D = \frac{0.9}{0.1}\times 100\text{ MB/s} \times 0.01 \text{ s} = 9\text{ MB}$。尝试一些不同的值，看看我们需要缓冲多少才能接近峰值带宽。需要多少才能达到峰值的 $95%$？ $99%$？</p>
<h2 id="问题查找-inode" class="heading-element"><span>5 问题：查找 Inode</span>
  <a href="#%e9%97%ae%e9%a2%98%e6%9f%a5%e6%89%be-inode" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了了解如何在 LFS 中查找 inode，让我们简要回顾一下如何在典型的 UNIX 文件系统中查找 inode。在典型的文件系统（例如 FFS）甚至旧的 UNIX 文件系统中，查找 inode 很容易，因为它们被组织在数组中并放置在磁盘上的固定位置。</p>
<p>例如，旧的 UNIX 文件系统将所有inode保存在磁盘的固定部分。因此，给定 inode number和起始地址，要查找特定 inode，只需将 inode number乘以 inode 的大小，然后将其添加到磁盘阵列的起始地址，即可计算出其准确的磁盘地址。 基于数组的索引（给定 inode number）既快速又简单。</p>
<p>在 FFS 中查找给定 inode number的 inode 只是稍微复杂一些，因为 FFS 将 inode 表分割成块，并将一组 inode 放置在每个柱面组中。因此，我们必须知道每个inode块有多大以及每个inode的起始地址。之后的计算类似，也很容易。</p>
<p>在LFS，生活更加困难。为什么？好吧，我们已经成功地将inode分散在整个磁盘上！更糟糕的是，我们永远不会就地覆盖，因此最新版本的索引节点（即我们想要的）不断移动。</p>
<h2 id="通过间接解决方案inode-map" class="heading-element"><span>6 通过间接解决方案：Inode Map</span>
  <a href="#%e9%80%9a%e8%bf%87%e9%97%b4%e6%8e%a5%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88inode-map" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了解决这个问题，LFS 的设计者通过一个名为 inode map（imap）的数据结构，在 inode number和 inode 之间引入了一层间接关系。imap 是一种将 inode number作为输入并生成该 inode 最新版本磁盘地址的结构。因此，可以想象它通常是作为一个简单的数组来实现的，每个条目有 4 个字节（磁盘指针）。当 inode 被写入磁盘时，imap 就会根据新的位置进行更新。</p>
<p>不幸的是，imap 需要保持持久性（即写入磁盘），这样做可以让 LFS 在崩溃时跟踪 inode 的位置，从而按预期运行。因此，有一个问题：imap 应该放在磁盘的哪个位置？</p>
<p>当然，它可以位于磁盘的固定位置。遗憾的是，由于它经常更新，这就需要在更新文件结构后再写入 imap，因此性能会受到影响（也就是说，<font color="red">在每次更新和 imap 的固定位置之间会有更多的磁盘寻道</font>）。</p>
<p>相反，LFS 会在写入所有其他新信息的位置旁边放置 inode 映射块。因此，在向文件 <code>k</code> 添加数据块时，LFS 实际上是将新数据块、其 inode 和 inode 映射的一部分一起写入磁盘，如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=small" data-sub-html="<h2>image-20240420111904512</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png" alt="image-20240420111904512" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=large 2x" data-title="image-20240420111904512" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在这张图中，<font color="red">存储在标记为 imap 的块中的 imap 数组的一块告诉 LFS inode k 位于磁盘地址 A1；这个 inode 又告诉 LFS 它的数据块 D 位于地址 A0</font>。</p>
<h2 id="完成解决方案检查点区域" class="heading-element"><span>7 完成解决方案：检查点区域</span>
  <a href="#%e5%ae%8c%e6%88%90%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%a3%80%e6%9f%a5%e7%82%b9%e5%8c%ba%e5%9f%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="如何找到inode-map" class="heading-element"><span>7.1 如何找到inode map</span>
  <a href="#%e5%a6%82%e4%bd%95%e6%89%be%e5%88%b0inode-map" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>你可能已经注意到这里的问题了。既然inode map的各个部分也分布在磁盘上，我们如何找到inode map呢？归根结底，没有什么神奇的：文件系统必须在磁盘上有一些固定且已知的位置才能开始文件查找。</p>
<p>LFS 在磁盘上为此提供了一个固定位置，称为<font color="red">检查点区域 (CR)</font>。检查点区域包含指向最新的 inode map片段的指针（即地址），因此可以通过首先读取 CR 来找到 inode map片段。请注意，检查点区域仅定期更新（例如每 30 秒左右），因此性能不会受到不良影响。因此，磁盘布局的整体结构包含一个检查点区域（指向 inode map的最新部分）；每个 inode 映射片段都包含 inode 的地址； inode 指向文件（和目录），就像典型的 UNIX 文件系统一样。</p>
<p>下面是检查点区域（注意它位于磁盘的起始位置，地址为 0）以及单个 imap 块、inode 和数据块的示例。一个真正的文件系统当然会有一个大得多的 CR（事实上，它会有两个，我们稍后会了解到）、许多 imap 块，当然还有更多的 inode、数据块等。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=small" data-sub-html="<h2>image-20240420132426842</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png" alt="image-20240420132426842" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=large 2x" data-title="image-20240420132426842" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="从磁盘读取文件" class="heading-element"><span>7.2 从磁盘读取文件</span>
  <a href="#%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了确保你理解 LFS 的工作原理，现在让我们来了解一下从磁盘读取文件的过程。假设内存中什么都没有。我们必须读取的第一个磁盘数据结构是检查点区域。检查点区域包含指向整个 inode map的指针（即磁盘地址），因此 LFS 会读入整个 inode map并缓存在内存中。在此之后，当得到文件的 inode number时，LFS 只需在 imap 中查找 inode number到 inode磁盘地址的映射，然后读入最新版本的 inode。</p>
<p>此时，LFS 会根据需要使用直接指针、间接指针或双向间接指针，完全按照典型 UNIX 文件系统的方式读取文件块。在普通情况下，<strong>LFS 从磁盘读取文件时执行的 I/O 次数应与典型文件系统相同</strong>；整个 imap 已被缓存，因此 LFS 在读取过程中所做的额外工作就是在 imap 中查找 inode 的地址。</p>
<h3 id="关于目录" class="heading-element"><span>7.3 关于目录</span>
  <a href="#%e5%85%b3%e4%ba%8e%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>到目前为止，我们已经通过仅考虑inode和数据块来简化了我们的讨论。但是，要访问文件系统中的文件（例如 <code>/home/zfhe/foo</code>），还必须访问某些目录。那么LFS是如何存储目录数据的呢？</p>
<p>幸运的是，目录结构与经典 UNIX 文件系统基本相同，因为目录只是（名称、inode number）映射的集合。例如，当在磁盘上创建文件时，LFS 必须写入新的 inode、一些数据以及引用该文件的目录数据及其 inode。请记住，LFS 将在磁盘上按顺序执行此操作（在缓冲更新一段时间后）。因此，在目录中创建文件<code>foo</code> 将导致磁盘上出现以下新结构：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=small" data-sub-html="<h2>image-20240420133133412</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png" alt="image-20240420133133412" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=large 2x" data-title="image-20240420133133412" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>inode map的片段包含目录文件 <code>dir</code> 以及新创建的文件 <code>f</code> 的位置信息。因此，当访问文件 <code>foo</code> （inode number为 $k$）时，您首先会在inode map（通常缓存在内存中）中查找目录 <code>dir</code> ($A3$) 的inode的位置；然后读取目录 inode，它给出目录数据的位置 ($A2$)；读取此数据块即可获得 <code>(foo, k)</code> 的名称到 inode number的映射。然后再次查阅inode map，找到inode number k（$A1$）的位置，最后在地址$A0$处读取所需的数据块。</p>
<p>LFS 中 inode 映射还解决了另一个严重问题，称为<font color="red">递归更新问题</font>。任何从不就地更新（例如 LFS），而是将更新移动到磁盘上的新位置的文件系统都会出现此问题。</p>
<p>具体来说，每当更新inode时，它在磁盘上的位置就会发生变化。如果我们不小心的话，这也会导致指向该文件的目录的更新，然后会强制要求更改该目录的父目录，依此类推，一直沿着文件系统树向上更新。</p>
<p>LFS通过inode map巧妙地避免了这个问题。尽管inode的位置可能会发生变化，但这种变化永远不会反映在目录本身中；相反，当目录保存相同的名称到inode number映射时，imap 结构会被更新。因此，通过间接，LFS 避免了递归更新问题。</p>
<h2 id="新问题垃圾回收" class="heading-element"><span>8 新问题：垃圾回收</span>
  <a href="#%e6%96%b0%e9%97%ae%e9%a2%98%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>8.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>您可能已经注意到 LFS 的另一个问题；它将文件的最新版本（包括其inode和数据）重复写入磁盘上的新位置。此过程在保持写入效率的同时，意味着 LFS 会将旧版本的文件结构分散在整个磁盘上。我们称这些旧版本为垃圾。例如，假设我们有一个由inode number $k$ 引用的现有文件，它指向单个数据块 $D0$。我们现在更新该块，生成新的inode和新的数据块。 LFS 的最终磁盘布局看起来像这样（注意，为了简单起见，我们省略了 imap 和其他结构；新的 imap 块也必须写入磁盘以指向新的 inode）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=small" data-sub-html="<h2>image-20240420150442686</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png" alt="image-20240420150442686" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=large 2x" data-title="image-20240420150442686" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，您可以看到磁盘上的inode和数据块都有两个版本，一个是旧版本（左侧），另一个是当前的、即时的版本（右侧）。通过（逻辑上）更新数据块这一简单行为，LFS 必须持久化大量新结构，从而在磁盘上留下旧版本的数据块。</p>
<p>举个例子，想象我们将一个块附加到原始文件 <code>k</code> 上。在这种情况下，会生成新版本的 inode，但旧数据块仍由 inode 指向。因此它仍然是有效的，并且完全属于当前文件系统：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=small" data-sub-html="<h2>image-20240420150821548</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png" alt="image-20240420150821548" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=large 2x" data-title="image-20240420150821548" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>那么我们应该如何处理这些旧版本的inode、数据块等呢？可以保留这些旧版本并允许用户恢复旧文件版本（例如，当他们不小心覆盖或删除文件时，这样做可能非常方便）；这种文件系统称为<strong>版本控制文件系统</strong>，因为它跟踪文件的不同版本。</p>
<p>然而，LFS 仅保留文件的最新实时版本；因此（在后台），LFS 必须定期查找文件数据、inode和其他结构的这些旧的无效版本，并清理它们；因此，清理应该使磁盘上的块再次空闲以供后续写入使用。请注意，清理过程是垃圾回收的一种形式，这是编程语言中出现的一种技术，可以自动释放程序未使用的内存。</p>
<p>前面我们讨论了段的重要性，因为它们是在 LFS 中实现对磁盘进行大量写入的机制。事实证明，它们对于有效清理也是不可或缺的。想象一下，如果 LFS 清理器在清理过程中简单地遍历并释放单个数据块、inode等，会发生什么。结果：文件系统在磁盘上分配的空间之间混合了一定数量的空闲孔。写入性能将大幅下降，因为 LFS 无法找到大的连续区域来顺序且高性能地写入磁盘。</p>
<p>相反，LFS 清理器逐段工作，从而为后续写入清理大块空间。基本清理过程如下。 LFS 清理器定期读取一些旧的（部分使用的）段，确定这些段中哪些块是有效的，然后写出一组新的段，其中仅包含有效的块，从而释放旧的段以供写入。具体来说，我们期望清理程序读取 $M$ 个现有段，将其内容压缩为 $N$ 个新段（其中 $N &lt; M$ ），然后将 $N$ 个段写入磁盘的新位置。然后，旧的 $M$ 段将被释放，可供文件系统用于后续写入。</p>
<p>然而，我们现在面临两个问题。</p>
<ul>
<li>第一个是<strong>机制</strong>：LFS 如何判断段内哪些块是有效块，哪些块是无效块？</li>
<li>第二个是<strong>策略</strong>：清理程序应该多久运行一次，以及应该选择清理哪些部分？</li>
</ul>
<h3 id="确定块有效性" class="heading-element"><span>8.2 确定块有效性</span>
  <a href="#%e7%a1%ae%e5%ae%9a%e5%9d%97%e6%9c%89%e6%95%88%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们首先解决机制问题。给定磁盘段 $S$ 内的数据块 $D$，LFS 必须能够确定 $D$ 是否处于有效状态。为此，LFS 向描述每个块的每个段添加了一些额外信息。具体来说，LFS包括每个数据块$D$包括它的inode number（它属于哪个文件）和它的偏移量（它是文件的哪个块）。该信息记录在段头部的结构中，称为<font color="red">段摘要块</font>。</p>
<p>有了这些信息，就可以很容易地确定一个块是有效的还是无效的。对于位于磁盘上地址 $A$ 的块 $D$，查看段摘要块并找到其inode number $N$ 和偏移量 $T$ 。接下来，在 imap 中查找 $N$ 所在的位置并从磁盘读取 $N$（也许它已经在内存中，这样更好）。最后，使用偏移量 $T$ ，查看 inode（或某个间接块）以查看 inode 认为该文件的第 $T$ 个块位于磁盘上的位置。如果它准确地指向磁盘地址A，LFS可以断定块D是有效的。如果它指向其他地方，LFS 可以断定 D 没有在使用中（即它已失效），从而知道不再需要该版本。这是伪代码摘要：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">=</span> <span class="n">SegmentSummary</span><span class="p">[</span><span class="n">A</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">inode</span> <span class="o">=</span> <span class="nf">Read</span><span class="p">(</span><span class="n">imap</span><span class="p">[</span><span class="n">N</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// block D is alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="c1">// block D is garbage
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>下面是描述该机制的图，其中段摘要块（标记为 $SS$）记录了地址 $A0$ 处的数据块实际上是文件 <code>k</code> 偏移量 0 处的一部分。通过检查 <code>k</code> 的 imap，可以找到 inode，并看到它确实指向该位置。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=small" data-sub-html="<h2>image-20240420153237660</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png" alt="image-20240420153237660" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=large 2x" data-title="image-20240420153237660" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>LFS 会采取一些快捷方式来提高确定有效性过程的效率。例如，当文件被截断或删除时，LFS 会增加其版本号，并在 imap 中记录新的版本号。通过在磁盘段中记录版本号，LFS 只需将磁盘上的版本号与 imap 中的版本号进行比较，就能缩短上述较长时间的检查，从而避免额外的读取。</p>
<h3 id="策略问题清理哪些块以及何时清理" class="heading-element"><span>8.3 策略问题：清理哪些块以及何时清理</span>
  <a href="#%e7%ad%96%e7%95%a5%e9%97%ae%e9%a2%98%e6%b8%85%e7%90%86%e5%93%aa%e4%ba%9b%e5%9d%97%e4%bb%a5%e5%8f%8a%e4%bd%95%e6%97%b6%e6%b8%85%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除上述机制外，LFS 还必须包含一套策略，<font color="red">以确定何时清理以及哪些块值得清理；确定何时清理比较简单：定期、空闲时或磁盘已满而不得不清理时。</font></p>
<p>而确定清理哪些块则更具挑战性，这也是许多研究论文的主题。在最初的 <a href="https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf"target="_blank" rel="external nofollow noopener noreferrer">LFS 论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>中，作者描述了一种试图分离热段和冷段的方法。热段是指内容经常被覆盖的段，因此，对于这样的段，最好的策略是等待很长时间再进行清理，因为越来越多的数据块被覆盖（在新的段中），从而被释放出来以供使用。</p>
<p>相比之下，冷段可能会有一些无效块，但其余内容相对稳定。因此，作者得出结论，应该尽早清理冷段，晚些清理热段，并开发了一种启发式方法来实现这一目标。然而，与大多数策略一样，这种策略并不完美；<a href="https://dl.acm.org/doi/10.1145/268998.266700"target="_blank" rel="external nofollow noopener noreferrer">后来的方法<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>展示了如何做得更好。</p>
<h2 id="崩溃恢复和日志" class="heading-element"><span>9 崩溃恢复和日志</span>
  <a href="#%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d%e5%92%8c%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后一个问题：如果 LFS 写入磁盘时系统崩溃，会发生什么？更新期间的崩溃对于文件系统来说是很棘手的，因此 LFS 也必须考虑这一点。</p>
<p><font color="red">在正常操作期间，LFS 缓冲段中的写入，然后（当段已满或经过一定时间时）将该段写入磁盘。 LFS 将这些写入组织在日志中，即检查点区域指向头段和尾段，每个段都指向下一个要写入的段。</font> LFS 还定期更新检查点区域。在这些操作（写入段、写入 CR）期间显然可能会发生崩溃。那么 LFS 如何处理写入这些结构期间的崩溃呢？</p>
<p>我们先来说第二种情况。为了确保 CR 更新以原子方式发生，LFS 实际上<strong>保留了两个 CR</strong>，分别位于磁盘的两端，并交替写入。 LFS 在使用指向 inode map的最新指针和其他信息更新 CR 时还实现了谨慎的协议；具体来说，它首先写出一个标头（带有时间戳），然后写出 CR 的主题，最后写出最后一个块（也带有时间戳）。如果系统在 CR 更新期间崩溃，LFS 可以通过查看一对不一致的时间戳来检测到这一情况。 LFS总是会选择使用最新的具有一致时间戳的CR，从而实现CR的一致更新。</p>
<p>现在我们来解决第一种情况。由于 LFS 大约每 30 秒写入一次 CR，因此文件系统的最后一个一致快照可能相当旧。因此，重新启动后，LFS 可以通过简单地读取检查点区域、它指向的 imap 片段以及后续文件和目录来轻松恢复；但是，最后几秒的更新将会丢失。</p>
<p>为了改进这一点，LFS 尝试通过数据库社区中称为<strong>前滚</strong>的技术来重建许多这些段。基本思想是从最后一个检查点区域开始，找到日志的末尾（包含在 CR 中），然后使用它来读取接下来的段并查看其中是否有任何有效的更新。如果有，LFS 会相应地更新文件系统，从而恢复自上一个检查点以来写入的大部分数据和元数据。</p>
]]></description></item><item><title>FSCK和日志</title><link>https://hezephyr.github.io/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/</link><pubDate>Sat, 11 May 2024 21:32:57 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/</guid><description><![CDATA[<h2 id="崩溃一致性" class="heading-element"><span>1 崩溃一致性</span>
  <a href="#%e5%b4%a9%e6%ba%83%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如我们到目前为止所看到的，文件系统管理一组数据结构来实现预期的抽象：文件、目录以及支持我们期望从文件系统获得的基本抽象所需的所有其他元数据。与大多数数据结构（例如，在正在运行的程序的内存中找到的数据结构）不同，文件系统数据结构必须持久存在，即它们必须长期存在，存储在即使断电也能保留数据的设备上（例如硬盘或基于闪存的 SSD）。</p>
<p>文件系统面临的一项主要挑战是如何在断电或系统崩溃的情况下更新持久数据结构。具体来说，如果在更新磁盘结构的过程中，有人被电源线绊倒并且机器断电，会发生什么情况？或者操作系统遇到bug而崩溃？由于断电和崩溃，更新持久数据结构可能非常棘手，并导致文件系统实现中出现一个新的有趣问题，称为<font color="red">崩溃一致性问题</font>。</p>
<p>这个问题很容易理解。想象一下，您必须更新两个磁盘上的结构 A 和 B，才能完成特定操作。由于磁盘一次仅服务一个请求，因此这些请求之一将首先到达磁盘（A 或 B）。如果系统在一次写入完成后崩溃或断电，磁盘上的结构将处于不一致的状态。因此，我们有一个所有文件系统都需要解决的关键问题：</p>
<blockquote>
<p>如何在崩溃的情况下更新磁盘？系统可能会崩溃或在任意两次写入之间断电，因此磁盘上的状态可能只会部分更新。崩溃后，系统启动并希望再次挂载文件系统（以便访问文件等）。鉴于崩溃可能在任意时间点发生，我们如何确保文件系统将磁盘映像保持在合理的状态？</p>
</blockquote>
<p>在本章中，我们将更详细地描述这个问题，并了解文件系统用来克服它的一些方法。我们将首先检查旧文件系统所采用的方法，称为 <strong>fsck</strong> 或<strong>文件系统检查器</strong>。然后，我们将注意力转向另一种方法，称为<strong>日志记录（也称为预写日志记录）</strong>，这种技术会为每次写入增加一点开销，但可以更快地从崩溃或断电中恢复。我们将讨论日志记录的基本机制，包括 Linux ext3（一种相对现代的日志文件系统）实现的几种不同风格的日志记录。</p>
<h2 id="详细示例" class="heading-element"><span>2 详细示例</span>
  <a href="#%e8%af%a6%e7%bb%86%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>2.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了开始我们对日志的研究，让我们来看一个例子。我们需要使用以某种方式更新磁盘结构的<strong>工作负载</strong>。假设工作负载很简单：向现有文件追加一个数据块。追加的方法是打开文件，调用 <code>lseek()</code> 将文件偏移量移动到文件末尾，然后在关闭文件之前向文件写入一个 4KB 的数据块。</p>
<p>我们还假设磁盘上使用的是标准的简单文件系统结构，类似于我们以前见过的文件系统。这个小例子包括一个 <strong>inode 位图</strong>（只有 8 位，每个 inode 一个）、一个<strong>数据位图</strong>（也是 8 位，每个数据块一个）、inodes（共 8 个，编号 0 至 7，分布在 4 个块中）和数据块（共 8 个，编号 0 至 7）。下面是该文件系统的示意图：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=small" data-sub-html="<h2>image-20240419123958722</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png" alt="image-20240419123958722" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=large 2x" data-title="image-20240419123958722" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>观察图片中的结构，可以看到一个已分配的 inode（inode number 2）和一个已分配的数据块（数据块 4），前者已在 inode 位图中标记，后者也在数据位图中标记。该 inode 被标记为 I[v1]，因为它是该 inode 的第一个版本；它将很快被更新（由于上述工作负载）。让我们也来看看这个简化的 inode 内部。在 I[v1] 中，我们可以看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">owner 		: remzi
</span></span><span class="line"><span class="cl">permissions : read-write
</span></span><span class="line"><span class="cl">size 		: 1
</span></span><span class="line"><span class="cl">pointer 	: 4
</span></span><span class="line"><span class="cl">pointer 	: null
</span></span><span class="line"><span class="cl">pointer 	: null
</span></span><span class="line"><span class="cl">pointer 	: null</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个简化的 inode 中，文件的<code>size</code>为 1（分配了一个块），第一个直接指针指向块 4（文件的第一个数据块 Da），所有其他三个直接指针都设置为 <code>null</code> （表明它们没有被使用）。当然，真正的inode还有更多的字段。</p>
<p>当我们追加到文件时，我们向其中添加一个新的数据块，因此必须更新三个磁盘结构：inode（必须指向新块并记录由于追加而产生的新的较大大小）、新的数据块Db，以及新版本的数据位图（称为B[v2]）来指示新的数据块已经被分配。</p>
<p>因此，在系统内存中，我们必须将三个块写入磁盘。更新后的索引节点（inode版本 2，简称 I[v2]）现在如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=small" data-sub-html="<h2>image-20240419124623098</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png" alt="image-20240419124623098" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=large 2x" data-title="image-20240419124623098" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为实现这一转换，文件系统必须向磁盘执行三次单独的写入操作，分别写入 inode (I[v2])、bitmap (B[v2]) 和数据块 (Db)。请注意，这些写入通常不会在用户发出 <code>write()</code> 系统调用时立即发生；相反，<font color="red">脏的 inode、位图和新数据会先在主内存（页面缓存或缓冲区缓存）中停留一段时间；然后，当文件系统最终决定将它们写入磁盘时（比如 5 秒或 30 秒后），文件系统会向磁盘发出必要的写入请求。</font></p>
<p>不幸的是，崩溃可能会发生，从而干扰对磁盘的更新。特别是，如果在写入其中一个或两个而不是全部三个之后发生崩溃，文件系统可能会处于一种奇怪的状态。</p>
<h3 id="崩溃场景" class="heading-element"><span>2.2 崩溃场景</span>
  <a href="#%e5%b4%a9%e6%ba%83%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了更好地理解这个问题，让我们看一些崩溃场景的例子。想象一下只有一次写入成功；因此存在三种可能的结果，我们在此列出：</p>
<ul>
<li>
<p><strong>仅将数据块 (Db) 写入磁盘。</strong></p>
<p>在这种情况下，数据就在磁盘上，但没有指向它的 inode，也没有位图显示该数据块已分配。因此，写入就好像从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题。</p>
</li>
<li>
<p><strong>只有更新的 inode（I[v2]）被写入磁盘。</strong></p>
<p>在这种情况下，inode 指向 Db 即将被写入的磁盘地址 (5)，但 Db 尚未被写入。因此，如果我们相信该指针，就会从磁盘读取<strong>垃圾数据</strong>（磁盘地址 5 的旧内容）。</p>
<p>此外，我们还遇到了一个新问题，我们称之<strong>为文件系统不一致</strong>。磁盘位图告诉我们，数据块 5 尚未分配，但 inode 却说它已经分配。位图和 inode 之间的不一致是文件系统数据结构的不一致；要使用文件系统，我们必须以某种方式解决这个问题。</p>
</li>
<li>
<p><strong>只有更新后的位图（B[v2]）被写入磁盘。</strong></p>
<p>在这种情况下，位图显示块 5 已分配，但却没有指向它的 inode。因此，文件系统再次出现不一致；如果不加以解决，这次写入将导致<strong>空间泄漏</strong>，因为文件系统永远不会使用块 5。</p>
</li>
</ul>
<p>在尝试向磁盘写入三个数据块的过程中，还有三种崩溃情况。在这些情况中，两次写入成功，最后一次写入失败：</p>
<ul>
<li>
<p><strong>inode (I[v2]) 和 bitmap (B[v2]) 被写入磁盘，但数据 (Db) 未被写入。</strong></p>
<p>在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图显示 5 正在使用中，因此从文件系统元数据的角度看一切正常。但有一个问题：5 中又出现了垃圾。</p>
</li>
<li>
<p><strong>写入了 inode (I[v2]) 和数据块 (Db)，但没有写入位图 (B[v2])</strong>。在这种情况下，我们的 inode 指向了磁盘上的正确数据，但 inode 和旧版本的位图 (B1) 之间再次出现不一致。因此，我们再次需要在使用文件系统前解决这个问题。</p>
</li>
<li>
<p><strong>位图 (B[v2]) 和数据块 (Db) 被写入，但 inode (I[v2]) 却没有被写入</strong>。在这种情况下，我们又遇到了 inode 和数据位图不一致的问题。然而，尽管块已被写入，位图也显示了它的使用情况，我们却不知道它属于哪个文件，因为没有 inode 指向该文件。</p>
</li>
</ul>
<h3 id="崩溃一致性问题" class="heading-element"><span>2.3 崩溃一致性问题</span>
  <a href="#%e5%b4%a9%e6%ba%83%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>希望从这些崩溃场景中，你能看到磁盘上的文件系统映像因崩溃而可能出现的诸多问题：文件系统数据结构不一致；空间泄漏；向用户返回垃圾数据等等。理想情况下，<font color="red">我们希望将文件系统从一种一致的状态（例如，在文件被附加之前）原子地移动到另一种一致的状态（例如，在将 inode、位图和新数据块写入磁盘之后）。</font>遗憾的是，我们无法轻易做到这一点，因为磁盘每次只提交一次写入，而在这些更新之间可能会发生崩溃或断电。我们将这一普遍问题称为崩溃一致性问题（也可称为一致性更新问题）。</p>
<h2 id="解决方案1文件系统检查器" class="heading-element"><span>3 解决方案#1：文件系统检查器</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%881%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%a3%80%e6%9f%a5%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>早期的文件系统采用一种简单的方法来解决崩溃一致性问题。基本上，它们决定任由不一致性发生，然后稍后（重启时）再修复它们。<code>fsck</code>就是这种懒惰方法的典型例子，它是一种 UNIX 工具，用于查找和修复此类不一致性；不同系统上也有类似的工具用于检查和修复磁盘分区。需要注意的是，这种方法并不能解决所有问题；例如，考虑上述文件系统看起来一致，但 inode 指向垃圾数据的情况。唯一真正的目标是确保文件系统元数据的内部一致性。</p>
<p>正如 McKusick 和 Kowalski 的<a href="https://www.usenix.org/conference/fast13/technical-sessions/presentation/ma"target="_blank" rel="external nofollow noopener noreferrer">论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>所总结的，<code>fsck</code> 工具的运行分为几个阶段。它在文件系统挂载和可用之前运行（<code>fsck</code> 假设运行时没有其他文件系统活动）；一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。以下是 <code>fsck</code> 工作的基本概要：</p>
<ul>
<li><strong>超级块</strong>：<code>fsck</code> 首先检查超级块看起来是否合理，主要是进行健全性检查，如确保文件系统大小大于已分配的块数。这些健全性检查的目的通常是发现可疑（损坏）的超级块；在这种情况下，系统（或管理员）可能会决定使用超级块的替代副本。</li>
<li><strong>空闲块</strong>：接下来，<code>fsck</code> 会扫描 inodes、间接块、双间接块等，以了解文件系统中当前分配的块。它利用这些知识生成正确版本的分配位图；因此，如果位图和 inodes 之间有任何不一致，可以通过信任 inodes 中的信息来解决。对所有 inodes 执行相同类型的检查，确保所有看起来正在使用的 inodes 都在 inode 位图中标记为正在使用。</li>
<li><strong>Inode状态</strong>：检查每个 inode 是否损坏或存在其他问题。例如，<code>fsck</code> 会确保每个已分配的 inode 都有一个有效的类型字段（如常规文件、目录、符号链接等）。如果 inode 字段存在不易修复的问题，该 inode 就会被视为可疑，并被 <code>fsck</code> 清除；inode 位图也会相应更新。</li>
<li><strong>Inode 链接</strong>：<code>fsck</code> 还会验证每个已分配 inode 的链接计数。链接计数表示包含对该特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，<code>fsck</code> 会从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录建立自己的链接计数。如果新计算的链接数与某个 inode 中的链接数不匹配，就必须采取纠正措施，通常是修复 inode 中的链接数。<font color="red">如果发现一个已分配的 inode，但没有目录指向它，它就会被移到<code>lost+found</code>目录&lt;/。</li>
<li><strong>重复</strong>：<code>fsck</code> 还会检查重复指针，即两个不同的 inode 指向同一块的情况。如果其中一个 inode 明显有问题，可能会被清除。或者，可以复制指向的块，从而根据需要给每个 inode 提供自己的副本。</li>
<li><strong>坏块</strong>：在扫描所有指针列表时，还会对坏块指针进行检查。如果一个指针明显指向超出其有效范围的内容，例如，它的地址指向的块大于分区大小，那么这个指针就被认为是 &ldquo;坏的&rdquo;。在这种情况下，<code>fsck</code> 不会做任何太聪明的事情；它只是从 inode 或间接块中删除（清除）指针。</li>
<li><strong>目录检查</strong>：<code>fsck</code> 无法理解用户文件的内容；但目录中包含文件系统本身创建的特定格式化信息。因此，<code>fsck</code> 会对每个目录的内容执行额外的完整性检查，确保&quot;. &ldquo;和&rdquo;.. &ldquo;是第一个条目，目录条目中引用的每个 inode 都已分配，并确保在整个层次结构中，没有任何目录被链接超过一次。</li>
</ul>
<p>如你所见，构建一个有效的 <code>fsck</code> 需要复杂的文件系统知识；要确保这样一段代码在所有情况下都能正确运行，是一项挑战。然而，<code>fsck</code>（以及类似方法）还有一个更大、也许更根本的问题：它们太慢了。在磁盘容量非常大的情况下，扫描整个磁盘以找到所有已分配块并读取整个目录树可能需要数分钟或数小时。随着磁盘容量的增加和 RAID 的普及，fsck 的性能变得令人望而却步。</p>
<p>从更高层次来看，<code>fsck</code> 的基本前提似乎有点不合理。想想我们上面的例子，只有三个数据块被写入磁盘；要扫描整个磁盘来修复在更新三个数据块时出现的问题，成本高得惊人。这种情况就好比你把钥匙掉在卧室的地板上，然后开始搜索整个房子的钥匙恢复算法，从地下室开始，逐个房间搜索。这样做虽然有效，但会造成浪费。因此，随着磁盘（和 RAID）的发展，研究人员和从业人员开始寻找其他解决方案。</p>
<h2 id="解决方案2日志或预写日志" class="heading-element"><span>4 解决方案#2：日志（或预写日志）</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%882%e6%97%a5%e5%bf%97%e6%88%96%e9%a2%84%e5%86%99%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>4.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>解决一致性更新问题的最流行的解决方案可能是从数据库管理系统领域窃取的一个想法。这种被称为<strong>预写日志</strong>的想法正是为了解决此类问题而发明的。在文件系统中，由于历史原因，我们通常将其称为<strong>预写日志记录</strong>。第一个做到这一点的文件系统是 Cedar，尽管许多现代文件系统都使用这个想法，包括 Linux ext3 和 ext4、reiserfs、IBM 的 JFS、SGI 的 XFS 和 Windows NTFS。</p>
<p>基本思路如下：更新磁盘时，在覆盖现有的结构之前，首先写下一个小注释（磁盘上其他某个众所周知的位置）描述您将要执行的操作。写这个注释是“预写”部分，我们将其写入我们组织为“<strong>日志</strong>”的结构中；因此，预写日志记录。</p>
<p>通过将注释写入磁盘，您可以保证如果在更新（覆盖）正在更新的结构期间发生崩溃，您可以返回并查看您所做的注释并重试；因此，您将确切地知道崩溃后要修复什么（以及如何修复），而不必扫描整个磁盘。根据设计，日志记录会在更新期间增加一些工作量，从而大大减少恢复期间所需的工作量。</p>
<p>现在我们将描述 <strong>Linux ext3</strong>（一种流行的日志文件系统）如何将日志合并到文件系统中。大多数磁盘结构与 <strong>Linux ext2</strong> 相同，例如，磁盘分为块组，每个块组包含 inode 位图、数据位图、inode 和数据块。新的关键结构是日志本身，它占用分区内或其他设备上的一些少量空间。因此，ext2 文件系统（没有日志）如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=small" data-sub-html="<h2>image-20240419132816961</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png" alt="image-20240419132816961" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=large 2x" data-title="image-20240419132816961" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>假设日志放置在同一个文件系统映像中（尽管有时它放置在单独的设备上，或者作为文件系统中的文件），带有日志的 ext3 文件系统如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=small" data-sub-html="<h2>image-20240419132922656</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png" alt="image-20240419132922656" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=large 2x" data-title="image-20240419132922656" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>真正的区别只是日志的存在，当然还有它的使用方式。</p>
<h3 id="数据日志" class="heading-element"><span>4.2 数据日志</span>
  <a href="#%e6%95%b0%e6%8d%ae%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>让我们看一个简单的例子来了解数据日志的工作原理。数据日志是 Linux ext3 文件系统的一种模式，本文的大部分讨论都是基于这种模式。</p>
<p>假设我们再次进行典型更新，希望将 inode (I[v2])、位图 (B[v2]) 和数据块 (Db) 再次写入磁盘。在将它们写入最终磁盘位置之前，我们首先要将它们写入日志（又称日记）。这就是日志中的内容：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=small" data-sub-html="<h2>image-20240419151824715</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png" alt="image-20240419151824715" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=large 2x" data-title="image-20240419151824715" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>可以看到，我们在这里写入了 5 个块。事务开始（TxB）告诉我们这次更新的信息，包括文件系统待更新的信息（例如，块 I[v2]、B[v2]和 Db 的最终地址），以及某种<strong>事务标识符（TID）</strong>。中间三个块只包含块本身的确切内容；这被称为<strong>物理日志</strong>，因为我们将更新的确切物理内容写入日志（另一种想法是<strong>逻辑日志</strong>，将更新的逻辑表述更紧凑地写入日志，例如 &ldquo;此更新希望将数据块 Db 附加到文件 X&rdquo;，这有点复杂，但可以节省日志空间，也许还能提高性能）。最后一个数据块（TxE）<strong>是该事务结束的标记</strong>，也包含 TID。</p>
<p>一旦事务安全地存储在磁盘上，我们就可以覆盖文件系统中的旧结构；这个过程称为<strong>检查点</strong>。因此，为了对文件系统进行检查点（即使其与日志中的待定更新保持同步），我们按照上述方式将I[v2]、B[v2] 和 Db 写入到它们的磁盘位置；如果这些写入成功完成，我们就对文件系统进行了检查点，基本上就完成了。因此，我们的初始操作序列为：</p>
<ol>
<li><strong>写日志</strong>：将事务写入日志，包括事务开始块、所有待处理的数据和元数据更新以及事务结束块；等待这些写入完成。</li>
<li><strong>检查点</strong>：将待处理的元数据和数据更新写入文件系统中的最终位置。</li>
</ol>
<p>在我们的示例中，我们首先将 TxB、I[v2]、B[v2]、Db 和 TxE 写入日志。当这些写入完成后，我们将通过检查点 I[v2]、B[v2] 和 Db 到它们在磁盘上的最终位置来完成更新。</p>
<p>当写入日志期间发生崩溃时，事情会变得有点棘手。在这里，我们尝试将事务中的一组块（例如，TxB、I[v2]、B[v2]、Db、TxE）写入磁盘。一种简单的方法是一次发出每一个，等待每一个完成，然后发出下一个。然而，这很慢。理想情况下，我们希望一次发出所有五个块写入，因为这会将五个写入转换为单个顺序写入，从而速度更快。然而，这是不安全的，原因如下：给定如此大的写入，磁盘内部可能会执行调度并以任何顺序完成大写入的小片段。因此，磁盘内部可以 (1) 写入 TxB、I[v2]、B[v2] 和 TxE，并且仅在稍后 (2) 写入 Db。不幸的是，如果磁盘在 (1) 和 (2) 之间断电，磁盘上的结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=small" data-sub-html="<h2>image-20240419195529232</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png" alt="image-20240419195529232" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=large 2x" data-title="image-20240419195529232" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<center>强制写入磁盘
</center>
<p>现代文件系统在强制两次磁盘写入之间保持顺序时需要额外的预防措施。过去，简单地等待第一次写入完成再进行第二次写入就足够了。然而，由于写入缓存的使用增加，这种方法不再有效。启用写入缓存后，磁盘可能会在将数据放置在内存缓存中后通知操作系统写入已完成，而不是立即将数据写入磁盘。这使得无法保证先前的写入在后续写入之前到达磁盘。</p>
<p>为了解决这个问题，一种解决方案是禁用写缓存，但这会影响性能。另一种现代方法是明确发出写屏障，确保在屏障之前发出的所有写入在屏障之后发出的任何写入之前到达磁盘。然而，最近的研究表明，一些磁盘制造商为了提高性能，可能会忽略写屏障请求，这可能导致错误操作。</p>
</blockquote>
<p>为什么会有这个问题？这个事务看起来是一个有效的事务（它有一个开始和结束，序列号匹配）。此外，文件系统无法查看第四个数据块并知道它是错误的；毕竟，它是任意的用户数据。因此，如果系统现在重启并运行恢复，它就会重放此事务，并无知地将垃圾数据块&rdquo;?? &ldquo;的内容复制到 Db 应该存放的位置。这对文件中的任意用户数据来说是很糟糕的；如果发生在文件系统的关键部分，如超级块上，情况就更糟了，可能导致文件系统无法挂载。</p>
<blockquote>
<center>优化日志写入
</center>
<p>文件系统首先要写出事务开始块和事务内容；只有在这些写入完成后，文件系统才能将事务结束块发送到磁盘，这样写入日志的效率特别低，通常会产生额外的旋转（因为磁盘通常需要等待正确的扇区旋转到磁头下方才能进行写入操作）。</p>
<p>Linux ext4中则提供了这样一个方法：将事务写入日志时，在开始和结束块中包含日志内容的校验和。这样做使文件系统能够一次写入整个事务，而不会产生等待；如果在恢复期间，文件系统发现事务中计算的校验和与存储的校验和不匹配，则可以断定事务写入期间发生了崩溃，从而丢弃文件系统更新。因此，通过对写入协议和恢复系统进行小的调整，文件系统可以实现更快的常见情况性能；最重要的是，系统稍微更可靠，因为从日志中读取的任何内容现在都受到校验和的保护。</p>
</blockquote>
<p>为避免这一问题，文件系统分两步进行事务写入。首先，文件系统将除 TxE 块外的所有块写入日志，并一次性完成这些写入操作。当这些写入完成后，日志将显示如下内容：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=small" data-sub-html="<h2>image-20240419201334299</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png" alt="image-20240419201334299" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=large 2x" data-title="image-20240419201334299" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这些写入完成后，文件系统会发出 TxE 块的写入，从而使日志处于最终安全状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=small" data-sub-html="<h2>image-20240419201416396</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png" alt="image-20240419201416396" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=large 2x" data-title="image-20240419201416396" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这个过程的一个重要方面是磁盘提供的原子性保证。事实证明，磁盘保证任何 512 字节的写入要么发生要么不发生（绝不会写一半）；因此，要确保 TxE 的写入是原子性的，就应该把它变成一个单一的 512 字节块。因此，我们目前更新文件系统的协议分为三个阶段：</p>
<ol>
<li><strong>日志写入</strong>：将事务内容（包括 TxB、元数据和数据）写入日志；等待写入完成。</li>
<li><strong>日志提交</strong>：将事务提交块（包含 TxE）写入日志；等待写入完成；事务即被提交。</li>
<li><strong>检查点</strong>：将更新内容（元数据和数据）写入磁盘上的最终位置。</li>
</ol>
<h3 id="恢复" class="heading-element"><span>4.3 恢复</span>
  <a href="#%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们了解文件系统如何使用日志的内容从崩溃中恢复。在此更新序列期间随时可能发生崩溃。</p>
<ul>
<li>如果崩溃发生在事务安全写入日志之前（即，在上面的步骤 2 完成之前），那么我们的工作就很简单：只需跳过挂起的更新。</li>
<li>如果崩溃发生在事务提交到日志之后、检查点完成之前，文件系统可以按如下方式恢复更新。当系统启动时，文件系统恢复过程将扫描日志并查找已提交到磁盘的事务；因此，这些事务会被<strong>重放</strong>（按顺序），文件系统再次尝试将事务中的块写出到它们在磁盘上的最终位置。这种形式的日志记录是最简单的形式之一，称为<strong>重做日志</strong>。通过恢复日志中已提交的事务，文件系统确保磁盘上的结构是一致的，因此可以通过挂载文件系统并为新请求做好准备来继续进行。</li>
</ul>
<p>请注意，在检查点期间的任何时候发生崩溃都是正常的，即使在对块的最终位置的一些更新已经完成之后也是如此。在最坏的情况下，其中一些更新只是在恢复期间再次执行。由于恢复是一种罕见的操作（仅在意外系统崩溃后发生），因此无需担心一些冗余写入。</p>
<h3 id="批处理日志更新" class="heading-element"><span>4.4 批处理日志更新</span>
  <a href="#%e6%89%b9%e5%a4%84%e7%90%86%e6%97%a5%e5%bf%97%e6%9b%b4%e6%96%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>您可能已经注意到，基本协议可能会增加大量额外的磁盘流量。例如，假设我们在同一目录中连续创建两个文件，分别称为 <code>file1</code> 和 <code>file2</code>。要创建一个文件，必须更新许多磁盘结构，至少包括：inode 位图（分配新的 inode）、文件新创建的 inode、包含新目录条目的的父目录的数据块和父目录 inode（现在有新的修改时间）。通过日志记录，我们在逻辑上将所有这些信息提交到我们创建的两个文件的日志中；因为这些文件位于同一目录中，并且假设它们甚至在同一 inode 块中具有 inode，这意味着如果我们不小心，我们最终将一遍又一遍地写入这些相同的块，即相同的目录数据块和 inode 可能会被重复写入，造成了额外的磁盘流量和性能开销。。</p>
<p>为了解决这个问题，某些文件系统不会一次将每个更新提交到磁盘（例如，Linux ext3）；相反，我们可以将所有更新缓冲到全局事务中。在上面的例子中，当创建两个文件时，文件系统只是将内存中的 inode 位图、文件的 inode、目录数据和目录 inode 标记为脏，并将它们添加到形成当前事务的块列表中。当最终将这些块写入磁盘时（例如，5 秒超时后），将提交包含上述所有更新的单个全局事务。因此，通过缓冲更新，文件系统在许多情况下可以避免过多的磁盘写入流量。</p>
<h3 id="限制日志大小" class="heading-element"><span>4.5 限制日志大小</span>
  <a href="#%e9%99%90%e5%88%b6%e6%97%a5%e5%bf%97%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>因此，我们已经达成了更新磁盘上文件系统结构的基本协议。文件系统在内存中缓冲更新一段时间；当最终写入磁盘时，文件系统首先仔细地将事务的详细信息写入日志（也称为预写日志）；事务完成后，文件系统将这些块检查点到它们在磁盘上的最终位置。</p>
<p>然而，日志的大小是有限的。如果我们继续向其中添加事务（如下图所示），它很快就会填满。你认为接下来会发生什么？</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=small" data-sub-html="<h2>image-20240419203504591</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png" alt="image-20240419203504591" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=large 2x" data-title="image-20240419203504591" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>日志满时会出现两个问题：</p>
<ul>
<li>第一个问题比较简单，但不那么关键：日志越大，恢复所需的时间就越长，因为恢复过程必须（按顺序）重放日志中的所有事务才能恢复。</li>
<li>第二个问题更为严重：当日志已满（或接近满）时，就无法再向磁盘提交任何事务，从而使文件系统变得 &ldquo;不那么有用&rdquo;（即无用）。</li>
</ul>
<p>为了解决这些问题，日志文件系统将日志视为循环数据结构，不断重复使用；这就是日志有时被称为<strong>循环日志</strong>的原因。为此，文件系统必须在检查点之后的一段时间内采取行动。具体来说，一旦事务被检查点化，文件系统就应释放日志中占用的空间，允许日志空间被重复使用。实现这一目的的方法有很多，例如，你可以简单地在日志超级块中标记日志中最旧和最新的非检查点事务，其他所有空间都是空闲的。下面是一个图表说明：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=small" data-sub-html="<h2>image-20240419203852114</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png" alt="image-20240419203852114" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=large 2x" data-title="image-20240419203852114" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在日志超级块（不要与主文件系统超级块混淆）中，日志系统记录足够的信息以了解哪些事务尚未设置检查点，从而减少恢复时间并允许以循环方式重复使用日志。因此，我们在基本协议中添加了另一个步骤：</p>
<ol>
<li><strong>日志写入</strong>：将事务内容（包含 TxB 和更新内容）写入日志，等待这些写入完成。</li>
<li><strong>日志提交</strong>：将事务提交块（包含TxE）写入日志，等待写入完成，事务现已提交。</li>
<li><strong>检查点</strong>：将更新内容写入文件系统中的最终位置。</li>
<li><strong>释放</strong>：一段时间后，通过更新日志超级块在日志中将事务标记为已释放。</li>
</ol>
<p>这样我们就有了最终的数据日志协议。但仍然存在一个问题：我们将每个数据块写入磁盘两次，这是一个沉重的成本，特别是对于像系统崩溃这样罕见的情况。</p>
<h3 id="元数据日志" class="heading-element"><span>4.6 元数据日志</span>
  <a href="#%e5%85%83%e6%95%b0%e6%8d%ae%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>尽管现在恢复速度很快（扫描日志并重放一些事务，而不是扫描整个磁盘），但文件系统的正常操作比我们期望的要慢。特别是，对于每次写入磁盘，我们现在也首先写入日志，从而使写入流量加倍；在顺序写入工作负载期间，这种加倍尤其令人痛苦，现在该工作负载将以驱动器峰值写入带宽的一半进行。此外，在写入日志和写入主文件系统之间，存在成本高昂的查找，这显着增加了某些工作负载的开销。</p>
<p>由于将每个数据块写入磁盘两次的成本很高，因此人们尝试了一些不同的方法来提高性能。例如，我们上面描述的日志模式通常称为<strong>数据日志</strong>（如在 Linux ext3 中），因为它记录所有用户数据（除了文件系统的元数据）。一种更简单（也更常见）的日志形式有时称为<strong>有序日志</strong>（或只是<strong>元数据日志</strong>），它几乎相同，只是用户数据不写入日志。因此，当执行与上述相同的更新时，以下信息将被写入日志：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=small" data-sub-html="<h2>image-20240419205044904</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png" alt="image-20240419205044904" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=large 2x" data-title="image-20240419205044904" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>之前写入日志的数据块 Db 将被写入文件系统本身，避免了额外的写入；考虑到磁盘的大部分 I/O 流量都是数据，不重复写入数据大大减少了日志的 I/O 负载。不过，这一修改确实提出了一个有趣的问题：我们应该在什么时候将数据块写入磁盘？</p>
<p>为了更好地理解这个问题，我们再来看看追加文件的例子。更新由三个数据块组成：I[v2]、B[v2] 和 Db。前两个块都是元数据，会被记录下来，然后进行检查点处理；后一个块只会被写入文件系统一次。我们应该何时将 Db 写入磁盘？这重要吗？</p>
<p>事实证明，对于纯元数据日志，数据写入的顺序确实很重要。例如，如果我们在事务（包含 I[v2] 和 B[v2]）完成后将 Db 写入磁盘，会怎样？不幸的是，这种方法存在一个问题：文件系统是一致的，但 I[v2] 最终可能指向垃圾数据。具体来说，考虑 I[v2] 和 B[v2] 已被写入，但 Db 未被写入磁盘的情况。这时文件系统会尝试恢复。由于 Db 不在日志中，文件系统将重放对 I[v2] 和 B[v2] 的写入，并生成一个一致的文件系统（从文件系统元数据的角度来看）。但是，I[v2] 将指向垃圾数据，即 Db 所在槽中的任何数据。</p>
<p>为了确保这种情况不会发生，一些文件系统（如 Linux ext3）会在将相关元数据写入磁盘之前，先将数据块（常规文件）写入磁盘。</p>
<p>具体来说，协议如下：</p>
<ol>
<li><strong>数据写入</strong>：将数据写入最终位置，等待完成（等待是可选的，详见下文）。</li>
<li><strong>日志元数据写入</strong>：将起始块和元数据写入日志，等待写入完成。</li>
<li><strong>日志提交</strong>：将事务提交块（包含 TxE）写入日志，等待写入完成，事务（包括数据）现已提交。</li>
<li><strong>检查点元数据</strong>：将元数据更新内容写入文件系统中的最终位置。</li>
<li><strong>释放</strong>：之后，在日志超级块中标记事务释放。</li>
</ol>
<p>通过强制先写入数据，文件系统可以保证指针永远不会指向垃圾文件。事实上，&quot;<font color="red">先写被指向对象，再写指向该对象的对象</font> &ldquo;这一规则是崩溃一致性的核心，其他崩溃一致性方案也进一步利用了这一规则（详见下文）。</p>
<p>在大多数系统中，元数据日志（类似于 ext3 的有序日志）比完整数据日志更受欢迎。例如，Windows NTFS 和 SGI 的 XFS 都使用某种形式的元数据日志。 Linux ext3 允许您选择数据、有序或无序模式（<font color="red">在无序模式下，可以随时写入数据</font>）。所有这些模式都保持元数据一致；它们的数据语义各不相同。</p>
<p>最后，请注意，如上述协议所示，在向日志发出写入（步骤 2）之前强制完成数据写入（步骤 1）并不是正确性所必需的。具体来说，<font color="red">最好同时对数据、事务开始块和日志元数据进行写入；唯一真正的要求是步骤 1 和 2 在发布日志提交块（步骤 3）之前完成。</font></p>
<h3 id="棘手的情况块重用" class="heading-element"><span>4.7 棘手的情况：块重用</span>
  <a href="#%e6%a3%98%e6%89%8b%e7%9a%84%e6%83%85%e5%86%b5%e5%9d%97%e9%87%8d%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>有一些有趣的情况会让日志记录变得更加棘手，因此值得讨论。其中许多情况都与块重用有关；正如Stephen Tweedie（ext3 的主要幕后推手之一）所说：</p>
<blockquote>
<p>&ldquo;整个系统最可怕的部分是什么？是删除文件。与删除有关的一切都令人毛骨悚然。所有与删除有关的事情&hellip;&hellip;都会让你做噩梦，因为如果块被删除，然后重新分配，会发生什么？</p>
</blockquote>
<p>Tweedie给出的具体例子如下。假设你正在使用某种形式的元数据日志（因此文件的数据块没有日志）。假设有一个名为 <code>foo</code> 的目录。用户向 <code>foo</code> 添加条目（比如创建文件），因此 <code>foo</code> 的内容（因为目录被视为元数据）被写入日志；假设 <code>foo</code> 目录数据的位置是块 1000。日志内容如下</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=small" data-sub-html="<h2>image-20240419210221686</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png" alt="image-20240419210221686" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=large 2x" data-title="image-20240419210221686" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>此时，用户删除目录中的所有内容以及目录本身，从而释放块 1000 以供重复使用。最后，用户创建一个新文件（例如 <code>foobar</code>），最终会重用曾经属于 <code>foo</code> 的相同块（1000）。 <code>foobar</code> 的 inode 及其数据都提交到磁盘；但请注意，由于正在使用元数据日志，因此只有 <code>foobar</code> 的 inode 会提交到日志；文件 <code>foobar</code> 中块 1000 中新写入的数据未记录。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=small" data-sub-html="<h2>image-20240419210410107</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png" alt="image-20240419210410107" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=large 2x" data-title="image-20240419210410107" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设发生了崩溃，并且所有这些信息仍在日志中。在重放期间，恢复过程只是重放日志中的所有内容，包括块 1000 中目录数据的写入；因此，重访会用旧目录内容覆盖当前文件 <code>foobar</code> 的用户数据！显然这不是一个正确的恢复操作，并且当用户读取文件 <code>foobar</code> 时肯定会感到惊讶。</p>
<p>对于这个问题有多种解决方案。例如，人们可以永远不会重用块，直到从日志中检查到删除所述块为止。 Linux ext3 所做的是<font color="red">向日志添加一种新类型的记录，称为撤销记录</font>。在上述情况下，删除目录将导致撤销记录写入日志。重放日志时，系统首先扫描此类撤销记录；任何此类撤销的数据都不会被重放，从而避免了上述问题。</p>
<h3 id="总结日记时间轴" class="heading-element"><span>4.8 总结日记：时间轴</span>
  <a href="#%e6%80%bb%e7%bb%93%e6%97%a5%e8%ae%b0%e6%97%b6%e9%97%b4%e8%bd%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=small" data-sub-html="<h2>image-20240419210913067</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png" alt="image-20240419210913067" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=large 2x" data-title="image-20240419210913067" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在结束对日志的讨论之前，我们用时间轴总结一下我们讨论过的协议。上图显示了记录数据和元数据时的协议，而下图显示了只记录元数据时的协议。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=small" data-sub-html="<h2>image-20240419210939002</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png" alt="image-20240419210939002" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=large 2x" data-title="image-20240419210939002" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在每个图中，时间都是向下递增的，图中的每一行都显示了可以发出或可能完成写入的逻辑时间。例如，在数据日志协议（第一张图）中，事务开始块（TxB）的写入和事务内容的写入在逻辑上可以同时发出，因此可以按任意顺序完成；但事务结束块（TxE）的写入必须在前述写入完成后才能发出。同样，在事务结束块提交之前，也不能开始对数据和元数据块进行检查点写入。水平虚线表示必须遵守写入排序要求的位置。</p>
<p>元数据日志协议也有类似的时间轴。请注意，数据写入在逻辑上可以与事务开始和日志内容的写入同时发出，但必须在事务结束发出前发出并完成。</p>
<p>最后要注意的是，时间轴中标记的每次写入的完成时间是任意的。在实际系统中，完成时间由 I/O 子系统决定，它可能会重新安排写入顺序以提高性能。我们对排序的唯一保证是协议正确性所必须执行的（如图中的水平虚线所示）。</p>
<h2 id="解决方案3其他方法" class="heading-element"><span>5 解决方案#3：其他方法</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%883%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>到目前为止，我们已经描述了保持文件系统元数据一致性的两种方法：</p>
<ul>
<li>基于 <code>fsck</code> 的惰性方法</li>
<li>日志记录的更主动的方法。</li>
</ul>
<p>然而，这些并不是唯一的两种方法。 Ganger 和 Patt 提出了一种这样的方法，称为<strong>软更新</strong>。这种方法仔细地对文件系统的所有写入进行排序，以确保磁盘上的结构永远不会处于不一致的状态。例如，<font color="red">通过在指向它的inode之前将一个指向的数据块写入磁盘，我们可以确保该inode永远不会指向垃圾</font>；对于文件系统的所有结构都可以导出类似的规则。然而，实施软更新可能是一个挑战；虽然上述日志层可以在对确切文件系统结构相对较少的了解的情况下实现，但软更新需要对每个文件系统数据结构的复杂了解，从而给系统增加了相当多的复杂性。</p>
<p>另一种方法称为<font color="red">写时复制（COW）</font>，并在许多流行的文件系统中使用，包括 Sun 的 ZFS。此技术永远不会覆盖原位的文件或目录；相反，它将新的更新放置到磁盘上以前未使用的位置。完成多次更新后，COW 文件系统会翻转文件系统的根结构以包含指向新更新的结构的指针。</p>
<p>COW 技术的一个重要优点是它使得保持文件系统的一致性变得更加简单。由于原始数据没有被直接修改，因此不需要复杂的同步或回滚机制来维护一致性，而是通过简单地修改指向新数据的指针来实现。</p>
<p>另一种方法是名为基于反向指针的一致性（backpointer-based consistency, BBC）的技术中，写入之间不强制执行任何顺序。为了实现一致性，系统中的每个块都添加了一个额外的反向指针；例如，每个数据块都有对其所属inode的引用。当访问文件时，文件系统可以通过检查前向指针（例如，inode 或直接块中的地址）是否指向引用它的块来确定文件是否一致。如果是这样，则所有内容都必须已安全到达磁盘，因此文件是一致的；如果不是，则文件不一致，并返回错误。通过向文件系统添加反向指针，可以获得一种新形式的惰性崩溃一致性。</p>
<p>最后，还有一种减少日志协议等待磁盘写入完成的次数的技术。这种新方法被称为<strong>乐观崩溃一致性</strong>，通过使用事务校验和的通用形式向磁盘发出尽可能多的写入，并包含一些其他技术来检测出现的不一致情况。对于某些工作负载，这些乐观技术可以将性能提高一个数量级。然而，要真正正常运行，需要稍微不同的磁盘接口。</p>
]]></description></item><item><title>快速文件系统</title><link>https://hezephyr.github.io/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:32:09 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="旧unix操作系统的问题" class="heading-element"><span>1 旧Unix操作系统的问题</span>
  <a href="#%e6%97%a7unix%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>UNIX 操作系统问世之初，UNIX奇才Ken Thompson自己编写了第一个文件系统。我们称之为 &ldquo;老 UNIX 文件系统&rdquo;，它非常简单。基本上，它的数据结构在磁盘上看起来是这样的：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=small" data-sub-html="<h2>image-20240418123744706</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png" alt="image-20240418123744706" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=large 2x" data-title="image-20240418123744706" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>超级块 (S) 包含有关整个文件系统的信息：卷有多大、有多少 inode、指向空闲块列表头部的指针等等。磁盘的inode区域包含文件系统的所有inodes。最后，大部分磁盘都被数据块占用了。</p>
<p>旧文件系统的好处是它很简单，并且支持文件系统试图提供的基本抽象：文件和目录层次结构。这个易于使用的系统是从过去笨拙的、基于记录的存储系统向前迈出的真正一步，并且目录层次结构相对于早期系统提供的更简单的单级层次结构来说是真正的进步。</p>
<p>问题是：<strong>性能非常糟糕</strong>。根据 Kirk McKusick 和他在伯克利的同事的测量，性能从一开始就很糟糕，而且随着时间的推移越来越差，到后来文件系统只能提供整个磁盘带宽的 2%！</p>
<p>主要问题在于，<strong>旧的 UNIX 文件系统把磁盘当作随机存取存储器来处理</strong>；数据被分散到各个地方，而不考虑保存数据的介质是磁盘这一事实，因此有实际而昂贵的定位成本。例如，一个文件的数据块往往离其 inode 很远，因此每当先读取 inode，然后再读取文件的数据块时，都会产生昂贵的寻道（这是一个相当常见的操作）。</p>
<p>更糟糕的是，由于没有对空闲空间进行仔细管理，文件系统最终会变得相当<strong>碎片化</strong>。空闲列表最终会指向散布在磁盘上的大量区块，当文件被分配时，它们只会占用下一个空闲区块。其结果是，逻辑上连续的文件会在磁盘上来回访问，从而大大降低了性能。例如，假设下面的数据块区域包含四个文件（A、B、C 和 D），每个文件的大小为 2 个数据块：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=small" data-sub-html="<h2>image-20240418125008864</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png" alt="image-20240418125008864" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=large 2x" data-title="image-20240418125008864" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果删除 B 和 D，则结果布局为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=small" data-sub-html="<h2>image-20240418125054288</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png" alt="image-20240418125054288" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=large 2x" data-title="image-20240418125054288" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如你所看到的，空闲空间被分割成两块，每块两个区块，而不是一块连续的四个区块。假设你现在想分配一个四块大小的文件 E：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=small" data-sub-html="<h2>image-20240418125147699</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png" alt="image-20240418125147699" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=large 2x" data-title="image-20240418125147699" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>你可以看到发生了什么：E 会被分散到整个磁盘，因此在访问 E 时，磁盘的性能不会达到峰值（顺序）。而是先读取 E1 和 E2，然后寻道，再读取 E3 和 E4。这种碎片问题在旧的 UNIX 文件系统中经常出现，而且会影响性能。顺便提一句：<font color="red"><strong>磁盘碎片整理工具</strong>正是用来解决这个问题的；它们会重组磁盘上的数据，将文件连续放置，并为一个或几个连续区域腾出空间，移动数据，然后重写 inodes 等，以反映变化。</font></p>
<p>还有一个问题：原始块大小太小（512 字节）。因此，从磁盘传输数据的效率本来就不高。块越小越好，因为可以最大限度地减少内部碎片（块内的浪费），但对传输不利，因为每个块都可能需要定位开销才能到达。这就是问题所在：</p>
<blockquote>
<p>如何组织文件系统数据结构以提高性能？在这些数据结构之上，我们需要哪种类型的分配策略？如何让文件系统 &ldquo;感知磁盘&rdquo;？</p>
</blockquote>
<h2 id="ffs磁盘感知是解决方案" class="heading-element"><span>2 FFS：磁盘感知是解决方案</span>
  <a href="#ffs%e7%a3%81%e7%9b%98%e6%84%9f%e7%9f%a5%e6%98%af%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>伯克利大学的一个小组决定建立一个更好、更快的文件系统，他们巧妙地将其称为<strong>快速文件系统（FFS）</strong>。他们的想法是设计 &ldquo;磁盘感知 &ldquo;的文件系统结构和分配策略，从而提高性能，他们正是这样做的。因此，FFS 开启了文件系统研究的新纪元；通过保留文件系统的相同接口（相同的 API，包括 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>close()</code> 和其他文件系统调用），但改变内部实现，作者为新文件系统的构建铺平了道路，这项工作一直持续到今天。几乎所有现代文件系统都遵循现有的接口（从而保持与应用程序的兼容性），同时出于性能、可靠性或其他原因改变其内部结构。</p>
<h2 id="组织结构柱面组" class="heading-element"><span>3 组织结构：柱面组</span>
  <a href="#%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e6%9f%b1%e9%9d%a2%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>第一步是更改磁盘结构。 FFS 将磁盘划分为<strong>多个柱面组</strong>。<strong>单柱面</strong>是硬盘驱动器不同表面上距驱动器中心距离相同的一组磁道；它被称为柱面是因为它与所谓的几何形状明显相似。 FFS将N个连续的柱面聚合为一组，因此整个磁盘可以被视为柱面组的集合。这是一个简单的示例，显示了具有六个盘片的驱动器的四个最外层磁道，以及由三个柱面组成的柱面组：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=small" data-sub-html="<h2>image-20240418130734316</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png" alt="image-20240418130734316" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=large 2x" data-title="image-20240418130734316" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，现代驱动器不会导出足够的信息供文件系统真正理解特定柱面是否正在使用；如前所述，<font color="red">磁盘导出块的逻辑地址空间，并将其几何细节隐藏在客户端之外。</font>因此，现代文件系统（例如Linux ext2、ext3和ext4）将驱动器组织成块组，每个块组只是磁盘地址空间的连续部分。下面的图片说明了一个示例，在该示例中，每8个块被组织到不同的块组中（请注意实际分组将包含更多块）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=small" data-sub-html="<h2>image-20240418130941919</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png" alt="image-20240418130941919" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=large 2x" data-title="image-20240418130941919" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>无论您将它们称为柱面组还是块组，这些组都是 FFS 用于提高性能的核心机制。至关重要的是，通过将两个文件放在同一组中，FFS 可以确保依次访问不会导致磁盘上的长时间查找。</p>
<p>为了使用这些组来存储文件和目录，FFS 需要能够将文件和目录放入一个组中，并在其中跟踪有关它们的所有必要信息。为此，FFS 包含您可能期望文件系统在每个组中具有的所有结构，例如 inode 空间、数据块以及一些用于跟踪这些结构是否已分配或空闲的结构。以下是 FFS 在单个柱面组中保留的内容的描述：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=small" data-sub-html="<h2>image-20240418131130383</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png" alt="image-20240418131130383" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=large 2x" data-title="image-20240418131130383" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在让我们更详细地检查一下这个单个柱面组的组成部分。出于可靠性原因，FFS 会在每个组中保留一份<strong>超级块 (S) 副本</strong>。挂载文件系统需要超级块；通过保留多个副本，如果其中一个副本损坏，你仍然可以通过工作副本挂载和访问文件系统。</p>
<p>在每个组内，FFS 需要跟踪该组的 inode 和数据块是否已分配。每个组的 <strong>inode 位图 (ib)</strong> 和<strong>数据位图 (db)</strong> 对每个组中的 inode 和数据块起作用。位图是管理文件系统中空闲空间的绝佳方法，因为很容易找到一大块空闲空间并将其分配给文件，或许可以避免旧文件系统中空闲列表的一些碎片问题。</p>
<p>最后，<strong>inode</strong> 和<strong>数据块区域</strong>与以前的 &ldquo;非常简单文件系统&rdquo;（VSFS）一样。像往常一样，每个柱面组的大部分由数据块组成。</p>
<blockquote>
<center>FFS 文件创建
</center>
<p>作为一个例子，想一想创建文件时必须更新哪些数据结构；在这个例子中，假设用户创建了一个新文件 <code>/foo/bar.txt</code>，文件长度为一个块（4KB）。该文件是新文件，因此需要一个新的 inode；因此，inode 位图和新分配的 inode 都将被写入磁盘。</p>
<p>文件中还有数据，因此也必须分配；数据位图和数据块（最终）将被写入磁盘。因此，对当前分区至少要进行四次写入（请注意，这些写入在进行之前可能会在内存中缓冲一段时间）。但这还不是全部！尤其是，在创建新文件时，还必须将文件放到文件系统的层次结构中，即必须更新目录。具体来说，必须更新父目录 <code>foo</code>，以添加 <code>bar.txt</code> 条目；这一更新可能适合 <code>foo</code> 的现有数据块，也可能需要分配一个新块（以及相关的数据位图）。<code>foo</code> 的 inode 也必须更新，以反映目录的新长度并更新时间字段（如最后修改时间）。</p>
<p>总的来说，创建一个新文件的工作量很大！也许下次再创建新文件时，你应该更加感激，或者至少对创建工作如此顺利感到惊讶。</p>
</blockquote>
<h2 id="策略如何分配文件和目录" class="heading-element"><span>4 策略：如何分配文件和目录</span>
  <a href="#%e7%ad%96%e7%95%a5%e5%a6%82%e4%bd%95%e5%88%86%e9%85%8d%e6%96%87%e4%bb%b6%e5%92%8c%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了这个组结构，FFS 现在必须决定如何将文件和目录以及相关元数据放置在磁盘上以提高性能。基本原则很简单：<font color="red">将相关的东西放在一起（其推论就是将不相关的东西分开）</font>。</p>
<p>因此，为了遵守这一原则，FFS 必须决定什么是“相关的”并将其放置在同一个区块组中；相反，不相关的项目应放置在不同的块组中。为了实现这一目标，FFS 使用了一些简单的放置启发式法。</p>
<p>首先是目录的放置。 FFS 采用一种简单的方法：找到分配目录数量较少（以平衡组之间的目录）和空闲 inode 数量较多（以便随后能够分配一堆文件）的柱面组，并将目录数据和inode放在该组中。当然，这里可以使用其他启发式方法（例如，考虑空闲数据块的数量）。</p>
<p>对于文件，FFS 做了两件事。</p>
<ul>
<li>首先，<font color="red">它确保（在一般情况下）将文件的数据块分配在与其 inode 相同的组中</font>，从而防止 inode 和数据之间的长时间查找（如在旧文件系统中）。</li>
<li>其次，<font color="red">它将同一目录中的所有文件放置在它们所在目录的柱面组中</font>。</li>
</ul>
<p>因此，如果用户创建四个文件：<code>/a/b</code>、<code>/a/c</code>、<code>/a/d</code> 和 <code>b/ f</code>，FFS 会尝试将前三个放置在彼此附近（同一组），而第四个放置在远处（在其他组中）。</p>
<p>让我们看一个此类分配的示例。在示例中，假设每组只有 10 个 inode 和 10 个数据块（都小得离谱），并且三个目录（根目录 <code>/</code>、<code>/a</code>、<code>/b</code>）和 4 个文件（<code>/a/ c</code>、<code>/a/d</code>、<code>/a/e</code>、<code>/b/f</code>) 根据 FFS 策略放置在其中。假设常规文件的大小各为两个块，并且目录只有一个数据块。对于该图，我们对每个文件或目录使用明显的符号（即 <code>/</code> 表示根目录，<code>a</code> 表示 <code>/a</code>，<code>f</code> 表示 <code>/b/f</code>，等等）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=small" data-sub-html="<h2>image-20240418201534595</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png" alt="image-20240418201534595" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=large 2x" data-title="image-20240418201534595" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，FFS 策略做了两个积极的事情：每个文件的数据块都靠近每个文件的 inode，同一目录中的文件彼此靠近（即 <code>/a/c</code>、<code>/a/d</code> 和 <code>/a/e</code>）都在组 1 中，并且目录 <code>/b</code> 及其文件 <code>/b/f</code> 在组 2 中彼此靠近）。</p>
<p>相比之下，现在让我们看一下 inode 分配策略，它只是将 inode 分布在组之间，试图确保没有组的 inode 表很快被填满。最终的分配可能如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=small" data-sub-html="<h2>image-20240418201925750</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png" alt="image-20240418201925750" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=large 2x" data-title="image-20240418201925750" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从图中可以看出，虽然此策略确实将文件（和目录）数据保留在其各自的 inode 附近，但目录中的文件在磁盘上任意分布，因此不会保留基于名称的局部性。对文件 <code>/a/c</code>、<code>/a/d</code> 和 <code>/a/e</code> 的访问现在跨越三组，而不是按照 FFS 方法跨越一组。</p>
<p>FFS 策略启发式方法并非基于对文件系统流量或任何特别细微的内容的广泛研究；相反，它们基于良好的老式常识。目录中的文件通常一起访问：想象一下编译一堆文件，然后将它们链接到单个可执行文件中。由于存在这种基于命名空间的局部性，FFS 通常会提高性能，确保相关文件之间的查找良好且简短。</p>
<h2 id="文件局部性测量" class="heading-element"><span>5 文件局部性测量</span>
  <a href="#%e6%96%87%e4%bb%b6%e5%b1%80%e9%83%a8%e6%80%a7%e6%b5%8b%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了更好地理解这些启发式方法是否有意义，让我们分析一些文件系统访问的痕迹，看看是否确实存在命名空间局部性。由于某种原因，文献中似乎没有对这个主题进行很好的研究。</p>
<p>具体来说，我们将使用 SEER 跟踪并分析目录树中文件访问彼此之间的“距离”有多远。例如，如果文件 <code>f</code> 被打开，然后在跟踪中下一个重新打开（在打开任何其他文件之前），则目录树中这两个打开之间的距离为零（因为它们是同一文件）。如果打开目录 <code>dir</code>中的文件 <code>f</code>（即 <code>dir/f</code>），然后打开同一目录中的文件 <code>g</code>（即 <code>dir/g</code>），则两个文件访问之间的距离为 1，因为它们共享同一目录但不是同一文件。换句话说，我们的距离度量衡量的是您必须在<strong>目录树上走多远才能找到两个文件的共同祖先</strong>；它们在树中越近，度量越低。</p>
<p>下图显示了在 SEER 集群中所有工作站的 SEER 跟踪中在所有跟踪的整体上观察到的局部性。该图沿 x 轴绘制差异指标，并沿 y 轴显示具有该差异的文件打开的累积百分比。具体来说，对于 SEER 跟踪（图中标记为“Trace”），您可以看到大约 7% 的文件访问是针对先前打开的文件，而近 40% 的文件访问是针对同一文件或到同一目录中的一（即相差零或一）。因此，FFS 局部性假设似乎是有意义的（至少对于这些痕迹而言）。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Locality_For_SEER_Traces.png" alt="image-20240418202721034" style="zoom:50%;" />
<p>有趣的是，另外 25% 左右的文件访问是针对距离为 2 的文件的。当用户以多级方式构建一组相关目录并在它们之间持续跳转时，就会发生这种类型的局部性。例如，如果用户有一个 <code>src</code> 目录并将目标文件（<code>.o</code> 文件）构建到 <code>obj</code> 目录中，并且这两个目录都是主目录 <code>proj</code> 的子目录，则常见的访问模式将是 <code>proj/src/foo .c</code> 后跟 <code>proj/obj/foo.o</code>。这两个访问之间的距离是 2，因为 <code>proj</code> 是共同的祖先。 FFS 不会在其策略中捕获这种类型的局部性，因此在此类访问之间会发生更多的查找。</p>
<p>为了进行比较，该图还显示了“随机”轨迹的局部性。随机跟踪是通过以随机顺序从现有 SEER 跟踪中选择文件并计算这些随机排序的访问之间的距离度量来生成的。正如您所看到的，正如预期的那样，随机跟踪中的命名空间局部性较少。然而，因为最终每个文件共享一个共同的祖先（例如根），所以存在一些局部性，因此随机作为比较点是有用的。</p>
<h2 id="大文件例外" class="heading-element"><span>6 大文件例外</span>
  <a href="#%e5%a4%a7%e6%96%87%e4%bb%b6%e4%be%8b%e5%a4%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在 FFS 中，文件放置的一般策略有一个重要的例外，那就是大文件。如果没有不同的规则，一个大文件就会占满它第一次放置的块组（也许还有其他块组）。以这种方式填满一个块组是不可取的，因为这会阻止后续的 &ldquo;相关 &ldquo;文件被放置在这个块组中，从而可能会损害文件访问的本地性。</p>
<p>因此，对于大文件，FFS 的做法如下。在第一个块组中分配了一定数量的块之后（例如 12 个块，或一个 inode 中可用的直接指针的数量），FFS 会将文件的下一个 &ldquo;大 &ldquo;块（例如第一个间接块指向的那些块）放到另一个块组（可能是为了降低利用率而选择的）中。然后，文件的下一个块被放到另一个不同的块组中，依此类推。</p>
<p>让我们通过一些图表来更好地理解这一策略。如果没有大文件例外情况，单个大文件就会将其所有块放入磁盘的一个部分。我们以一个文件 (<code>/a</code>) 为例进行研究，该文件有 30 个块，FFS 配置为每个组 10 个 inodes 和 40 个数据块。下面是没有大文件例外情况的 FFS 的描述：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=small" data-sub-html="<h2>image-20240418204128184</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png" alt="image-20240418204128184" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=large 2x" data-title="image-20240418204128184" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如图所示，<code>/a</code> 填满了group 0 中的大部分数据块，而其他组仍然是空的。如果现在在根目录 (<code>/</code>) 中创建了其他文件，那么组中就没有太多空间来存放它们的数据了。</p>
<p>在大文件例外情况下（此处设置为每个块中包含五个块），FFS 会将文件分散到各个组中，因此任何一个组内的利用率都不会太高：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=small" data-sub-html="<h2>image-20240418204256591</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png" alt="image-20240418204256591" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=large 2x" data-title="image-20240418204256591" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>你可能注意到，将文件块分散到磁盘上会降低性能，尤其是在相对常见的顺序文件访问情况下（例如，用户或应用程序按顺序读取 0 到 29 块）。但您可以通过谨慎选择块大小来解决这个问题。</p>
<p>具体来说，如果块的大小足够大，文件系统就会花大部分时间从磁盘传输数据，而只花（相对较少的）时间在块的各块之间查找。<font color="red">这种通过增加每次开销的工作量来减少开销的过程称为摊销，是计算机系统中的一种常用技术</font>。</p>
<p>让我们举个例子：假设磁盘的平均定位时间（即寻道和旋转）为 10 毫秒。再假设磁盘的数据传输速度为 40 MB/s。如果您的目标是将一半时间用于在数据块之间寻道，一半时间用于传输数据（从而达到磁盘峰值性能的 50%），那么每 10 毫秒的定位时间就需要花费 10 毫秒来传输数据。那么问题来了：一个数据块需要多大才能花费 10 毫秒来传输数据？我们来计算一下：
$$
\frac{40\cancel{MB}}{\cancel{sec}}\cdot\frac{1024KB}{1\cancel{MB}}\cdot\frac{1\cancel{sec}}{1000\cancel{ms}}\cdot10\cancel{ms}=409.6KB
$$
基本上，这个等式表示的是：如果您以 40 MB/s 的速度传输数据，则每次查找时只需传输 409.6KB，以便将一半的时间用于查找，一半的时间用于传输。同样，您可以计算实现 90% 峰值带宽（结果约为 3.69MB），甚至 99% 峰值带宽（40.6MB！）所需的块大小。正如您所看到的，您越接近峰值，这些块就越大（有关这些值如下图所示）。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Amortization_How_Big_Do_Chunks_Have_To_Be.png" alt="image-20240418205144894" style="zoom:50%;" />
<p>不过，FFS 并没有使用这种计算方法，以便将大文件分摊到各个组。相反，它根据 inode 本身的结构采取了一种简单的方法。前 12 个直接块与 inode 放在同一个组中；随后的每个间接块及其指向的所有块则放在不同的组中。对于 4KB 的块大小和 32 位磁盘地址，此策略意味着文件的每 1024 个块 (4MB) 被放置在单独的组中，唯一的例外是直接指针指向的文件的第一个 48KB。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=small" data-sub-html="<h2>image-20240418205920172</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png" alt="image-20240418205920172" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=large 2x" data-title="image-20240418205920172" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，磁盘驱动器的发展趋势是，传输速率的提高相当快，因为磁盘制造商善于将更多bit压缩到相同的表面，但与寻道有关的驱动器机械方面（磁盘臂速度和旋转速度）的提高却相当缓慢。这意味着，随着时间的推移，机械成本会变得相对更昂贵，因此，为了摊销这些成本，你必须在两次寻道之间传输更多的数据。</p>
<h2 id="关于-ffs-的其他一些事情" class="heading-element"><span>7 关于 FFS 的其他一些事情</span>
  <a href="#%e5%85%b3%e4%ba%8e-ffs-%e7%9a%84%e5%85%b6%e4%bb%96%e4%b8%80%e4%ba%9b%e4%ba%8b%e6%83%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>FFS 还引入了其他一些创新。特别是，设计者们非常担心小文件的容纳问题；事实证明，当时许多文件的大小都在 2KB 左右，使用 4KB 的块虽然有利于传输数据，但空间效率却不高。因此，对于一个典型的文件系统来说，这种<strong>内部碎片</strong>会导致大约一半的磁盘空间被浪费。</p>
<p>FFS 设计者的解决方案很简单，也很好地解决了这个问题。他们决定引入<strong>子块</strong>，即文件系统可以分配给文件的 512 字节的小块。这样，如果你创建了一个小文件（比如 1KB 大小），它将占用两个子块，从而不会浪费整个 4KB 的块。<font color="red">随着文件的增大，文件系统将继续为其分配 512 字节的块，直到获得完整的 4KB 数据。这时，FFS 会找到一个 4KB 的块，将子块复制到其中，然后释放子块以备将来使用。</font></p>
<p>你可能会认为这个过程效率很低，需要文件系统做大量额外的工作（尤其是执行复制时需要大量额外的 I/O）。因此，FFS 通常通过修改 <code>libc</code> 库来避免这种低效行为；<font color="red">该库会对写入内容进行缓冲，然后以 4KB 的分块形式将其发送到文件系统，从而在大多数情况下完全避免了子块特殊化</font>。</p>
<p>FFS 引入的第二项重要功能是优化磁盘布局以提高性能。在那个时代（SCSI 和其他更现代的设备接口出现之前），磁盘的复杂程度要低得多，需要主机 CPU 以更实际的方式控制其运行。当文件被放置在磁盘的连续扇区上时，FFS 就会出现问题，如下图左侧所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=small" data-sub-html="<h2>image-20240418210429044</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png" alt="image-20240418210429044" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=large 2x" data-title="image-20240418210429044" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>特别是在顺序读取时出现问题。FFS 会首先发出对 0 号块的读取；当读取完成后，FFS 再发出对 1 号块的读取时，为时已晚：1 号块已经在磁头下方旋转，现在读取 1 号块将会导致完全旋转。</p>
<p>FFS 采用不同的布局解决了这个问题，如上图右侧所示。通过跳过每一个其他块（在示例中），FFS 有足够的时间在下一个块经过磁头之前请求下一个块。事实上，FFS 很聪明，它能计算出特定磁盘在布局时应跳过多少块，以避免额外的旋转；这种技术被称为<strong>参数化</strong>，因为 FFS 会计算出磁盘的特定性能参数，并利用这些参数来决定准确的交错布局方案。</p>
<p>你可能会想：这个方案毕竟没那么好。事实上，使用这种布局，你只能获得峰值带宽的 50%，因为你必须绕每个磁道两次，才能读取每个区块一次。幸运的是，现代磁盘要聪明得多：<font color="red">它们会在内部读入整个磁道，并将其缓冲到内部磁盘缓存中（因此通常称为磁道缓冲区）</font>。这样，在后续读取磁道时，磁盘就会从缓存中返回所需的数据。因此，文件系统不再需要担心这些令人难以置信的低级细节。如果设计得当，抽象和更高级别的接口可能是件好事。</p>
<p>此外，还增加了其他一些可用性改进。FFS 是最早允许使用<strong>长文件名</strong>的文件系统之一，从而使文件系统中的文件名更具表现力，而不是传统的固定大小方法（如 8 个字符）。此外，文件系统还引入了一个新概念，即<strong>符号链接</strong>。硬链接的局限性在于它们不能指向目录（因为担心会在文件系统层次结构中引入循环），而且只能指向同一卷内的文件（即 inode number必须仍然有意义）。<font color="red">符号链接允许用户创建指向系统中任何其他文件或目录的 &ldquo;别名&rdquo;，因此更加灵活</font>。FFS 还引入了用于重命名文件的原子 <code>rename()</code> 操作。除基本技术外，易用性方面的改进也为 FFS 赢得了更多用户。</p>
]]></description></item><item><title>文件系统实现</title><link>https://hezephyr.github.io/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 11 May 2024 21:05:11 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</guid><description><![CDATA[<h2 id="思维模型" class="heading-element"><span>1 思维模型</span>
  <a href="#%e6%80%9d%e7%bb%b4%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>要考虑文件系统，我们通常建议考虑它们的两个不同方面；如果您了解这两个方面，您可能就会了解文件系统的基本工作原理。</p>
<ul>
<li>首先是文件系统的<font color="red">数据结构</font>。换句话说，文件系统使用什么类型的磁盘结构来组织其数据和元数据？我们将看到的第一个文件系统（包括下面的 vsfs）采用简单的结构，如块数组或其他对象，而更复杂的文件系统，如 SGI 的 XFS，使用更复杂的基于树的结构。</li>
<li>文件系统的第二个方面是它的<font color="red">访问方法</font>。它如何将进程发出的调用（例如 <code>open()</code>、<code>read()</code>、<code>write()</code> 等）映射到其结构上？在执行特定系统调用期间会读取哪些结构？写了哪些？所有这些步骤的执行效率如何？</li>
</ul>
<p>如果您了解文件系统的数据结构和访问方法，您就已经开发了一个关于它如何真正工作的良好思维模型，这是系统思维的关键部分。</p>
<blockquote>
<center>文件系统思维模型
</center>
<p>思维模型是你在学习系统时真正想要开发的东西。对于文件系统，您的思维模型最终应该包括以下问题的答案：</p>
<ol>
<li>哪些磁盘结构存储文件系统的数据和元数据？</li>
<li>当进程打开文件时会发生什么？</li>
<li>在读取或写入期间访问哪些磁盘结构？</li>
</ol>
<p>通过研究和改进您的思维模型，您可以对正在发生的事情形成抽象的理解，而不仅仅是试图理解某些文件系统代码的细节。</p>
</blockquote>
<h2 id="vsfs的整体组织" class="heading-element"><span>2 VSFS的整体组织</span>
  <a href="#vsfs%e7%9a%84%e6%95%b4%e4%bd%93%e7%bb%84%e7%bb%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们现在开发 vsfs 文件系统数据结构的整体磁盘组织。我们需要做的第一件事是将磁盘分为块；简单的文件系统仅使用一种块大小，这正是我们在这里要做的。我们选择常用的大小 4 KB。</p>
<p>因此，我们对构建文件系统的磁盘分区的看法很简单：一系列块，每个块大小为 4 KB。在大小为 $N$ 个 4 KB 块的分区中，块的寻址范围为 $0$ 到 $N − 1$。假设我们有一个非常小的磁盘，只有 64 个块：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=small" data-sub-html="<h2>image-20240417111330145</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png" alt="image-20240417111330145" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=large 2x" data-title="image-20240417111330145" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在让我们考虑一下需要在这些块中存储什么来构建文件系统。当然，首先想到的是用户数据。事实上，任何文件系统中的大部分空间都是（并且应该是）用户数据。我们将用于用户数据的磁盘区域称为<strong>数据区域</strong>，并且为了简单起见，为这些块保留磁盘的固定部分，例如磁盘上 64 个块中的最后 56 个块：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=small" data-sub-html="<h2>image-20240417111520646</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png" alt="image-20240417111520646" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=large 2x" data-title="image-20240417111520646" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>文件系统必须跟踪每个文件的信息。该信息是<strong>元数据</strong>的关键部分，跟踪诸如哪些数据块（在数据区域中）组成文件、文件的大小、其所有者和访问权限、访问和修改时间以及其他类似信息等。为了存储这些信息，文件系统通常有一个称为<code>inode</code>的结构。</p>
<p>为了容纳inodes，我们还需要在磁盘上为它们保留一些空间。我们将磁盘的这一部分称为inode表，它仅保存磁盘上inodes的数组。因此，我们的磁盘映像现在看起来像下图，假设我们使用 64 个块中的 5 个作为inodes（在图中用 I 表示）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=small" data-sub-html="<h2>image-20240417112112851</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png" alt="image-20240417112112851" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=large 2x" data-title="image-20240417112112851" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这里我们应该注意，inode 通常不会那么大，例如 128 或 256 字节。假设每个 inode 256 字节，一个 4 KB 的块可以容纳 16 个 inodes，而我们上面的文件系统总共包含 80 个 inodes。在我们的简单文件系统中，构建在一个微小的 64 块分区上，这个数字代表我们的文件系统中可以拥有的最大文件数；但是，请注意，构建在更大磁盘上的相同文件系统可以简单地分配更大的inode表，从而容纳更多文件。</p>
<p>到目前为止，我们的文件系统已经有了数据块（D）和 inodes（I），但仍然缺少一些东西。正如您可能已经猜到的，仍然需要的一个主要组件是<font color="red">某种跟踪inodes或数据块是否空闲或已分配的方法。</font>因此，这种分配结构是任何文件系统中必需的元素。</p>
<p>当然，有许多可行的分配跟踪方法。例如，我们可以使用一个指向第一个空闲块的<strong>空闲列表</strong>，该块再指向下一个空闲块，依此类推。相反，我们选择了一种简单且流行的结构，称为<strong>位图</strong>，其中包括数据区域（<strong>数据位图</strong>）和inode表（inode位图）。位图是一个简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。因此我们新的磁盘布局，带有inode位图 (i) 和数据位图 (d)：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=small" data-sub-html="<h2>image-20240417112825881</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png" alt="image-20240417112825881" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=large 2x" data-title="image-20240417112825881" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>您可能会注意到，为这些位图使用整个 4 KB 块有点过大；这样的位图可以跟踪是否分配了32K个对象，但我们只有80个inode和56个数据块。然而，为了简单起见，我们还是为每个位图使用整个 4 KB 块。</p>
<p>我们非常简单的文件系统的磁盘结构的设计中还剩下一个块。我们将其保留给<strong>超级块</strong>，在下图中用 S 表示。<font color="red">超级块包含有关此特定文件系统的信息，例如，包括文件系统中有多少个 inodes 和数据块（在本例中分别为 80 和 56）、inode 表开始的位置（块 3）等等</font>。它还可能包含某种幻数来标识文件系统类型（在本例中为 vsfs）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=small" data-sub-html="<h2>image-20240417113149921</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png" alt="image-20240417113149921" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=large 2x" data-title="image-20240417113149921" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>因此，<font color="red">在挂载文件系统时，操作系统会首先读取超级块，初始化各种参数，然后将卷附加到文件系统树上。</font>这样，当访问卷内文件时，系统就能准确知道在哪里可以找到所需的磁盘结构。</p>
<h2 id="文件组织inode" class="heading-element"><span>3 文件组织：Inode</span>
  <a href="#%e6%96%87%e4%bb%b6%e7%bb%84%e7%bb%87inode" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>文件系统最重要的磁盘结构之一是 inode；几乎所有文件系统都有与此类似的结构。名称 inode 是<strong>index node</strong>的缩写，这是 UNIX和可能更早的系统中赋予它的历史名称，使用它是因为这些节点最初排列在数组中，并且在访问特定 inode 时索引到该数组。</p>
<blockquote>
<center>数据结构 — INODE
</center>
<p>inode 是许多文件系统中使用的通用名称，用于描述保存给定文件元数据的结构，例如其长度、权限及其组成块的位置。这个名字至少可以追溯到 UNIX（如果不是更早的系统的话，可能更早可以追溯到 Multics）；它是<code>index node</code>（索引节点）的缩写，因为inode number用于索引磁盘上inodes数组，以便找到该编号的inode。正如我们将看到的，inode的设计是文件系统设计的关键部分之一。大多数现代系统对于它们跟踪的每个文件都有某种类似的结构，但可能将它们称为不同的东西（例如 dnodes、fnodes 等）。</p>
</blockquote>
<p>每个inode都隐式地通过一个数字（称为<code>i-number</code>）引用，我们之前称之为文件的底层名称。在vsfs（以及其他简单的文件系统中），给定一个<code>i-number</code>，您应该能够直接计算出对应<code>inode</code>位于磁盘上的位置。例如，以上述的vsfs inode表为例：：大小为20KB（5个4KB块），因此包含80个inodes（假设每个inode为256字节）；进一步假设inode区域从12KB开始（即超级块从0KB开始，inode位图在地址4KB处，数据位图在8KB处，因此inode表紧随其后）。在vsfs中，我们因此有以下布局来表示文件系统分区开头部分的情况（特写视图）:</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=small" data-sub-html="<h2>image-20240417125143762</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png" alt="image-20240417125143762" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=large 2x" data-title="image-20240417125143762" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>要读取number为 32 的 inode，文件系统首先要计算 inode 区域的偏移量（$32 \cdot sizeof (inode)$ 或 $8192$），将其与磁盘上 inode 表的起始地址（<code>inodeStartAddr = 12KB</code>）相加，从而得出所需 inode 块的正确字节地址：20KB。回想一下，磁盘不是字节寻址的，而是由大量可寻址扇区（通常为 512 字节）组成。因此，要获取包含 inode 32 的 inode 块，文件系统将向 $\frac{20×1024}{512}$ 扇区或 40 扇区发出读取命令，以获取所需的 inode 块。更一般地说，inode 块的扇区地址<code>sector</code>可按如下方式计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">inumber</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">inode_t</span><span class="p">))</span> <span class="o">/</span> <span class="n">blockSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">sector</span> <span class="o">=</span> <span class="p">((</span><span class="n">blk</span> <span class="o">*</span> <span class="n">blockSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">inodeStartAddr</span><span class="p">)</span> <span class="o">/</span> <span class="n">sectorSize</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>每个 <code>inode</code> 内部实际上包含了文件所需的所有信息：文件类型（例如常规文件、目录等）、大小、分配给它的块数、保护信息（例如谁拥有该文件、以及谁可以访问它）、一些时间信息，包括文件创建、修改或上次访问的时间，以及有关其数据块驻留在磁盘上的位置的信息（例如某种指针）。我们将有关文件的所有此类信息称为<strong>元数据</strong>；事实上，文件系统中除了纯用户数据之外的任何信息通常被称为<strong>元数据</strong>。 ext2中的一个inode示例如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=small" data-sub-html="<h2>image-20240417130232939</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png" alt="image-20240417130232939" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=large 2x" data-title="image-20240417130232939" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>inode 设计中最重要的决策之一是它如何引用数据块的位置。一种简单的方法是在 inode 内有一个或多个直接指针（磁盘地址）；每个指针指向属于该文件的一个磁盘块。这种方法是有限的：例如，如果您想要一个非常大的文件（例如，<strong>大于</strong>块大小乘以 inode 中的直接指针数量），那么您就不走运了。</p>
<h3 id="多级索引" class="heading-element"><span>3.2 多级索引</span>
  <a href="#%e5%a4%9a%e7%ba%a7%e7%b4%a2%e5%bc%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了支持更大的文件，文件系统设计者不得不在 inodes 中引入不同的结构。一种常见的想法是使用一种被称为<strong>间接指针</strong>的特殊指针。<font color="red">它不指向包含用户数据的块，而是指向包含更多指针的块，每个指针都指向用户数据。</font>因此，一个 inode 可能有一定数量的直接指针（如 12 个）和一个间接指针。如果文件长得足够大，就会分配一个间接块（来自磁盘的数据块区域），并将间接指针的 inode 插槽设置为指向它。假设有 4KB 的数据块和 4 字节的磁盘地址，则又增加了 1024 个指针；文件可以增长到 $(12 + 1024) \cdot 4K$ 或 4144KB。</p>
<p>毫不奇怪，在这种方法中，您可能希望支持更大的文件。要做到这一点，<font color="red">只需向inode添加另一个指针：双间接指针。</font>该指针指向一个包含指向间接块的指针的块，每个间接块都包含对数据块的指针。因此，双间接块增加了通过额外 $1024 × 1024$ 或 100 万个 4KB 块来扩展文件的可能性，换句话说支持超过 4GB 大小的文件。然而您可能需要更多，并且我们打赌您知道这将导致什么：<strong>三重间接指针</strong>。</p>
<p>总体而言，这种不平衡树被称为多级索引方法来定位文件块。让我们以十二个直接指针为例进行研究，并且还有单间接块和双间接块。假设每个块大小为 4 KB，并且每个指针占用 4 字节，则该结构可以容纳略大于 4 GB 大小的文件（即 $(12 +  1024 + 1024^2) × 4 KB）$。您能计算出通过添加三重间接块可以处理多大尺寸的文件吗？（$1024^3$）</p>
<p>许多文件系统使用多级索引，其中包括常用文件系统如 Linux ext2和ext3、NetApp 的WAFL ，以及原始 UNIX 文件系统等等 。其他一些文件系统如 SGI XFS 和 Linux ext4 使用<strong>范围</strong>而不是简单指针（它们类似于虚拟内存讨论中段）。</p>
<blockquote>
<center>考虑基于范围的方法
</center>
<p>另一种方法是使用范围而不是指针。范围只是一个磁盘指针加上一个长度（以块为单位）；因此，不需要为文件的每个块提供一个指针，而只需要一个指针和一个长度来指定文件在磁盘上的位置。只有单个范围是有限的，因为在分配文件时可能很难找到磁盘上连续的可用空间块。因此，基于盘区的文件系统通常允许多个盘区，从而在文件分配期间为文件系统提供了更多的自由度。</p>
<p>比较这两种方法，基于指针的方法最灵活，但每个文件使用大量元数据（特别是对于大文件）。基于范围的方法不太灵活，但更紧凑；特别是，当磁盘上有足够的可用空间并且文件可以连续布置时（这实际上是任何文件分配策略的目标），它们可以很好地工作。</p>
</blockquote>
<p>您可能想知道：为什么要使用这样的不平衡树？为什么不采用其他方法呢？事实证明，许多研究人员研究了文件系统及其使用方式，几乎每次他们都会发现几十年来一直存在的某些“真理”。其中一项发现是大多数文件都很小。这种不平衡的设计反映了这样的现实；如果大多数文件确实很小，那么针对这种情况进行优化是有意义的。因此，使用少量的直接指针（典型数字为 12），一个 inode 可以直接指向 48 KB 的数据，而对于较大的文件则需要一个（或多个）间接块。Agrawal等人 最近的一项研究总结了这些结果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=small" data-sub-html="<h2>image-20240417143438784</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png" alt="image-20240417143438784" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=large 2x" data-title="image-20240417143438784" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当然，在inode设计的空间中，还存在许多其他的可能性；毕竟，inode 只是一种数据结构，任何存储相关信息并能够有效查询的数据结构就足够了。由于文件系统软件很容易更改，因此如果工作负载或技术发生变化，您应该愿意探索不同的设计。</p>
<h2 id="目录组织" class="heading-element"><span>4 目录组织</span>
  <a href="#%e7%9b%ae%e5%bd%95%e7%bb%84%e7%bb%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在 vsfs 中（与许多文件系统一样），目录的组织很简单；目录基本上只包含（条目名称，inode number）对的列表。对于给定目录中的每个文件或目录，目录的数据块中有一个字符串和一个数字。对于每个字符串，也可能有一个长度（假设名称可变）。</p>
<p>例如，假设目录 <code>dir</code>（inode number为 5）中包含三个文件（<code>foo</code>、<code>bar</code> 和 <code>foobar_is_a_pretty_longname</code> ），inode number分别为 12、13 和 24。 <code>dir</code> 的磁盘数据可能如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=small" data-sub-html="<h2>image-20240417150136421</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png" alt="image-20240417150136421" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=large 2x" data-title="image-20240417150136421" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，每个条目都有一个 inode number、记录长度（名称的总字节数加上任何剩余空间）、字符串长度（名称的实际长度），最后是条目的名称。请注意，每个目录都有两个额外的条目：<code>.</code>点 &ldquo;和<code>..</code>. &ldquo;点-点&rdquo;；点目录只是当前目录（本例中为 <code>dir</code>），而点-点是父目录（本例中为根目录）。</p>
<p>删除文件（例如调用 <code>unlink()</code>）可能会在目录中间留下一个空位，因此也应该有某种方法来标记这个空位（例如使用保留的 inode number，如 0）。这种删除是使用记录长度的原因之一：新的条目可能会重复使用旧的、更大的条目，因此会有额外的空间。</p>
<blockquote>
<center>基于链接的方法</center>
<p>设计 inode 的另一种更简单的方法是使用链表。因此，在inode内，您不需要多个指针，而只需要一个指针来指向文件的第一个块。要处理更大的文件，请在该数据块的末尾添加另一个指针，依此类推，这样就可以支持大文件。</p>
<p>正如您可能已经猜到的，链接文件分配对于某些工作负载来说表现不佳；例如，考虑读取文件的最后一个块，或者只是进行随机访问。因此，为了使链接分配更好地工作，一些系统将在内存中保留链接信息表，而不是将下一个指针与数据块本身一起存储。该表由数据块D的地址索引；条目的内容只是 D 的下一个指针，即文件中 D 后面的下一个块的地址。空值也可能存在（指示文件结束），或者其他一些标记来指示特定块是空闲的。拥有这样的下一个指针表使得链接分配方案可以有效地进行随机文件访问，只需首先扫描（在内存中）表以找到所需的块，然后直接访问（在磁盘上）它。</p>
<p>这样的表是不是听起来很熟悉？我们所描述的是<strong>文件分配表</strong>或 <strong>FAT</strong> 文件系统的基本结构。是的，这个经典的旧 Windows 文件系统（在 NTFS之前）基于简单的基于链接的分配方案。与标准 UNIX 文件系统还存在其他差异；例如，本身没有inodes，而是存储有关文件的元数据并直接引用该文件的第一个块的目录条目，这使得创建硬链接变得不可能。</p>
</blockquote>
<p>您可能想知道目录到底存储在哪里。通常，文件系统将目录视为一种特殊类型的文件。因此，<font color="red">目录在 inode 表中的某个位置有一个 inode（inode 的 type 字段标记为“目录”而不是“常规文件”）。</font>该目录具有inode指向的数据块（也许还有间接块）；这些数据块位于我们简单文件系统的数据块区域中。因此，我们的磁盘结构保持不变。</p>
<p>我们还应该再次注意，这个简单的线性目录条目列表并不是存储此类信息的唯一方法。和以前一样，任何数据结构都是可能的。例如，XFS以 B 树形式存储目录，使文件创建操作（必须确保文件名在创建之前未使用过）比具有必须在其目录中完整扫描的简单列表的系统更快。</p>
<h2 id="空闲空间管理" class="heading-element"><span>5 空闲空间管理</span>
  <a href="#%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>文件系统必须跟踪哪些 inodes 和数据块是空闲的，哪些不是，以便在分配新文件或目录时能为其找到空间。因此，<strong>空闲空间管理</strong>对所有文件系统都很重要。在 vsfs 中，我们有两个简单的位图可以完成这项任务。</p>
<p>例如，当我们创建一个文件时，必须为该文件分配一个 inode。因此，文件系统将在位图中搜索空闲的 inode，并将其分配给文件；文件系统必须将 inode 标记为已用（用 1 表示），并最终用正确的信息更新磁盘位图。在分配数据块时，也会进行类似的操作。</p>
<p>在为新文件分配数据块时，还可能需要考虑一些其他因素。例如，一些 Linux 文件系统（如 <code>ext2</code> 和 <code>ext3</code>）在创建新文件并需要数据块时，会寻找一连串空闲的块（如 8 个）；通过找到这样一连串空闲的块，然后将它们分配给新创建的文件，文件系统可以保证文件的一部分在磁盘上是连续的，从而提高性能。因此，这种预分配策略是为数据块分配空间时常用的启发式方法。</p>
<blockquote>
<p>管理可用空间的方法有很多种；位图只是一种方式。一些早期的文件系统使用空闲列表，其中超级块中的单个指针被保留指向第一个空闲块；在该块内，保留下一个空闲指针，从而形成系统空闲块的列表。当需要一个块时，使用头块并相应地更新列表。</p>
<p>现代文件系统使用更复杂的数据结构。例如，SGI 的 XFS使用某种形式的 B 树来紧凑地表示磁盘的哪些块是空闲的。与任何数据结构一样，不同的时空权衡都是可能的。</p>
</blockquote>
<h2 id="访问路径读写" class="heading-element"><span>6 访问路径：读写</span>
  <a href="#%e8%ae%bf%e9%97%ae%e8%b7%af%e5%be%84%e8%af%bb%e5%86%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>既然我们对文件和目录在磁盘上的存储方式有了一定的了解，我们就应该能够在读取或写入文件的过程中跟踪操作流程。因此，了解访问路径上发生的事情是理解文件系统如何工作的第二个关键；请注意！</p>
<p>在下面的示例中，我们假设文件系统已经加载，因此超级块已经在内存中。其他一切（即 inodes、目录）仍在磁盘上。</p>
<h3 id="从磁盘读取文件" class="heading-element"><span>6.1 从磁盘读取文件</span>
  <a href="#%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在这个简单的示例中，我们首先假设您只想简单地打开一个文件（例如 <code>/foo/bar</code>），读取它，然后关闭它。对于这个简单的示例，我们假设文件大小仅为 12KB（即 3 个块）。</p>
<p>当发出 <code>open(&quot;/foo/bar&quot;, O RDONLY)</code> 调用时，文件系统首先需要找到文件 <code>bar</code> 的 <code>inode</code>，以获取有关文件的一些基本信息（权限信息、文件大小等） 。为此，文件系统必须能够找到inode，但它现在拥有的只是完整路径名。文件系统必须遍历路径名，从而找到所需的inode。</p>
<p>所有遍历都从文件系统的根目录（简称为 <code>/</code>）开始。因此，FS首先从磁盘读取的是根目录的inode。但是这个索引节点在哪里呢？要找到一个 inode，我们必须知道它的 i-number。通常，我们在其父目录中查找文件或目录的 i-number；根没有父父目录（根据定义）。因此，根 inode number必须是“众所周知的”；当文件系统被挂载时，FS必须知道它是什么。在大多数 UNIX 文件系统中，根 inode number为 2。因此，为了开始该过程，FS 读取包含 inode number为2 的块（第一个 inode 块）。</p>
<p>一旦读入 inode，FS 就可以在其中查找指向数据块的指针，其中包含根目录的内容。因此，FS 将使用这些磁盘上的指针来读取目录，在本例中查找 <code>foo</code> 的条目。通过读入一个或多个目录数据块，它将找到 <code>foo</code> 的条目；一旦找到，FS 也将找到接下来需要的 <code>foo</code> 的 inode number（假设是 44）。</p>
<p>下一步是递归遍历路径名，直到找到所需的 inode。在这个例子中，FS读取包含<code>foo</code>的inode的块，然后读取其目录数据，最后找到<code>bar</code>的inode number。 <code>open()</code> 的最后一步是将 <code>bar</code> 的 inode 读入内存；然后，FS 进行<strong>最终的权限检查</strong>，在每个进程的打开文件表中为此进程分配一个文件描述符，并将其返回给用户。</p>
<p>打开后，程序可以发出 <code>read()</code> 系统调用来读取文件。因此，第一次读取（在偏移量 0 处，除非已调用 <code>lseek()</code>）将读取文件的第一个块，并查询 <code>inode</code> 以查找该块的位置；它还可能用新的上次访问时间更新inode。读取将进一步更新该文件描述符的内存中打开文件表，更新文件偏移量，以便下一次读取将读取第二个文件块等。</p>
<p>在某个时刻，文件将被关闭。这里要做的工作要少得多；显然，文件描述符应该被释放，但现在，这就是 FS 真正需要做的。不发生任何磁盘 I/O。</p>
<p>下图描述了整个过程；时间在图中向下增加。在图中，打开文件会导致发生大量读取，以便最终找到文件的 inode。之后，读取每个块需要文件系统首先查看 inode，然后读取该块，然后通过写入更新 inode 的上次访问时间字段。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=small" data-sub-html="<h2>image-20240417154339356</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png" alt="image-20240417154339356" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=large 2x" data-title="image-20240417154339356" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>另请注意，打开操作生成的 I/O 量与路径名的长度成正比。对于路径中的每个附加目录，我们必须读取其inode及其数据。大型目录的存在会使情况变得更糟；在这里，我们只需要读取一个数据块来获取目录的内容，而对于一个大目录，我们可能需要读取许多数据块才能找到所需的条目。</p>
<h3 id="从磁盘写入文件" class="heading-element"><span>6.2 从磁盘写入文件</span>
  <a href="#%e4%bb%8e%e7%a3%81%e7%9b%98%e5%86%99%e5%85%a5%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>写入文件的过程与此类似。首先，必须打开文件（如上所述）。然后，应用程序可以发出 <code>write()</code> 调用，用新内容更新文件。最后，关闭文件。</p>
<p>与读取不同的是，向文件写入也可能<strong>分配</strong>一个数据块（除非该数据块被覆盖等）。在写入一个新文件时，每次写入不仅要向磁盘写入数据，还要首先决定向文件分配哪个块，并相应地更新磁盘的其他结构（如数据位图和 inode）。因此，对文件的每次写入在逻辑上会产生 5 次 I/O：</p>
<ul>
<li>一次读取数据位图（然后更新数据位图，将新分配的块标记为已使用）；</li>
<li>一次写入数据位图（将其新状态反映到磁盘上）；</li>
<li>两次读取并写入 inode（根据新块的位置更新 inode）；</li>
<li>最后一次写入实际块本身。</li>
</ul>
<p>如果考虑到创建文件这种简单而常见的操作，写入流量甚至会更大。要创建一个文件，文件系统不仅要分配一个 inode，还要在包含新文件的目录中分配空间。这样做的 I/O 总流量相当大：</p>
<ul>
<li>一次读取 inode 位图（查找空闲的 inode）；</li>
<li>一次写入 inode 位图（标记已分配）；</li>
<li>一次写入新 inode 本身（初始化）；</li>
<li>一次写入目录数据（将文件的高级名称与其 inode number联系起来）；</li>
<li>以及一次读取和写入目录 inode 以更新它。</li>
</ul>
<p>如果目录需要增长以容纳新的条目，还需要额外的 I/O（即数据位图和新目录块）。所有这些都只是为了创建一个文件！</p>
<p>让我们看一个具体的示例，其中创建了文件 <code>/foo/bar</code>，并向其中写入了三个块。下图显示了 <code>open()</code>（创建文件）期间以及三个 4KB 写入的每一个期间发生的情况。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=small" data-sub-html="<h2>image-20240417160026092</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png" alt="image-20240417160026092" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=large 2x" data-title="image-20240417160026092" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，对磁盘的读取和写入按照引起它们发生的系统调用进行分组，并且它们可能发生的粗略顺序从图的顶部到底部。您可以看到创建文件的工作量：在本例中需要 10 个 I/O，遍历路径名，然后最终创建文件。您还可以看到，每次分配写入都会花费 5 个 I/O：一对读取和更新 inode，另一对读取和更新数据位图，最后写入数据本身。</p>
<p>文件系统如何以合理的效率完成这些任务？即使是最简单的操作，如打开、读取或写入文件，也会产生大量分散在磁盘上的 I/O 操作。文件系统如何才能降低这么多 I/O 操作带来的高昂成本呢？</p>
<h2 id="缓存和缓冲" class="heading-element"><span>7 缓存和缓冲</span>
  <a href="#%e7%bc%93%e5%ad%98%e5%92%8c%e7%bc%93%e5%86%b2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如上面的例子所示，读写文件的成本很高，需要对（慢速）磁盘进行多次 I/O。大多数文件系统都会积极使用系统内存（DRAM）来缓存重要的数据块，以解决明显存在的巨大性能问题。</p>
<p>想象一下上面的打开示例：如果没有缓存，每次打开文件都需要对目录层次结构中的每一级进行至少两次读取（一次读取相关目录的 inode，至少一次读取其数据）。对于长路径名（例如，<code>/1/2/3/.../100/file.txt</code>），文件系统光是打开文件就需要执行数百次读取！</p>
<p>因此，早期的文件系统引入了<strong>固定大小的缓存</strong>来保存常用数据块。就像我们在讨论虚拟内存时一样，LRU 等策略和不同的变体将决定在缓存中保留哪些区块。这种固定大小的缓存通常在启动时分配，大约占总内存的 10%。</p>
<p>然而，这种<strong>静态的内存分区</strong>可能会造成浪费；如果文件系统在某个时间点不需要 10%的内存怎么办？如果采用上述固定大小的方法，文件缓存中未使用的页面就无法重新用于其他用途，从而造成浪费。</p>
<p>相比之下，现代系统采用的<strong>是动态分区方法</strong>。具体来说，许多现代操作系统<font color="red">将虚拟内存页和文件系统页整合到统一的页面缓存中。</font>这样，内存就可以更灵活地分配给虚拟内存和文件系统，具体取决于哪个系统在特定时间需要更多内存。</p>
<blockquote>
<center>了解静态与静态动态分区
</center>
<p>在不同的客户端/用户之间划分资源时，可以使用<strong>静态分区或动态分区</strong>。静态方法只是将资源一次划分为固定比例；例如，如果有两个可能的内存用户，您可以将一些固定部分的内存分配给一个用户，并将其余部分分配给另一个用户。动态方法更加灵活，随着时间的推移提供不同数量的资源；例如，一个用户可能在一段时间内获得较高百分比的磁盘带宽，但随后，系统可能会切换并决定为不同的用户提供更大比例的可用磁盘带宽。</p>
<p>每种方法都有其优点。静态分区可确保每个用户获得一定的资源份额，通常可以提供更可预测的性能，并且通常更容易实现。动态分区可以实现更好的利用率（通过让资源匮乏的用户消耗原本空闲的资源），但实现起来可能更复杂，并且如果用户的闲置资源被其他用户占用，在需要时需要很长时间才能收回，则会导致性能下降。通常情况下，没有最好的方法；相反，你应该思考手头的问题，然后决定哪种方法最合适。</p>
</blockquote>
<p>现在想象一下带缓存的文件打开示例。第一次打开可能会产生大量的 I/O 流量来读取目录 inode 和数据，但同一文件（或同一目录中的文件）的后续文件打开大部分会在缓存中进行，因此不需要 I/O。</p>
<p>我们还要考虑缓存对写入的影响。如果缓存足够大，就可以完全避免读取 I/O，而写入流量必须进入磁盘才能持久化。因此，缓存对写入流量的过滤器与对读取流量的过滤器不同。也就是说，写缓冲确实具有许多性能优势。</p>
<ul>
<li>首先，<font color="red">通过延迟写入，文件系统可以将一些更新批处理到较小的一组 I/O 中</font>；例如，如果在创建一个文件时更新inode位图，然后在创建另一个文件时更新inode位图，则文件系统会通过在第一次更新后延迟写入来节省 I/O。</li>
<li>其次，<font color="red">通过在内存中缓冲大量写入，系统可以调度后续 I/O，从而提高性能。</font></li>
<li>最后，<font color="red">有些写入可以通过延迟来完全避免。例如，如果应用程序创建了一个文件然后将其删除，则延迟写入以将文件创建反映到磁盘可以完全避免它们。</font>在这种情况下，懒惰（将块写入磁盘）是一种美德。</li>
</ul>
<p>基于上述原因，大多数现代文件系统都会在内存中缓冲写入 5 到 30 秒，这也是另一种权衡：如果系统在更新传播到磁盘之前崩溃，更新就会丢失；但是，如果在内存中保留更长时间，就可以通过批处理、调度甚至避免写入来提高性能。</p>
<blockquote>
<center>了解持久/性能的权衡</center>
<p>存储系统通常会向用户提供持久/性能的权衡。如果用户希望写入的数据立即持久，系统必须全力将新写入的数据提交到磁盘，因此写入速度很慢（但安全）。但是，如果用户可以容忍少量数据的丢失，系统可以在内存中缓冲写入一段时间，然后将其写入磁盘（在后台）。这样做会使写入看起来很快完成，从而提高感知性能；但是，如果发生崩溃，尚未提交到磁盘的写入将会丢失，因此需要进行权衡。要了解如何正确进行这种权衡，最好了解使用存储系统的应用程序需要什么；例如，虽然丢失网络浏览器下载的最后几张图像可能是可以容忍的，但丢失向您的银行帐户添加资金的数据库事务的一部分可能会更难以容忍。</p>
</blockquote>
<p>有些应用程序（如数据库）并不喜欢这种权衡。因此，为了避免因写入缓冲而造成意外数据丢失，它们只需通过调用<code>fsync()</code>、使用绕过缓存的<strong>直接 I/O 接口</strong>或使用<strong>原始磁盘接口</strong>来强制写入磁盘，从而完全避开文件系统。虽然大多数应用程序都能接受文件系统的取舍，但如果默认情况不能令人满意，也有足够的控制措施让系统按照你的意愿行事。</p>
]]></description></item><item><title>文件和目录</title><link>https://hezephyr.github.io/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</link><pubDate>Sat, 11 May 2024 21:04:20 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</guid><description><![CDATA[<h2 id="文件和目录" class="heading-element"><span>1 文件和目录</span>
  <a href="#%e6%96%87%e4%bb%b6%e5%92%8c%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>随着时间的推移，在存储虚拟化过程中形成了两个关键的抽象概念。第一个是文件。文件只是一个由字节组成的线性数组，每个字节都可以读写。每个文件都有某种底层名称，通常是某个数字；通常情况下，用户并不知道这个名称（我们将看到）。由于历史原因，文件的底层名称通常被称为其inode number（索引节点号）。</p>
<p>在大多数系统中，操作系统并不了解文件的结构（例如，它是图片、文本文件还是 C 代码）；相反，<font color="red">文件系统的职责仅仅是将这些数据持久地存储在磁盘上</font>，并确保当你再次请求数据时，你能得到当初放在那里的数据。做到这一点并不像看起来那么简单！</p>
<p>第二个抽象概念是目录。目录和文件一样，也有一个底层名称（即inode number），但其内容却非常具体：它包含一个（用户可读名称、底层名称）对列表。例如，假设有一个底层名称为 &ldquo;10 &ldquo;的文件，用户可读文件名为 &ldquo;foo&rdquo;。因此，&ldquo;foo &ldquo;所在的目录就会有一个条目（&ldquo;foo&rdquo;, &ldquo;10&rdquo;），将用户可读名称映射到底层名称。<font colro="red">目录中的每个条目都指向文件或其他目录</font>。通过将目录放置在其他目录中，用户可以建立一个任意的目录树（或目录层次结构），所有文件和目录都存储在该目录下。</p>
<p>目录层次结构从根目录开始（在基于 UNIX 的系统中，根目录简称为 <code>/</code>），并使用某种分隔符来命名随后的子目录，直到所需的文件或目录被命名为止。例如，如果用户在根目录<code>/</code>中创建了一个目录 <code>foo</code>，然后在目录 <code>foo</code> 中创建了一个文件 <code>bar.txt</code>，我们可以通过其<strong>绝对路径名</strong>来引用该文件，在本例中为 <code>/foo/bar.txt</code> 。更复杂的目录树如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=small" data-sub-html="<h2>image-20240416102432763</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png" alt="image-20240416102432763" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=large 2x" data-title="image-20240416102432763" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>示例中的有效目录为 <code>/</code>、<code>/foo</code>、<code>/bar</code>、<code>/bar/bar</code>、<code>/bar/foo</code>，有效文件为 <code>/foo/bar.txt</code> 和 <code>/bar/foo/bar.txt</code>。目录和文件可以具有相同的名称，只要它们位于文件系统树中的不同位置即可（例如，图中有两个名为 <code>bar.txt</code> 的文件，<code>/foo/bar.txt</code> 和 <code>/bar/foo/bar.txt</code>）。</p>
<p>您可能还注意到，此示例中的文件名通常由两部分组成：<code>bar</code> 和 <code>txt</code>，以<code>.</code>分隔。第一部分是任意名称（描述文件），而文件名的第二部分通常用于指示文件的类型，例如，它是 C 代码（例如<code>.c</code>）还是图像（例如 <code>.jpg</code>） ，或音乐文件（例如<code>.mp3</code>）。然而，这通常只是一个约定：通常没有强制规定名为 <code>main.c</code> 的文件中包含的数据确实是 C 源代码。</p>
<p>因此，我们可以看到文件系统提供的一件伟大的事情：一种命名我们感兴趣的所有文件的便捷方法。名称在系统中很重要，因为访问任何资源的第一步就是能够命名它。因此，在 UNIX 系统中，文件系统提供了一种统一的方式来访问磁盘、U盘、CD-ROM、许多其他设备以及事实上还有许多其他东西，它们都位于同一个目录树下。</p>
<h2 id="文件系统接口" class="heading-element"><span>2 文件系统接口</span>
  <a href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="文件操作" class="heading-element"><span>2.1 文件操作</span>
  <a href="#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="创建文件" class="heading-element"><span>2.1.1 创建文件</span>
  <a href="#%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们将从最基本的操作开始：创建文件。这可以通过 <code>open</code> 系统调用来实现；调用 <code>open()</code> 并传递 <code>O_CREAT</code> 标志，程序就可以创建一个新文件。下面是一些示例代码，用于在当前工作目录下创建一个名为 &ldquo;foo &ldquo;的文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>例程<code>open()</code> 使用多个不同的标志。在本例中，如果文件不存在，第二个参数会创建文件（<code>O_CREAT</code>），确保该文件只能被写入（<code>O_WRONLY</code>），并且如果文件已经存在，则将其截断为 0 字节大小，从而删除任何现有内容（<code>O_TRUNC</code>）。第三个参数指定权限，在这种情况下，文件所有者可以读写文件。</p>
<p><code>open()</code> 的一个重要方面是它的返回值：<strong>文件描述符</strong>。<font color="red">文件描述符只是一个整数，每个进程都是私有的，在 UNIX 系统中用于访问文件</font>；因此，一旦文件被打开，你就可以使用文件描述符来读取或写入文件，前提是你有这样做的权限。因此，文件描述符是一种能力，即一个不透明的句柄，它赋予你执行某些操作的权力。另一种将文件描述符视为指向文件类型对象的指针的方法是：一旦你有了这样一个对象，你就可以调用其他 &ldquo;方法 &ldquo;来访问文件，如<code>read()</code>和 <code>write()</code>。如上所述，文件描述符由操作系统按进程进行管理。这意味着在 UNIX 系统的 <code>proc</code> 结构中保存了某种简单的结构（如数组）。下面是 xv6 内核中的相关内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">proc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span> <span class="c1">// Open files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一个简单数组（最多包含 <code>NOFILE</code> 打开的文件）可以跟踪每个进程打开了哪些文件。数组的每个条目实际上只是一个指向<code>struct file</code>的指针，它将用于跟踪正在读取或写入的文件信息。</p>
<h4 id="读写文件" class="heading-element"><span>2.1.2 读写文件</span>
  <a href="#%e8%af%bb%e5%86%99%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><h5 id="顺序读写" class="heading-element"><span>2.1.2.1 顺序读写</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e8%af%bb%e5%86%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>有了一些文件后，我们当然会想读取或写入它们，让我们从读取一个现有文件开始。如果我们在命令行中输入，我们可能只使用程序 <code>cat</code> 将文件的内容转储到屏幕上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s1">&#39;Hello, World&#39;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; cat foo
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>在此代码片段中，我们将程序 <code>echo</code> 的输出重定向到文件 <code>foo</code>，然后该文件中包含内容“Hello, World”。然后我们使用 <code>cat</code> 来查看文件的内容。但是<code>cat</code>程序如何访问文件<code>foo</code>呢？</p>
<p>为了找到这一点，我们将使用一个非常有用的工具来跟踪程序进行的系统调用。在 Linux 上，该工具称为 <code>strace</code>；其他系统也有类似的工具（请参阅 Mac 上的 <code>dtruss</code>，或某些较旧的 UNIX 变体上的 <code>truss</code>）。 <code>strace</code> 的作用是跟踪程序运行时所做的每个系统调用，并将跟踪转储到屏幕上供您查看。</p>
<p>下面是一个使用 <code>strace</code> 来确定 <code>cat</code> 正在做什么的示例（为了便于阅读，删除了一些调用）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; strace cat foo
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">openat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;foo&#34;</span>, O_RDONLY<span class="p">|</span>O_LARGEFILE<span class="o">)</span>       <span class="o">=</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">read<span class="o">(</span>3, <span class="s2">&#34;Hello, World\n&#34;</span>, 131072<span class="o">)</span>       <span class="o">=</span> <span class="m">13</span>
</span></span><span class="line"><span class="cl">write<span class="o">(</span>1, <span class="s2">&#34;Hello, World\n&#34;</span>, 13<span class="o">)</span>          <span class="o">=</span> <span class="m">13</span>
</span></span><span class="line"><span class="cl">Hello, World
</span></span><span class="line"><span class="cl">read<span class="o">(</span>3, <span class="s2">&#34;&#34;</span>, 131072<span class="o">)</span>                     <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">close<span class="o">(</span>3<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">+++ exited with <span class="m">0</span> +++</span></span></code></pre></td></tr></table>
</div>
</div><p>cat 做的第一件事是打开文件进行读取。我们应该注意以下几点：</p>
<ol>
<li>首先，该文件仅打开用于读取（而不是写入），如 <code>O_RDONLY 标志</code>所示；</li>
<li>其次，使用 64 位偏移量 (<code>O_LARGEFILE</code>)；</li>
<li>第三，对 <code>openat()</code>（和<code>oepn()</code>一样）的调用成功并返回一个文件描述符，其值为 3。</li>
</ol>
<p>为什么第一次调用 <code>openat()</code> 返回 3，而不是您可能期望的 0 或 1？事实证明，<font color="red">每个正在运行的进程已经打开了三个文件：标准输入（进程可以读取以接收输入）、标准输出（进程可以写入以将信息转储到屏幕）和标准错误（进程可以向其写入错误消息）</font>。它们分别由文件描述符 0、1 和 2 表示。因此，当您第一次打开另一个文件时（如上面的 cat 所做的那样），它几乎肯定是文件描述符 3。</p>
<p>打开成功后，<code>cat</code> 会使用 <code>read()</code> 系统调用从文件中重复读取一些字节。</p>
<ol>
<li><code>read()</code> 的第一个参数是文件描述符，它告诉文件系统要读取哪个文件；当然，一个进程可能同时打开多个文件，因此描述符能让操作系统知道某个特定读取指向哪个文件。</li>
<li>第二个参数指向一个缓冲区，<code>read()</code>的结果将放置在这个缓冲区中；在上面的系统调用跟踪中，<code>strace</code> 在这个位置（&ldquo;Hello, World&rdquo;）显示了读取的结果。</li>
<li>第三个参数是缓冲区的大小，在本例中为 131072 B。对 <code>read()</code> 的调用也成功返回，这里返回的是读取的字节数（13，其中 12 个字节表示 &ldquo;Hello, World&quot;中的字符，1 个字节表示行结束标记）。</li>
</ol>
<p>此时，你会看到 <code>strace</code> 的另一个有趣结果：对 <code>write()</code> 系统调用的一次调用，调用的是文件描述符 1。如上文所述，这个描述符被称为标准输出，因此它被用来将 &ldquo;Hello, World&quot;这个字符串写到屏幕上，就像 <code>cat</code> 程序要做的那样。但它会直接调用 <code>write()</code> 吗？也许会（如果高度优化的话）。但如果没有，<code>cat</code>程序可能会调用库例程 <code>printf()</code>；<code>printf()</code> 会在内部计算出传给它的所有格式细节，并最终写入标准输出，将结果打印到屏幕上。</p>
<p>然后，<code>cat</code> 程序尝试从文件中读取更多信息，但由于文件中已经没有字节了，<code>read()</code> 返回 <code>0</code>，程序知道这意味着它已经读完了整个文件。因此，程序会调用 <code>close()</code> 来表示它已经读完了文件 &ldquo;foo&rdquo;，并传入相应的文件描述符。文件就这样关闭了，文件的读取也就完成了。</p>
<p>写文件的步骤与此类似。首先，打开一个文件进行写入，然后调用 <code>write()</code> 系统调用，对于较大的文件，可能会重复调用，最后关闭 <code>write()</code>。使用 <code>strace</code> 来跟踪对文件的写入，或许是跟踪你自己编写的程序，或许是跟踪 <code>dd</code> 工具，例如 <code>dd if=foo of=bar</code>（从文件<code>foo</code>中读取数据，并将其写入到文件<code>bar</code>中）。</p>
<h5 id="非顺序读写" class="heading-element"><span>2.1.2.2 非顺序读写</span>
  <a href="#%e9%9d%9e%e9%a1%ba%e5%ba%8f%e8%af%bb%e5%86%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>到目前为止，我们已经讨论了如何读取和写入文件，但所有访问都是顺序的；也就是说，我们要么从头到尾读取一个文件，要么从头到尾写出一个文件。</p>
<p>然而，有时能够读取或写入文件中的特定偏移量是很有用的。例如，如果您在文本文档上构建索引，并使用它来查找特定单词，您最终可能会从文档中的一些随机偏移量中读取。为此，我们将使用 <code>lseek()</code> 系统调用。这是函数原型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>第一个参数是<code>filedes</code>的（文件描述符）。</li>
<li>第二个参数是<code>offset</code>，它将文件偏移量定位到文件中的特定位置。</li>
<li>第三个参数由于历史原因被称为 <code>whence</code>，它决定了寻找的具体执行方式。摘自<code>man  page: man lseek</code>：
<ul>
<li>如果<code>whence</code>是<code>SEEK_SET</code>，则偏移量设置为偏移字节。</li>
<li>如果<code>whence</code>是<code>SEEK_CUR</code>，则偏移量设置为其当前位置加上偏移字节。</li>
<li>如果<code>whence</code>是<code>SEEK_END</code>，则偏移量设置为文件的大小加上偏移量字节。</li>
</ul>
</li>
</ul>
<blockquote>
<center>数据结构——打开文件表</center>
<p><font color="red">每个进程都维护一个文件描述符数组，每个文件描述符都引用系统范围的<strong>打开文件表</strong>中的一个条目。</font>该表中的每个条目都会跟踪描述符引用的底层文件、当前偏移量以及其他相关详细信息，例如文件是否可读或可写。</p>
</blockquote>
<p>从上述描述中可以看出，对于进程打开的每个文件，操作系统都会跟踪一个 &ldquo;当前 &ldquo;偏移量，该偏移量决定了下一次读取或写入将从文件的哪个位置开始。因此，<font color="red">打开文件的抽象概念之一就是它有一个当前偏移量，该偏移量通过两种方式之一进行更新</font>。</p>
<ul>
<li>第一种方式是，当读取或写入 $N$ 个字节时，$N$ 会添加到当前偏移量中；<font color="red">因此每次读取或写入都会隐式更新偏移量</font>。</li>
<li>第二种方式是通过 <code>lseek</code> 来显式更新偏移量，如上文所述。</li>
</ul>
<p>正如你可能已经猜到的，偏移量保存在我们之前看到的<code>struct file</code>中，由 <code>struct proc</code> 引用。下面是该结构的 xv6（简化）定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">readable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">writable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如您在该结构中所看到的，操作系统可以使用它来确定打开的文件是否可读或可写（或两者）、它引用的底层文件（由 <code>struct inode</code> 指针 <code>ip</code> 指向）以及当前偏移量（<code>off</code>）。还有一个引用计数（<code>ref</code>），我们将在下面进一步讨论。</p>
<p>这些文件结构代表了系统中当前打开的所有文件；它们有时一起称为打开文件表。 xv6 内核也将它们保留为数组，每个条目有一个锁，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">file</span> <span class="n">file</span><span class="p">[</span><span class="n">NFILE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">ftable</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们通过几个例子来更清楚地说明这一点。首先，让我们跟踪一个打开文件（大小为 300 字节）并通过重复调用 <code>read()</code> 系统调用来读取该文件的进程，每次读取 100 字节。以下是相关系统调用的跟踪，以及每个系统调用返回的值，以及此文件访问的打开文件表中的当前偏移量的值：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=small" data-sub-html="<h2>image-20240416142836821</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png" alt="image-20240416142836821" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=large 2x" data-title="image-20240416142836821" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>跟踪中有几项值得注意。</p>
<ol>
<li>首先，您可以看到打开文件时当前偏移量如何初始化为零。</li>
<li>接下来，您可以看到它是如何随着进程的每次 <code>read()</code> 递增的；这使得进程可以轻松地继续调用 <code>read()</code> 来获取文件的下一个块。</li>
<li>最后，您可以看到最后尝试的 <code>read()</code> 超过文件末尾如何返回零，从而向进程表明它已完整读取文件。</li>
</ol>
<p>让我们跟踪一个打开同一个文件两次并向每个文件发出读取的进程。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=small" data-sub-html="<h2>image-20240416143511054</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png" alt="image-20240416143511054" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=large 2x" data-title="image-20240416143511054" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，分配了两个文件描述符（3 和 4），每个描述符都引用打开文件表中的不同条目（在本示例中，条目 <code>10</code> 和 <code>11</code>，如表标题所示；OFT 代表打开文件表）。如果您跟踪所发生的情况，您可以看到每个当前偏移量是如何独立更新的。</p>
<p>在最后一个示例中，进程在读取之前使用 <code>lseek()</code> 重新定位当前偏移量；在这种情况下，只需要一个打开文件表条目（与第一个示例相同）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=small" data-sub-html="<h2>image-20240416143932186</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png" alt="image-20240416143932186" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=large 2x" data-title="image-20240416143932186" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这里，<code>lseek()</code> 调用首先将当前偏移量设置为 200。随后的 <code>read()</code> 读取接下来的 50 个字节，并相应地更新当前偏移量。</p>
<blockquote>
<center>调用 LSEEK()不执行磁盘寻道</center>
<p><code>lseek()</code> 调用只是简单地改变操作系统内存中的一个变量，该变量跟踪了特定进程下一次读取或写入将从哪个偏移开始。当向磁盘发出读取或写入请求时，如果不在与上次读取或写入相同磁道上，则会发生磁头移动，这就是磁盘寻道。更令人困惑的是，通过调用 <code>lseek()</code> 从文件的随机部分进行读取或写入，并且接着对这些随机部分进行读取/写入，确实会导致更多的磁盘寻道。因此，调用<code>lseek()</code> 确实可能导致在即将进行的读取或写入中产生一次寻道，但绝对不会引起任何磁盘 I/O 操作本身发生。</p>
</blockquote>
<h4 id="共享文件表条目" class="heading-element"><span>2.1.3 共享文件表条目</span>
  <a href="#%e5%85%b1%e4%ba%ab%e6%96%87%e4%bb%b6%e8%a1%a8%e6%9d%a1%e7%9b%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在许多情况下（如上面的示例所示），文件描述符到打开文件表中的条目的映射是一对一的映射。例如，当一个进程运行时，它可能决定打开一个文件，读取它，然后关闭它；在此示例中，该文件将在打开的文件表中具有唯一的条目。<font color="red">即使其他进程同时读取同一个文件，每个进程也会在打开的文件表中拥有自己的条目</font>。这样，文件的每次逻辑读取或写入都是独立的，并且每次访问给定文件时都有自己的当前偏移量。</p>
<p>然而，有一些有趣的情况，打开文件表中的条目是共享的。其中一种情况发生在父进程使用 <code>fork()</code> 创建子进程时。下面显示了一个小代码片段，其中父级创建了一个子级，然后等待它完成。子进程通过调用 <code>lseek()</code> 调整当前偏移量，然后退出。最后，父进程在等待子进程后，检查当前偏移量并打印出其值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;file.txt&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">rc</span> <span class="o">=</span> <span class="nf">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child: offset %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: offset %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nf">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当我们运行这个程序时，我们会看到以下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ make fork-seek
</span></span><span class="line"><span class="cl">gcc -c fork-seek.c
</span></span><span class="line"><span class="cl">gcc fork-seek.o -o fork-seek
</span></span><span class="line"><span class="cl">❯ ./fork-seek
</span></span><span class="line"><span class="cl">child: offset <span class="m">10</span>
</span></span><span class="line"><span class="cl">parent: offset <span class="m">10</span></span></span></code></pre></td></tr></table>
</div>
</div><p>下图显示了连接每个进程私有描述符数组、共享打开文件表条目以及从它到底层文件系统 inode 的引用的关系。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Processes_Sharing_An_Open_File_Table_Entry.png" alt="image-20240416145540776" style="zoom:67%;" />
<p>请注意，我们最终在这里使用了<strong>引用计数</strong>。<font color="red">当文件表项被共享时，其引用计数会增加；只有当两个进程都关闭该文件（或退出）时，该条目才会被删除。</font></p>
<p>在父进程和子进程之间共享打开的文件表条目有时很有用。例如，如果您创建多个协作处理某项任务的进程，它们可以写入同一输出文件，而无需任何额外的协调。有关调用 <code>fork()</code> 时进程共享的内容的更多信息，请参阅手册页：<code>man fork</code>。</p>
<p>另一种有趣且可能更有用的共享情况发生在<code>dup()</code> 系统调用（及其非常相似的系统调用<code>dup2()</code> 甚至 <code>dup3()</code>）中。</p>
<p><code>dup()</code>调用允许进程创建一个新的文件描述符，该文件描述符引用与现有描述符相同的底层打开文件。下面这个代码片段展示了如何使用 <code>dup()</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;README&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd2</span> <span class="o">=</span> <span class="nf">dup</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 现在 fd 和 fd2 可以互换使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>dup()</code> 调用（特别是 <code>dup2()</code>）在编写 UNIX shell 和执行输出重定向等操作时非常有用，有以下几点：</p>
<ol>
<li><strong>标准流重定向：</strong> 在 shell 编程中，通常需要将标准输入、标准输出和标准错误流重定向到文件或者其他进程的管道中。通过 <code>dup()</code> 函数，可以复制文件描述符，并将其与标准流相关联，从而实现输出重定向操作。</li>
<li><strong>管道通信：</strong> 在 shell 中，管道用于将一个进程的输出连接到另一个进程的输入，以实现进程之间的通信。<code>dup()</code> 函数可以用于复制文件描述符，从而创建管道的输入和输出端口。</li>
<li><strong>文件描述符管理：</strong> 在大型 shell 脚本中，可能会涉及到大量的文件描述符操作。通过 <code>dup()</code> 函数，可以更方便地管理文件描述符，使得代码更加清晰易读。</li>
</ol>
<h4 id="使用-fsync-立即写入" class="heading-element"><span>2.1.4 使用 <code>fsync()</code> 立即写入</span>
  <a href="#%e4%bd%bf%e7%94%a8-fsync-%e7%ab%8b%e5%8d%b3%e5%86%99%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">大多数时候，当程序调用 <code>write()</code> 时，它只是告诉文件系统：请在将来的某个时刻将此数据写入持久存储</font>。出于性能原因，文件系统会将此类写入在内存中缓冲一段时间（例如 5 秒或 30 秒）；在稍后的时间点，写入实际上将被发送到存储设备。从调用应用程序的角度来看，写入似乎很快完成，并且只有在极少数情况下（例如，在 <code>write()</code> 调用之后但在写入磁盘之前机器崩溃）才会丢失数据。</p>
<p>然而，某些应用程序需要的不仅仅是这个最终保证。例如，在数据库管理系统（DBMS）中，正确的恢复协议的开发需要能够不时地强制写入磁盘。</p>
<p>为了支持这些类型的应用程序，大多数文件系统提供了一些额外的控制 API。在 UNIX 世界中，提供给应用程序的接口称为 <code>int fsync(int fd)</code>。当进程为特定文件描述符调用 <code>fsync()</code> 时，文件系统会通过将指定文件描述符引用的文件的所有<strong>脏（即尚未写入）数据</strong>强制写入磁盘来做出响应。一旦所有这些写入完成，<code>fsync()</code> 例程就会返回。</p>
<blockquote>
<p>flush的软刷新版本，相比于fsync，它更为柔和，因为它不直接将数据写入到磁盘中的持久存储，而是将用户空间级别的缓冲区中的数据刷新到操作系统的缓冲区（例如glibc中的缓冲区）。</p>
<p>具体来说，它的作用是将用户空间（应用程序）中的数据刷新到操作系统的内核缓冲区中，而不是直接写入磁盘。这使得数据在应用程序和操作系统之间进行了一次更柔和的传递，不需要等待数据真正写入磁盘，因此称为“柔和版本”。相比之下，fsync是一个更严格的操作，它要求将数据直接写入到磁盘中，确保数据的持久化，并等待写入完成的确认。</p>
</blockquote>
<p>下面这段代码如何使用 <code>fsync()</code> 的简单示例。该代码打开文件 foo，向其中写入单个数据块，然后调用 <code>fsync()</code> 以确保立即强制写入磁盘。一旦 <code>fsync()</code> 返回，应用程序就可以安全地继续前进，知道数据已被持久化（如果 <code>fsync()</code> 正确实现了）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">ssize_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="nf">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Data written to disk successfully.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有趣的是，这个序列并不能保证你所期望的一切；在某些情况下，你还需要对包含文件 <code>foo</code> 的目录进行 <code>fsync()</code>。添加这一步不仅能确保文件本身在磁盘上，还能确保文件（如果是新创建的）也能持久地成为目录的一部分。不足为奇的是，这类细节经常被忽视，从而导致许多应用程序级的错误&hellip;&hellip;</p>
<h4 id="重命名文件" class="heading-element"><span>2.1.5 重命名文件</span>
  <a href="#%e9%87%8d%e5%91%bd%e5%90%8d%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>一旦我们有了一个文件，有时为文件指定一个不同的名称会很有用。当在命令行中输入时，这是通过 <code>mv</code> 命令完成的；在此示例中，文件 <code>foo</code> 被重命名为 <code>bar</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ mv foo bar
</span></span><span class="line"><span class="cl">$ strace mv foo bar
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">rename<span class="o">(</span><span class="s2">&#34;foo&#34;</span>, <span class="s2">&#34;bar&#34;</span><span class="o">)</span>                    <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>strace</code>，我们可以看到 <code>mv</code> 使用了系统调用 <code>rename(char *old, char *new)</code>，它需要两个参数：文件的原始名称（<code>old</code>）和新名称（<code>new</code>）。</p>
<p><code>rename()</code>调用提供了一个有趣的保证，那就是它（通常）是作为与系统崩溃有关的原子调用实现的；如果系统在重命名过程中崩溃，文件要么被命名为旧名，要么被命名为新名，不会出现奇怪的中间状态。因此，<code>rename()</code> 对于支持某些需要对文件状态进行原子更新的应用程序至关重要。</p>
<p>让我们说得具体一点。想象一下，你正在使用一个文件编辑器（如 <code>emacs</code>），然后在文件中间插入一行。例如，文件名是 <code>foo.txt</code>。编辑器可能会更新文件，以保证新文件的内容与原来的内容一致，并加上插入的一行，具体方法如下（为简单起见，忽略了错误检查）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo.txt.tmp&#34;</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// write out new version of file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">rename</span><span class="p">(</span><span class="s">&#34;foo.txt.tmp&#34;</span><span class="p">,</span> <span class="s">&#34;foo.txt&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，编辑器所做的事情很简单：以临时名称 (<code>foo.txt.tmp</code>) 写出文件的新版本，使用 <code>fsync()</code> 将其强制写入磁盘，然后当应用程序确定新文件时元数据和内容都在磁盘上，将临时文件重命名为原始文件的名称。最后一步以原子方式将新文件交换到位，同时删除旧版本的文件，从而实现原子文件更新。</p>
<h4 id="获取文件信息" class="heading-element"><span>2.1.6 获取文件信息</span>
  <a href="#%e8%8e%b7%e5%8f%96%e6%96%87%e4%bb%b6%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>除了文件访问之外，我们期望文件系统保留有关其存储的每个文件的大量信息。通常我们称这些关于文件的数据为<strong>元数据</strong>。要查看特定文件的元数据，我们可以使用 <code>stat()</code> 或 <code>fstat()</code> 系统调用。这些调用接受一个路径名（或文件描述符）到一个文件，并填充一个如下所示的 <code>stat</code> 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">dev_t</span> <span class="n">st_dev</span><span class="p">;</span> <span class="cm">/* ID of device containing file */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ino_t</span> <span class="n">st_ino</span><span class="p">;</span> <span class="cm">/* inode number */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">mode_t</span> <span class="n">st_mode</span><span class="p">;</span> <span class="cm">/* protection */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">nlink_t</span> <span class="n">st_nlink</span><span class="p">;</span> <span class="cm">/* number of hard links */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uid_t</span> <span class="n">st_uid</span><span class="p">;</span> <span class="cm">/* user ID of owner */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">gid_t</span> <span class="n">st_gid</span><span class="p">;</span> <span class="cm">/* group ID of owner */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">dev_t</span> <span class="n">st_rdev</span><span class="p">;</span> <span class="cm">/* device ID (if special file) */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">st_size</span><span class="p">;</span> <span class="cm">/* total size, in bytes */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">blksize_t</span> <span class="n">st_blksize</span><span class="p">;</span> <span class="cm">/* blocksize for filesystem I/O */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">blkcnt_t</span> <span class="n">st_blocks</span><span class="p">;</span> <span class="cm">/* number of blocks allocated */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">st_atime</span><span class="p">;</span> <span class="cm">/* time of last access */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">st_mtime</span><span class="p">;</span> <span class="cm">/* time of last modification */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">st_ctime</span><span class="p">;</span> <span class="cm">/* time of last status change */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，每个文件都保存了大量信息，包括文件大小（以字节为单位）、底层名称（即 inode number）、一些所有权信息、文件被访问或修改的时间等。要查看这些信息，可以使用命令行工具<code>stat</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s1">&#39;Hello, World&#39;</span> &gt; file
</span></span><span class="line"><span class="cl">&gt; stat file
</span></span><span class="line"><span class="cl">  File: file
</span></span><span class="line"><span class="cl">  Size: <span class="m">13</span>        	Blocks: <span class="m">8</span>          IO Block: <span class="m">4096</span>   regular file
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1339196</span>     Links: <span class="m">1</span>
</span></span><span class="line"><span class="cl">Access: <span class="o">(</span>0664/-rw-rw-r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    zfhe<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    zfhe<span class="o">)</span>
</span></span><span class="line"><span class="cl">Access: 2024-04-16 19:10:20.591807830 +0800
</span></span><span class="line"><span class="cl">Modify: 2024-04-16 19:10:20.591807830 +0800
</span></span><span class="line"><span class="cl">Change: 2024-04-16 19:10:20.591807830 +0800
</span></span><span class="line"><span class="cl"> Birth: 2024-04-16 19:10:20.591807830 +0800</span></span></code></pre></td></tr></table>
</div>
</div><p>事实证明，每个文件系统通常将此类信息保存在称为 <code>inode</code>的结构中。当我们讨论文件系统实现时，我们将了解更多关于 <code>inode</code> 的知识。现在，您应该将<code>inode</code>视为由文件系统保存的持久数据结构，其中包含我们上面看到的信息。所有 <code>inode</code> 都驻留在磁盘上；活动副本通常缓存在内存中以加快访问速度。</p>
<h4 id="删除文件" class="heading-element"><span>2.1.7 删除文件</span>
  <a href="#%e5%88%a0%e9%99%a4%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>至此，我们知道如何创建文件并按顺序或不按顺序访问它们。但是如何删除文件呢？如果您使用过 UNIX，您可能认为您知道：只需运行 <code>rm</code> 程序即可。但是 <code>rm</code> 使用什么系统调用来删除文件呢？让我们再次使用<code>strace</code>来找出答案。这里我们删除文件“file”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; strace rm file
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">unlinkat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;file&#34;</span>, 0<span class="o">)</span>           <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div><p>我们已经从跟踪输出中删除了大量无关紧要的内容，只留下对神秘系统调用 <code>unlinkat()</code> 的一次调用。如你所见，<code>unlinkat()</code> 第一个参数<code>AT_FDCWD</code> 表示使用当前工作目录作为基础目录进行文件操作，第二个参数接受要删除的文件名，第三个是一个标志参数<code>0</code>，通常用于指定操作行为的一些选项，但在这种情况下，它是用来指示删除操作的默认行为，成功后返回 0。但这也给我们带来了一个巨大的谜团：为什么这个系统调用被命名为 &ldquo;unlink&rdquo;？为什么不直接使用 &ldquo;remove &ldquo;或 &ldquo;delete&quot;呢？要了解这个谜题的答案，我们首先必须了解的不仅仅是文件，还有目录。</p>
<blockquote>
<p>在Linux系统中，系统调用 <code>openat</code>、<code>unlinkat</code> 等带有 <code>at</code> 后缀的调用是为了提供更灵活的文件操作方式。这些带有 <code>at</code> 后缀的系统调用允许在指定的目录中执行文件操作，而不是在当前工作目录中。</p>
<p>这种设计的优点在于它允许程序员指定一个基础目录进行文件操作，而不必依赖于当前工作目录。这对于需要跨多个目录操作文件的程序尤其有用。例如，如果程序需要打开不在当前目录下的文件，而是相对于某个固定的基础目录，那么使用 <code>openat</code> 调用就可以轻松实现这一点。</p>
<p>因此，<code>openat</code>、<code>unlinkat</code> 等系统调用提供了更加灵活和安全的文件操作方式，使程序员可以更精确地控制文件操作的上下文。</p>
</blockquote>
<h3 id="目录操作" class="heading-element"><span>2.2 目录操作</span>
  <a href="#%e7%9b%ae%e5%bd%95%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除了文件之外，还可以使用一组与目录相关的系统调用来创建、读取和删除目录。请注意，<font color="red">您永远不能直接写入目录；由于目录的格式被视为文件系统元数据，因此您只能通过在其中创建文件、目录或其他对象类型等方式间接更新目录。</font>通过这种方式，文件系统可以确保目录的内容始终符合预期。</p>
<h4 id="创建目录" class="heading-element"><span>2.2.1 创建目录</span>
  <a href="#%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>要创建目录，可以使用单个系统调用 <code>mkdir()</code>。同名的 <code>mkdir</code> 程序可用于创建这样的目录。让我们看一下当我们运行 <code>mkdir</code> 程序来创建一个名为 <code>foo</code> 的简单目录时会发生什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; strace mkdir foo
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">mkdir<span class="o">(</span><span class="s2">&#34;foo&#34;</span>, 0777<span class="o">)</span>                      <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div><p>当创建这样的目录时，它被视为“empty”，尽管它确实具有最少的内容。具体来说，一个空目录有两个条目：一个条目引用其自身，另一个条目引用其父目录。前者被称为“.” （点）目录，后者为“..”（点-点）。其中根目录是文件系统的顶层目录，因此它没有父目录，在 UNIX 文件系统中，根目录的父目录通常被表示为自身，即指向自己。</p>
<p>您可以通过将标志 (<code>-a</code>) 传递给程序 <code>ls</code> 来查看这些目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -al foo
</span></span><span class="line"><span class="cl">total <span class="m">8</span>
</span></span><span class="line"><span class="cl">drwxrwxr-x <span class="m">2</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 19:48 .
</span></span><span class="line"><span class="cl">drwxrwxr-x <span class="m">3</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 19:48 ..</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="读取目录" class="heading-element"><span>2.2.2 读取目录</span>
  <a href="#%e8%af%bb%e5%8f%96%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>现在我们已经创建了一个目录，我们可能也希望读取一个目录。事实上，这正是程序 <code>ls</code> 所做的。让我们编写自己的小工具（例如 <code>ls</code>），看看它是如何完成的。</p>
<p>我们不只是像打开文件一样打开目录，而是使用一组新的调用。下面是一个打印目录内容的示例程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DIR</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">);</span>                 <span class="c1">// Open current directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">dp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">d</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Read one directory entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Print the inode number and name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%lu %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_ino</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">closedir</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>                       <span class="c1">// Close the directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该程序使用了三个调用：<code>opendir()</code>、<code>readdir()</code> 和 <code>closedir()</code> 来完成工作，您可以看到接口是多么简单；我们只是使用一个简单的循环一次读取一个目录条目，并打印出目录中每个文件的名称和<code>inode number</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ make read_dir
</span></span><span class="line"><span class="cl">gcc -c read_dir.c
</span></span><span class="line"><span class="cl">gcc read_dir.o -o read_dir
</span></span><span class="line"><span class="cl">❯ ./read_dir
</span></span><span class="line"><span class="cl"><span class="m">26212234</span> .
</span></span><span class="line"><span class="cl"><span class="m">22996964</span> ..
</span></span><span class="line"><span class="cl"><span class="m">26257183</span> file.txt
</span></span><span class="line"><span class="cl"><span class="m">26257285</span> fork-seek
</span></span><span class="line"><span class="cl"><span class="m">26256904</span> Makefile
</span></span><span class="line"><span class="cl"><span class="m">26261892</span> fsync.c
</span></span><span class="line"><span class="cl"><span class="m">26257284</span> fork-seek.o
</span></span><span class="line"><span class="cl"><span class="m">26258349</span> dup
</span></span><span class="line"><span class="cl"><span class="m">26261922</span> fsync
</span></span><span class="line"><span class="cl"><span class="m">26258348</span> dup.o
</span></span><span class="line"><span class="cl"><span class="m">26405969</span> read_dir.o
</span></span><span class="line"><span class="cl"><span class="m">26212238</span> README.md
</span></span><span class="line"><span class="cl"><span class="m">26261927</span> foo
</span></span><span class="line"><span class="cl"><span class="m">26405970</span> read_dir
</span></span><span class="line"><span class="cl"><span class="m">26405873</span> read_dir.c
</span></span><span class="line"><span class="cl"><span class="m">26258222</span> dup.c
</span></span><span class="line"><span class="cl"><span class="m">26256864</span> fork-seek.c
</span></span><span class="line"><span class="cl"><span class="m">26261921</span> fsync.o</span></span></code></pre></td></tr></table>
</div>
</div><p>下面的声明显示了 <code>struct dirent</code> 数据结构中每个目录条目中的可用信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">dirent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">d_name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span> <span class="cm">/* filename */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ino_t</span> <span class="n">d_ino</span><span class="p">;</span> <span class="cm">/* inode number */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">d_off</span><span class="p">;</span> <span class="cm">/* offset to the next dirent */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">d_reclen</span><span class="p">;</span> <span class="cm">/* length of this record */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_type</span><span class="p">;</span> <span class="cm">/* type of file */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于目录中的信息很少（基本上只是将名称映射到 <code>inode number</code>，以及其他一些细节），程序可能希望在每个文件上调用 <code>stat()</code> 来获取每个文件的更多信息，如长度或其他详细信息。事实上，当你给 <code>ls</code> 传递 <code>-l</code> 标志时，它就会这么做。</p>
<h4 id="删除目录" class="heading-element"><span>2.2.3 删除目录</span>
  <a href="#%e5%88%a0%e9%99%a4%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最后，你可以调用 <code>rmdir()</code>（由同名程序 <code>rmdir</code> 使用）删除目录。不过，与删除文件不同，删除目录更加危险，因为一条命令就可能删除大量数据。因此，<code>rmdir()</code> 要求在删除之前目录必须为空（即只有&rdquo;. &ldquo;和&rdquo;.. &ldquo;条目）。如果试图删除非空目录，<code>rmdir()</code> 函数的调用就会失败。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo/foo.txt
</span></span><span class="line"><span class="cl">&gt; rmdir foo
</span></span><span class="line"><span class="cl">rmdir: failed to remove <span class="s1">&#39;foo&#39;</span>: Directory not empty
</span></span><span class="line"><span class="cl">&gt; rm foo/foo.txt
</span></span><span class="line"><span class="cl">&gt; rmdir foo</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="链接" class="heading-element"><span>3 链接</span>
  <a href="#%e9%93%be%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="硬链接" class="heading-element"><span>3.1 硬链接</span>
  <a href="#%e7%a1%ac%e9%93%be%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在，我们通过了解一种在文件系统树中创建条目的新方法，即 <code>link()</code> 系统调用，回到为什么要通过 <code>unlink()</code> 来删除文件的谜题上来。<code>link()</code> 系统调用需要两个参数，一个旧路径名和一个新路径名；当你把一个新文件名 &ldquo;链接 &ldquo;到一个旧文件名时，你基本上就创造了另一种方式来引用同一个文件。在本例中，命令行程序 <code>ln</code> 就是用来实现这一功能的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; cat foo
</span></span><span class="line"><span class="cl">Hello, World
</span></span><span class="line"><span class="cl">&gt; ln foo foo2
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们创建了一个包含单词“Hello, World”的文件，并将其命名为<code>foo</code>。然后我们使用 <code>ln</code> 程序创建到该文件的硬链接。之后，我们可以通过打开 <code>foo</code> 或 <code>foo2</code> 来检查该文件。</p>
<p>链接的工作原理是，它只是在创建链接的目录中创建另一个名称，并将其指向与原始文件相同的 <code>inode number</code>（即底层名称）。文件并没有以任何方式复制；相反，你现在只有两个名称（<code>foo</code>和 <code>foo2</code>），它们都指向同一个文件。我们甚至可以在目录本身中看到这一点，打印出每个文件的 <code>inode number</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -i foo foo2
</span></span><span class="line"><span class="cl"><span class="m">1339196</span> foo  
</span></span><span class="line"><span class="cl"><span class="m">1339196</span> foo2</span></span></code></pre></td></tr></table>
</div>
</div><p>通过向 <code>ls</code> 传递 <code>-i</code> 标志，它会打印出每个文件的 <code>inode number</code>（以及文件名）。这样，你就能看到 <code>link</code> 到底做了什么：它只是对相同的 <code>inode number</code>（本例中为 1339196）进行了新的引用。</p>
<p>现在，你可能开始明白为什么 <code>unlink()</code> 要叫 <code>unlink()</code>了。当你创建文件时，实际上是在做两件事。</p>
<ul>
<li>首先，你正在创建一个结构（inode），它将跟踪文件的几乎所有相关信息，包括文件大小、块在磁盘上的位置等等。</li>
<li>其次，将一个人类可读的名称链接到该文件，并将该链接放到一个目录中。</li>
</ul>
<p>在文件系统中创建了文件的硬链接后，原始文件名（<code>foo</code>）和新创建的文件名（<code>foo2</code>）就没有什么区别了；事实上，它们都只是指向文件底层元数据的链接，而文件底层元数据就在 <code>inode number</code>1339196中。</p>
<p>因此，要从文件系统中删除文件，我们需要调用 <code>unlink()</code>。在上面的例子中，我们可以删除名为 <code>file</code> 的文件，并且仍然可以顺利访问该文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls
</span></span><span class="line"><span class="cl">foo  foo2
</span></span><span class="line"><span class="cl">&gt; rm foo
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>这样做的原因是，当文件系统取消链接文件时，它会检查 <code>inode number</code>内的引用计数。该<strong>引用计数</strong>（有时称为<strong>链接计数</strong>）允许文件系统跟踪有多少不同的文件名已链接到该特定 <code>inode</code>。当调用 <code>unlink()</code> 时，它会删除文件名（正在删除的文件）与给定 <code>inode number</code>之间的“链接”，并减少引用计数；<font olor="red">只有当引用计数为零时，文件系统才会同时释放inode和相关数据块，从而真正“删除”文件。</font></p>
<p>当然，您可以使用 <code>stat()</code> 查看文件的引用计数。让我们看看当我们创建和删除文件的硬链接时会发生什么。在此示例中，我们将创建指向同一文件的三个链接，然后将其删除。观察链接计数！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">1</span>
</span></span><span class="line"><span class="cl">&gt; ln foo foo2
</span></span><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">2</span>
</span></span><span class="line"><span class="cl">&gt; ln foo2 foo3
</span></span><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">3</span>
</span></span><span class="line"><span class="cl">&gt; rm foo
</span></span><span class="line"><span class="cl">&gt; stat foo2 <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">2</span>
</span></span><span class="line"><span class="cl">&gt; rm foo2
</span></span><span class="line"><span class="cl">&gt; stat foo3 <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="符号链接软链接" class="heading-element"><span>3.2 符号链接（软链接）</span>
  <a href="#%e7%ac%a6%e5%8f%b7%e9%93%be%e6%8e%a5%e8%bd%af%e9%93%be%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>还有另一种非常有用的链接类型，它称为<strong>符号链接</strong>，有时也称为<strong>软链接</strong>。事实证明，硬链接有一定的局限性：</p>
<ul>
<li>您不能为目录创建硬链接，因为担心会在目录树中创建循环。例如，假设有两个目录A和B，它们都包含一个硬链接到对方的硬链接。这种情况下，无论你从A开始还是从B开始，都会导致无限的循环，因为通过任一路径进入其中一个目录后，你可以通过硬链接返回到另一个目录，反复无穷地进行。</li>
<li>您不能硬链接到其他磁盘分区中的文件（因为 <code>inode number</code>仅在特定文件系统内唯一，而不是跨文件系统）；</li>
</ul>
<p>因此，创建了一种称为符号链接的新型链接。要创建这样的链接，您可以使用相同的程序 <code>ln</code>，但带有 <code>-s</code> 标志。这是一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; ln -s foo foo2
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>正如您所看到的，创建软链接看起来非常相似，现在可以通过文件名 <code>foo</code> 以及符号链接名 <code>foo2</code> 来访问原始文件。</p>
<p>然而，除了表面上的相似性之外，符号链接实际上与硬链接有很大不同。符号链接实际上本身就是一个不同类型的文件。我们已经讨论过常规文件和目录；<font color="red">符号链接是文件系统所知的第三种类型。</font>符号链接上的统计数据揭示了一切：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep regular
</span></span><span class="line"><span class="cl">  Size: <span class="m">13</span>        	Blocks: <span class="m">8</span>          IO Block: <span class="m">4096</span>   regular file
</span></span><span class="line"><span class="cl">&gt; stat foo2 <span class="p">|</span> grep symbolic
</span></span><span class="line"><span class="cl">  Size: <span class="m">3</span>         	Blocks: <span class="m">0</span>          IO Block: <span class="m">4096</span>   symbolic link</span></span></code></pre></td></tr></table>
</div>
</div><p>运行 <code>ls</code> 也揭示了这个事实。如果仔细观察 <code>ls</code> 输出的长格式的第一个字符，您会发现最左侧列中的第一个字符是 <code>-</code> 表示常规文件，<code>d</code> 表示目录，<code>l</code> 表示软链接。您还可以查看符号链接的大小（在本例中为 3 个字节），以及链接指向的内容（名为 <code>foo</code> 的文件）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -al
</span></span><span class="line"><span class="cl">total <span class="m">12</span>
</span></span><span class="line"><span class="cl">drwxrwxr-x  <span class="m">2</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 21:02 .
</span></span><span class="line"><span class="cl">drwxr-x--- <span class="m">22</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 21:03 ..
</span></span><span class="line"><span class="cl">-rw-rw-r--  <span class="m">1</span> zfhe zfhe   <span class="m">13</span> Apr <span class="m">16</span> 20:56 foo
</span></span><span class="line"><span class="cl">lrwxrwxrwx  <span class="m">1</span> zfhe zfhe    <span class="m">3</span> Apr <span class="m">16</span> 20:56 foo2 -&gt; foo</span></span></code></pre></td></tr></table>
</div>
</div><p><code>foo2</code> 是 3 个字节的原因是因为符号链接的形成方式是将链接到的文件的路径名作为链接文件的数据。因为我们链接到了一个名为 <code>foo</code> 的文件，所以我们的链接文件 <code>foo2</code> 很小（3 个字节）。如果我们链接到更长的路径名，我们的链接文件会更大：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; a_longer_filename
</span></span><span class="line"><span class="cl">&gt; ln -s a_longer_filename file
</span></span><span class="line"><span class="cl">&gt; ls -al a_longer_filename file
</span></span><span class="line"><span class="cl">-rw-rw-r-- <span class="m">1</span> zfhe zfhe <span class="m">13</span> Apr <span class="m">16</span> 21:04 a_longer_filename
</span></span><span class="line"><span class="cl">lrwxrwxrwx <span class="m">1</span> zfhe zfhe <span class="m">17</span> Apr <span class="m">16</span> 21:05 file -&gt; a_longer_filename</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，由于符号链接的创建方式，它们留下了所谓的悬空引用的可能性，悬空引用可能会导致程序错误，因为它们试图访问不再有效的内存位置或资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; ln -s foo foo2
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World
</span></span><span class="line"><span class="cl">&gt; rm foo
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">cat: foo2: No such file or directory</span></span></code></pre></td></tr></table>
</div>
</div><p>正如您在此示例中所看到的，与硬链接完全不同，删除名为 <code>foo</code> 的原始文件会导致链接指向不再存在的路径名。</p>
<h2 id="权限位和访问控制列表" class="heading-element"><span>4 权限位和访问控制列表</span>
  <a href="#%e6%9d%83%e9%99%90%e4%bd%8d%e5%92%8c%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%88%97%e8%a1%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>进程的抽象提供了两个中心虚拟化：CPU和内存。每一种虚拟化都会给进程造成一种错觉，以为它拥有自己的专用 CPU 和专用内存；实际上，操作系统使用了各种技术，以安全可靠的方式在相互竞争的实体之间共享有限的物理资源。</p>
<p>正如本章所述，文件系统也提供了磁盘的虚拟视图，将磁盘从一堆原始块转化为更方便用户使用的文件和目录。然而，文件系统的抽象与 CPU 和内存的抽象明显不同，因为文件通常由不同用户和进程共享，并不总是私有的。因此，文件系统中通常有一套更全面的机制来实现不同程度的共享。</p>
<p>此类机制的第一种形式是经典的 UNIX <strong>权限位</strong>。要查看文件 <code>foo.txt</code> 的权限，只需输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -l foo.txt
</span></span><span class="line"><span class="cl">-rw-rw-r-- <span class="m">1</span> zfhe zfhe <span class="m">0</span> Apr <span class="m">16</span> 21:12 foo.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>我们只关注该输出的第一部分，即 <code>-rw-r--r--</code>。这里的第一个字符仅显示文件的类型： <code>-</code> 表示常规文件（即 <code>foo.txt</code>），<code>d</code> 表示目录，<code>l</code> 表示符号链接，依此类推；这（大部分）与权限无关，所以我们暂时忽略它。</p>
<p>我们感兴趣的是权限位，它们由接下来的九个字符（<code>rw-r--r--</code>）表示。对于每个常规文件、目录和其他实体，这些位确定谁可以访问它以及如何访问它。</p>
<p>权限由三组组成：</p>
<ol>
<li>文件所有者可以对文件执行哪些操作；</li>
<li>组中的某个人可以对文件执行哪些操作；</li>
<li>最后是任何人（有时称为其他人）都可以执行哪些操作。</li>
</ol>
<p>所有者、组成员或其他人可以拥有的能力包括读取文件、写入文件或执行文件的能力。在上面的示例中，<code>ls</code> 输出的前三个字符表明该文件可由所有者 (<code>rw-</code>) 读取和写入，并且只能由组<code>zfhe</code>成员以及系统中的其他任何人读取 (<code>r --</code> 后面跟着 <code>r--</code>)。</p>
<p>文件的所有者可以轻松更改这些权限，例如通过使用 <code>chmod</code>命令（<strong>更改文件模式</strong>）（还有<code>chown</code>：更改文件或目录的所有者；<code>chgrp</code>：更改文件或目录的所属组）。要删除除所有者之外的任何人访问该文件的能力，您可以输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; chmod <span class="m">600</span> foo.txt
</span></span><span class="line"><span class="cl">&gt; ls -l foo.txt
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> zfhe zfhe <span class="m">0</span> Apr <span class="m">16</span> 21:12 foo.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>这条命令启用了所有者的可读位（4）和可写位（2）（将它们 OR 在一起会产生上面的 6），但将组和其他人的权限位分别设置为 0 和 0，从而将权限设置为 <code>rw-------</code>。</p>
<p>执行位尤其有趣。对于普通文件，它的存在决定了程序是否可以运行。例如，如果我们有一个名为 hello.csh 的简单 shell 脚本，我们可能希望通过输入以下内容来运行它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ./hello.csh
</span></span><span class="line"><span class="cl">hello, from shell world.</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，如果我们没有正确设置该文件的执行位，就会发生以下情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; chmod <span class="m">600</span> hello.csh
</span></span><span class="line"><span class="cl">&gt; ./hello.csh
</span></span><span class="line"><span class="cl">zsh: permission denied: ./hello.csh</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<center>文件系统的超级用户
</center>
<p>允许哪个用户执行特权操作以帮助管理文件系统？例如，如果需要删除一个不活动用户的文件以节省空间，谁有权这样做？</p>
<p>在本地文件系统中，常见的默认设置是存在某种超级用户（即 <code>root</code>），它可以访问所有文件，而不受权限限制。在分布式文件系统（如 AFS，它有访问控制列表）中，一个名为 <code>system:administrators</code> 的组包含受信任的用户。</p>
<p>在这两种情况下，这些受信任的用户都代表着固有的安全风险；如果攻击者能够以某种方式冒充此类用户，攻击者就可以访问系统中的所有信息，从而违反预期的隐私和保护保证。</p>
</blockquote>
<p>对于目录，执行位的行为略有不同。具体来说，它使用户（或组或每个人）能够执行诸如将目录（即 <code>cd</code>）更改为给定目录之类的操作，并结合可写位在其中创建文件。在 UNIX 文件系统中，具体如下：</p>
<ol>
<li><strong>读权限（r）</strong>：允许查看目录中的文件列表（即列出目录中的内容）。</li>
<li><strong>写权限（w）</strong>：允许在目录中创建、删除和重命名文件。</li>
<li><strong>执行权限（x）</strong>：允许进入目录。要进入目录，用户必须拥有目录的执行权限。</li>
</ol>
<p>除了权限位之外，一些文件系统，包括称为 AFS 的分布式文件系统，还包括更复杂的控制。例如，AFS 以每个目录的<strong>访问控制列表</strong> (ACL) 的形式执行此操作。访问控制列表是一种更通用、更强大的方式来准确表示谁可以访问给定资源。在文件系统中，这使用户能够创建一个非常具体的列表，其中列出谁可以读取一组文件，谁不能读取一组文件，这与上述权限位的所有者/组/所有人模型不同。</p>
<p>例如，以下是一位用户的 AFS 帐户中的私有目录的访问控制，如 <code>fs listacl</code> 命令所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; fs listacl private
</span></span><span class="line"><span class="cl">Access list <span class="k">for</span> private is
</span></span><span class="line"><span class="cl">Normal rights:
</span></span><span class="line"><span class="cl">    system:administrators rlidwka
</span></span><span class="line"><span class="cl">    remzi rlidwka</span></span></code></pre></td></tr></table>
</div>
</div><p>该列表显示系统管理员和用户 <code>remzi</code> 都可以查找、插入、删除和管理此目录中的文件，以及读取、写入和锁定这些文件，具体标识符解释如下。</p>
<ul>
<li><code>r</code>: 读取权限 (Read)</li>
<li><code>l</code>: 列出目录权限 (List)</li>
<li><code>i</code>: 插入权限 (Insert)</li>
<li><code>d</code>: 删除权限 (Delete)</li>
<li><code>w</code>: 写入权限 (Write)</li>
<li><code>k</code>: 锁定权限 (Lock)</li>
<li><code>a</code>: 管理权限 (Administer)</li>
</ul>
<p>要允许某人（在本例中为其他用户）访问此目录，用户 <code>remzi</code> 只需输入以下命令即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; fs setacl private/ andrea rl
</span></span><span class="line"><span class="cl">&gt; fs listacl private
</span></span><span class="line"><span class="cl">Access list <span class="k">for</span> private is
</span></span><span class="line"><span class="cl">Normal rights:
</span></span><span class="line"><span class="cl">    system:administrators rlidwka
</span></span><span class="line"><span class="cl">    remzi rlidwka
</span></span><span class="line"><span class="cl">    andrea rl</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<center>警惕TOCTTOC
</center>
<p>TOCTTOU 是 &ldquo;Time of Check to Time of Use&rdquo; 的缩写，指的是在检查某个条件和使用该条件之间可能存在的时间间隔。这个术语通常用于描述安全漏洞，特别是在多线程或并发环境中，由于时间间隔导致的条件竞争问题。</p>
<p>1974 年，McPhee注意到计算机系统存在问题。具体来说，McPhee 指出“&hellip;如果有效性检查和与该有效性检查相关的操作之间存在时间间隔，并且通过多任务处理，可以在该时间间隔期间故意更改有效性检查变量，导致控制程序执行无效操作。”今天，我们将此称为“Time of Check to Time of Use ”(TOCTTOU) 问题，可惜，这种情况仍然可能发生。</p>
<p>Bishop 和 Dilger描述的一个简单示例展示了用户如何欺骗更值得信赖的服务，从而造成麻烦。例如，想象一下，邮件服务以 root 身份运行（因此有权访问系统上的所有文件）。该服务将传入消息附加到用户的收件箱文件中，如下所示。首先，它调用 <code>lstat()</code> 来获取有关该文件的信息，特别是确保它实际上只是目标用户拥有的常规文件，而不是指向邮件服务器不应更新的另一个文件的链接。然后，检查成功后，服务器用新消息更新文件。</p>
<p>不幸的是，检查和更新之间的差距导致了一个问题：攻击者（在本例中，是接收邮件的用户，因此有权访问收件箱）切换收件箱文件（通过调用 <code>rename()</code>) 指向敏感文件，例如 <code>/etc/passwd</code>（其中保存有关用户及其密码的信息）。如果这种切换发生在正确的时间（在检查和访问之间），服务器将用邮件的内容更新敏感文件。攻击者现在可以通过发送电子邮件写入敏感文件，从而提升权限；通过更新<code>/etc/passwd</code>，攻击者可以添加具有root权限的帐户，从而获得系统的控制权。</p>
<p>TOCTTOU 问题没有任何简单而出色的解决方案。<font color="red">一种方法是减少需要 root 权限才能运行的服务数量，这会有所帮助</font>。 <code>O_NOFOLLOW</code> 标志使得如果目标是符号链接，<code>open()</code> 将失败，从而避免需要所述链接的攻击。更激进的方法，例如使用<strong>事务性文件系统</strong>，可以解决问题，但广泛部署的事务性文件系统并不多。因此，通常的建议：编写以高权限运行的代码时要小心！</p>
</blockquote>
<h2 id="制作和挂载文件系统" class="heading-element"><span>5 制作和挂载文件系统</span>
  <a href="#%e5%88%b6%e4%bd%9c%e5%92%8c%e6%8c%82%e8%bd%bd%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们现在已经了解了访问文件、目录和某些特殊类型链接的基本接口。不过，我们还应该讨论一个话题：如何从许多底层文件系统中生成完整的目录树。要完成这项任务，首先要制作文件系统，然后挂载这些文件系统，以便访问其中的内容。</p>
<p>为了创建文件系统，大多数文件系统都提供了一个工具，通常被称为 <code>mkfs</code>（读作 &ldquo;make fs&rdquo;），它可以完成这项任务。其原理如下：输入一个设备（如磁盘分区，如 <code>/dev/sda1</code>）和一个文件系统类型（如 <code>ext3</code>）给该工具，<font color="red">它就会在该磁盘分区中写入一个以根目录为起点的空文件系统。</font>mkfs 说：“那就有一个文件系统吧！”</p>
<p>不过，一旦创建了这样一个文件系统，就需要在统一文件系统树中对其进行访问。这项任务需要通过 <code>mount</code> 程序来完成（它会让底层系统调用 <code>mount()</code> 来完成真正的工作）。<code>mount</code> 程序的作用非常简单，<font color="red">就是将一个现有目录作为目标挂载点，然后在目录树上粘贴一个新的文件系统。</font></p>
<p>这里的一个例子可能很有用。假设我们有一个未挂载的 <code>ext3</code> 文件系统，存储在设备分区 <code>/dev/sda1</code>，其内容如下：一个根目录，其中包含两个子目录 <code>a</code> 和 <code>b</code>，每个子目录又包含一个名为 <code>foo</code> 的文件。假设我们希望将该文件系统挂载到挂载点 <code>/home/users</code>。我们可以这样输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; mount -t ext3 /dev/sda1 /home/users</span></span></code></pre></td></tr></table>
</div>
</div><p>如果挂载成功，这个新文件系统就可用了。不过，请注意现在访问新文件系统的方式。要查看根目录的内容，我们可以这样使用 <code>ls</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls /home/users/
</span></span><span class="line"><span class="cl">a b</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，路径名 <code>/home/users/</code> 现在指的是新挂载目录的根目录。同样，我们可以使用 <code>/home/users/a</code> 和 <code>/home/users/b</code> 这两个路径名访问目录 <code>a</code> 和 <code>b</code>。最后，可以通过 <code>/home/users/a/foo</code> 和 <code>/home/users/b/foo</code> 访问名为 <code>foo</code> 的文件。这就是挂载的魅力所在：挂载将所有文件系统统一为一棵树，使命名统一、方便，而不是拥有多个独立的文件系统。要查看系统上挂载了哪些文件，以及挂载在哪些位置，只需运行<code>mount</code>程序即可。你会看到如下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; mount
</span></span><span class="line"><span class="cl">/dev/sda1 on / <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">proc on /proc <span class="nb">type</span> proc <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">sysfs on /sys <span class="nb">type</span> sysfs <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">/dev/sda5 on /tmp <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">/dev/sda7 on /var/vice/cache <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">tmpfs on /dev/shm <span class="nb">type</span> tmpfs <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">AFS on /afs <span class="nb">type</span> afs <span class="o">(</span>rw<span class="o">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种疯狂的组合表明有大量不同的文件系统，包括 <code>ext3</code>（基于磁盘的标准文件系统）、<code>proc</code> 文件系统（用于访问当前进程信息的文件系统）、<code>tmpfs</code>（仅用于临时文件的文件系统） ）和 <code>AFS</code>（分布式文件系统）都粘合到这台机器的文件系统树上。</p>
<h2 id="总结" class="heading-element"><span>6 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><strong>文件</strong>是可以创建、读取、写入和删除的字节数组。它有一个唯一引用它的底层名称（即<code>number</code>）。此层名称通常称为<code>inode number</code>。</li>
<li><strong>目录</strong>是元组的集合，每个元组都包含一个人类可读的名称及其映射到的底层名称。每个条目要么引用另一个目录，要么引用一个文件。每个目录本身也有一个底层名称（<code>inode number</code>）。目录总是有两个特殊条目：<code>.</code>条目（引用自身）和 <code>..</code> 条目（引用其父条目）。</li>
<li><strong>目录树</strong>或<strong>目录层次结构</strong>将所有文件和目录组织成一棵大树，从根开始。</li>
<li>要访问文件，进程必须使用系统调用（通常为 <code>open()</code>）来请求操作系统的许可。如果授予权限，操作系统会返回一个文件描述符，然后在权限和意图允许的情况下，该文件描述符可用于读或写访问。</li>
<li>每个文件描述符都是一个私有的、每个进程的实体，它引用打开文件表中的一个条目。其中的条目跟踪这次访问<font color="red">引用了哪个文件、文件的当前偏移量（即下一次读取或写入将访问文件的哪一部分）以及其他相关信息。</font></li>
<li>调用<code>read()</code> 和<code>write()</code> 自然会更新当前偏移量；否则，进程可以使用 <code>lseek()</code> 来更改其值，从而能够随机访问文件的不同部分。</li>
<li>要强制更新持久性存储，进程必须使用<code>fsync()</code> 或相关调用。然而，在保持高性能的同时正确执行此操作具有挑战性，因此在执行此操作时请仔细考虑。</li>
<li>要使文件系统中的多个人类可读名称引用同一基础文件，请使用<strong>硬链接或符号链接</strong>。每种方法在不同的情况下都有用，因此在使用之前请考虑它们的优点和缺点。请记住，<font color="red">删除文件只是从目录层次结构中执行最后一次<code>unlink()</code> 操作</font>。</li>
<li>大多数文件系统都有启用和禁用共享的机制。此类控制的基本形式是由<strong>权限位</strong>提供的；更复杂的访问控制列表（ACL）可以更精确地控制谁可以访问和操作信息。</li>
</ul>
]]></description></item><item><title>廉价磁盘冗余阵列</title><link>https://hezephyr.github.io/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/</link><pubDate>Sat, 11 May 2024 21:03:30 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当我们使用磁盘时，</p>
<ul>
<li>有时我们希望它更快； I/O 操作速度很慢，因此可能成为整个系统的瓶颈。</li>
<li>有时我们希望它更大；越来越多的数据被放到网上，因此我们的磁盘变得越来越满。</li>
<li>有时我们希望它更加可靠；当磁盘发生故障时，如果我们的数据没有备份，所有有价值的数据都会消失。</li>
</ul>
<p>所以关键问题是：我们怎样才能制作大型、快速、可靠的存储系统？有哪些关键技术？不同方法之间的权衡是什么？</p>
<p>在本章中，我们将介绍<font color="red">廉价磁盘冗余阵列，即 RAIDs</font>，这是一种<font color="red">协同使用多个磁盘来构建更快、更大、更可靠的磁盘系统的技术</font>。该术语是由加州大学伯克利分校的一组研究人员（由 David Patterson 和 Randy Katz 教授以及当时的学生 Garth Gibson 领导）于 20 世纪 80 年代末提出的。大约在这个时候，许多不同的研究人员同时得出了使用多个磁盘来构建更好的存储系统的基本思想。</p>
<p>从外部来看，RAIDs 看起来像一个磁盘：一组可以读取或写入的块。在内部，RAID 是一个复杂的系统，由多个磁盘、内存（易失性和非易失性）以及一个或多个用于管理系统的处理器组成。硬件 RAID 非常类似于计算机系统，专门用于管理一组磁盘的任务。</p>
<p>与单个磁盘相比，RAID 具有如下优点。</p>
<ol>
<li><strong>性能</strong>。并行使用多个磁盘可以大大加快 I/O 时间。</li>
<li><strong>容量</strong>。大数据集需要大磁盘。</li>
<li><strong>可靠性</strong>；将数据分布在多个磁盘上（没有 RAID 技术）使得数据容易受到单个磁盘丢失的影响；通过某种形式的冗余，RAID 可以容忍磁盘丢失并继续运行，就像没有发生任何问题一样。</li>
</ol>
<blockquote>
<center>提示：透明性有助于部署</center>
<p>在考虑如何为系统添加新功能时，应始终考虑能否以透明的方式添加这些功能，即不要求更改系统的其他部分。要求完全重写现有软件（或彻底改变硬件）会降低想法产生影响的几率。RAID 就是一个很好的例子，当然，它的透明性也是其成功的原因之一；管理员可以安装一个基于 SCSI 的 RAID 存储阵列，而不是 SCSI 磁盘，系统的其他部分（主机、操作系统等）无需做任何改动即可开始使用。通过解决部署问题，RAID 从一开始就取得了巨大成功。</p>
</blockquote>
<p>令人惊奇的是，RAID 为使用 RAID 的系统提供了透明的优势，也就是说，对于主机系统而言，RAID 就像一个大磁盘。当然，透明性的好处在于，它使人们能够简单地用 RAID 更换磁盘，而无需更改任何软件；操作系统和客户端应用程序无需修改即可继续运行。通过这种方式，透明性大大提高了 RAID 的可部署性，使用户和管理员在使用 RAID 时不必担心软件兼容性问题。</p>
<p>我们现在讨论 RAID 的一些重要方面。我们首先讨论<strong>接口和故障模型</strong>，然后讨论如何从<strong>容量</strong>、<strong>可靠性</strong>和<strong>性能</strong>这三个重要方面评估 RAID 设计。然后，我们将讨论对 RAID 设计和实施很重要的其他一些问题。</p>
<h2 id="接口和-raid-内部结构" class="heading-element"><span>2 接口和 RAID 内部结构</span>
  <a href="#%e6%8e%a5%e5%8f%a3%e5%92%8c-raid-%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于上面的文件系统来说，RAID 看起来就像一个大的、（希望）快速且（希望）可靠的磁盘。就像单个磁盘一样，它表现为块的线性阵列，每个块都可以由文件系统（或其他客户端）读取或写入。</p>
<p>当文件系统向 RAID 发出逻辑 I/O 请求时，RAID 内部必须计算要访问哪个磁盘（或多个磁盘）才能完成请求，然后发出一个或多个物理 I/O 来完成该请求。这些物理 I/O 的确切性质取决于 RAID 级别，我们将在下面详细讨论。然而，作为一个简单的例子，考虑一个 RAID，它保留每个块的两个副本（每个副本位于一个单独的磁盘上）；当写入此类镜像 RAID 系统时，RAID 必须为其发出的每一个逻辑 I/O 执行两次物理 I/O。</p>
<p>RAID 系统通常是一个独立的硬件盒，通过标准连接（如 SCSI 或 SATA）与主机相连。不过，RAID 的内部结构相当复杂，包括一个<strong>运行固件的微控制器</strong>，用于指导 RAID 的运行；<strong>DRAM 等易失性内存</strong>，用于在数据块读写时对其进行缓冲；在某些情况下，非易失性内存用于对写入进行安全缓冲；甚至可能还包括用于执行奇偶校验计算的专用逻辑（在某些 RAID 级别中非常有用，下文将详细介绍）。从高层次来看，RAID 在很大程度上是一种专用计算机系统：它有处理器、内存和磁盘；但它运行的不是应用程序，而是专门用于操作 RAID 的软件。</p>
<h2 id="故障模型" class="heading-element"><span>3 故障模型</span>
  <a href="#%e6%95%85%e9%9a%9c%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了理解 RAID 并比较不同的方法，我们必须有一个故障模型。 RAID 旨在检测某些类型的磁盘故障并从中恢复；因此，准确地了解会出现哪些故障对于实现可行的设计至关重要。</p>
<p>我们假设的第一个故障模型非常简单，被称为<font color="red">故障停止故障模型</font>。在此模型中，磁盘可以恰好处于两种状态之一：工作或故障。使用工作磁盘，所有块都可以读取或写入。相反，当磁盘发生故障时，我们假设它永久丢失。</p>
<p>故障停止模型的一个关键方面是它对故障检测的假设。具体来说，当磁盘出现故障时，我们假设很容易检测到这一点。例如，在 RAID 阵列中，我们假设 RAID 控制器硬件（或软件）可以立即观察到磁盘发生故障。</p>
<p>因此，目前我们不必担心更复杂的“静默”故障，例如磁盘损坏。我们也不必担心单个块在其他工作磁盘上变得无法访问（有时称为潜在扇区错误）。稍后我们将考虑这些更复杂（不幸的是，更现实）的磁盘故障。</p>
<h2 id="如何评估-raid" class="heading-element"><span>4 如何评估 RAID</span>
  <a href="#%e5%a6%82%e4%bd%95%e8%af%84%e4%bc%b0-raid" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>构建 RAID 有多种不同的方法。这些方法中的每一种都有不同的特征，值得评估，以便了解它们的优点和缺点。</p>
<p>具体来说，我们将依据三个指标评估每个 RAID 设计。</p>
<ol>
<li>
<p>第一个指标是<strong>容量</strong>；给定一组 N 个磁盘，每个磁盘有 B 个块，RAID 客户端有多少可用容量？如果没有冗余，答案是$N\cdot B$；相反，如果我们有一个系统保留每个块的两个副本（称为镜像），则我们获得的有用容量为$\frac{N\cdot B}{2}$。不同的方案（例如基于奇偶校验的方案）往往介于两者之间。</p>
</li>
<li>
<p>第二个指标是<strong>可靠性</strong>。给定的设计可以容忍多少个磁盘故障？根据我们的故障模型，我们假设只有整个磁盘可能发生故障；在之后（即数据完整性），我们将考虑如何处理更复杂的故障模式。</p>
</li>
<li>
<p>最后一个指标是<strong>性能</strong>。评估性能有些困难，因为它很大程度上取决于磁盘阵列的工作负载。因此，在评估性能之前，我们将首先介绍一组应该考虑的典型工作负载。</p>
<blockquote>
<p>我们现在考虑三种重要的 RAID 设计：RAID Level 0（条带化）、RAID Level 1（镜像）和 RAID Levels 4/5（基于奇偶校验的冗余）。将这些设计中的每一个命名为“level”源于atterson，Gibson和Katz在伯克利的开创性工作。</p>
</blockquote>
</li>
</ol>
<p>在分析 RAID 性能时，可以考虑两种不同的性能指标。首先是<font color="red">单请求延迟</font>。了解 RAID 的单个 I/O 请求的延迟非常有用，因为它揭示了单个逻辑 I/O 操作期间可以存在多少并行性。第二个是 RAID 的<font color="red">稳态吞吐量</font>，即许多并发请求的总带宽。由于 RAID 通常用于高性能环境，因此稳态带宽至关重要，因此将成为我们分析的主要焦点。</p>
<p>为了更详细地了解吞吐量，我们需要提出一些感兴趣的工作负载。在本次讨论中，我们假设有两种类型的工作负载：顺序工作负载和随机工作负载。对于顺序工作负载，我们假设对数组的请求来自大的连续块；例如，访问 1 MB 数据的请求（或一系列请求），从块 $x$ 开始到块 ($x+1$ MB) 结束，将被视为连续的。顺序工作负载在许多环境中都很常见（想象一下在大文件中搜索关键字），因此被认为很重要。</p>
<p>对于随机工作负载，我们假设每个请求都相当小，并且每个请求都发送到磁盘上不同的随机位置。例如，随机请求流可能首先访问逻辑地址 10 处的 4KB，然后访问逻辑地址 550,000，然后访问 20,100，等等。一些重要的工作负载，例如数据库管理系统 (DBMS) 上的事务工作负载，表现出这种类型的访问模式，因此它被认为是重要的工作负载。</p>
<p>当然，真正的工作负载并不那么简单，并且通常混合了顺序和看似随机的组件以及两者之间的行为。为了简单起见，我们只考虑这两种可能性。</p>
<p>正如您所知，顺序和随机工作负载将导致磁盘的性能特征存在很大差异。通过顺序访问，磁盘以其最有效的模式运行，花费很少的时间寻道和等待旋转，而大部分时间用于传输数据。对于随机访问，情况恰恰相反：大部分时间都花在寻道和等待旋转上，而花在传输数据上的时间相对较少。为了在我们的分析中捕捉到这种差异，我们假设磁盘在顺序工作负载下可以以 $S\text{ MB/s}$ 的速度传输数据，在随机工作负载下可以以$R\text{ MB/s}$的速度传输数据。一般来说，S 远大于 R（即 S ≫ R）。</p>
<p>为了确保我们理解这种差异，让我们做一个简单的练习。具体来说，我们根据以下磁盘特性来计算 S 和 R。假设顺序传输平均大小为 10 MB，随机传输平均大小为 10 KB。</p>
<p>另外，假设以下磁盘特性：</p>
<ul>
<li>平均寻道时间 7 ms</li>
<li>平均旋转延迟 3 ms</li>
<li>磁盘传输速率 50 MB/s</li>
</ul>
<p>为了计算 S，我们需要首先计算出典型的 10 MB 传输所花费的时间。首先，我们花费 7 毫秒进行寻道，然后花费 3 毫秒进行旋转。最后，传输开始；$\frac{10\text{ MB}}{50\text{ MB/s}}$ 导致传输时间为 $\frac{1}{5}s$，即 200 毫秒。因此，对于每个 10 MB 请求，我们花费 210 毫秒完成请求。要计算 S，我们只需：
$$
S=\frac{\text{Amount of Data}}{\text{Time to access}}=\frac{10\text{ MB}}{210ms}=47.62\text{ MB/s}
$$
正如我们所看到的，由于传输数据花费大量时间，S 非常接近磁盘的峰值带宽（寻道和旋转成本已摊销）。我们可以类似地计算 R。寻道和旋转是一样的；然后我们计算传输所花费的时间，即$\frac{10\text{ KB}}{50\text{ MB/s}}$ ，即 0.195 毫秒。
$$
R=\frac{\text{Amount of Data}}{\text{Time to access}}=\frac{10\text{ KB}}{10ms+0.195ms}=0.981\text{ MB/s}
$$
我们可以看到，R 小于 1 MB/s，S/R 接近 50 MB/s</p>
<h2 id="raid-level-0条带化" class="heading-element"><span>5 RAID Level 0：条带化</span>
  <a href="#raid-level-0%e6%9d%a1%e5%b8%a6%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>5.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>第一个 RAID Level实际上根本不是 RAID Level，因为没有冗余。不过，RAID Level（或称条带化）是性能和容量的绝佳上限，因此值得了解。</p>
<p>最简单的条带化形式是在系统磁盘上对数据块进行条带化，如下所示（这里假设有 4 个磁盘阵列）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=small" data-sub-html="<h2>image-20240414220046035</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png" alt="image-20240414220046035" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=large 2x" data-title="image-20240414220046035" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从上表中，你可以了解到基本概念：将磁盘阵列的数据块以循环方式分布在磁盘上。这种方法的设计目的是在请求连续的磁盘阵列块时，从磁盘阵列中提取最大的并行性（例如，在大的顺序读取中）。我们将同一行中的块称为一个条带；因此，块 0、1、2 和 3 位于上述同一条带中。</p>
<p>在示例中，我们做了一个简化假设，即在移动下一个磁盘之前，每个磁盘上只放置一个块（每个块的大小为 4KB）。然而，这种安排并不一定是必须的。例如，我们可以将块跨越多个磁盘进行排列，如下表所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=small" data-sub-html="<h2>image-20240414220112661</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png" alt="image-20240414220112661" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=large 2x" data-title="image-20240414220112661" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在本例中，我们在每个磁盘上放置两个 4KB 的数据块，然后再移动到下一个磁盘。因此，该 RAID 阵列的数据块大小为 8KB，一个磁条由 4 个数据块或 32KB 的数据组成。</p>
<blockquote>
<center>RAID 映射问题</center>
<p>在研究 RAID 的容量、可靠性和性能特征之前，我们首先介绍一下所谓的映射问题。所有RAID阵列都会出现这个问题；简而言之，给定一个要读取或写入的逻辑块，RAID 如何准确地知道要访问哪个物理磁盘和偏移量？</p>
<p>对于这些简单的 RAID levels，我们不需要太复杂就能将逻辑块正确映射到其物理位置。以上面的第一个条带化示例为例（块大小=1，数据块 = 4KB）。在这种情况下，给定逻辑块地址 A，RAID 可以使用两个简单的方程轻松计算所需的磁盘和偏移量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Disk</span>   <span class="o">=</span> <span class="n">A</span> <span class="o">%</span> <span class="n">number_of_disks</span>
</span></span><span class="line"><span class="cl"><span class="n">Offset</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">number_of_disks</span></span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，这些都是整数运算（例如，4 / 3 = 1 而不是 1.33333&hellip;）。让我们通过一个简单的例子来看看这些方程是如何工作的。想象一下，在上面的第一个 RAID 中，块 14 的请求到达。假设有 4 个磁盘，这意味着我们感兴趣的磁盘是 (14 % 4 = 2)：磁盘 2。确切的块计算公式为： （14 / 4 = 3)：块3。因此，块14应该在第三个磁盘（磁盘2，从0开始）的第四个块（块3，从0开始）上找到，这正是它所在的位置。</p>
</blockquote>
<h3 id="块大小" class="heading-element"><span>5.2 块大小</span>
  <a href="#%e5%9d%97%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>块大小主要影响阵列的性能。例如，较小的块大小意味着许多文件将在许多磁盘上进行条带化，从而提高单个文件读写的并行性；然而，跨多个磁盘访问块的定位时间会增加，因为整个请求的定位时间由跨所有驱动器的请求定位时间的最大值决定。</p>
<p>另一方面，大的块大小会降低这种文件内并行性，从而依赖多个并发请求来实现高吞吐量。然而，大的块大小会减少定位时间；例如，如果单个文件适合一个块并因此被放置在单个磁盘上，则访问它时产生的定位时间将只是单个磁盘的定位时间。</p>
<p>因此，确定“最佳”块大小很难，因为它需要大量有关磁盘系统的工作负载的知识。对于本次讨论的其余部分，我们将假设数组使用单个块 (4KB) 的块大小。大多数数组使用较大的块大小（例如 64 KB），但对于我们下面讨论的问题，确切的块大小并不重要；因此，为了简单起见，我们使用单个块。</p>
<h3 id="评估-条带化" class="heading-element"><span>5.3 评估 条带化</span>
  <a href="#%e8%af%84%e4%bc%b0-%e6%9d%a1%e5%b8%a6%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们来评估条带化的容量、可靠性和性能。从容量的角度来看，条带化是完美的：给定 N 块磁盘，每块磁盘的大小为 B 块，条带化就能提供$N\cdot B$ 个有用容量容量块。从可靠性的角度来看，条带化也是完美的，但也是糟糕的：任何磁盘故障都会导致数据丢失。</p>
<p>最后，性能也非常出色：所有磁盘都能利用，而且往往是并行利用，为用户的 I/O 请求提供服务。例如，从延迟的角度来看，单块请求的延迟应与单个磁盘的延迟基本相同；毕竟 RAID-0 只需将该请求重定向到其中一个磁盘即可。从稳态吞吐量的角度来看，我们希望获得系统的全部带宽。因此，吞吐量等于 N（磁盘数量）乘以 S（单个磁盘的连续带宽）。对于大量随机 I/O，我们可以再次使用所有磁盘，从而获得 $N\cdot R$MB/s。我们将在下文中看到，这些值既是最简单的计算值，也是与其他 RAID levels相比的上限。</p>
<h2 id="raid-level-1镜像" class="heading-element"><span>6 RAID Level 1：镜像</span>
  <a href="#raid-level-1%e9%95%9c%e5%83%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>6.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除条带化之外，我们的第一个 RAID Level称为 RAID Level 1，或镜像。在镜像系统中，我们只需为系统中的每个数据块制作一个以上的副本；当然，每个副本都应放置在单独的磁盘上。通过这种方法，我们可以<font color="red">容忍磁盘故障</font>。</p>
<p>在典型的镜像系统中，我们假设 RAID 会为每个逻辑块保留两个物理副本。下面是一个例子：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=small" data-sub-html="<h2>image-20240414224917155</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png" alt="image-20240414224917155" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=large 2x" data-title="image-20240414224917155" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在示例中，磁盘 0 和磁盘 1 的内容完全相同，磁盘 2 和磁盘 3 的内容也完全相同；<font color="red">数据在这些镜像对中进行条带化处理</font>。事实上，你可能已经注意到，在磁盘上放置块拷贝有多种不同的方法。上面的排列方式很常见，有时也被称为 <strong>RAID-10</strong> 或（<strong>RAID 1+0</strong>），因为它使用镜像对（RAID-1），然后在其上使用条带（RAID-0）；另一种常见的排列方式是 <strong>RAID-01</strong>（或 <strong>RAID 0+1</strong>），它包含两个大型条带（RAID-0）阵列，然后在其上使用镜像（RAID-1）。现在，我们只讨论假设上述布局的镜像。</p>
<p>从镜像阵列读取数据块时，RAID 有一个选择：可以读取任一副本。例如，如果向 RAID 发出读取逻辑块 5 的命令，RAID 可以自由选择从磁盘 2 或磁盘 3 读取。但在写入逻辑块时，就没有这样的选择了：RAID 必须更新数据的两个副本，以保持可靠性。但请注意，这些写入可以并行进行；例如，对逻辑块 5 的写入可以同时写入磁盘 2 和磁盘 3。</p>
<h3 id="raid-1分析" class="heading-element"><span>6.2 RAID-1分析</span>
  <a href="#raid-1%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>让我们评估一下 RAID-1。</p>
<ul>
<li>从容量的角度来看，RAID-1 是昂贵的；镜像级别 = 2 时，我们只能获得峰值有用容量的一半。在 N 块磁盘上有 B 个数据块时，RAID-1 的有用容量为 $\frac{N\cdot B}{2}$。</li>
<li>从可靠性的角度来看，RAID-1 表现出色。它可以承受任何一块磁盘的故障。如果运气好的话，RAID-1 还能做得更好。想象一下，在上图中，磁盘 0 和磁盘 2 同时发生故障。在这种情况下，数据不会丢失！一般来说，镜像系统（镜像级别为 2）可以承受 1 个磁盘的故障，最多可以承受 $\frac{N}{2}$ 个磁盘的故障，具体取决于哪些磁盘发生故障。在实践中，我们通常不喜欢听天由命，因此大多数人认为镜像可以很好地处理单个故障。</li>
<li>最后，我们分析一下性能。从单个读取请求的延迟角度来看，我们可以看到它与单个磁盘的延迟相同；RAID-1 所做的只是将读取指向其中一个副本。写入则略有不同：它需要两次物理写入才能完成。这两次写入是并行进行的，因此时间与单个写入的时间大致相同；但是，由于逻辑写入必须等待两次物理写入完成，因此会受到两个请求中最坏情况下的寻道和旋转延迟，因此（平均而言）会略高于写入单个磁盘的时间。</li>
</ul>
<blockquote>
<center>RAID 一致性更新问题</center>
<p>在分析 RAID-1 之前，让我们首先讨论任何多磁盘 RAID 系统中都会出现的一个问题，即一致性更新问题 。写入任何必须在单个逻辑操作期间更新多个磁盘的 RAID 时都会出现此问题。在这种情况下，假设我们正在考虑镜像磁盘阵列。</p>
<p>想象一下，向 RAID 发出写操作，然后 RAID 决定必须将其写入两个磁盘，即磁盘 0 和磁盘 1。然后，RAID 向磁盘 0 发出写操作，但就在 RAID 可以向磁盘发出请求之前1、发生断电（或系统崩溃）。在这种不幸的情况下，让我们假设对磁盘 0 的请求已完成（但显然对磁盘 1 的请求没有完成，因为它从未发出）。</p>
<p>这种过早断电的结果是该块的两个副本现在不一致；磁盘 0 上的副本是新版本，磁盘 1 上的副本是旧版本。我们希望发生的是两个磁盘的状态都以原子方式改变，即，要么两个磁盘最终都成为新版本，要么都不成为新版本。</p>
<p>解决这个问题的一般方法是在执行之前使用某种<font color="red">预写日志</font>首先记录 RAID 将要执行的操作（即用某条数据更新两个磁盘）。通过采用这种方法，我们可以确保在发生崩溃时，会发生正确的事情；通过运行将所有待处理事务重播到 RAID 的恢复过程，我们可以确保没有两个镜像副本（在 RAID-1 情况下）不同步。</p>
<p>最后一点：由于每次写入时记录到磁盘的成本非常昂贵，因此大多数 RAID 硬件都包含少量非易失性 RAM（例如，电池供电的 RAM），用于执行此类记录。因此，无需花费高昂的日志记录到磁盘的成本即可提供一致的更新。</p>
</blockquote>
<p>为了分析稳态吞吐量，我们从顺序工作负载开始。当顺序写入磁盘时，每次逻辑写入必须导致两次物理写入；例如，当我们写入逻辑块0（上图）时，RAID内部会将其同时写入磁盘0和磁盘1。因此，我们可以得出镜像阵列顺序写入时获得的最大带宽为（$\frac{N}{2}\cdot S$)，或峰值带宽的一半。</p>
<p>不幸的是，我们在顺序读取期间获得了完全相同的性能。人们可能认为顺序读取可以做得更好，因为它只需要读取数据的一份副本，而不是两者都读取。然而，让我们用一个例子来说明为什么这没有多大帮助。假设我们需要读取块 0、1、2、3、4、5、6 和 7。假设我们将 0 的读取发送到磁盘 0，将 1 的读取发送到磁盘 2，将 2 的读取发送到磁盘 1 ，以及将 3 读取到磁盘 3。我们继续分别向磁盘 0、2、1 和 3 发出对 4、5、6 和 7 的读取。人们可能天真地认为，由于我们利用了所有磁盘，因此我们实现了阵列的全部带宽。</p>
<p>然而，要知道情况并非（必然）如此，请考虑单个磁盘（例如磁盘 0）收到的请求。首先，它收到对块0的请求；然后，它收到对块 4 的请求（跳过块 2）。事实上，每个磁盘都会收到对每个其他块的请求。当它在跳过的块上旋转时，它不会向客户端提供有用的带宽。因此，每个磁盘只能提供其峰值带宽的一半。因此，顺序读取只能获得($\frac{N}{2}\cdot S$)MB/s的带宽。</p>
<p>随机读取是镜像 RAID 的最佳情况。在这种情况下，我们可以将读取分布在所有磁盘上，从而获得全部可能的带宽。因此，对于随机读取，RAID-1 提供 $N\cdot R$ MB/s。</p>
<p>最后，随机写入的性能如您所料：$\frac{N}{2}\cdot R$ MB/s。每个逻辑写入必须转化为两个物理写入，因此当所有磁盘都在使用时，客户端只会将其视为可用带宽的一半。尽管对逻辑块 $x$ 的写入变成了对两个不同物理磁盘的两次并行写入，但许多小请求的带宽仅达到我们在条带化中看到的一半。正如我们很快就会看到的，获得一半的可用带宽实际上非常好！</p>
<h2 id="raid-level-4使用奇偶校验节省空间" class="heading-element"><span>7 RAID Level 4：使用奇偶校验节省空间</span>
  <a href="#raid-level-4%e4%bd%bf%e7%94%a8%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c%e8%8a%82%e7%9c%81%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-2" class="heading-element"><span>7.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们现在介绍一种不同的向磁盘阵列添加冗余的方法，称为<strong>奇偶校验</strong>。基于奇偶校验的方法试图使用更少的容量，从而克服镜像系统所付出的巨大空间代价。然而，这种方法以<strong>性能</strong>为代价。</p>
<p>下面是一个五磁盘 RAID-4 系统示例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=small" data-sub-html="<h2>image-20240415095640999</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png" alt="image-20240415095640999" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=large 2x" data-title="image-20240415095640999" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们为每个数据条带添加了一个奇偶校验块，用于存储该数据块条带的冗余信息。例如，奇偶校验块 P1 具有从块 4、5、6 和 7 计算出的冗余信息。</p>
<p>要计算奇偶校验，我们需要使用一个数学函数，使我们能够承受条带中任何一个块的丢失。事实证明，简单的函数 XOR 就能很好地做到这一点。对于一组给定的bit，如果bit中 1 的个数为偶数，则所有这些bit的 XOR 返回 0；如果 1 的个数为奇数，则返回 1。例如：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=small" data-sub-html="<h2>image-20240415100052993</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png" alt="image-20240415100052993" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=large 2x" data-title="image-20240415100052993" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在第一行（0,0,1,1）中，有两个 1（C2、C3），因此所有这些值的 XOR 将是 0 (P)；同样，在第二行中只有一个 1（C1），因此 XOR 必须是 1 (P)。您可以用一种简单的方法记住这一点：任何一行中 1 的个数必须是偶数（而不是奇数）；这就是 RAID 必须保持的<strong>不变性</strong>，这样奇偶校验才会正确。</p>
<p>从上面的例子中，您或许还能猜到如何使用奇偶校验信息来从故障中恢复。假设标有 C2 的列丢失了。要想知道该列中应该有哪些值，我们只需读入该行中的所有其他值（包括 XOR 的奇偶校验位），然后重建正确的答案。具体来说，假设第一行 C2 列的值丢失了（它是一个 1）；通过读取该行中的其他值（C0 中的 0、C1 中的 0、C3 中的 1 和奇偶校验列 P 中的 0），我们得到了 0、0、1 和 0。因为我们知道 XOR 在每一行中保持偶数个 1，所以我们知道丢失的数据一定是：一个 。请注意我们是如何计算重构值的：我们只需将数据位和奇偶校验位一起 XOR 即可，与最初计算奇偶校验的方法相同。</p>
<p>现在你可能想知道：我们说的是将所有这些bit进行 XOR，但从上面我们知道 RAID 在每个磁盘上放置了 4KB （或更大）的数据块；我们如何对一堆数据块应用 XOR 来计算奇偶校验呢？事实证明这也很简单。只需对数据块的每个位执行逐位 XOR 即可；将每个逐位 XOR 的结果放入奇偶校验块的相应位槽中即可。例如，如果我们有大小为 4 位的数据块，它们可能看起来像这样：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=small" data-sub-html="<h2>image-20240415100519049</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png" alt="image-20240415100519049" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=large 2x" data-title="image-20240415100519049" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从表中可以看出，每个数据块的每个bit都要计算奇偶校验，并将计算结果放入奇偶校验数据块中。</p>
<h3 id="raid-4-分析" class="heading-element"><span>7.2 RAID-4 分析</span>
  <a href="#raid-4-%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们分析一下RAID-4。从容量的角度来看，RAID-4 使用 1 个磁盘来为其保护的每组磁盘提供奇偶校验信息。因此，RAID 组的有用容量为 $(N − 1) · B$。</p>
<p>可靠性也很容易理解：<font color="red">RAID-4 只能容忍 1 个磁盘故障，不能再出现更多故障。</font>如果多个磁盘丢失，则根本无法重建丢失的数据。</p>
<p>最后，还有性能。这次，让我们从分析稳态吞吐量开始。顺序读取性能可以利用除奇偶校验磁盘之外的所有磁盘，从而提供 $(N − 1) · S\text{ MB/s}$ 的峰值有效带宽（一个简单的情况）。</p>
<p>要了解顺序写入的性能，我们必须首先了解它们是如何完成的。将大块数据写入磁盘时，RAID-4 可以执行称为<font color="red">全条带写入的简单优化</font>。例如，想象一下块 0、1、2 和 3 已作为写入请求的一部分发送到 RAID 的情况（如下表所示）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=small" data-sub-html="<h2>image-20240415101029694</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png" alt="image-20240415101029694" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=large 2x" data-title="image-20240415101029694" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在这种情况下，RAID可以简单地计算P0的新值（通过对块0、1、2和3执行异或），然后将所有块（包括奇偶校验块）并行写入上面的五个磁盘中（表中以灰色突出显示）。因此，全条带写入是 RAID-4 写入磁盘的最有效方式。</p>
<p>一旦我们了解了全条带写入，计算 RAID-4 上顺序写入的性能就很容易了；有效带宽也是$(N − 1) · S\text{ MB/s}$。即使在操作过程中不断使用奇偶校验磁盘，客户端也无法从中获得性能优势。</p>
<p>现在我们来分析一下随机读取的性能。从上表中还可以看到，一组 1-block 随机读取将分布在系统的数据磁盘上，但不会分布在奇偶校验磁盘上。因此，有效性能为：$(N − 1) · R\text{ MB/s}$。</p>
<p>我们最后保存的随机写入呈现了 RAID-4 最有趣的情况。假设我们希望覆盖上面示例中的块 1。我们可以直接覆盖它，但这会给我们带来一个问题：奇偶校验块 P0 将不再准确地反映条带的正确奇偶校验值；在此示例中，P0 也必须更新。如何才能既正确又高效地更新呢？</p>
<p>事实证明有两种方法。第一个称为<font color="red">加法奇偶校验</font>，要求我们执行以下操作。要计算新奇偶校验块的值，请并行读入条带中的所有其他数据块（在示例中为块 0、2 和 3），并将这些数据块与新块 (1) 进行异或。结果就是新的奇偶校验块。为了完成写入，您可以将新数据和新奇偶校验写入各自的磁盘，同样是并行的。</p>
<p>该技术的问题在于它会随着磁盘数量的增加而扩展，因此在较大的 RAID 中需要大量读取来计算奇偶校验。因此，<font color="red">采用减法奇偶校验法</font>。</p>
<p>例如，想象一下这一串位（4 个数据位，一个奇偶校验）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=small" data-sub-html="<h2>image-20240415101714960</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png" alt="image-20240415101714960" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=large 2x" data-title="image-20240415101714960" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>假设我们希望用一个新值覆盖位 C2，我们将其称为$C2_{new}$ 。减法分三个步骤进行。</p>
<ol>
<li>
<p>首先，我们读入C2处的旧数据（$C2_{old}=1$）和旧奇偶校验（$P_{old}=0$）。</p>
</li>
<li>
<p>然后，我们比较旧数据和新数据；</p>
<ul>
<li>如果它们相同（例如，$C2_{new}=C2_{old}$），那么我们知道奇偶校验位也将保持相同（即，$P_{new}=P_{old}$）。</li>
<li>然而，如果它们不同，那么我们必须将旧奇偶校验位翻转到其当前状态的相反状态，即，如果($P_{old}==1$)，$P_{new}$将被设置为0；如果 ($P_{old}==0$)，$P_{new}$将被设置为 1。我们可以用 XOR 巧妙地表达整个过程（其中 $\oplus$ 是 XOR 运算符）：</li>
</ul>
<p>$$
P_{new}=(C_{old}\oplus C_{new})\oplus P_{old}
$$</p>
</li>
</ol>
<p>由于我们处理的是数据块而不是bit，因此我们对数据块中的所有bit进行计算（例如，每个数据块中的 4096 个字节乘以每个字节的 8 个bit）。因此，在大多数情况下，新的数据块会与旧的数据块不同，因此新的奇偶校验数据块也会不同。现在，你应该能算出何时使用加法奇偶校验计算，何时使用减法奇偶校验计算。想一想，系统中需要有多少磁盘才能使加法计算法的 I/O 次数少于减法计算法；交叉点是多少？</p>
<p>在进行性能分析时，我们假设使用的是减法。因此，每写一次，RAID 必须执行 4 次物理 I/O（两次读和两次写）。现在假设有大量的写操作提交给 RAID，那么 RAID-4 可以并行执行多少次写操作呢？要理解这一点，让我们再看看 RAID-4 布局，如下表所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=small" data-sub-html="<h2>image-20240415102557259</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png" alt="image-20240415102557259" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=large 2x" data-title="image-20240415102557259" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设大约在同一时间有 2 个小写入提交到 RAID-4，即块 4 和 13（表中用 * 标记）。这些磁盘的数据位于磁盘 0 和 1 上，因此数据的读取和写入可以并行发生，这很好。出现的问题是奇偶校验磁盘；两个请求都必须读取 4 和 13 的相关奇偶校验块、奇偶校验块 P1 和 P3（用 + 标记）。希望问题现在已经清楚了：奇偶校验磁盘是此类工作负载下的瓶颈；因此，我们有时将其称为基于奇偶校验的 RAID 的<strong>小写入问题</strong>。因此，<font color="red">即使数据磁盘可以并行访问，奇偶校验磁盘也会阻止任何并行性的实现；由于奇偶校验磁盘的存在，对系统的所有写入都将被序列化</font>。由于奇偶校验磁盘每个逻辑 I/O 必须执行两次 I/O（一次读，一次写），因此我们可以通过计算奇偶校验磁盘在这两个 I/O 上的性能来计算 RAID-4 中小型随机写入的性能，因此我们达到了 $\frac{R}{2}$ MB/s。随机小写入下的 RAID-4 吞吐量很糟糕；当您向系统添加磁盘时，它不会得到改善。</p>
<p>最后，我们将分析 RAID-4 中的 I/O 延迟。大家现在都知道，单次读取（假设没有故障）只是映射到单个磁盘，因此其延迟相当于单个磁盘请求的延迟。单次写入的延迟需要两次读取，然后两次写入；读取和写入可以并行进行，因此总延迟大约是单个磁盘的两倍（存在一些差异，因为我们必须等待两次读取完成，从而获得最坏情况下的定位时间，但更新不会产生寻道成本，因此可能是比平均定位成本更好的定位时间）。</p>
<h2 id="raid-level-5旋转奇偶校验" class="heading-element"><span>8 RAID Level 5：旋转奇偶校验</span>
  <a href="#raid-level-5%e6%97%8b%e8%bd%ac%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-3" class="heading-element"><span>8.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了解决（至少部分地）小写入问题，Patterson、Gibson 和 Katz 引入了 RAID-5。 RAID-5 的工作方式几乎与 RAID-4 相同，只是它在驱动器之间旋转奇偶校验块，如下表所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=small" data-sub-html="<h2>image-20240415103321139</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png" alt="image-20240415103321139" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=large 2x" data-title="image-20240415103321139" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如您所看到的，每个条带的奇偶校验块现在在磁盘上旋转，以消除 RAID-4 的奇偶校验磁盘瓶颈。</p>
<h3 id="raid-5-分析" class="heading-element"><span>8.2 RAID 5 分析</span>
  <a href="#raid-5-%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>RAID-5 的大部分分析与 RAID-4 相同。例如，两个级别的有效容量和容错能力是相同的。顺序读写性能也是如此。单个请求（无论是读还是写）的延迟也与 RAID-4 相同。</p>
<p>随机读取性能好一点，因为我们现在可以利用所有磁盘。最后，随机写入性能比 RAID-4 显着提高，因为它<font color="red">允许跨请求并行</font>。想象一下对块 1 的写入和对块 10 的写入；这将变成对磁盘 1 和磁盘 4 的请求（针对块 1 及其奇偶校验P0）以及对磁盘 0 和磁盘 2 的请求（针对块 10 及其奇偶校验P2）。因此，它们可以并行进行。事实上，我们通常可以假设，给定大量随机请求，我们将能够保持所有磁盘均匀忙碌。如果是这样的话，那么我们小写的总带宽将是 $\frac{N}{4}\cdot R$ MB/s。 4 个丢失的因素是由于每次 RAID-5 写入仍然生成 4 次总 I/O 操作，这只是使用基于奇偶校验的 RAID 的成本。</p>
<p>因为 RAID-5 基本上与 RAID-4 相同，除了在少数情况下更好之外，在市场上几乎完全取代了 RAID-4。唯一没有被取代的地方是那些知道自己永远不会执行大写操作的系统，从而完全避免小写问题；在这些情况下，有时会使用 RAID-4，因为它构建起来稍微简单一些。</p>
<h2 id="raid-比较" class="heading-element"><span>9 RAID 比较</span>
  <a href="#raid-%e6%af%94%e8%be%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现在，如下表所示，我们总结了 RAID Levels的简化比较。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=small" data-sub-html="<h2>image-20240415103909530</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png" alt="image-20240415103909530" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=large 2x" data-title="image-20240415103909530" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，我们省略了许多细节以简化我们的分析。例如，在镜像系统中写入时，平均寻道时间比仅写入单个磁盘时稍长，因为寻道时间是两次寻道（每个磁盘上一次）的最大值。因此，两个磁盘的随机写入性能通常会略低于单个磁盘的随机写入性能。此外，在更新 RAID-4/5 中的奇偶校验磁盘时，第一次读取旧奇偶校验可能会导致完全寻道和旋转，但第二次写入奇偶校验只会导致旋转。</p>
<p>然而，表中的比较确实捕捉到了本质差异，并且对于理解跨 RAID Levels的权衡很有用。对于延迟分析，我们简单地使用 T 来表示对单个磁盘的请求所花费的时间。</p>
<p>总而言之：</p>
<ul>
<li>如果您严格<font color="red">要求性能而不关心可靠性</font>，那么<font color="red">条带化</font>显然是最好的。</li>
<li>然而，如果您想要<font color="red">随机 I/O 性能和可靠性</font>，<font color="red">镜像</font>是最好的；您所付出的成本是损失容量。</li>
<li>如果<font color="red">容量和可靠性</font>是您的主要目标，那么 <font color="red">RAID-5 就是首选</font>；您付出的代价是小写性能。最后，如果您<font color="red">始终执行顺序 I/O 并希望最大化容量</font>，那么 RAID-5 也是最有意义的。</li>
</ul>
]]></description></item><item><title>硬盘驱动器</title><link>https://hezephyr.github.io/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/</link><pubDate>Sat, 11 May 2024 21:01:32 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/</guid><description><![CDATA[<p>几十年来，硬盘驱动器一直是计算机系统中持久数据存储的主要形式，文件系统技术的大部分发展都是基于它们的行为。因此，在构建管理磁盘的文件系统软件之前，有必要了解磁盘操作的细节。</p>
<blockquote>
<center>关键问题</center>
<p>现代硬盘驱动器如何存储数据？接口是什么？数据实际上是如何布局和访问的？磁盘调度如何提高性能？</p>
</blockquote>
<h2 id="接口" class="heading-element"><span>1 接口</span>
  <a href="#%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>让我们先来了解一下现代磁盘驱动器的接口。所有现代硬盘的基本接口都很简单。硬盘由大量扇区（512 字节块）组成，每个扇区都可读写。在有 <code>n</code> 个扇区的磁盘上，扇区的编号从 <code>0</code> 到 <code>n - 1</code>。因此，我们可以将磁盘视为一个扇区数组；<code>0</code> 至 <code>n - 1</code> 就是<strong>硬盘的地址空间</strong>。</p>
<p>多扇区操作是可能的；事实上，许多文件系统一次可以读写 4KB （或更多）。不过，在更新磁盘时，硬盘制造商唯一能保证的是<font color="red">单次 512 字节的写入是原子性的（即要么全部完成，要么根本不完成）</font>；因此，如果发生意外断电，可能只会完成较大写入的一部分（有时称为撕裂写入）。</p>
<p>大多数磁盘驱动器客户端都会做出一些假设，但这些假设并没有在接口中直接指定；Schlosser 和 Ganger 将此称为磁盘驱动器的 &ldquo;不成文契约&rdquo;。具体来说，我们通常可以假定，<font color="red">访问硬盘地址空间内相邻的两个区块会比访问相距较远的两个区块更快</font>。我们通常还可以假设，<font color="red">以连续块（即顺序读取或写入）方式访问块是最快的访问模式，通常比任何随机访问模式都要快得多</font>。</p>
<h2 id="基本几何" class="heading-element"><span>2 基本几何</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e5%87%a0%e4%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>让我们开始了解现代磁盘的一些组成部分。我们先从<strong>盘片</strong>开始，盘片是一个圆形硬表面，通过磁性变化将数据持久地存储在上面。磁盘可能有一个或多个盘片；每个盘片有两个面，每个面称为一个表面。这些盘片通常由某种硬质材料（如铝）制成，然后涂上一层薄薄的磁层，使硬盘即使在关机时也能持久存储比特数据。</p>
<p>盘片都围绕<strong>主轴</strong>结合在一起，主轴与电机相连，电机以恒定（固定）的速度带动盘片旋转（当硬盘接通电源时）。转速通常以每分钟转数（RPM）为单位，现代的典型值在 7,200 RPM 到 15,000 RPM 之间。请注意，我们通常会对单次旋转的时间感兴趣，例如，转速为 10,000 RPM 的硬盘意味着单次旋转大约需要 6 毫秒（6 毫秒）。</p>
<p>数据以同心圆扇形编码在每个表面上；我们称这样的同心圆为一个<strong>磁道</strong>。单个表面包含成千上万条轨道，它们紧密地排列在一起，数百条轨道的宽度仅相当于人的头发丝。</p>
<p>要从磁盘表面读写，我们需要一种机制，让我们能够感知（即读取）磁盘上的磁性图案，或引起磁性图案的变化（即写入）。读写过程由<strong>磁头</strong>完成；驱动器的每个表面都有一个磁头。磁头连接在单个<strong>磁盘臂</strong>上，磁盘臂在磁盘表面移动，将磁头定位在所需磁道上。</p>
<h2 id="简单的磁盘驱动器" class="heading-element"><span>3 简单的磁盘驱动器</span>
  <a href="#%e7%ae%80%e5%8d%95%e7%9a%84%e7%a3%81%e7%9b%98%e9%a9%b1%e5%8a%a8%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="工作原理" class="heading-element"><span>3.1 工作原理</span>
  <a href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>磁盘结构如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hard_Disk_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hard_Disk_Example.png?size=small" data-sub-html="<h2>image-20240413220625584</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hard_Disk_Example.png" alt="image-20240413220625584" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hard_Disk_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hard_Disk_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hard_Disk_Example.png?size=large 2x" data-title="image-20240413220625584" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>让我们通过一次一个磁道构建模型来了解磁盘的工作原理。假设我们有一个单磁道的简单磁盘，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Disk_With_Just_A_Single_Track.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Disk_With_Just_A_Single_Track.png?size=small" data-sub-html="<h2>image-20240413143435952</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Disk_With_Just_A_Single_Track.png" alt="image-20240413143435952" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Disk_With_Just_A_Single_Track.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Disk_With_Just_A_Single_Track.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Disk_With_Just_A_Single_Track.png?size=large 2x" data-title="image-20240413143435952" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该磁道只有 12 个扇区，每个扇区大小为 512 字节（我们典型的扇区大小），因此通过数字 0 到 11 进行寻址。我们这里的单盘片围绕主轴旋转，电机连接到主轴上。当然磁道本身并不重要；我们希望能够读取或写入这些扇区，因此我们需要一个磁头，连接到磁盘臂上，就像下图所示。在图中，连接到臂末端的磁盘头位于扇区 6 上方，并且表面逆时针旋转。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Single_Track_Plus_A_Head.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Single_Track_Plus_A_Head.png?size=small" data-sub-html="<h2>image-20240413212732509</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Single_Track_Plus_A_Head.png" alt="image-20240413212732509" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Single_Track_Plus_A_Head.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Single_Track_Plus_A_Head.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Single_Track_Plus_A_Head.png?size=large 2x" data-title="image-20240413212732509" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="单磁道延迟旋转延迟" class="heading-element"><span>3.2 单磁道延迟：旋转延迟</span>
  <a href="#%e5%8d%95%e7%a3%81%e9%81%93%e5%bb%b6%e8%bf%9f%e6%97%8b%e8%bd%ac%e5%bb%b6%e8%bf%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了了解简单的单磁道磁盘如何处理请求，设想我们现在收到一个读取 0 号数据块的请求。磁盘应如何处理该请求？</p>
<p>在我们的简单磁盘中，磁盘无需做太多工作。特别是，<font color="red">它必须等待所需的扇区在磁头下旋转</font>。这种等待在现代硬盘中经常发生，是 I/O 服务时间的重要组成部分，因此有一个专门的名称：<strong>旋转延迟</strong>。在示例中，如果全部旋转延迟为$R$，那么磁盘在等待 0 进入读/写磁头（如果我们从 6 开始）时，需要大约 $\frac{R}{2}$ 的旋转延迟。在此单磁道上，最坏的情况是向扇区 5 提出请求，为了满足这样的请求，磁盘几乎要产生一个完整的旋转延迟。</p>
<h3 id="多磁道寻道时间" class="heading-element"><span>3.3 多磁道：寻道时间</span>
  <a href="#%e5%a4%9a%e7%a3%81%e9%81%93%e5%af%bb%e9%81%93%e6%97%b6%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>到目前为止，我们的磁盘只有一条磁道，这不太现实；现代磁盘当然有数百万条磁道。因此，让我们来看看更加逼真的磁盘表面，这个磁盘有三个磁道如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_Example.png?size=small" data-sub-html="<h2>image-20240413222542362</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_Example.png" alt="image-20240413222542362" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_Example.png?size=large 2x" data-title="image-20240413222542362" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，磁头当前位于最内侧的磁道上（包含 24 到 35 个扇区）；下一个磁道包含下一组扇区（12 到 23），最外侧的磁道包含第一个扇区（0 到 11）。</p>
<p>为了了解驱动器如何访问给定扇区，我们现在跟踪对远程扇区的请求会发生什么，例如，对扇区 11 的读取。为了服务此读取，驱动器必须首先将磁盘臂移动到正确的磁道（在本例中为最外层），这一过程称为<font color="red">寻道</font>。查找和旋转是成本最高的磁盘操作之一。</p>
<p>应该注意的是，寻道有多个阶段：首先是磁盘臂移动的加速阶段；然后当磁盘臂全速移动时滑行，然后当磁盘臂减慢时减速；当磁头小心地定位在正确的磁道上时，最终稳定下来。稳定时间通常非常重要，例如 0.5 到 2 毫秒，因为驱动器必须确保找到正确的磁道。</p>
<p>寻道后，磁盘臂将磁头定位在正确的磁道上。下图描述了寻道。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_With_Seek_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_With_Seek_Example.png?size=small" data-sub-html="<h2>image-20240414105224859</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_With_Seek_Example.png" alt="image-20240414105224859" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_With_Seek_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_With_Seek_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Plus_A_Head_With_Seek_Example.png?size=large 2x" data-title="image-20240414105224859" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如我们所看到的，在寻道过程中，磁盘臂已移动到所需的磁道，并且盘片当然也旋转了，在本例中大约旋转了 3 个扇区。这样，扇区9即将从磁头下方经过，我们只需忍受短暂的旋转延迟即可完成传输。</p>
<p>当扇区 11 经过磁盘头下方时，将发生 I/O 的最后阶段，称为传输，其中数据从表面读取或写入表面。这样，我们就有了 I/O 时间的完整情况：首先是寻道，然后等待旋转延迟，最后是传输。</p>
<h3 id="其他一些细节" class="heading-element"><span>3.4 其他一些细节</span>
  <a href="#%e5%85%b6%e4%bb%96%e4%b8%80%e4%ba%9b%e7%bb%86%e8%8a%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>关于硬盘驱动器的运行方式还有一些其他有趣的细节。许多驱动器采用某种<font color="red">磁道倾斜</font>来确保即使在跨越磁道边界时也可以正确服务顺序读取。在我们的简单示例磁盘中，这可能如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Track_Skew_Of_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Track_Skew_Of_2.png?size=small" data-sub-html="<h2>image-20240414105619864</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Track_Skew_Of_2.png" alt="image-20240414105619864" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Track_Skew_Of_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Track_Skew_Of_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Three_Tracks_Track_Skew_Of_2.png?size=large 2x" data-title="image-20240414105619864" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>扇区通常会出现这样的倾斜，因为从一个磁道切换到另一个磁道时，磁盘需要时间来重新定位磁头（甚至是相邻的磁道）。如果没有这种偏斜，磁头会移动到下一个磁道，但所需的下一个区块已经在磁头下方旋转，因此硬盘需要等待几乎整个旋转延迟才能访问下一个区块。</p>
<p>另一个实际情况是，外磁道往往比内磁道有更多的扇区，这是几何学的结果；因为外磁道有更多的空间。这些磁道通常被称为<strong>多分区磁盘驱动器</strong>，即磁盘被组织成多个区，一个区是表面上连续的一组磁道。每个区的每个磁道都有相同数量的扇区，外区的扇区数量多于内区。</p>
<p>最后，现代磁盘驱动器的一个重要组成部分是缓存，由于历史原因，有时也称为磁道缓冲区。这种缓存只是一小部分内存（通常约为 8 或 16 MB），磁盘驱动器可以用它来保存从磁盘读取或写入磁盘的数据。例如，从磁盘读取扇区时，磁盘驱动器可能会决定读入该磁道上的所有扇区，并将其缓存在内存中；这样做可让磁盘驱动器快速响应对同一磁道的任何后续请求。</p>
<p>在写入时，磁盘驱动器可以选择：是在将数据存入内存时确认写入已完成，还是在数据实际写入磁盘后确认？前者称为<font color="red">回写缓存（有时也称为即时报告）</font>，后者称为<font color="red">直写缓存</font>。回写缓存有时会让磁盘驱动器看起来 &ldquo;更快&rdquo;，但也可能是危险的；如果文件系统或应用程序要求按一定顺序将数据写入磁盘以保证正确性，回写缓存可能会导致问题。</p>
<h2 id="io时间" class="heading-element"><span>4 I/O时间</span>
  <a href="#io%e6%97%b6%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现在我们有了磁盘的抽象模型，可以通过一些分析来更好地了解磁盘性能。特别是，我们现在可以将 I/O 时间表示为三个主要部分的总和：
$$
T_{I/O}=T_{seek}+T_{rotation}+T_{transfer}
$$
请注意，I/O 速率 ($R_{I/O}$) 通常更容易用于驱动器之间的比较（如下所示），可以轻松地根据时间计算出来。只需将传输大小除以所花费的时间即可：
$$
R_{I/O}=\frac{Size_{Transfer}}{T_{I/O}}
$$
为了更好地了解 I/O 时间，让我们执行以下计算。假设有两个我们感兴趣的工作负载。第一个称为<font color="red">随机工作负载</font>，向磁盘上的随机位置发出小（例如 4KB）读取。随机工作负载在许多重要应用程序中很常见，包括数据库管理系统。第二种称为<Font color="red">顺序工作负载&lt;/，它只是从磁盘连续读取大量扇区，而不会跳转。顺序访问模式非常常见，因此也很重要。</p>
<p>为了了解随机工作负载和顺序工作负载之间的性能差异，我们需要首先对磁盘驱动器做出一些假设。让我们看一下<code>Seagate</code>的几款现代磁盘。第一个称为 Cheetah 15K.5，是一款高性能 SCSI 驱动器。第二个是 Barracuda，是一款专为容量而设计的硬盘。两者的详细信息如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Specs_SCSI_Versus.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Specs_SCSI_Versus.png?size=small" data-sub-html="<h2>image-20240414124805189</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Specs_SCSI_Versus.png" alt="image-20240414124805189" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Specs_SCSI_Versus.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Specs_SCSI_Versus.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Specs_SCSI_Versus.png?size=large 2x" data-title="image-20240414124805189" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如您所看到的，这些驱动器具有截然不同的特征，并且在许多方面很好地概括了磁盘驱动器市场的两个重要组成部分。第一个是**“高性能”<strong>驱动器市场，该市场的驱动器设计为尽可能快地旋转、提供较短的寻道时间并快速传输数据。第二个是</strong>“容量”**市场，其中每字节成本是最重要的方面；因此，驱动器速度较慢，但可以将尽可能多的位装入可用空间。</p>
<p>根据这些数字，我们可以开始计算驱动器在上述两种工作负载下的表现如何。让我们首先看看随机工作负载。假设每次 4 KB 读取发生在磁盘上的随机位置，我们可以计算每次此类读取需要多长时间。关于<code>Cheetah</code>：
$$
T_{seek}=4ms,T_{rotation}=2ms,T_{transfer}=30\mu s
$$
平均寻道时间（4 毫秒）是根据制造商报告的平均时间得出的；请注意，完全寻道（从表面的一端到另一端）可能需要三倍的时间。</p>
<blockquote>
<p>所有寻道距离的平均值（对于具有N个磁道的磁盘），在两个磁道x和y之间。</p>
<p>$\frac{1}{N^2}\sum\limits_{x=0}^N\sum\limits_{y=0}^N|x-y|\approx \frac{1}{N^2}\int_{x=0}^N\int_{y=0}^N|x-y|dxdy=\frac{1}{N^2}(\frac{1}{3}x^3-\frac{N}{2}x^2+\frac{N^2}{2}x)|_0^N=\frac{N}{3}$</p>
</blockquote>
<p>平均旋转延迟是直接根据转速计算出来的。15000 RPM 等于 250 RPS（每秒旋转次数）；因此，每次旋转需要 4 毫秒。磁盘平均旋转半圈，因此平均时间为 2 毫秒。最后，传输时间只是峰值传输速率的传输大小；在这里，它非常小，只需30 微秒。</p>
<p>因此，根据上述公式，Cheetah的 $T_{I/O}$大概等于 6 毫秒。要计算 I/O 速率，我们只需用传输大小除以平均时间，即可得出 Cheetah 在随机工作负载下的 RI/O 速率约为 0.66 MB/s。对 Barracuda 进行同样的计算后，$T_{I/O}$ 约为 13.2 毫秒，速度慢了一倍多，因此传输速率约为 0.31 MB/s。</p>
<p>现在我们来看看顺序工作负载。在这里，我们可以假设在进行一次很长的传输之前，有一次寻道和旋转。为简单起见，假设传输大小为 100 MB。因此，Cheetah 和 Barracuda 的 $T_{I/O}$分别约为 800 毫秒和 950 毫秒。因此，I/O 速率非常接近 125 MB/s 和 105 MB/s 的峰值传输速率。下图总结了这些计算。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Performance_Example2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Performance_Example2.png?size=small" data-sub-html="<h2>image-20240414134514487</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Performance_Example2.png" alt="image-20240414134514487" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Performance_Example2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Performance_Example2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Disk_Drive_Performance_Example2.png?size=large 2x" data-title="image-20240414134514487" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该图向我们展示了一些重要信息。首先，也是最重要的一点，随机和顺序工作负载之间的硬盘性能差距很大，Cheetah 几乎相差 200 倍左右，而 Barracuda 则相差 300 倍以上。这就是计算史上最明显的设计提示。</p>
<p>第二点更为微妙：高端 &ldquo;性能 &ldquo;硬盘与低端 &ldquo;容量 &ldquo;硬盘之间的性能差异很大。出于这个原因（还有其他原因），人们往往愿意花高价购买前者，而尽可能便宜地购买后者。</p>
<h2 id="磁盘调度" class="heading-element"><span>5 磁盘调度</span>
  <a href="#%e7%a3%81%e7%9b%98%e8%b0%83%e5%ba%a6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>由于 I/O 的成本很高，操作系统在决定向磁盘发出 I/O 的顺序方面一直扮演着重要角色。更具体地说，给定一组 I/O 请求后，<strong>磁盘调度程序</strong>会检查这些请求，并决定下一步调度哪个请求。在作业调度中，每个作业的长度通常是未知的，而磁盘调度则不同，我们可以很好地猜测一个 &ldquo;作业&rdquo;（即磁盘请求）需要多长时间。通过估算请求的寻道时间和可能的旋转延迟，磁盘调度程序可以知道每个请求需要多长时间，从而（贪婪地）挑选出服务时间最短的请求。因此，磁盘调度程序在运行时会尽量遵循 SJF（最短作业优先）原则。</p>
<h3 id="sstf最短寻道时间优先" class="heading-element"><span>5.1 SSTF：最短寻道时间优先</span>
  <a href="#sstf%e6%9c%80%e7%9f%ad%e5%af%bb%e9%81%93%e6%97%b6%e9%97%b4%e4%bc%98%e5%85%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一种早期的磁盘调度方法称为<font color="red">最短寻道时间优先 (SSTF)</font>（也称为最短寻道优先或 SSF）。 SSTF 按磁道对 I/O 请求队列进行排序，选择最近磁道上的请求首先完成。例如，假设磁头当前位置在内磁道上方，并且我们有对扇区21（中磁道）和2（外磁道）的请求，那么我们首先向21发出请求，等待其完成，然后向 2 发出请求，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Scheduling_Request_21_And_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Scheduling_Request_21_And_2.png?size=small" data-sub-html="<h2>image-20240414134912561</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Scheduling_Request_21_And_2.png" alt="image-20240414134912561" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Scheduling_Request_21_And_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Scheduling_Request_21_And_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Scheduling_Request_21_And_2.png?size=large 2x" data-title="image-20240414134912561" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>SSTF 在此示例中效果很好，首先搜索中磁道，然后搜索外磁道。然而，SSTF 并不是万能的，原因如下。首先，驱动器几何结构对于主机操作系统不可用；相反，它看到的是一个块数组。幸运的是，这个问题很容易解决。操作系统可以简单地实现<font color="red">最近块优先（NBF）</font>，而不是 SSTF，它接下来使用最近的块地址来调度请求。</p>
<p>第二个问题更为根本：<strong>饥饿</strong>。想象一下，在上面的示例中，如果磁头当前所在的内部轨道有稳定的请求流。然后，纯 SSTF 方法将完全忽略对任何其他轨道的请求。因此问题的关键是：如何处理磁盘饥饿？我们如何实现类似 SSTF 的调度但避免饥饿？</p>
<h3 id="电梯调度又称-scan-或-c-scan" class="heading-element"><span>5.2 电梯调度（又称 SCAN 或 C-SCAN）</span>
  <a href="#%e7%94%b5%e6%a2%af%e8%b0%83%e5%ba%a6%e5%8f%88%e7%a7%b0-scan-%e6%88%96-c-scan" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这个问题的答案早在几年前就已提出，而且相对简单明了。该算法最初被称为 <strong>SCAN</strong>，它只是在磁盘上来回移动，按顺序在磁道上处理请求。我们把在磁盘上的单次移动（从外磁道到内磁道，或从内磁道到外磁道）称为一次扫描。因此，如果磁道上的某个块的请求已经在这次磁盘扫描中得到过处理，那么该请求不会立即得到处理，而是会排队等待下一次扫描（另一个方向）。</p>
<p>SCAN 有许多变体，其作用都差不多。例如，Coffman 等人提出了 F-SCAN，在进行扫描时冻结待处理队列；这一操作将扫描过程中收到的请求放入队列，稍后再处理。这样做可以通过延迟服务晚到（但距离较近）的请求来避免远端请求的饥饿。</p>
<p><font color="red">C-SCAN</font> 是另一种常见的变体，是 Circular SCAN 的缩写。该算法不是双向扫描磁盘，而是只从外向内扫描，然后在外层磁道重置，重新开始。这样做对内磁道和外磁道都比较公平，因为纯粹的来回 SCAN 会偏向于中间磁道，也就是说，在扫描完外磁道后，SCAN 会经过中间磁道两次，然后再回到外磁道。</p>
<p>现在应该很清楚SCAN 算法（及其同类算法）有时被称为<strong>电梯算法</strong>的原因，因为它的行为就像一部电梯，要么上行，要么下行，而不仅仅是根据哪个楼层更近来处理对哪个楼层的请求。试想一下，如果你从 10 楼下到 1 楼，有人在 3 楼上了电梯并按了 4 楼，而电梯却因为 4 楼比 1 楼 &ldquo;近 &ldquo;而上了 4 楼，那该有多烦人！正如你所看到的，电梯算法在现实生活中的使用，可以防止在电梯上发生打斗。在磁盘中，它只是防止饥饿。</p>
<p>遗憾的是，SCAN 及其类似技术并不代表最好的调度技术。特别是，SCAN（甚至是 SSTF）实际上并没有尽可能地遵循 SJF 原则。尤其是，它们忽略了旋转。因此，这也是另一个关键症结所在：我们如何实现一个算法，更加接近SJF，并考虑寻道和旋转？</p>
<h3 id="sptf-最短定位时间优先" class="heading-element"><span>5.3 SPTF： 最短定位时间优先</span>
  <a href="#sptf-%e6%9c%80%e7%9f%ad%e5%ae%9a%e4%bd%8d%e6%97%b6%e9%97%b4%e4%bc%98%e5%85%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在讨论<strong>最短定位时间优先或 SPTF 调度</strong>（有时也称为最短访问时间优先或 SATF）（这是我们问题的解决方案）之前，让我们确保更详细地理解这个问题。下图展示了一个例子。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Sometimes_Not_Good_Enough.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Sometimes_Not_Good_Enough.png?size=small" data-sub-html="<h2>image-20240414140304936</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Sometimes_Not_Good_Enough.png" alt="image-20240414140304936" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Sometimes_Not_Good_Enough.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Sometimes_Not_Good_Enough.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSTF_Sometimes_Not_Good_Enough.png?size=large 2x" data-title="image-20240414140304936" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在该示例中，磁头当前位于内轨道的第 30 个扇区上方。因此，调度程序必须决定：下一个请求应该调度 16 号扇区（位于中间磁道）还是 8 号扇区（位于外磁道）。那么，下一次应该为哪个扇区提供服务呢？</p>
<p>答案当然是 &ldquo;视情况而定&rdquo;。这里所说的取决于寻道时间与旋转时间的相对比。在我们的例子中，如果寻道时间远高于旋转延迟，那么 SSTF（及其变体）就没有问题。但是，设想一下：</p>
<ul>
<li>如果寻道时间比旋转时间快很多。那么，在我们的示例中，在外磁道上进一步寻道以服务请求 8 将比在中间磁道上执行较短的寻道以服务请求 16 更有意义，因为请求 16 在经过磁盘头之前必须旋转一圈。</li>
<li>如果旋转时间比寻道时间快很多。那么，服务请求16则比服务请求8更好。</li>
</ul>
<p>如上所述，在现代硬盘上，寻道和旋转大致相同（当然，这取决于具体的请求），因此 SPTF 非常有用并能提高性能。然而，在操作系统中实现 SPTF 就更加困难了，因为操作系统通常并不清楚磁道边界的位置或磁头当前的位置（旋转意义上）。因此，SPTF 通常在硬盘内部执行。</p>
<h3 id="其他调度问题" class="heading-element"><span>5.4 其他调度问题</span>
  <a href="#%e5%85%b6%e4%bb%96%e8%b0%83%e5%ba%a6%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在简要介绍基本磁盘操作、调度和相关主题时，我们还没有讨论其他许多问题。其中一个问题是：在现代系统中，磁盘调度是在哪里执行的？在旧系统中，所有的调度工作都是由操作系统完成的；在查看了一系列待处理请求后，操作系统会挑选出最佳请求并将其发送给磁盘。该请求完成后，再选择下一个请求，以此类推。那时的磁盘比较简单。</p>
<p>在现代系统中，磁盘可以容纳多个未处理请求，而且本身就有复杂的内部调度器（可以准确执行 <strong>SPTF</strong>；在磁盘控制器内部，所有相关细节都是可用的，包括磁头的准确位置）。因此，操作系统调度程序通常会选择它认为最好的几个请求（比如 16 个），并将它们全部发送给磁盘；然后，磁盘会利用其内部的磁头位置知识和详细的磁道布局信息，以最佳的（SPTF）顺序为上述请求提供服务。</p>
<p>磁盘调度程序执行的另一项重要相关任务是 <font color="red">I/O 合并</font>。例如，假设有一系列读取区块 33、8、34 的请求，如上图所示。在这种情况下，调度程序应将对第 33 和第 34 块的请求合并为一个单一的双块请求；调度程序所做的任何重新排序都是根据合并后的请求执行的。合并在操作系统层面尤为重要，因为它可以减少发送到磁盘的请求数量，从而降低开销。</p>
<p>现代调度程序要解决的最后一个问题是：在向磁盘发出 I/O 之前，系统应该等待多长时间？人们可能会天真地认为，磁盘一旦有了哪怕一个 I/O，就应该立即向驱动器发出请求；这种方法被称为<font color="red">工作保护</font>，因为如果有请求需要服务，磁盘就永远不会闲置。然而，对预期磁盘调度的研究表明，有时等待一下会更好，这就是所谓的非工作保护方法。通过等待，新的、&ldquo;更好的 &ldquo;请求可能会到达磁盘，从而提高整体效率。当然，决定何时等待、等待多长时间可能很棘手。</p>
]]></description></item><item><title>IO设备</title><link>https://hezephyr.github.io/posts/27.io%E8%AE%BE%E5%A4%87/</link><pubDate>Sat, 11 May 2024 20:59:41 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/27.io%E8%AE%BE%E5%A4%87/</guid><description><![CDATA[<h2 id="系统架构" class="heading-element"><span>1 系统架构</span>
  <a href="#%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了开始我们的讨论，让我们看一下典型系统的“经典”图。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Prototypical_System_Architecture_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Prototypical_System_Architecture_Example.png?size=small" data-sub-html="<h2>image-20240412145750053</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Prototypical_System_Architecture_Example.png" alt="image-20240412145750053" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Prototypical_System_Architecture_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Prototypical_System_Architecture_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Prototypical_System_Architecture_Example.png?size=large 2x" data-title="image-20240412145750053" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该图显示了通过<font color="red">某种内存总线或互连</font>连接到系统主内存的单个 CPU。一些设备通过<font color="red">通用 I/O 总线</font>连接到系统，在许多现代系统中，该总线是 <strong>PCI</strong>（或其众多衍生产品之一）；显卡和其他一些更高性能的 I/O 设备可能会在这里找到。最后，更底层的是我们所说的一种或多种<font color="red">外围总线</font>，例如 <strong>SCSI</strong>、<strong>SATA</strong> 或 USB。它们将慢速设备连接到系统，包括磁盘、鼠标和键盘。</p>
<p>您可能会问的一个问题是：为什么我们需要这样的层次结构？简而言之：物理和成本。公共汽车速度越快，其长度就必须越短；因此，高性能内存总线没有太多空间来插入设备等。此外，设计高性能总线的成本相当高。因此，系统设计人员采用了这种分层方法，其中需要高性能的组件（例如显卡）靠近 CPU。性能较低的组件距离较远。将磁盘和其他慢速设备放置在外围总线上的好处是多方面的。特别是，您可以在其上放置大量设备。</p>
<p>当然，现代系统越来越多地使用专用芯片组和更快的点对点互连来提高性能。下图为Intel Z270 芯片组的示意图。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Modern_System_Architecture.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Modern_System_Architecture.png?size=small" data-sub-html="<h2>image-20240412150741468</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Modern_System_Architecture.png" alt="image-20240412150741468" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Modern_System_Architecture.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Modern_System_Architecture.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Modern_System_Architecture.png?size=large 2x" data-title="image-20240412150741468" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在顶部，CPU 与内存系统的连接最紧密，但也与显卡（以及显示器）有高性能连接，以支持游戏和其他图形密集型应用程序。</p>
<p>CPU 通过<font color="red">英特尔专有的 DMI（Direct Media Interface, 直接媒体接口）</font>连接到 I/O 芯片，其余设备通过许多不同的互连连接到该芯片。右侧，一个或多个硬盘通过<font color="red">eSATA</font>接口连接到系统； ATA（AT 附件，指提供与 IBM PC AT 的连接）、SATA（串行 ATA）和现在的 eSATA（外部 SATA）代表了过去几十年来存储接口的演变，每向前一步都在增加性能与现代存储设备保持同步。</p>
<p>I/O 芯片下方是许多 <font color="red">USB（Universal Serial Bus, 通用串行总线）</font>连接，在此描述中，这些连接使键盘和鼠标能够连接到计算机。在许多现代系统中，USB 用于此类低性能设备。</p>
<p>最后，在左侧，其他更高性能的设备可以通过 <font color="red">PCIe（Peripheral Component Interconnect Express，外围组件互连扩展）</font>连接到系统。在此图中，网络接口连接到系统；更高性能的存储设备（例如NVMe持久存储设备）通常连接在这里。</p>
<p>下图是一个真实的配备 Xeon E5-2600 v4 的双插槽服务器，展示了两个CPU（中央处理器）及其相关组件的连接方式。每个CPU都具有多达22个核心，这两个CPU通过QPI链接连接，然后通过内存控制器与DRAM连接（DDR4（Double Data Rate 4）是一种内存标准，它提供了更高的数据传输速率和更低的功耗，是当前常见的内存类型）。此外，它们还与PCIe总线相连，并分别有40条PCIe线路到CPU1和CPU2。</p>
<p>CPU与众多外设的连接通常是通过主板上的I/O芯片组实现的，这个芯片组包括北桥（PCH，Platform Controller Hub）和南桥（ICH，I/O Controller Hub）。在较新的系统中，这些功能可能被集成到一个单一的PCH芯片中。DMI（Direct Media Interface）是CPU与PCH之间的一种高速连接接口，它允许CPU通过PCH与各种外设进行通信。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Real_CPU_System_Architecture_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Real_CPU_System_Architecture_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Real_CPU_System_Architecture_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Real_CPU_System_Architecture_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Real_CPU_System_Architecture_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Real_CPU_System_Architecture_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>下图显示了一个计算机系统的PCIe连接布局。从CPU Package开始，它通过Host Bridge与Root Complex(RC)相连。在RC中，有多个Core与Memory Controller相连。PCIe Switch位于RC和外设之间，管理着数据传输。此外，还有多个PCIe Bus、PCIe Bridge和PCIe Endpoint。每个部分都有其对应的bus、dev、fun、pri、sec和sub的标识。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Pcle_Structure_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Pcle_Structure_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Pcle_Structure_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Pcle_Structure_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Pcle_Structure_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Pcle_Structure_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="规范设备" class="heading-element"><span>2 规范设备</span>
  <a href="#%e8%a7%84%e8%8c%83%e8%ae%be%e5%a4%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现在让我们看一个规范设备（不是真实的设备），并使用该设备来加深我们对提高设备交互效率所需的一些机制的理解。如下图所示，我们可以看到设备有两个重要的组件。第一个是它向系统其余部分提供的硬件接口。就像软件一样，硬件也必须提供某种接口，允许系统软件控制其操作。因此，所有设备都有一些特定的接口和协议用于典型的交互。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Canonical_Device_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Canonical_Device_Example.png?size=small" data-sub-html="<h2>image-20240412155318734</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Canonical_Device_Example.png" alt="image-20240412155318734" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Canonical_Device_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Canonical_Device_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Canonical_Device_Example.png?size=large 2x" data-title="image-20240412155318734" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>任何设备的第二部分是其内部结构。设备的这一部分是特定于实现的，负责实现设备向系统呈现的抽象。非常简单的设备将有一个或几个硬件芯片来实现其功能；更复杂的设备将包括一个简单的 CPU、一些通用内存和其他特定于设备的芯片来完成其工作。例如，现代 RAID 控制器可能包含数十万行固件（即硬件设备内的软件）来实现其功能。</p>
<h2 id="规范协议" class="heading-element"><span>3 规范协议</span>
  <a href="#%e8%a7%84%e8%8c%83%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在上图中，（简化的）设备接口由三个寄存器组成：</p>
<ul>
<li><font color="red">状态寄存器</font>，可通过读取状态寄存器来查看设备的当前状态；</li>
<li><font color="red">命令寄存器</font>，用于通知设备执行某项任务；</li>
<li><font color="red">数据寄存器</font>，用于向设备传递数据或从设备获取数据。</li>
</ul>
<p>通过读写这些寄存器，操作系统可以控制设备的行为。现在，让我们来描述一下操作系统与设备之间可能进行的典型交互，以便让设备代表自己做一些事情。协议如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">While</span> <span class="p">(</span><span class="n">STATUS</span> <span class="o">==</span> <span class="n">BUSY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span> <span class="c1">// wait until device is not busy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Write</span> <span class="n">data</span> <span class="n">to</span> <span class="n">DATA</span> <span class="k">register</span>
</span></span><span class="line"><span class="cl"><span class="n">Write</span> <span class="n">command</span> <span class="n">to</span> <span class="n">COMMAND</span> <span class="nf">register</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">Doing</span> <span class="n">so</span> <span class="n">starts</span> <span class="n">the</span> <span class="n">device</span> <span class="n">and</span> <span class="n">executes</span> <span class="n">the</span> <span class="n">command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">While</span> <span class="p">(</span><span class="n">STATUS</span> <span class="o">==</span> <span class="n">BUSY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span> <span class="c1">// wait until device is done with your request
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该协议有四个步骤。</p>
<ol>
<li>首先，操作系统通过重复读取状态寄存器来等待设备准备好接收命令；我们称之为<strong>轮询</strong>设备（基本上，只是询问发生了什么）。</li>
<li>其次，操作系统将一些数据发送到数据寄存器；例如，可以想象，如果这是一个磁盘，则需要进行多次写入才能将磁盘块（例如 4KB）传输到设备。当主 CPU 参与数据移动时（如本示例协议所示），我们将其称为<font color="red">编程 I/O (PIO)</font>。</li>
<li>然后，操作系统向命令寄存器写入命令；这样做会隐式地让设备知道数据存在并且它应该开始处理命令。</li>
<li>最后，操作系统通过再次循环轮询设备来等待设备完成，等待查看它是否完成（然后可能会收到一个错误代码来指示成功或失败）。</li>
</ol>
<p>这个基本协议的优点是简单且有效。然而，这也存在一些低效率和不便之处。您可能在协议中注意到的第一个问题是轮询似乎效率低下；具体来说，它浪费了大量的 CPU 时间来等待（可能很慢的）设备完成其活动，而不是切换到另一个就绪进程，从而更好地利用 CPU。</p>
<p>所以问题关键是操作系统如何在不频繁轮询的情况下检查设备状态，从而降低管理设备所需的 CPU 开销？</p>
<h2 id="通过中断降低-cpu-开销" class="heading-element"><span>4 通过中断降低 CPU 开销</span>
  <a href="#%e9%80%9a%e8%bf%87%e4%b8%ad%e6%96%ad%e9%99%8d%e4%bd%8e-cpu-%e5%bc%80%e9%94%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>多年前，许多工程师为了改善这种交互方式，发明了我们已经见过的：中断。操作系统可以发出一个请求，让调用进程进入休眠状态，然后切换到另一个任务，而不是反复轮询设备。当设备最终完成操作时，它会引发硬件中断，导致 CPU 在预定的中断服务例程（ISR）或更简单的中断处理程序处跳转到操作系统。处理程序只是一段操作系统代码，它将完成请求（例如，从设备读取数据和错误代码），并唤醒等待 I/O 的进程，然后该进程可按需要继续运行。</p>
<p>因此，中断允许计算和 I/O 重叠，这是提高利用率的关键。这条时间线显示了问题所在：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Polling_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Polling_Example.png?size=small" data-sub-html="<h2>image-20240412161030799</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Polling_Example.png" alt="image-20240412161030799" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Polling_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Polling_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Polling_Example.png?size=large 2x" data-title="image-20240412161030799" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，进程 1 在 CPU 上运行一段时间（由 CPU 线上重复的 1 表示），然后向磁盘发出 I/O 请求以读取一些数据。在没有中断的情况下，系统只是简单地自旋，重复轮询设备的状态，直到 I/O 完成（由 p 表示）。磁盘服务该请求，最后进程 1 可以再次运行。</p>
<p>相反，如果我们利用中断并允许重叠，操作系统可以在等待磁盘时执行其他操作：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Interrupt.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Interrupt.png?size=small" data-sub-html="<h2>image-20240412161507503</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Interrupt.png" alt="image-20240412161507503" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Interrupt.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Interrupt.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_Interrupt.png?size=large 2x" data-title="image-20240412161507503" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，操作系统在 CPU 上运行进程 2，同时磁盘服务进程 1 的请求。当磁盘请求完成时，会发生中断，操作系统唤醒进程1并再次运行它。这样，CPU和磁盘在中间的一段时间内都得到了适当的利用。</p>
<p>请注意，使用中断并不总是最好的解决方案。例如，假设一个设备执行任务的速度非常快：第一次轮询通常会发现该设备已完成任务。在这种情况下使用中断实际上会减慢系统速度：切换到另一个进程、处理中断以及切换回发出进程的成本很高。<font color="red">因此，如果设备速度很快，最好进行轮询；如果速度很慢，那么允许重叠的中断是最好的。如果设备的速度未知，或者有时快有时慢，最好使用混合轮询一段时间，然后如果设备尚未完成，则使用中断。</font>这种分两阶段的方法可能会达到两全其美的效果。</p>
<p>不使用中断的另一个原因出现在网络中。当大量传入数据包均产生中断时，操作系统可能会发生活锁，即发现自己只处理中断，而不允许用户级进程运行并实际服务请求。例如，假设一个 Web 服务器由于成为黑客新闻上排名最高的条目而经历了负载爆发。在这种情况下，最好偶尔使用轮询来更好地控制系统中发生的情况，并允许 Web 服务器在返回设备检查更多数据包到达之前为某些请求提供服务。</p>
<p>另一种基于中断的优化是<font color="red">合并</font>。在这样的设置中，需要引发中断的设备首先等待一段时间，然后再将中断传递给 CPU。在等待期间，其他请求可能很快完成，因此可以将多个中断合并为单个中断传递，从而降低中断处理的开销。当然，等待太久会增加请求的延迟，这是系统中常见的权衡。</p>
<h2 id="通过-dma-实现更高效的数据移动" class="heading-element"><span>5 通过 DMA 实现更高效的数据移动</span>
  <a href="#%e9%80%9a%e8%bf%87-dma-%e5%ae%9e%e7%8e%b0%e6%9b%b4%e9%ab%98%e6%95%88%e7%9a%84%e6%95%b0%e6%8d%ae%e7%a7%bb%e5%8a%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>不幸的是，我们的规范协议还有另一个方面需要我们注意。特别是，当使用编程 I/O (PIO) 将大量数据传输到设备时，CPU 再次因一项相当琐碎的任务而负担过重，从而浪费了大量的时间和精力，而这些时间和精力本来可以更好地花在运行上其他流程。这个时间线说明了这个问题：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_Example_3.png?size=small" data-sub-html="<h2>image-20240413084020326</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_Example_3.png" alt="image-20240413084020326" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_Example_3.png?size=large 2x" data-title="image-20240413084020326" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在时间线中，进程 1 正在运行，然后希望将一些数据写入磁盘。然后它启动 I/O，该 I/O 必须将数据从内存显式复制到设备，一次一个字（图中标记为 c）。复制完成后，I/O 开始在磁盘上进行，CPU 最终可以用于其他用途。</p>
<blockquote>
<center>关键：如何降低 PIO 开销</center>
<p>使用 PIO，CPU 会花费太多时间手动将数据移入和移出设备。我们如何才能卸载这项工作，从而更有效地利用 CPU？</p>
</blockquote>
<p>解决这一问题的方法就是我们所说的直接内存访问（DMA）。DMA 引擎本质上是系统中一个非常特殊的设备，它可以在设备和主内存之间协调传输，而无需 CPU 的过多干预。DMA 的工作原理如下。以向设备传输数据为例，操作系统将对 DMA 引擎进行编程，告诉它数据在内存中的位置、需要复制多少数据以及发送到哪个设备。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setup_dma_transfer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">source_address</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">destination_address</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_size</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此时，操作系统就完成了传输，可以继续其他工作。当 DMA 完成时，DMA 控制器会发出中断，操作系统因此知道传输已经完成。修改后的时间线如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_DMA_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_DMA_Example.png?size=small" data-sub-html="<h2>image-20240413084446102</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_DMA_Example.png" alt="image-20240413084446102" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_DMA_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_DMA_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Utilization_By_DMA_Example.png?size=large 2x" data-title="image-20240413084446102" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从时间轴上可以看到，复制数据的工作现在由 DMA 控制器负责。因为在这段时间内 CPU 是空闲的，操作系统可以做其他事情，这里选择运行进程 2。这样，在进程 1 再次运行之前，进程 2 可以使用更多的 CPU。</p>
<h2 id="设备交互" class="heading-element"><span>6 设备交互</span>
  <a href="#%e8%ae%be%e5%a4%87%e4%ba%a4%e4%ba%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现在我们对执行 I/O 所涉及的效率问题有了一定的了解，为了将设备合并到现代系统中，我们还需要处理一些其他问题。到目前为止，您可能已经注意到一个问题：我们还没有真正谈论操作系统如何与设备实际通信！因此，关键问题是：</p>
<blockquote>
<p>硬件应该如何与设备通信？是否应该有明确的指示？或者还有其他方法可以做到吗？</p>
</blockquote>
<p>随着时间的推移，已经开发出两种主要的设备通信方法。第一种也是最古老的方法（IBM 大型机使用了很多年）是使用<font color="red">显式 I/O 指令</font>。这些指令指定操作系统将数据发送到特定设备寄存器的方式，从而允许构建上述协议。</p>
<p>例如，在 x86 系统中，<code>in</code> 和 <code>out</code> 指令可用于与设备通信。例如，要向设备发送数据，调用者需要指定<font color="red">一个包含数据的寄存器和一个命名设备的特定端口</font>。执行该指令后，就会产生所需的行为。</p>
<p>此类指令通常具有特权。操作系统控制着设备，因此操作系统是唯一允许与设备直接通信的实体。试想一下，如果任何程序都能读写磁盘，那么整个系统都会陷入混乱（一如既往），因为任何用户程序都可以利用这个漏洞完全控制机器。</p>
<p>与设备交互的第二种方法称为<font color="red">内存映射 I/O</font>。采用这种方法时，硬件会将设备寄存器当作内存位置来使用。要访问特定寄存器，操作系统会发出加载（读取）或存储（写入）地址；然后硬件会将加载/存储路由到设备，而不是主内存。</p>
<p>这两种方法并没有很大的优势。内存映射方法的优点是不需要新指令来支持，但这两种方法目前仍在使用。</p>
<h2 id="适配操作系统设备驱动程序" class="heading-element"><span>7 适配操作系统：设备驱动程序</span>
  <a href="#%e9%80%82%e9%85%8d%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们要讨论的最后一个问题是：我们将讨论的最后一个问题是：如何将具有非常特定接口的设备整合到操作系统中，而且我们希望保持尽可能通用。例如，考虑一个文件系统。我们希望构建一个可以在<code>SCSI</code>磁盘、<code>IDE</code>磁盘、<code>USB</code>闪存驱动器等设备上运行的文件系统，我们希望文件系统能相对忽略如何向这些不同类型的驱动器发出读取或写入请求的所有细节。</p>
<p>因此，我们面临的关键问题是：如何让操作系统的大部分功能保持设备中立，从而将设备交互的细节从主要的操作系统子系统中隐藏起来？</p>
<p>这个问题可以通过古老的<strong>抽象</strong>技术来解决。在最底层，操作系统中的一个软件必须详细了解设备是如何工作的。我们称这一软件为<font color="red">设备驱动程序</font>，设备交互的任何细节都封装在其中。</p>
<p>让我们通过研究 Linux 文件系统软件栈，看看这种抽象如何帮助操作系统的设计和实现。下图粗略描绘了 Linux 软件的组织结构。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_File_System_Stack_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_File_System_Stack_Example.png?size=small" data-sub-html="<h2>image-20240413091848773</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_File_System_Stack_Example.png" alt="image-20240413091848773" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_File_System_Stack_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_File_System_Stack_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_File_System_Stack_Example.png?size=large 2x" data-title="image-20240413091848773" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从图中可以看出，文件系统（当然也包括上面的应用程序）完全不关心它所使用的磁盘类的具体情况；它只需向通用块层发出块读写请求，通用块层会将这些请求路由到相应的设备驱动程序，设备驱动程序会处理发出具体请求的细节。虽然经过简化，但该图显示了这些细节是如何从操作系统的大部分功能中隐藏起来的。</p>
<p>该图还显示了设备的<font color="red">原始接口</font>，它使特殊应用程序（例如<font color="red">文件系统检查器</font>或<font color="red">磁盘碎片整理工具</font>）能够直接读取和写入块，而不使用文件抽象。大多数系统提供这种类型的接口来支持这些低级存储管理应用程序。</p>
<p>请注意，上面看到的封装也有其缺点。例如，如果有一个设备具有许多特殊功能，但必须向内核的其余部分提供通用接口，那么这些特殊功能将不会被使用。例如，在具有 SCSI 设备的 Linux 中就会出现这种情况，这些设备具有非常丰富的错误报告；因为其他块设备（例如 ATA/IDE）的错误处理要简单得多，所以更高级别的软件收到的只是通用 <code>EIO</code>（通用 IO 错误）错误代码；因此，<code>SCSI</code> 可能提供的任何额外细节都会在文件系统中丢失。</p>
<p>有趣的是，由于您可能插入系统的任何设备都需要设备驱动程序，因此随着时间的推移，它们已经占据了内核代码的很大一部分。对 Linux 内核的研究表明，超过 70% 的操作系统代码都存在于设备驱动程序中 ；对于基于 Windows 的系统，该值可能也相当高。因此，<font color="red">当人们告诉您操作系统有数百万行代码时，他们真正说的是操作系统有数百万行设备驱动程序代码。</font>当然，对于任何给定的安装，大部分代码可能并不活跃（即，一次只有少数设备连接到系统）。也许更令人沮丧的是，由于驱动程序通常是由“业余爱好者”（而不是全职内核开发人员）编写的，因此它们往往会存在更多错误，因此是导致内核崩溃的主要因素。</p>
<h2 id="案例研究简单的-ide-磁盘驱动程序xv6-使用-qemu-ide" class="heading-element"><span>8 案例研究：简单的 IDE 磁盘驱动程序（xv6 使用 QEMU IDE）</span>
  <a href="#%e6%a1%88%e4%be%8b%e7%a0%94%e7%a9%b6%e7%ae%80%e5%8d%95%e7%9a%84-ide-%e7%a3%81%e7%9b%98%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8fxv6-%e4%bd%bf%e7%94%a8-qemu-ide" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了更深入地研究，让我们快速看一下实际的设备：IDE 磁盘驱动器。我们将查看 xv6 源代码，以获取工作 IDE 驱动程序的简单示例。</p>
<p>IDE 磁盘为系统提供了一个简单的接口，由四种类型的寄存器组成：</p>
<ul>
<li>
<p><strong>控制寄存器</strong></p>
<p>Address 0x3F6 = 0x80 (0000 1RE0): R=reset, E=0 means &ldquo;enable interrupt”</p>
</li>
<li>
<p><strong>命令块寄存器</strong></p>
<p>Address 0x1F0 = Data Port Address</p>
<p>0x1F1 = Error Address</p>
<p>0x1F2 = Sector Count Address</p>
<p>0x1F3 = LBA low byte (Logical Block Address) Address</p>
<p>0x1F4 = LBA mid byte Address</p>
<p>0x1F5 = LBA hi byte Address</p>
<p>0x1F6 = 1B1D TOP4LBA: B=LBA, D=drive Address</p>
<p>0x1F7 = Command/status</p>
</li>
<li>
<p><strong>状态寄存器</strong></p>
<p>Address 0x1F7</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">7</th>
          <th style="text-align: left">6</th>
          <th style="text-align: left">5</th>
          <th style="text-align: left">4</th>
          <th style="text-align: left">3</th>
          <th style="text-align: left">2</th>
          <th style="text-align: left">1</th>
          <th style="text-align: left">0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">USY |</td>
          <td style="text-align: left">EADY |</td>
          <td style="text-align: left">AULT |</td>
          <td style="text-align: left">EEK |</td>
          <td style="text-align: left">RQ  |</td>
          <td style="text-align: left">ORR |</td>
          <td style="text-align: left">DX/EX |</td>
          <td style="text-align: left">RROR |</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>错误寄存器</strong></p>
<p>Address 0x1F1</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">7</th>
          <th style="text-align: left">6</th>
          <th style="text-align: left">5</th>
          <th style="text-align: left">4</th>
          <th style="text-align: left">3</th>
          <th style="text-align: left">2</th>
          <th style="text-align: left">1</th>
          <th style="text-align: left">0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">BK  |</td>
          <td style="text-align: left">NC  |</td>
          <td style="text-align: left">C   |</td>
          <td style="text-align: left">DNF |</td>
          <td style="text-align: left">CR  |</td>
          <td style="text-align: left">BRT |</td>
          <td style="text-align: left">0NF |</td>
          <td style="text-align: left">MNF |</td>
      </tr>
  </tbody>
</table>
<ul>
<li>BBK: Bad Block</li>
<li>UNC: Uncorrectable data error</li>
<li>MC: Media Changed</li>
<li>IDNF: ID mark Not Found</li>
<li>MCR: Media Change Requested</li>
<li>ABRT: Command aborted</li>
<li>T0NF: Track 0 Not Found</li>
<li>AMNF: Address Mark Not Found</li>
</ul>
</li>
</ul>
<p><font color="red">控制、命令块、状态和错误</font>。通过使用（在 x86 上）<code>in</code>和<code>out</code> I/O 指令读取或写入特定的“I/O 地址”（例如下面的 <code>0x3F6</code>），可以使用这些寄存器。</p>
<p>与设备交互的基本协议如下，假设设备已经初始化。</p>
<ul>
<li>**等待驱动器准备就绪。**读取状态寄存器 (<code>0x1F7</code>)，直到驱动器就绪且不繁忙。</li>
<li>**将参数写入命令寄存器。**将扇区计数、要访问的扇区的逻辑块地址 (LBA) 和驱动器编号（主驱动器 = 0x00 或从驱动器 = 0x10，因为 IDE 只允许两个驱动器）写入命令寄存器 (<code>0x1F2-0x1F6</code>)。</li>
<li>**启动I/O。**通过向命令寄存器发出读/写命令。将 <code>READ—WRITE</code> 命令写入命令寄存器 (0x1F7)。</li>
<li><strong>数据传输（用于写入）</strong>：等待驱动器状态为READY 和DRQ（驱动器数据请求）；将数据写入数据端口。</li>
<li>**处理中断。**在最简单的情况下，为每个传输的扇区处理一个中断；更复杂的方法允许批处理，从而在整个传输完成时进行最后一次中断。</li>
<li>**错误处理。**每次操作后，读取状态寄存器。如果 ERROR 位打开，读取错误寄存器以了解详细信息。</li>
</ul>
<p>该协议的大部分内容可以在 xv6 IDE 驱动程序中找到，如下面这段代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">buf</span> <span class="p">{</span> <span class="c1">//chunk of 512B to read/write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">sector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="c1">// LRU cache list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">qnext</span><span class="p">;</span> <span class="c1">// disk queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">uchar</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define B_BUSY  0x1  </span><span class="c1">// buffer is locked by some process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define B_VALID 0x2  </span><span class="c1">// buffer has been read from disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define B_DIRTY 0x4  </span><span class="c1">// buffer needs to be written to disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">ide_wait_ready</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(((</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="nf">inb</span><span class="p">(</span><span class="mh">0x1f7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">IDE_BSY</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">IDE_DRDY</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span> <span class="c1">// loop until drive isn’t busy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ide_start_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ide_wait_ready</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">outb</span><span class="p">(</span><span class="mh">0x3f6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// generate interrupt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// how many sectors? one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// write LBA to command register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f3</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span> <span class="c1">// LBA goes here ... LBA 0-7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f4</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span> <span class="c1">// ... and here LBA 8-15
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f5</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span> <span class="c1">// ... and here! LBA 16-23
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0x30 set LBA mode, ((b-&gt;dev&amp;1)&lt;&lt;4) 根据设备号（b-&gt;dev）来设置主/从设备位。设备号为 0 或 1，左移 4 位后会设置到控制寄存器中相应的位置。((b-&gt;sector&gt;&gt;24)&amp;0x0f) 用于提取 LBA 的第24到第27位，这些位表示扇区地址的高四位，然后通过与 0x0f 位掩码进行按位与运算来获取这些位。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f6</span><span class="p">,</span> <span class="mh">0xe0</span> <span class="o">|</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sector</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// B_DIRTY：缓冲区数据被修改过；B_VALID：缓冲区数据有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">B_DIRTY</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f7</span><span class="p">,</span> <span class="n">IDE_CMD_WRITE</span><span class="p">);</span> <span class="c1">// this is a WRITE，告诉磁盘控制器执行写入操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">outsl</span><span class="p">(</span><span class="mh">0x1f0</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">512</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// transfer data too!写入数据寄存器，outsl函数以32位（4字节）为单位传输数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">outb</span><span class="p">(</span><span class="mh">0x1f7</span><span class="p">,</span> <span class="n">IDE_CMD_READ</span><span class="p">);</span> <span class="c1">// this is a READ (no data) 告诉磁盘控制器执行读取操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ide_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ide_lock</span><span class="p">);</span>	<span class="c1">// 获取锁，确保对队列的访问是安全的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ide_queue</span><span class="p">;</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span> <span class="n">pp</span><span class="o">=&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">qnext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span> <span class="c1">// 遍历磁盘I/O 请求队列，移动到队尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// add request to end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ide_queue</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// if q is empty，则立即发送请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">ide_start_request</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// send req to disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B_VALID</span><span class="o">|</span><span class="n">B_DIRTY</span><span class="p">))</span> <span class="o">!=</span> <span class="n">B_VALID</span><span class="p">)</span> <span class="c1">// 直到请求的数据状态变为有效为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sleep</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ide_lock</span><span class="p">);</span> <span class="c1">// wait for completion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ide_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ide_intr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ide_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查当前请求是否是读取操作并且磁盘处于就绪状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">B_DIRTY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">ide_wait_ready</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">insl</span><span class="p">(</span><span class="mh">0x1f0</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">512</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// if READ: get data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">B_VALID</span><span class="p">;</span>	<span class="c1">// set flag to VALID，表示数据已经被读取或写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">B_DIRTY</span><span class="p">;</span>	<span class="c1">// 清除DIRTY flag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wakeup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// wake waiting process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">ide_queue</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">qnext</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// start next request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">ide_start_request</span><span class="p">(</span><span class="n">ide_queue</span><span class="p">);</span> <span class="c1">// (if one exists)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ide_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该驱动程序（初始化后）通过四个主要函数工作。</p>
<p>第一个是 <code>ide_rw()</code>，它将请求排队（如果还有其他待处理的请求），或者直接将其发送到磁盘（通过 <code>ide_start_request()</code>）；无论哪种情况，例程都会等待请求完成并将调用进程置于睡眠状态。</p>
<p>第二个是 <code>ide_start_request()</code>，用于向磁盘发送请求（在写入的情况下可能还有数据）； <code>in</code> 和 <code>out</code> x86 指令分别被调用来读取和写入设备寄存器。</p>
<p>启动请求例程使用第三个函数 <code>ide_wait_read()</code>，以确保驱动器在向其发出请求之前已准备就绪。</p>
<p>最后，当发生中断时，会调用 <code>ide_intr()</code>；它从设备读取数据（如果请求是读，而不是写），唤醒等待 I/O 完成的进程，并且（如果 I/O 队列中有更多请求），通过 <code>ide_start_request()</code>启动下一个 I/O。</p>
]]></description></item><item><title>基于事件的并发</title><link>https://hezephyr.github.io/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/</link><pubDate>Sat, 11 May 2024 20:55:25 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/</guid><description><![CDATA[<p>到目前为止，我们在写并发性的时候，好像构建并发应用程序的唯一方法就是使用线程。就像生活中的许多事情一样，这并不完全正确。具体来说，基于图形用户界面的应用程序和某些类型的互联网服务器经常使用不同风格的并发编程。这种风格被称为<font color="red">基于事件的并发</font>，已在一些现代系统中流行起来，包括 node.js 等服务器端框架，但其根源在于 C/UNIX 系统，我们将在下文讨论。</p>
<p>基于事件的并发解决了两个方面的问题。首先，在多线程应用程序中正确管理并发性是一项挑战；正如我们所讨论的，可能会出现锁丢失、死锁和其他令人讨厌的问题。其次，在多线程应用程序中，开发人员几乎无法控制特定时刻的调度；相反，程序员只需创建线程，然后寄希望于底层操作系统以合理的方式在可用 CPU 上调度这些线程。由于很难构建一个通用的调度程序，在所有情况下都能很好地处理所有工作负载，操作系统有时会以非最佳的方式调度工作。因此，我们的关键是：</p>
<blockquote>
<p>我们如何在不使用线程的情况下构建并发服务器，从而保留对并发的控制并避免一些似乎困扰多线程应用程序的问题？</p>
</blockquote>
<h2 id="基本思想事件循环" class="heading-element"><span>1 基本思想：事件循环</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如上所述，我们将使用的基本方法称为基于事件的并发。这种方法非常简单：只需等待某件事情（即 &ldquo;事件&rdquo;）发生；当事件发生时，检查事件的类型，并完成所需的少量工作（可能包括发出 I/O 请求，或安排其他事件的未来处理等）。就是这样！</p>
<p>在了解细节之前，我们先来看看典型的基于事件的服务器是什么样的。此类应用程序基于一个简单的结构，即事件循环。事件循环的伪代码是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">events</span> <span class="o">=</span> <span class="nf">getEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="n">in</span> <span class="n">events</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">processEvent</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实就是这么简单。主循环只需等待事件发生（在上面的代码中调用 <code>getEvents()</code>），然后对返回的每个事件逐个进行处理；处理每个事件的代码称为<font color="red">事件处理程序</font>。重要的是，当处理程序处理事件时，它是系统中发生的唯一活动；因此，决定下一步处理哪个事件就相当于调度。这种对调度的显式控制是基于事件的方法的基本优势之一。</p>
<p>但是，上述讨论给我们留下了一个更大的问题：基于事件的服务器究竟如何确定哪些事件正在发生，尤其是在网络和磁盘 I/O 方面？具体来说，事件服务器如何判断信息是否已经到达？</p>
<h2 id="一个重要的apiselect或者poll" class="heading-element"><span>2 一个重要的API：<code>select()</code>（或者<code>poll()</code>）</span>
  <a href="#%e4%b8%80%e4%b8%aa%e9%87%8d%e8%a6%81%e7%9a%84apiselect%e6%88%96%e8%80%85poll" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>考虑到这个基本事件循环，接下来我们必须解决如何接收事件的问题。在大多数系统中，可以通过 <code>select()</code> 或 <code>poll()</code> 系统调用使用一个基本 API。</p>
<p>这些接口使程序能够简单地检查是否有任何需要处理的传入 I/O。例如，想象一下一个网络应用（比如一个 Web 服务器）希望检查是否有任何网络数据包已经到达以便对其进行服务。这些系统调用让你正好做到了这一点。以 <code>select()</code> 为例。手册页（在 Mac 上）描述了该 API 的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">           <span class="n">fd_set</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">readfds</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">           <span class="n">fd_set</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">writefds</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">           <span class="n">fd_set</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">errorfds</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">           <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">timeout</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>手册页中的实际描述： <code>select()</code> 检查其地址在 <code>readfds</code>、<code>writefds</code> 和 <code>errorfds</code>中传递的 I/O 描述符集，以查看其中的某些描述符是否已准备好读取、准备好写入或有异常条件待定。检查每个集合中的第一个 <code>nfds</code> 描述符，即检查描述符集合中从 <code>0</code> 到 <code>nfds-1</code> 的描述符。返回时，<code>select()</code> 将给定的描述符集替换为由已准备好执行请求的操作的描述符组成的子集。 <code>select()</code> 返回所有集合中就绪描述符的总数。</p>
<p>关于 <code>select()</code> 的几点。首先，请注意，它可以让您检查描述符是否可以读取和写入；前者让服务器确定新数据包已到达并需要处理，而后者让服务知道何时可以回复（即出站队列未满）。</p>
<p>其次，注意超时参数。这里的一种常见用法是将超时设置为 <code>NULL</code>，这会导致 <code>select()</code> 无限期地阻塞，直到某个描述符准备就绪。然而，更强大的服务器通常会指定某种超时；一种常见的技术是将超时设置为零，从而使用对 <code>select()</code> 的调用来立即返回。</p>
<p><code>poll()</code> 系统调用非常相似。有关详细信息，请参阅其手册页。不管怎样，这些基本原语为我们提供了一种构建非阻塞事件循环的方法，它只需检查传入的数据包，从套接字中读取消息，并根据需要进行回复。</p>
<h2 id="使用select" class="heading-element"><span>3 使用<code>select()</code></span>
  <a href="#%e4%bd%bf%e7%94%a8select" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了更具体地说明这一点，我们来看看如何使用 <code>select()</code> 查看哪些网络描述符上有传入的报文。下面这段代码显示了一个简单的示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// open and set up a bunch of sockets (not shown)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// main loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// initialize the fd_set to all zero
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">fd_set</span> <span class="n">readFDs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readFDs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// now set the bits for the descriptors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// this server is interested in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// (for simplicity, all of them from min to max)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">fd</span> <span class="o">=</span> <span class="n">minFD</span><span class="p">;</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">maxFD</span><span class="p">;</span> <span class="n">fd</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readFDs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// do the select
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">select</span><span class="p">(</span><span class="n">maxFD</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readFDs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// check which actually have data using FD_ISSET()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">fd</span> <span class="o">=</span> <span class="n">minFD</span><span class="p">;</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">maxFD</span><span class="p">;</span> <span class="n">fd</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readFDs</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="nf">processFD</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码其实相当简单易懂。在初始化之后，服务器进入一个无限循环。在循环内部，它首先使用 <code>FD_ZERO()</code> 宏清除文件描述符集，然后使用 <code>FD_SET()</code> 将 <code>minFD</code> 到 <code>maxFD</code> 的所有文件描述符都包含在文件描述符集中。例如，这组描述符可能代表服务器正在关注的所有网络套接字。最后，服务器调用 <code>select()</code> 查看哪些连接上有可用数据。然后，在一个循环中使用 <code>FD_ISSET()</code>，事件服务器就能看到哪些描述符已准备好数据，并处理传入的数据。</p>
<p>当然，真正的服务器要比这复杂得多，需要在发送消息、发出磁盘 I/O 和许多其他细节时使用逻辑。</p>
<h2 id="为什么更简单不需要锁" class="heading-element"><span>4 为什么更简单？不需要锁</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9b%b4%e7%ae%80%e5%8d%95%e4%b8%8d%e9%9c%80%e8%a6%81%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了单 CPU 和基于事件的应用程序，并发程序中的问题就不复存在了。具体来说，由于一次只处理一个事件，因此无需获取或释放锁；基于事件的服务器不会被其他线程中断，因为它是绝对的单线程。因此，线程程序中常见的并发问题在基于事件的基本方法中并不存在。</p>
<blockquote>
<center>TIP：不要阻塞基于事件的服务器</center>
<p>基于事件的服务器可以对任务调度进行细粒度的控制。然而，为了维持这种控制，不能进行任何阻止调用者执行的调用；不遵守此设计技巧将导致基于事件的服务器被阻塞，会发生一系列的严重问题。</p>
</blockquote>
<h2 id="问题阻塞系统调用" class="heading-element"><span>5 问题：阻塞系统调用</span>
  <a href="#%e9%97%ae%e9%a2%98%e9%98%bb%e5%a1%9e%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>到目前为止，基于事件的编程听起来不错，对吗？你只需编写一个简单的循环，然后在事件发生时进行处理。你甚至不需要考虑锁定问题！但是有一个问题：<font color="red">如果一个事件要求你发出一个可能会阻塞的系统调用怎么办？</font></p>
<p>例如，假设客户端向服务器发出请求，要求从磁盘读取文件，并将文件内容返回给请求客户端（就像简单的 HTTP 请求一样）。要处理这样的请求，某个事件处理程序最终必须发出 <code>open()</code> 系统调用来打开文件，然后再发出一系列 <code>read()</code> 调用来读取文件。当文件被读入内存后，服务器可能会开始向客户端发送结果。</p>
<p><code>open()</code> 和 <code>read()</code> 调用都可能向存储系统发出 I/O 请求（当所需的元数据或数据不在内存中时），因此可能需要很长时间才能提供服务。对于基于线程的服务器来说，这不是问题：当发出 I/O 请求的线程暂停（等待 I/O 完成）时，其他线程可以运行，从而使服务器取得进展。事实上，I/O 和其他计算的这种自然重叠正是基于线程的编程非常自然和简单的原因。</p>
<p>然而，在基于事件的方法中，没有其他线程可以运行：只有主事件循环。这就意味着，如果事件处理程序发出的调用阻塞，整个服务器就会这样做：阻塞，直到调用完成。当事件循环阻塞时，系统就会处于闲置状态，从而造成巨大的潜在资源浪费。因此，在基于事件的系统中，我们有一条必须遵守的规则：不允许阻塞调用。</p>
<h2 id="解决方案异步-io" class="heading-element"><span>6 解决方案：异步 I/O</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e5%bc%82%e6%ad%a5-io" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了克服这一限制，许多现代操作系统引入了向磁盘系统发出 I/O 请求的新方法，一般称为<font color="red">异步 I/O</font>。这些接口使应用程序能够发出 I/O 请求，并在 I/O 完成之前立即将控制权返回给调用者；其他接口使应用程序能够确定各种 I/O 是否已完成。</p>
<p>例如，让我们看看 Mac 提供的接口（其他系统也有类似的 API）。应用程序接口围绕着一个基本结构，即<code>struct aiocb</code> 或 <strong>AIO 控制块</strong>（常用术语）。该结构的简化版本如下（更多信息请参阅手册）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">aiocb</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aio_fildes</span><span class="p">;</span> <span class="cm">/* File descriptor */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">aio_offset</span><span class="p">;</span> <span class="cm">/* File offset */</span>
</span></span><span class="line"><span class="cl">    <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aio_buf</span><span class="p">;</span> <span class="cm">/* Location of buffer */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">aio_nbytes</span><span class="p">;</span> <span class="cm">/* Length of transfer */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要对文件进行异步读取，应用程序应首先在此结构中填入相关信息：要读取文件的文件描述符（<code>aio_fildes</code>）、文件中的偏移量（<code>aio_offset</code>）以及请求的长度（<code>aio_nbytes</code>），最后是读取结果应复制到的目标内存位置（<code>aio_buf</code>）。</p>
<p>填入此结构后，应用程序必须发出异步调用来读取文件；在 Mac 上，此 API 只是异步读取 API：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该调用会尝试发出 I/O；如果成功，它就会立即返回，应用程序（即基于事件的服务器）可以继续工作。</p>
<p>不过，我们还必须解决最后一个难题。我们如何判断 I/O 是否已完成，从而确定缓冲区（<code>aio_buf</code> 指向的缓冲区）中已包含所请求的数据？这就需要最后一个 API。在 Mac 上，它被称为 <code>aio_error()</code>。该 API 如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">aio_error</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该系统调用检查 <code>aiocbp</code> 引用的请求是否已完成。如果是，则例程返回成功（用零表示）；如果不是，则返回 <code>EINPROGRESS</code>。因此，对于每个未完成的异步 I/O，应用程序可以通过调用 <code>aio_error()</code><font color="red"> 定期轮询系统，以确定所述 I/O 是否尚未完成</font>。</p>
<p>您可能已经注意到的一件事是检查 I/O 是否已完成是一件很痛苦的事情；如果一个程序在给定时间点发出了数十或数百个 I/O，它是否应该简单地重复检查每个 I/O，或者先等待一会儿，或者……？</p>
<p>为了解决这个问题，一些系统提供了一种基于中断的方法。此方法使用 UNIX 信号来通知应用程序异步 I/O 何时完成，从而无需重复询问系统。</p>
<p>在没有异步 I/O 的系统中，纯粹基于事件的方法无法实现。不过，聪明的研究人员已经推导出了能很好代替它们的方法。例如，Pai 等人 描述了一种混合方法，<font color="red">其中事件用于处理网络数据包，线程池用于管理未完成的 I/O。</font>详情请阅读他们的<a href="https://www.usenix.org/legacy/events/usenix99/full_papers/pai/pai.pdf"target="_blank" rel="external nofollow noopener noreferrer">论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<blockquote>
<center>UNIX 信号</center>
<p>在所有现代 UNIX 变体中，都有一个被称为<strong>信号</strong>的庞大而迷人的基础架构。最简单来说，信号提供了一种与进程通信的方式。具体来说，信号可以传递给应用程序；传递信号时，应用程序会停止正在进行的任何操作，以运行<strong>信号处理程序</strong>（即应用程序中处理该信号的代码）。处理完成后，进程将恢复之前的行为。</p>
<p>每个信号都有一个名称，如 <code>HUP</code>（挂起）、<code>INT</code>（中断）、<code>SEGV</code>（分段违规）等；详情请查看手册页面：<code>man signal</code>。有趣的是，有时内核本身也会发出信号。例如，当你的程序遇到分段违规时，操作系统会向其发送 <code>SIGSEGV</code>（在信号名称前加上 <code>SIG</code> 是很常见的）；如果你的程序被配置为捕获该信号，你实际上可以运行一些代码来响应这种错误的程序行为（这对调试很有用）。当一个信号被发送到一个未配置为处理该信号的进程时，一些默认行为将被执行；对于 <code>SEGV</code>，该进程将被杀死。</p>
<p>下面是一个进入无限循环的简单程序，但它首先设置了一个信号处理程序来捕获 <code>SIGHUP</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">handle</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;stop wakin’ me up...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">signal</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// doin’ nothin’ except catchin’ some sigs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你可以使用 kill 命令行工具向它发送信号。这样做会中断程序中的主 while 循环，并运行处理程序代码 <code>handle()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ ./loop_signal<span class="p">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>1<span class="o">]</span> <span class="m">66420</span>
</span></span><span class="line"><span class="cl">❯ <span class="nb">kill</span> -HUP <span class="m">66420</span>
</span></span><span class="line"><span class="cl">stop wakin’ me up...</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="另一个问题状态管理" class="heading-element"><span>7 另一个问题：状态管理</span>
  <a href="#%e5%8f%a6%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>基于事件的方法的另一个问题是，这类代码的编写通常比传统的基于线程的代码复杂。原因如下：当一个事件处理程序发出异步 I/O 时，它必须打包一些程序状态，供下一个事件处理程序在 I/O 最终完成时使用；而在基于线程的程序中不需要这项额外工作，因为程序所需的状态在线程的栈中。Adya 等人将这项工作称为<font color="red">人工栈管理</font>，它是基于事件的编程的基础。</p>
<p>为了更具体地说明这一点，让我们来看一个简单的例子：基于线程的服务器需要从文件描述符（<code>fd</code>）中读取数据，并在完成后将从文件中读取的数据写入网络套接字描述符（<code>sd</code>）。代码（忽略错误检查）如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">rc</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所看到的，在多线程程序中，做这样的工作是轻而易举的；当 <code>read()</code> 最终返回时，代码会立即知道要写入哪个套接字，因为该信息就在线程的堆栈中（在变量 <code>sd</code> 中）。</p>
<p>而在基于事件的系统中，情况就没那么简单了。要执行同样的任务，我们首先要使用上述 AIO 调用异步发出读取指令。假设我们使用 <code>aio_error()</code> 调用定期检查读取是否完成；当该调用通知我们读取完成时，基于事件的服务器如何知道该做什么？</p>
<p>正如 Adya 等人所描述的那样，解决办法是使用一种古老的编程语言结构，即 <code>continuation</code>。虽然听起来很复杂，但其实想法很简单：基本上，在某个数据结构中记录完成处理该事件所需的信息；当事件发生时（即磁盘 I/O 完成时），查找所需的信息并处理该事件。</p>
<p>在这种特殊情况下，解决方案是在某种数据结构（如哈希表）中记录套接字描述符 (<code>sd</code>)，并以文件描述符 (<code>fd</code>) 为索引。磁盘 I/O 完成后，事件处理程序将使用文件描述符查找<code>continuation</code>，并将套接字描述符的值返回给调用者。此时（最后），服务器就可以进行最后的工作，将数据写入套接字。</p>
<h2 id="事件仍有哪些困难" class="heading-element"><span>8 事件仍有哪些困难？</span>
  <a href="#%e4%ba%8b%e4%bb%b6%e4%bb%8d%e6%9c%89%e5%93%aa%e4%ba%9b%e5%9b%b0%e9%9a%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>基于事件的方法还有一些其他困难需要提及。例如，当系统从单核 CPU 转向多核 CPU 时，基于事件的方法的一些简便性就消失了。具体来说，为了利用一个以上的 CPU，事件服务器必须并行运行多个事件处理程序；这样做时，通常的同步问题（如临界区）就会出现，必须采用通常的解决方案（如锁）。因此，<font color="red">在现代多核系统上，不加锁的简单事件处理已不再可能。</font></p>
<p>基于事件的方法的另一个问题是，它不能很好地与<strong>分页</strong>等某些类型的系统活动集成。例如，如果事件处理程序发生页面故障，它就会阻塞，因此服务器在页面故障完成之前不会取得进展。尽管服务器在结构上已经避免了显式阻塞，但页面故障导致的这种隐式阻塞是难以避免的，因此在普遍存在时会导致严重的性能问题。</p>
<p>第三个问题是，随着时间的推移，基于事件的代码可能难以管理，因为各种例程的确切语义会发生变化。例如，如果一个例程从非阻塞变为阻塞，那么调用该例程的事件处理程序也必须随之改变，以适应其新的性质，即把自己撕成两半。由于阻塞对于基于事件的服务器来说是灾难性的，因此程序员必须时刻注意每个事件所使用的应用程序接口在语义上的变化。</p>
<p>最后，虽然异步磁盘 I/O 现在已经可以在大多数平台上实现，但它需要很长的时间才能实现，而且它与异步网络 I/O 的集成方式也不像你想象的那么简单和统一。例如，虽然我们希望使用 <code>select()</code> 接口来管理所有未完成的 I/O，但通常需要将用于网络的 <code>select()</code> 和用于磁盘 I/O 的 AIO 调用结合起来使用。</p>
]]></description></item><item><title>并发bug</title><link>https://hezephyr.github.io/posts/25.%E5%B9%B6%E5%8F%91bug/</link><pubDate>Sat, 11 May 2024 20:54:28 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/25.%E5%B9%B6%E5%8F%91bug/</guid><description><![CDATA[<h2 id="存在哪些类型的并发bug" class="heading-element"><span>1 存在哪些类型的并发bug？</span>
  <a href="#%e5%ad%98%e5%9c%a8%e5%93%aa%e4%ba%9b%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%b9%b6%e5%8f%91bug" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>第一个也是最明显的问题是：复杂的并发程序中会出现哪些类型的并发bug？这个问题一般来说很难回答，但幸运的是，其他一些人已经为我们完成了这项工作。具体来说，我们依赖于 Lu 等人的一项研究。它详细分析了许多流行的并发应用程序，以了解实践中出现的bug类型。</p>
<p>该研究重点关注四个主要且重要的开源应用程序：MySQL（流行的数据库管理系统）、Apache（著名的 Web 服务器）、Mozilla（著名的 Web 浏览器）和 OpenOffice（MS Office 套件的免费版本，有些人实际使用）。在这项研究中，作者研究了在每个代码库中发现并修复的并发性bug，将开发人员的工作转化为定量bug分析；了解这些结果可以帮助您了解成熟代码库中实际发生的问题类型。</p>
<p>下图显示了 Lu 及其同事研究的bug汇总。从图中可以看出，总共有 105 个bug，其中大部分不是死锁（74 个）；其余 31 个是死锁bug。此外，您还可以看到每个应用程序的bug数量；OpenOffice 的并发bug总数只有 8 个，而 Mozilla 则有近 60 个。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Bugs_In_Modern_Applications.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Bugs_In_Modern_Applications.png?size=small" data-sub-html="<h2>image-20240411160133229</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Bugs_In_Modern_Applications.png" alt="image-20240411160133229" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Bugs_In_Modern_Applications.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Bugs_In_Modern_Applications.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Bugs_In_Modern_Applications.png?size=large 2x" data-title="image-20240411160133229" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们现在对这些不同类别的bug（非死锁、死锁）进行更深入的研究。对于第一类非死锁bug，我们将使用研究中的示例进行讨论。对于第二类死锁bug，我们将讨论在预防、避免或处理死锁方面所做的大量工作。</p>
<h2 id="非死锁bug" class="heading-element"><span>2 非死锁bug</span>
  <a href="#%e9%9d%9e%e6%ad%bb%e9%94%81bug" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>根据 Lu 的研究，非死锁bug占并发bug的大多数。但这些bug属于哪种类型？它们是如何产生的？我们该如何修复它们？我们现在讨论 Lu 等人发现的两大类非死锁bug：原子性违规bug和顺序违规bug。</p>
<h3 id="原子性违规bug" class="heading-element"><span>2.1 原子性违规bug</span>
  <a href="#%e5%8e%9f%e5%ad%90%e6%80%a7%e8%bf%9d%e8%a7%84bug" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>遇到的第一类问题被称为原子性违规。下面是一个在 MySQL 中发现的简单示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fputs</span><span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="n">thd</span><span class="o">-&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在示例中，两个不同的线程访问了结构体 <code>thd</code> 中的字段 <code>proc_info</code>。第一个线程检查值是否为非空值，然后打印其值；第二个线程将其设置为空值。显然，如果第一个线程执行了检查，但在调用 <code>fputs</code> 之前被中断，那么第二个线程可能会在中间运行，从而将指针设置为 NULL；当第一个线程恢复运行时，它将崩溃，因为 NULL 指针将被 <code>fputs</code> 解除引用。</p>
<p>根据 Lu 等人的说法，原子性违规的更正式定义是：<font color="red">“违反了多个内存访问之间所需的可串行性（即代码区域应该是原子性的，但在执行过程中并未强制执行原子性）。”</font>在上面的示例中，代码对 <code>proc_info</code> 的非 NULL 检查以及 <code>fputs()</code> 调用中 <code>proc_info</code> 的使用有一个原子性假设（用 Lu 的话说）；当假设不正确时，代码将无法按预期工作。</p>
<p>找到此类问题的解决方案通常（但并非总是）很简单。在此解决方案中，我们只需在共享变量引用周围添加锁，确保当任一线程访问 <code>proc_info</code> 字段时，它都持有锁（<code>proc_info_lock</code>）。当然，访问该结构的任何其他代码也应该在执行此操作之前获取此锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">proc_info_lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_info_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fputs</span><span class="p">(</span><span class="n">thd</span><span class="o">-&gt;</span><span class="n">proc_info</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_info_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_info_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">thd</span><span class="o">-&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_info_lock</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="顺序违规bug" class="heading-element"><span>2.2 顺序违规bug</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e8%bf%9d%e8%a7%84bug" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Lu 等人发现的另一种常见的非死锁bug被称为 &ldquo;顺序违规&rdquo;。下面是另一个简单的例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">mThread</span> <span class="o">=</span> <span class="nf">PR_CreateThread</span><span class="p">(</span><span class="n">mMain</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mMain</span><span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">mState</span> <span class="o">=</span> <span class="n">mThread</span><span class="o">-&gt;</span><span class="n">State</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>线程 2 中的代码似乎假定变量 <code>mThread</code> 已被初始化（并且不是 NULL）；但是，如果线程 2 创建后立即运行，那么在线程 2 的 <code>mMain()</code> 中访问 <code>mThread</code> 时，它的值将不会被设置，并且很可能会因解引用 NULL 指针而崩溃。请注意，我们假设 <code>mThread</code> 的值最初为 NULL；如果不是，那么在线程 2 中通过解引用访问任意内存位置时，可能会发生更奇怪的事情。</p>
<p>违反顺序的更正式定义是这样的：<font color="red">&ldquo;两个（组）内存访问之间的理想顺序被颠倒（即 A 应总是在 B 之前执行，但在执行过程中顺序并没有被强制执行）&quot;。</font></p>
<p>解决这类bug的方法一般是强制执行排序。正如我们之前详细讨论过的，使用<strong>条件变量</strong>是将这种同步方式添加到现代代码库中的一种简单而稳健的方法。在上面的例子中，我们可以将代码重写如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">mtLock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_cond_t</span> 	<span class="n">mtCond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">mtInit</span> 			   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">mThread</span> <span class="o">=</span> <span class="nf">PR_CreateThread</span><span class="p">(</span><span class="n">mMain</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// signal that the thread has been created...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtInit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtCond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mMain</span><span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// wait for the thread to be initialized...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">mtInit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtCond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mState</span> <span class="o">=</span> <span class="n">mThread</span><span class="o">-&gt;</span><span class="n">State</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个固定的代码序列中，我们添加了一个锁（<code>mtLock</code>）和相应的条件变量（<code>mtCond</code>），以及一个状态变量（<code>mtInit</code>）。初始化代码运行时，它会将 <code>mtInit</code> 的状态设置为 1，并发出信号表示已完成设置。如果线程 2 在这之前运行，它将等待这个信号和相应的状态变化；如果线程 2 在之后运行，它将检查状态，发现初始化已经发生（即 <code>mtInit</code> 被设置为 1），从而继续正常运行。需要注意的是，我们可以使用 <code>mThread</code> 作为状态变量本身，但为了简单起见，这里不这样做。当线程之间需要排序时，条件变量（或 信号量）就能派上用场。</p>
<h2 id="死锁bug" class="heading-element"><span>3 死锁bug</span>
  <a href="#%e6%ad%bb%e9%94%81bug" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除了上面提到的并发bug，在许多具有复杂锁定协议的并发系统中还会出现一个典型的问题，即死锁。例如，当一个线程（例如线程 1）持有一个锁（L1）并等待另一个锁（L2）时，就会出现死锁；不幸的是，持有锁 L2 的线程（线程 2）正在等待 L1 被释放。下面的代码片段演示了这种潜在的死锁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span><span class="o">:</span> 					<span class="n">Thread</span> <span class="mi">2</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span> 	<span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span> 	<span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，如果这段代码运行，并不一定会发生死锁；相反，如果线程 1 获取锁 L1，然后线程 2 发生上下文切换，则可能会发生这种情况。此时，线程 2 获取 L2，并尝试获取 L1。因此，我们遇到了死锁，因为每个线程都在等待另一个线程，而两个线程都无法运行。</p>
<p>如下图所示，图中出现循环就表明出现了死锁。这张图应该能说明问题。程序员应该如何编写代码以便以某种方式处理死锁？我们问题的关键是我们应该如何构建系统来预防、避免或至少检测死锁并从中恢复？这是当今系统中真正的问题吗？</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Deadlock-Dependency-Graph.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Deadlock-Dependency-Graph.png?size=small" data-sub-html="<h2>image-20240411184424257</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Deadlock-Dependency-Graph.png" alt="image-20240411184424257" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Deadlock-Dependency-Graph.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Deadlock-Dependency-Graph.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Deadlock-Dependency-Graph.png?size=large 2x" data-title="image-20240411184424257" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="为什么会出现死锁" class="heading-element"><span>3.2 为什么会出现死锁</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0%e6%ad%bb%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>你可能会想，像上面这样的简单死锁似乎很容易避免。例如，如果线程 1 和线程 2 都确保以相同的顺序抓取锁，死锁就永远不会出现。那么，为什么会出现死锁呢？</p>
<p>其中一个原因是，在大型代码库中，组件之间会产生复杂的依赖关系。以操作系统为例。虚拟内存系统可能需要访问文件系统，以便从磁盘分页读入一个数据块；文件系统随后可能需要一个内存页来读入该数据块，从而与虚拟内存系统发生关联。因此，在大型系统中设计锁定策略时必须小心谨慎，以避免代码中可能自然出现的循环依赖关系造成死锁。</p>
<p>另一个原因是<strong>封装</strong>的本质。作为软件开发人员，我们被教导要隐藏实现的细节，从而使软件更容易以模块化的方式构建。遗憾的是，这种模块化与锁定并不匹配。正如 Jula 等人所指出的，一些看似无害的接口几乎会让你陷入死锁。例如，以 Java 向量类和 <code>AddAll()</code> 方法为例。这个例程的调用过程如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Vector</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="nf">AddAll</span><span class="p">(</span><span class="n">v2</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在内部，由于该方法需要是多线程安全的，因此需要获取添加到 (v1) 的向量和参数 (v2) 的锁。该例程以某种任意顺序获取所述锁（先是 v1，然后是 v2），以便将 v2 的内容添加到 v1。如果其他线程几乎同时调用 <code>v2.AddAll(v1)</code>，则可能会出现死锁，而所有这些都对调用应用程序来说是隐藏的。</p>
<h3 id="死锁原因" class="heading-element"><span>3.3 死锁原因</span>
  <a href="#%e6%ad%bb%e9%94%81%e5%8e%9f%e5%9b%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>发生死锁需要满足四个条件：</p>
<ol>
<li><strong>互斥</strong>：线程声明对其所需资源的独占控制（例如，线程获取锁）。</li>
<li><strong>持有并等待</strong>：线程持有分配给它们的资源（例如，它们已经获取的锁），同时等待其他资源（例如，它们希望获取的锁）。</li>
<li><strong>不可抢占</strong>：无法从持有资源的线程中强制删除资源（例如锁）。</li>
<li><strong>循环等待</strong>：存在循环线程链，使得每个线程持有链中下一个线程正在请求的一个或多个资源（例如，锁）。</li>
</ol>
<p>如果这四个条件中任何一个不满足，就不会发生死锁。因此，我们首先探索防止死锁的技术；这些策略中的每一个都旨在防止出现上述情况之一，因此是处理死锁问题的一种方法。</p>
<h3 id="预防死锁" class="heading-element"><span>3.4 预防死锁</span>
  <a href="#%e9%a2%84%e9%98%b2%e6%ad%bb%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="循环等待" class="heading-element"><span>3.4.1 循环等待</span>
  <a href="#%e5%be%aa%e7%8e%af%e7%ad%89%e5%be%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最实用的预防方法（当然也是经常使用的方法）可能是编写锁定代码，使其永远不会引起循环等待条件。要做到这一点，最直接的方法就是为锁的获取提供一个<strong>总排序</strong>。例如，如果系统中只有两个锁（<code>L1</code> 和<code>L2</code>），则可以通过始终在 <code>L2</code> 之前获取 <code>L1</code> 来防止死锁。这种严格的排序可以确保不会出现循环等待，从而避免死锁。</p>
<p>当然，在更复杂的系统中，会存在两个以上的锁，因此很难实现完全的锁排序（也许根本没有必要）。因此，部分排序可以有效地构建锁获取结构，从而避免死锁。Linux 中的内存映射代码就是一个很好的部分锁排序的真实例子；源代码顶部的注释揭示了十组不同的锁获取顺序，包括简单的如 &ldquo;<code>i_mutex</code> before <code>i_mmap_mutex</code> &ldquo;和更复杂的如 &ldquo;<code>i_mmap_mutex</code> before <code>private_lock</code> before <code>swap_lock</code> before <code>mapping-&gt;tree_lock</code>&quot;。</p>
<p>可以想象，无论是全部排序还是部分排序，都需要精心设计锁定策略，而且必须非常谨慎。此外，排序只是一种惯例，马虎的程序员很容易忽略锁定协议，并可能导致死锁。最后，锁排序要求对代码库以及各种例程的调用方式有深入的了解；只要有一个bug，就可能导致死锁。</p>
<blockquote>
<center>TIP：通过锁地址强制执行锁排序</center>
<p>在某些情况下，一个函数必须获取两个（或更多）锁；因此，我们知道我们必须小心，否则可能会出现死锁。想象一个按如下方式调用的函数：<code>do_something(mutex_t *m1, mutex_t *m2)</code>。如果代码总是在 <code>m2</code> 之前获取 <code>m1</code>（或者总是在 <code>m1</code> 之前获取 <code>m2</code>），则可能会死锁，因为一个线程可以调用 <code>do_something(L1, L2)</code>，而另一个线程可以调用 <code>do_something(L2, L1)</code>。</p>
<p>为了避免这个特殊问题，聪明的程序员可以使用每个锁的地址作为获取锁的顺序。通过以从高到低或从低到高的地址顺序获取锁，<code>do_something()</code> 可以保证它始终以相同的顺序获取锁，无论它们传入的顺序如何。代码看起来像这样这：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">m1</span> <span class="o">&gt;</span> <span class="n">m2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// grab locks in high-to-low address order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">m2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">m2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Code assumes that m1 != m2 (it is not the same lock)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过使用这种简单的技术，程序员可以确保简单高效地实现无死锁的多锁获取。</p>
</blockquote>
<h4 id="持有并等待" class="heading-element"><span>3.4.2 持有并等待</span>
  <a href="#%e6%8c%81%e6%9c%89%e5%b9%b6%e7%ad%89%e5%be%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>通过原子方式一次性获取所有锁，可以避免死锁的保持和等待要求。在实际操作中，可以通过以下方式实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">prevention</span><span class="p">);</span> <span class="c1">// begin lock acquisition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">prevention</span><span class="p">);</span> <span class="c1">// end
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过首先获取锁<code>prevention</code>，此代码确保在获取锁时不会发生任何不及时的线程切换，从而再次避免死锁。当然，这要求任何时候任何线程抓取一个锁时，它首先获取全局预防锁。例如，如果另一个线程尝试以不同顺序抓取锁<code>L1</code>和<code>L2</code>，则是可以的，因为在这样做时它将持有<code>prevention</code>锁。</p>
<p>请注意，由于多种原因，该解决方案存在问题。和以前一样，封装对我们不利：当调用例程时，这种方法要求我们准确地知道必须持有哪些锁并提前获取它们。这种技术还可能会降低并发性，因为所有锁都必须尽早（立即）获取，而不是在真正需要时获取。</p>
<h4 id="不可抢占" class="heading-element"><span>3.4.3 不可抢占</span>
  <a href="#%e4%b8%8d%e5%8f%af%e6%8a%a2%e5%8d%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>因为我们通常将锁视为一直保持到调用解锁为止，所以多次获取锁常常会给我们带来麻烦，因为在等待一个锁时，我们正在持有另一个锁。许多线程库提供了一组更灵活的接口来帮助避免这种情况。具体来说，例程 <code>pthread_mutex_trylock()</code> 要么获取锁（如果可用）并返回成功，要么返回指示锁已被持有的bug代码；在后一种情况下，如果您想抓住该锁，可以稍后重试。</p>
<p>这样的接口可以按如下方式使用来构建无死锁、有序鲁棒的锁获取协议：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nl">top</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，另一个线程可以遵循相同的协议，但以另一种顺序（先 <code>L2</code> 后 <code>L1</code>）获取锁，这样程序仍然不会出现死锁。然而，一个新的问题出现了：<strong>活锁</strong>。两个线程有可能（虽然可能性不大）都在重复尝试这种顺序，但多次都无法获得两个锁。在这种情况下，两个系统都在重复运行这个代码序列（因此不是死锁），但却没有取得进展，因此被称为活锁。活锁问题也有解决方法：例如，可以在循环之前添加一个随机延迟，然后重新尝试整个过程，从而降低竞争线程之间重复干扰的几率。</p>
<p>关于这个解决方案的一点是：它绕过了使用 <code>trylock</code> 方法的难点。第一个可能再次出现的问题是封装：如果这些锁中的一个被埋在某个被调用的例程中，那么跳回起点的实现就会变得更加复杂。<font color="red">例如，如果在获取 L1 后，代码分配了一些内存，那么在获取 L2 失败后，就必须释放这些内存，然后再跳回到顶层，重新尝试整个序列。</font>不过，在有限的情况下（例如前面提到的 Java 向量方法），这种方法可能会很有效。</p>
<p>你可能还会注意到，这种方法并没有真正加入抢占（从拥有锁的线程中强行夺走锁的操作），而是使用 <code>trylock</code> 方法允许开发者以一种优雅的方式退出锁的所有权（即抢占自己的所有权）。不过，这是一种实用的方法，因此尽管在这方面并不完美，我们还是将其包含在这里。</p>
<h4 id="互斥" class="heading-element"><span>3.4.4 互斥</span>
  <a href="#%e4%ba%92%e6%96%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最后一种防范技术是完全避免互斥。一般来说，我们知道这很困难，因为我们希望运行的代码确实存在临界区。那么我们能做些什么呢？</p>
<p>Herlihy 提出了一个想法：我们可以设计各种完全不需要锁的数据结构。这些无锁（以及相关的无等待）方法背后的理念很简单：利用强大的硬件指令，可以以不需要显式锁定的方式构建数据结构。</p>
<p>举个简单的例子，假设我们有一条比较和交换指令，你可能还记得这是一条由硬件提供的原子指令，它的作用如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">address</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>想象一下，我们现在想以原子方式将一个值递增一定量。我们可以这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">AtomicIncrement</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">old</span> <span class="o">+</span> <span class="n">amount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们没有获取锁，进行更新，然后释放它，而是构建了一种方法，反复尝试将值更新为心智并使用<code>CompareAndSwap</code>来执行此操作。通过这种方式，不会获取锁，并且不会出现死锁（尽管活锁仍然是可能的）。</p>
<p>让我们考虑一个稍微复杂的例子：列表插入。以下是在列表头部插入的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码执行简单的插入操作，但如果多个线程 &ldquo;同时 &ldquo;调用，就会出现竞争条件。当然，我们可以用获取和释放锁来解决这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">listlock</span><span class="p">);</span> <span class="c1">// begin critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">listlock</span><span class="p">);</span> <span class="c1">// end critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个解决方案中，我们使用了传统的锁。相反，我们可以尝试使用<code>CompareAndSwap</code>指令，以无锁定方式执行插入操作。下面是一种可行的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的代码会更新下一个指针，使其指向当前头部，然后尝试将新创建的节点交换到列表的新头部。但是，如果其他线程在此期间成功地交换了一个新的头，那么这个操作就会失败，从而导致这个线程用新的头再次重试。</p>
<p>当然，建立一个有用的列表需要的不仅仅是列表插入，毫不奇怪，建立一个能以无锁方式插入、删除和执行查找的列表并非易事。</p>
<h3 id="通过调度避免死锁" class="heading-element"><span>3.5 通过调度避免死锁</span>
  <a href="#%e9%80%9a%e8%bf%87%e8%b0%83%e5%ba%a6%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在某些情况下，避免死锁比预防死锁更可取。避免死锁需要一些全局知识，了解各个线程在执行期间可能会获取哪些锁，并随后以保证不会发生死锁的方式调度所述线程。</p>
<p>例如，假设我们有两个处理器和四个线程，必须在它们上进行调度。进一步假设我们知道线程 1 (<code>T1</code>) 获取锁 <code>L1</code> 和 <code>L2</code>（以某种顺序，在执行期间的某个时刻），<code>T2</code> 也获取 <code>L1</code> 和 <code>L2</code>，<code>T3</code> 仅获取 <code>L2</code>，而 <code>T4</code> 根本不获取锁。我们可以以表格形式展示线程的这些锁获取需求：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center">T1</th>
          <th style="text-align: center">T2</th>
          <th style="text-align: center">T3</th>
          <th style="text-align: center">T4</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">L1</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">no</td>
          <td style="text-align: center">no</td>
      </tr>
      <tr>
          <td style="text-align: center">L2</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">no</td>
      </tr>
  </tbody>
</table>
<p>因此，智能调度程序可以计算出，只要 <code>T1</code> 和 <code>T2</code> 不同时运行，就不会出现死锁。下面就是这样一个调度程序：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example.png?size=small" data-sub-html="<h2>image-20240411195407552</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example.png" alt="image-20240411195407552" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example.png?size=large 2x" data-title="image-20240411195407552" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，（<code>T3</code> 和 <code>T1</code>）或（<code>T3</code> 和 <code>T2</code>）是可以重叠的。即使 <code>T3</code> 抓住了锁 <code>L2</code>，它也不会因为与其他线程同时运行而导致死锁，因为它只抓住了一个锁。让我们再看一个例子。在这个例子中，对相同资源（同样是锁 <code>L1</code> 和 <code>L2</code>）的争用更多，如下面的争用表所示：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center">T1</th>
          <th style="text-align: center">T2</th>
          <th style="text-align: center">T3</th>
          <th style="text-align: center">T4</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">L1</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">Yes</td>
          <td style="text-align: center">no</td>
      </tr>
      <tr>
          <td style="text-align: center">L2</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">yes</td>
          <td style="text-align: center">no</td>
      </tr>
  </tbody>
</table>
<p>其中，线程 <code>T1</code>、<code>T2</code> 和 <code>T3</code> 都需要在执行过程中的某个时刻同时抓住锁 <code>L1</code> 和 <code>L2</code>。下面是一个可以保证不发生死锁的调度表：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example_2.png?size=small" data-sub-html="<h2>image-20240411195925218</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example_2.png" alt="image-20240411195925218" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CPU_Scheduler_Example_2.png?size=large 2x" data-title="image-20240411195925218" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如你所看到的，静态调度导致了一种保守的方法，即 <code>T1</code>、<code>T2</code> 和 <code>T3</code> 都在同一个处理器上运行，因此完成作业的总时间大大延长。虽然这些任务有可能同时运行，但由于担心死锁，我们无法这样做，而代价就是性能。</p>
<p>Dijkstra 的银行家算法就是这种方法的一个著名例子。遗憾的是，这些方法只在非常有限的环境中有用，例如，在嵌入式系统中，人们完全了解必须运行的全部任务集及其所需的锁。此外，这种方法还会限制并发性，正如我们在上文第二个例子中看到的那样。因此，通过调度避免死锁并不是一种广泛使用的通用解决方案。</p>
<h3 id="检测和恢复" class="heading-element"><span>3.6 检测和恢复</span>
  <a href="#%e6%a3%80%e6%b5%8b%e5%92%8c%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最后一个通用策略是允许死锁偶尔发生，然后在检测到死锁后采取一些措施。例如，如果操作系统每年都会出现一次死锁，那么你只需重启操作系统，然后继续愉快地（或暴躁地）工作。如果死锁很少发生，那么这种不解决问题的方法确实非常实用。</p>
<p>许多数据库系统都采用了死锁检测和恢复技术。死锁检测器定期运行，构建资源图并检查其是否存在循环。一旦出现循环（死锁），系统就需要重新启动。如果首先需要对数据结构进行更复杂的修复，则可能需要人工参与，以简化修复过程。</p>
]]></description></item><item><title>信号量</title><link>https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Sat, 11 May 2024 20:53:31 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description><![CDATA[<h2 id="信号量定义" class="heading-element"><span>1 信号量：定义</span>
  <a href="#%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%ae%9a%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>信号量是一个具有整数值的对象，我们可以使用两个例程对其进行操作；在 POSIX 标准中，这些例程是 <code>sem_wait()</code> 和 <code>sem_post()</code>。因为信号量的初始值决定了它的行为，所以在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，代码所下示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">sem_t</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在代码，我们声明了一个信号量 <code>s</code> 并通过将 1 作为第三个参数传递来将其初始化值为 1。在我们将看到的所有示例中，<code>sem_init()</code> 的第二个参数都将设置为 0；**这表明信号量在同一进程中的线程之间共享。**有关信号量其他用法的详细信息（即如何使用它们来同步不同进程之间的访问），请参阅手册页：<code>man sem_init</code>，这需要第二个参数的不同值。</p>
<p>信号量初始化后，我们可以调用两个函数之一与之交互：<code>sem_wait()</code> 或 <code>sem_post()</code>。这两个函数的行为如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Decrement the value of semaphore s by one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If the value becomes negative, the calling thread will block until it becomes positive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Once the value becomes positive, the thread will continue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="kt">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Increment the value of semaphore s by one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If there are one or more threads waiting (i.e., the semaphore was previously negative),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// wake one of the waiting threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>目前，我们不关心这些例程的实施，这显然需要一些小心；当多个线程调用 <code>sem_wait()</code> 和 <code>sem_post()</code> 时，显然需要管理这些临界区。我们现在将重点讨论如何使用这些原语；稍后我们可能会讨论它们是如何构建的。</p>
<p>我们应该在这里讨论接口的几个重要方面。</p>
<ul>
<li>首先，我们可以看到 <code>sem_wait()</code> 要么立即返回（因为当我们调用 <code>sem_wait()</code> 时信号量的值为 1 或更高），要么导致调用者暂停执行以等待后续的操作。当然，多个调用线程可能会调用 <code>sem_wait()</code>，因此所有线程都会排队等待被唤醒。</li>
<li>其次，我们可以看到 <code>sem_post()</code> 不会像 <code>sem_wait()</code> 那样等待某些特定条件成立。相反，它只是增加信号量的值，然后，如果有一个线程等待被唤醒，则唤醒其中一个线程。</li>
<li>第三，信号量的值，当为负时，等于等待线程的数量。虽然信号量的用户一般看不到这个值，但这个不变量还是值得了解的，也许它能帮助你记住信号量的功能。</li>
</ul>
<p>（暂时）不用担心信号量内可能出现的竞争条件；假设它们所做的操作是原子执行的。我们很快就会使用锁和条件变量来做到这一点。</p>
<h2 id="二进制信号量锁" class="heading-element"><span>2 二进制信号量（锁）</span>
  <a href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%bf%a1%e5%8f%b7%e9%87%8f%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们现在准备使用信号量。我们的第一个用途将是我们已经熟悉的：使用信号量作为锁。代码片段如下；其中，您会看到我们只是用 <code>sem_wait()/sem post()</code> 包围感兴趣的临界区。然而，使这项工作成功的关键是信号量 <code>m</code> 的初始值（代码中初始化为 X）。 X 应该是什么？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="c1">// Initialize semaphore to X; what should X be?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Critical section here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>回顾上面 <code>sem_wait()</code> 和 <code>sem_post()</code> 例程的定义，我们可以看到初始值应该是 1。</p>
<p>为了清楚起见，让我们想象有两个线程的场景。第一个线程（线程0）调用<code>sem_wait()</code>；它首先会递减信号量的值，将其更改为 0。然后，仅当该值不大于或等于 0 时才会等待。因为该值为 0，所以 <code>sem_wait()</code> 将简单地返回，并且调用线程将继续，线程 0 现在可以自由进入临界区。如果当线程 0 在临界区内时没有其他线程尝试获取锁，则当它调用 <code>sem_post()</code> 时，它只会将信号量的值恢复为 1（并且不会唤醒正在等待的线程，因为没有） 。下图显示了该场景的踪迹。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=small" data-sub-html="<h2>image-20240410161246190</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png" alt="image-20240410161246190" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=large 2x" data-title="image-20240410161246190" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当线程 0 “持有锁”（即，它已调用 <code>sem_wait()</code> 但尚未调用 <code>sem_post()</code>），并且另一个线程（线程 1）尝试通过调用 <code>sem_wait</code> 进入临界区时，会出现更有趣的情况。在这种情况下，线程 1 会将信号量的值递减至 $-1$，从而等待（使其自身进入睡眠状态并放弃处理器）。当线程 0 再次运行时，它最终会调用 <code>sem_post()</code>，将信号量的值递增回零，然后唤醒等待线程（线程 1），线程 1 就能够为自己获取锁。当线程 1 完成时，它将再次增加信号量的值，再次将其恢复为 1。</p>
<p>下图显示了此示例的踪迹。除了线程操作外，图中还显示了每个线程的<strong>调度器状态</strong>：运行、就绪（即可运行但未运行）和休眠。请特别注意，线程 1 在试图获取已持有的锁时进入了睡眠状态；只有当线程 0 再次运行时，线程 1 才能被唤醒并再次运行。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=small" data-sub-html="<h2>image-20240410161839026</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png" alt="image-20240410161839026" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=large 2x" data-title="image-20240410161839026" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果你想通过自己的示例来解决这个问题，可以尝试多个线程排队等待锁的场景。在这种跟踪过程中，semaphore 的值会是多少？</p>
<p>因此，我们可以将 semaphores 用作锁。由于锁只有两种状态（持有和未持有），因此我们有时将用作锁的信号量称为二进制信号量。需要注意的是，如果你只是以这种二进制方式使用一个信号量，那么它的实现方式可能比我们在这里介绍的通用信号量更简单。</p>
<h2 id="用于排序的信号量" class="heading-element"><span>3 用于排序的信号量</span>
  <a href="#%e7%94%a8%e4%ba%8e%e6%8e%92%e5%ba%8f%e7%9a%84%e4%bf%a1%e5%8f%b7%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>信号量对于对并发程序中的事件进行排序也很有用。例如，线程可能希望等待列表变为非空，以便可以从中删除元素。在这种使用模式中，我们经常发现一个线程等待某件事发生，而另一个线程使某件事发生，然后发出信号表明它已经发生，从而唤醒等待的线程。因此，我们使用信号量作为<strong>排序</strong>原语（类似于我们之前使用<strong>条件变量</strong>）。</p>
<p>下面是一个简单的例子。设想一个线程创建了另一个线程，然后想等待它完成执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">child</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Signal here: child is done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="c1">// What should X be?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Wait here for child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当这个程序运行时，我们希望看到以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nl">parent</span><span class="p">:</span> <span class="n">begin</span>
</span></span><span class="line"><span class="cl"><span class="n">child</span>
</span></span><span class="line"><span class="cl"><span class="nl">parent</span><span class="p">:</span> <span class="n">end</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么问题来了，如何使用信号量来达到这样的效果？事实证明，答案相对容易理解。正如您在代码中看到的，父线程只需调用 <code>sem_wait()</code> ，则子线程 调用<code>sem_post()</code> ，等待子线程完成执行的条件变为 true。然而，这就提出了一个问题：这个信号量的初始值应该是多少？</p>
<p>答案当然是信号量的值应该设置为0。有两种情况需要考虑。首先，我们假设父线程创建了子线程，但子线程尚未运行（即，它位于就绪队列中但未运行）。在这种情况下，如下图所示，父线程将子线程调用 <code>sem_post()</code> 之前调用 <code>sem_wait()</code>；我们希望父线程等待子线程运行起来。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20(Case%201).png?size=small" data-sub-html="<h2>image-20240410163051099</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png" alt="image-20240410163051099" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=large 2x" data-title="image-20240410163051099" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>发生这种情况的唯一方法是信号量的值不大于 0；因此，0 是初始值。父进程运行，将信号量递减（至 -1），然后等待（睡眠）。当子进程最终运行时，它将调用 <code>sem_post()</code>，将信号量的值增加到 0，并唤醒父进程，然后父进程将从 <code>sem_wait()</code> 返回并完成程序。</p>
<p>第二种情况发生在子线程在父线程有机会调用<code>sem_wait()</code> 之前运行完成时，运行跟踪如下图所示。在这种情况下，子线程将首先调用 <code>sem_post()</code>，从而将信号量的值从 0 增加到 1。当父线程有机会运行时，它将调用 <code>sem_wait()</code> 并发现信号量的值为 1；因此，父线程将递减该值（到 0）并从 <code>sem_wait()</code> 返回，无需等待，也达到了预期的效果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20(Case%202).png?size=small" data-sub-html="<h2>image-20240410163202016</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png" alt="image-20240410163202016" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=large 2x" data-title="image-20240410163202016" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="生产者消费者有界缓冲区问题" class="heading-element"><span>4 生产者/消费者（有界缓冲区）问题</span>
  <a href="#%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%9c%89%e7%95%8c%e7%bc%93%e5%86%b2%e5%8c%ba%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="首次尝试" class="heading-element"><span>4.1 首次尝试</span>
  <a href="#%e9%a6%96%e6%ac%a1%e5%b0%9d%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们解决这个问题的首次尝试引入了两个信号量：<code>empty</code> 和 <code>full</code>，线程将分别使用它们来指示缓冲区条目何时被清空或填满。下面是解决生产者和消费者问题的首次尝试代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer</span><span class="p">[</span><span class="n">fill</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>        <span class="c1">// Line F1: Place value in the buffer at the current fill index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fill</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX</span><span class="p">;</span>     <span class="c1">// Line F2: Move the fill index to the next position in a circular buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">use</span><span class="p">];</span>       <span class="c1">// Line G1: Retrieve the value from the buffer at the current use index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">use</span> <span class="o">=</span> <span class="p">(</span><span class="n">use</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX</span><span class="p">;</span>       <span class="c1">// Line G2: Move the use index to the next position in a circular buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>                  <span class="c1">// Return the retrieved value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">empty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">full</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>        <span class="c1">// Line P1: Wait for at least one empty buffer slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>                  <span class="c1">// Line P2: Produce an item and place it in the buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>         <span class="c1">// Line P3: Signal that a buffer slot has been filled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>         <span class="c1">// Line C1: Wait for at least one filled buffer slot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span>             <span class="c1">// Line C2: Consume an item from the buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>        <span class="c1">// Line C3: Signal that a buffer slot has been emptied
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span>    <span class="c1">// MAX buffers are empty to begin with...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>       <span class="c1">// ... and 0 are full
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个示例中，生产者首先等待缓冲区变空，然后将数据放入缓冲区，而消费者同样等待缓冲区被填满，然后才使用缓冲区。让我们先假设 <code>MAX=1</code>（数组中只有一个缓冲区），看看这样是否可行。</p>
<p>再假设有两个线程，一个生产者，一个消费者。让我们看看在单 CPU 上的具体情况。假设消费者先运行。因此，消费者将运行代码中的 C1 行，调用 <code>sem_wait(&amp;full)</code>。由于 <code>full</code> 的初始化值为 0，因此调用将递减 <code>full</code>（至 -1），阻塞消费者，并等待另一个线程按预期在 <code>full</code> 上调用 <code>sem_post()</code>。</p>
<p>假设生产者随后运行。它将运行到 P1 行，从而调用 <code>sem_wait(&amp;empty)</code> 例程。与消费者不同，生产者将继续运行这一行，因为 empty 已被初始化为 MAX 值（在本例中为 1）。因此，empty 将被递减为 0，生产者将把一个数据值放入缓冲区的第一个入口（P2 行）。然后，生产者将继续运行到 P3 行，并调用 <code>sem_post(&amp;full)</code>，将 <code>full</code> 信号量的值从 -1 改为 0，并唤醒消费者（例如，将其从阻塞状态转为就绪状态）。</p>
<p>在这种情况下，可能会发生两种情况。如果生产者继续运行，它将循环并再次运行 P1 行。如果生产者被中断，消费者开始运行，它将调用 <code>sem_wait(&amp;full)</code>（C1 行），发现缓冲区确实已满，从而消耗掉缓冲区。无论哪种情况，我们都实现了所需的行为。</p>
<p>你可以用更多线程（例如多个生产者和多个消费者）来尝试这个例子。它应该仍然有效。</p>
<p>现在让我们假设 MAX 大于 1（比如 <code>MAX = 10</code>）。在这个例子中，我们假设有多个生产者和多个消费者。现在我们遇到了一个问题：竞争条件。仔细看看<code> put()</code> 和<code>get()</code> 代码。想象一下，两个生产者（$P_a$ 和 $P_b$）同时调用 <code>put()</code>。假设生产者 $P_a$ 首先运行，并开始填充第一个缓冲区条目（F1 行的 <code>fill = 0</code>）。$P_a$ 还没来得及将<code>fill</code>计数器递增到 1，就被中断了。生产者 $P_b$ 开始运行，并在第 F1 行将其数据放入缓冲区的第 0 个元素，这意味着那里的旧数据被覆盖！这是不允许的；我们不希望生产者的任何数据丢失。</p>
<h3 id="一个解决方案添加互斥" class="heading-element"><span>4.2 一个解决方案：添加互斥</span>
  <a href="#%e4%b8%80%e4%b8%aa%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%b7%bb%e5%8a%a0%e4%ba%92%e6%96%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>正如你所看到的，我们在这里忘记了互斥。缓冲区的填充和缓冲区索引的递增是一个临界区，因此必须小心保护。因此，让我们使用我们的二进制信号量并添加一些锁，代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">empty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">full</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line P0 (NEW LINE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// Line P1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// Line P2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> <span class="c1">// Line P3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line P4 (NEW LINE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line C0 (NEW LINE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> <span class="c1">// Line C1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span> <span class="c1">// Line C2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// Line C3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line C4 (NEW LINE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// MAX buffers are empty to begin with...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// ... and 0 are full
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// mutex=1 because it is a lock (NEW LINE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="避免死锁" class="heading-element"><span>4.3 避免死锁</span>
  <a href="#%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在，我们在代码的整个 <code>put()/get()</code> 部分添加了一些锁，如 NEW LINE 注释所示。这似乎是个正确的想法，但却行不通。为什么？死锁。为什么会出现死锁？想象一下两个线程，一个生产者，一个消费者。消费者先运行。它获取了<code>mutex</code>（C0 行），然后在<code>full</code>信号量上调用 <code>sem_wait()</code>（C1 行）；由于还没有数据，这个调用会导致消费者阻塞，从而占用 CPU；但重要的是，消费者仍然持有锁。</p>
<p>然后生产者运行。如果它能运行，就能唤醒消费者线程，一切都会好起来。不幸的是，它做的第一件事就是调用二进制 <code>mutex</code>信号量（P0 行）上的 <code>sem_wait()</code>。该锁已被锁定。因此，生产者现在也只能等待。</p>
<p>这里有一个简单的循环。消费者持有<code>mutex</code>，正在等待某人发出<code>full</code>的信号。生产者可以发出<code>full</code>的信号，但也在等待<code>mutex</code>。因此，生产者和消费者都在互相等待：这就是典型的死锁。</p>
<h3 id="可行的解决方案" class="heading-element"><span>4.4 可行的解决方案</span>
  <a href="#%e5%8f%af%e8%a1%8c%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>要解决这个问题，我们只需缩小锁的范围。下面代码显示了正确的解决方案。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">empty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">full</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">sem_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// Line P1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line P1.5 (MOVED MUTEX HERE...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// Line P2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line P2.5 (... AND HERE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> <span class="c1">// Line P3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> <span class="c1">// Line C1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line C1.5 (MOVED MUTEX HERE...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span> <span class="c1">// Line C2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line C2.5 (... AND HERE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// Line C3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// MAX buffers are empty to begin with...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// ... and 0 are full
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// mutex=1 because it is a lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所看到的，我们只需将<code>mutex</code>获取和释放移到临界区附近；而<code>full</code>等待<code>empty</code>空等待以及信号代码则留在外部。这就是一个简单而有效的有界缓冲区，是多线程程序中常用的模式。</p>
<h2 id="读者写者锁" class="heading-element"><span>5 读者—写者锁</span>
  <a href="#%e8%af%bb%e8%80%85%e5%86%99%e8%80%85%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>另一个经典问题源于人们对更灵活的锁定原语的渴望，即不同的数据结构访问可能需要不同类型的锁定。举例来说，假设有许多并发的列表操作，包括插入和简单的查找。插入操作会改变 list 的状态（因此传统的临界区是合理的），而查找操作只是读取数据结构；只要我们能保证没有插入操作正在进行，我们就能允许许多查找操作并发进行。我们现在要开发的支持这种操作的特殊类型锁被称为读写锁。这种锁的代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_rwlock_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">sem_t</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">// binary semaphore (basic lock)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">sem_t</span> <span class="n">writelock</span><span class="p">;</span> <span class="c1">// used to allow ONE writer or MANY readers 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">readers</span><span class="p">;</span> <span class="c1">// count of readers reading in critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="kt">rwlock_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rwlock_init</span><span class="p">(</span><span class="kt">rwlock_t</span> <span class="o">*</span><span class="n">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rw</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Initialize lock semaphore with value 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">writelock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Initialize writelock semaphore with value 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rwlock_acquire_readlock</span><span class="p">(</span><span class="kt">rwlock_t</span> <span class="o">*</span><span class="n">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// Lock the critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rw</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Increment the number of readers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">writelock</span><span class="p">);</span> <span class="c1">// First reader acquires writelock, preventing writers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// Unlock the critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rwlock_release_readlock</span><span class="p">(</span><span class="kt">rwlock_t</span> <span class="o">*</span><span class="n">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// Lock the critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rw</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">--</span><span class="p">;</span> <span class="c1">// Decrement the number of readers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">writelock</span><span class="p">);</span> <span class="c1">// Last reader releases writelock, allowing writers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// Unlock the critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rwlock_acquire_writelock</span><span class="p">(</span><span class="kt">rwlock_t</span> <span class="o">*</span><span class="n">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">writelock</span><span class="p">);</span> <span class="c1">// Acquire writelock, preventing other readers and writers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rwlock_release_writelock</span><span class="p">(</span><span class="kt">rwlock_t</span> <span class="o">*</span><span class="n">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">writelock</span><span class="p">);</span> <span class="c1">// Release writelock, allowing other readers and writers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码非常简单。如果某个线程想要更新相关数据结构，它应该调用一对新的同步操作：<code>rwlock_acquire_writelock()</code>（获取写锁）和 <code>rwlock_release_ writelock()</code>（释放写锁）。在内部，这些操作只是使用<code>writelock</code>信号量来确保只有单个写者可以获取锁，从而进入临界区更新相关数据结构。</p>
<p>更有趣的是一对获取和释放读锁的例程。在获取读取锁时，读者首先获取锁，然后递增 <code>readers</code> 变量，以跟踪当前数据结构中有多少个读者。当第一个读者获得锁时，<code>rwlock_acquire_readlock()</code> 中的重要步骤就开始了；在这种情况下，读者也会通过调用<code>writelock</code>信号量上的 <code>sem_wait()</code> 来获得写锁，然后通过调用 <code>sem_post()</code> 来释放锁。</p>
<p>因此，一旦一个读者获得了读锁，就会允许更多读者也获得读锁；但是，任何希望获得写锁的线程都必须等到所有读者都读完；最后一个退出临界区的线程会调用 <code>writelock</code> 信号量上的<code>sem_post()</code>，从而让等待的写者获得写锁。</p>
<p>这种方法有效（如预期），但也有一些负面影响，特别是在公平性方面。特别是，读者饿死写者是相对容易的。对于这个问题存在更复杂的解决方案；也许你能想到更好的实现？提示：考虑一下一旦写者正在等待，您需要做什么来防止更多的读取者进入锁。</p>
<p>读者饿死写者的问题可以通过修改读者和写者的优先级策略来解决。具体思路如下：</p>
<ol>
<li><strong>增加写者优先策略</strong>：让写者优先于读者获取锁，这样当有写者等待时，新到来的读者需要等待写者完成后才能进入临界区。</li>
<li><strong>写者优先锁设计</strong>：引入一个额外的变量或信号量来表示写者是否在等待，如果有写者等待，读者需要等待写者完成后才能获取锁。</li>
</ol>
<p>最后，应该注意的是，应该谨慎使用读写锁。它们通常会增加更多的开销（特别是对于更复杂的实现），因此与仅使用简单且快速的锁定原语相比，最终不会提高性能。不管怎样，它们再次展示了我们如何以有趣且有用的方式使用信号量。</p>
<blockquote>
<center>TIP：简单而愚蠢的方法可能更好（希尔定律）</center>
<p>你永远不应该低估这样一种观念：简单而愚蠢的方法可能是最好的方法。对于锁定，有时简单的自旋锁效果最好，因为它易于实现且速度快。虽然读/写锁之类的东西听起来很酷，但它们很复杂，而复杂可能意味着缓慢。因此，总是先尝试简单而愚蠢的方法。这种追求简单的想法在很多地方都可以找到。早期的一个来源是 Mark Hill 的论文，该论文研究了如何为 CPU 设计缓存。 Hill 发现简单的直接映射缓存比花哨的集合关联设计效果更好（原因之一是在缓存中，更简单的设计可以实现更快的查找）。正如希尔简洁地总结他的工作：“大而笨更好。”因此，我们将类似的建议称为希尔定律。</p>
</blockquote>
<h2 id="哲学家就餐问题" class="heading-element"><span>6 哲学家就餐问题</span>
  <a href="#%e5%93%b2%e5%ad%a6%e5%ae%b6%e5%b0%b1%e9%a4%90%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>6.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Dijkstra 提出并解决的一个最著名的并发问题被称为 &ldquo;哲学家就餐问题&rdquo;。这个问题之所以有名，是因为它很有趣，在智力上也有点意思；然而，它的实际效用却很低。</p>
<p>问题的基本设置是这样的，如下图所示：假设有五位 &ldquo;哲学家 &ldquo;围坐在一张桌子旁。每对 &ldquo;哲学家 &ldquo;之间有一把叉子（因此一共有五把叉子）。哲学家们有思考的时候，不需要叉子，也有吃饭的时候。为了吃饭，哲学家需要两把叉子，左边的和右边的。对这些叉子的争夺以及随之而来的同步问题，正是我们在并发编程中要研究的问题。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=small" data-sub-html="<h2>image-20240410212019871</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png" alt="image-20240410212019871" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=large 2x" data-title="image-20240410212019871" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是每个哲学家的基本循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">think</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">getforks</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">eat</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">putforks</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么，关键的挑战是编写例程 <code>getforks()</code> 和 <code>putforks()</code>，这样就不会出现死锁，不会有哲学家挨饿而永远吃不到东西，并且并发性很高（即，许多哲学家可以同时吃饭）尽可能）。</p>
<p>我们将使用一些辅助函数来找到解决方案，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">left</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">right</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当哲学家 $p$ 希望引用他们左边的叉子时，他们只需调用 <code>left(p)</code>。类似地，通过调用 <code>right(p)</code> 来引用哲学家 $p$ 右边的叉子；其中的模运算符处理最后一个哲学家 ($p=4$) 试图抓住他们右边的叉子（叉子 0）的情况。</p>
<p>我们还需要一些信号量来解决这个问题。假设我们有五个，每个叉子一个：<code>sem_t forks[5]</code>。</p>
<h3 id="残缺的解决方案" class="heading-element"><span>6.2 残缺的解决方案</span>
  <a href="#%e6%ae%8b%e7%bc%ba%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们尝试第一个解决方案。假设我们将每个信号量（在 <code>forks</code> 数组中）初始化为值 1。还假设每个哲学家都知道自己的数字 (<code>p</code>)。因此，我们可以编写 <code>getforks()</code> 和 <code>putforks()</code> 例程，代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">getforks</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_wait</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">left</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_wait</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">right</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">putforks</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_post</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">left</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sem_post</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">right</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个（残缺的）解决方案背后的直觉如下。为了获得叉子，我们只需抓住每个叉子上的“锁”：首先是左边的，然后是右边的。当我们吃完后，我们就释放它们。很简单，不是吗？不幸的是，在这种情况下，简单就意味着破碎。</p>
<p>如果每个哲学家碰巧在任何哲学家抓住右边的叉子之前抓住了他们左边的叉子，那么每个哲学家都会永远拿着一把叉子并等待另一把叉子。具体来说，哲学家0抓叉子0，哲学家1抓叉子1，哲学家2抓叉子2，哲学家3抓叉子3，哲学家4抓叉子4；所有的叉子都已获得，所有的哲学家都在等待另一位哲学家拥有的叉子。我们很快就会更详细地研究死锁；目前，可以肯定地说这不是一个有效的解决方案。</p>
<h3 id="解决方案打破依赖" class="heading-element"><span>6.3 解决方案：打破依赖</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%89%93%e7%a0%b4%e4%be%9d%e8%b5%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>要解决这个问题，最简单的方法就是改变至少一位哲学家获取分叉的方式；事实上，Dijkstra 本人就是这样解决这个问题的。具体来说，假设哲学家 4（编号最高者）以不同的顺序获取分叉。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">getforks</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">right</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">left</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">left</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sem_wait</span><span class="p">(</span><span class="n">forks</span><span class="p">[</span><span class="nf">right</span><span class="p">(</span><span class="n">p</span><span class="p">)]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于最后一位哲学家会先抓右边，然后再抓左边，因此不会出现每位哲学家都抓到一个叉子，却只能等待另一个叉子的情况；等待的循环被打破了。</p>
<p>像这样的 &ldquo;著名 &ldquo;问题还有很多，比如抽烟者问题或睡觉的理发师问题。它们中的大多数只是思考并发问题的借口；其中有些问题的名字很吸引人。如果你有兴趣了解更多，或者只是想多练习并发思维，可以去查查这些问题。</p>
<h2 id="如何实现信号量" class="heading-element"><span>7 如何实现信号量</span>
  <a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%bf%a1%e5%8f%b7%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后，让我们使用低级同步原语、锁和条件变量来构建我们自己的信号量版本，称为<code>Zemaphores</code>。这个任务相当简单，代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__Zem_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>               <span class="c1">// Value of the semaphore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>    <span class="c1">// Condition variable for signaling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>   <span class="c1">// Mutex for protecting shared data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">Zem_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Initializes the semaphore with the specified initial value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Zem_init</span><span class="p">(</span><span class="n">Zem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>        <span class="c1">// Set initial value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>     <span class="c1">// Initialize condition variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>    <span class="c1">// Initialize mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Decrements the value of the semaphore (waits if the value is zero)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Zem_wait</span><span class="p">(</span><span class="n">Zem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>          <span class="c1">// Lock the mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>        <span class="c1">// Wait while value is less than or equal to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// Wait on the condition variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>                    <span class="c1">// Decrement the value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>        <span class="c1">// Unlock the mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Increments the value of the semaphore and signals waiting threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Zem_post</span><span class="p">(</span><span class="n">Zem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>          <span class="c1">// Lock the mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>                    <span class="c1">// Increment the value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>         <span class="c1">// Signal waiting threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>        <span class="c1">// Unlock the mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从代码中可以看出，我们只使用了一把锁和一个条件变量，再加上一个状态变量来跟踪信号量的值。</p>
<ul>
<li><code>Zem_t</code>结构体定义了一个信号量，其中包含了一个整数值 <code>value</code> 用于表示信号量的状态，一个条件变量 <code>cond</code> 用于线程间的同步通信，以及一个互斥锁 <code>lock</code> 用于保护共享数据。</li>
<li><code>Zem_init</code> 函数用于初始化信号量，将初始值赋给 <code>value</code>，并分别初始化条件变量和互斥锁。</li>
<li><code>Zem_wait</code> 函数用于等待信号量，首先获取互斥锁，然后在一个循环中检查 <code>value</code> 是否小于等于 0，如果是则等待条件变量，直到被唤醒后再次检查。一旦 <code>value</code> 大于 0，就将其减一并释放互斥锁。</li>
<li><code>Zem_post</code> 函数用于释放信号量，首先获取互斥锁，然后将 <code>value</code> 加一，以及唤醒等待在条件变量上的线程，最后释放互斥锁。</li>
</ul>
<p>我们的 Zemaphore 和 Dijkstra 定义的纯信号量之间的一个细微差别是，我们不保持信号量的值（当为负时）反映等待线程的数量这一不变式；事实上，该值永远不会低于零。此行为更容易实现并且与当前的 Linux 实现相匹配。</p>
<blockquote>
<center>TIP：小心泛化</center>
<p>因此，泛化的抽象技术在系统设计中非常有用，其中一个好的想法可以变得稍微更广泛，从而解决更大类别的问题。然而，泛化时要小心；正如Lampson警告我们的那样，“不要泛化；泛化通常是错误的”。</p>
<p>人们可以将信号量视为锁和条件变量的泛化；然而，是否需要这样的泛化？而且，考虑到在信号量之上实现条件变量的困难，也许这种泛化并不像您想象的那么普遍。</p>
</blockquote>
]]></description></item><item><title>条件变量</title><link>https://hezephyr.github.io/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Sat, 11 May 2024 20:49:39 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description><![CDATA[<p>到目前为止，我们已经开发了锁的概念，并了解了如何通过正确的硬件和操作系统支持组合来正确构建锁。不幸的是，锁并不是构建并发程序所需的唯一原语。</p>
<p>特别是，在很多情况下，线程希望在继续执行之前检查<strong>条件</strong>是否为真。例如，父线程可能希望在继续之前检查子线程是否已完成（这通常称为 join()）；这样的等待应该如何实现呢？我们来看下面这段代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common_threads.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">child</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// XXX how to indicate we are done?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// create child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// XXX how to wait for child?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们希望在这里看到以下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nl">parent</span><span class="p">:</span> <span class="n">begin</span>
</span></span><span class="line"><span class="cl"><span class="n">child</span>
</span></span><span class="line"><span class="cl"><span class="nl">parent</span><span class="p">:</span> <span class="n">end</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以尝试使用共享变量，如下面这段代码所示。此解决方案通常可以工作，但效率非常低，因为父进程会自旋并浪费 CPU 时间。我们在这里想要的是某种方法让父进程进入睡眠状态，直到我们等待的条件（例如，子进程完成执行）实现为止。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common_threads.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">child</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// create child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// spin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<center>关键：如何等待条件？</center>
<p>在多线程程序中，线程在继续操作之前等待某些条件变为真通常很有用。这种简单的方法，即只是自旋直到条件成立，效率非常低并且浪费 CPU 周期，并且在某些情况下可能是不正确的。那么，线程应该如何等待条件呢？</p>
</blockquote>
<h2 id="定义和例程" class="heading-element"><span>1 定义和例程</span>
  <a href="#%e5%ae%9a%e4%b9%89%e5%92%8c%e4%be%8b%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了等待条件成真，线程可以使用所谓的<strong>条件变量</strong>。条件变量是一个显式队列，当某些执行状态（即某些条件）不符合预期时（通过<strong>等待条件</strong>），线程可以将自己置于该队列中；当其他线程改变上述状态时，可以唤醒一个（或多个）等待的线程，从而允许它们继续执行（通过<strong>向条件发出信号</strong>）。这个想法可以追溯到 Dijkstra 使用的 &ldquo;私有信号&rdquo;；后来，Hoare 在他关于监控器的工作中将类似的想法命名为 &ldquo;条件变量&rdquo;。</p>
<p>要声明这样一个条件变量，只需这样写：<code>pthread_cond_t c</code>;，将 <code>c</code> 声明为条件变量（注意：还需要适当的初始化）。条件变量有两个相关操作：<code>wait()</code> 和 <code>signal()</code>。<code>wait()</code>调用在线程希望进入休眠状态时执行；<code>signal()</code>调用在线程改变了程序中的某些内容，从而希望唤醒在此条件下等待的休眠线程时执行。具体来说，POSIX 调用是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为简单起见，我们通常将其称为 <code>wait(</code>) 和 <code>signal()</code>。关于 <code>wait()</code>调用，有一点你可能会注意到，它也将一个<code>mutex</code>作为参数；它假定在调用 <code>wait()</code> 时这个<code>mutex</code>已被锁定。<code>wait()</code>的职责是释放锁并让调用线程休眠（<strong>原子式</strong>）；当线程醒来时（在其他线程发出信号后），它必须在返回调用者之前重新获取锁。之所以如此复杂，是因为我们希望在线程试图让自己进入休眠状态时，防止出现某些竞争条件。</p>
<p>让我们来看看<code>join</code>问题的解决方案，以便更好地理解这一点，代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common_threads.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_cond_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thr_exit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>    <span class="c1">// wake up waiting thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">child</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thr_exit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thr_join</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// unlock m and wait for signal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thr_join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有两种情况需要考虑。第一种情况是父线程创建了子线程，但自己继续运行（假设我们只有一个处理器），因此立即调用 <code>thr_join()</code> 等待子线程完成。在这种情况下，父线程会获取锁，检查子线程是否完成（未完成），然后调用 <code>wait()</code> 使自己进入休眠状态（从而释放锁）。子线程最终将运行，打印信息 &ldquo;child&rdquo;，并调用 <code>thr_exit()</code> 来唤醒父线程；该代码只是获取锁、设置状态变量 <code>done</code>，并向父线程发出信号，从而唤醒父线程。最后，父线程将运行（从 <code>wait()</code>返回时锁已被锁定）、解锁并打印最终信息 &ldquo;parent:end：结束&rdquo;。</p>
<p>在第二种情况下，子进程在创建后立即运行，将 <code>done</code> 设为 1，调用信号唤醒睡眠线程（但没有，所以直接返回），然后完成。然后父线程运行，调用 <code>thr_join()</code>，发现 done 为 1，于是不再等待，直接返回。</p>
<p>最后一点：你可能会发现父进程在决定是否等待条件时使用了 <code>while</code> 循环而不是 <code>if</code> 语句。虽然从程序逻辑上看，这并非绝对必要，但这始终是个好主意，我们将在下文中看到。</p>
<p>为了确保你理解 <code>thr_exit()</code> 和 <code>thr_join()</code> 代码中每一段代码的重要性，让我们尝试几种不同的实现方法。首先，你可能想知道我们是否需要完成状态变量。如果代码看起来像下面的示例呢？这样行得通吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thr_exit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thr_join</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，这种方法是有问题的。想象一下，如果子进程立即运行并立即调用<code>thr_exit()</code>；在这种情况下，子进程会发出信号，但条件上没有任何线程处于休眠状态。当父进程运行时，它将简单地调用<code>wait</code>并被卡住；没有任何线程会唤醒它。从这个例子中，你应该意识到状态变量<code>done</code>的重要性；它记录了线程感兴趣的值。睡眠、唤醒和锁定都围绕着它构建。</p>
<p>以下是另一个糟糕的实现方式。在这个例子中，我们假设不需要持有锁来发出信号和等待。可能会出现什么问题？思考一下！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thr_exit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thr_join</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里的问题是一个微妙的竞争条件。具体来说，如果父线程调用<code>thr_join()</code>，然后检查done的值，它会发现它是0，从而尝试进入睡眠状态。但就在它调用 <code>wait</code> 进入睡眠状态之前，父线程被中断，子线程开始运行。子线程将状态变量 <code>done</code> 更改为 1 并发出信号，但没有线程在等待，因此没有线程被唤醒。当父线程再次运行时，它就永远沉睡了，这是可悲的。</p>
<blockquote>
<center>TIP：在发出信号时始终保持锁定
</center>
<p>虽然并非在所有情况下都严格要求保持锁定，但在使用条件变量时，在发出信号时保持锁定可能是最简单且最好的方法。上面的示例显示了必须持有锁才能正确的情况；然而，在其他一些情况下，不这样做也可以，但可能是您应该避免的事情。因此，为了简单起见，<font color="red">在调用信号时保持锁定</font>。</p>
<p>本技巧的反面，即在调用 <code>wait</code> 时保持锁定，不仅仅是一个技巧，而是 <code>wait</code> 语义所强制的，因为 <code>wait</code> 总是</p>
<ul>
<li>假设在调用它时锁定已被持有，</li>
<li>释放当让调用者进入睡眠状态时所说的锁</li>
<li>在返回之前重新获取锁。</li>
</ul>
<p>因此，这个技巧的概括是正确的：<font color="red">在调用 <code>signal</code> 或 <code>wait</code> 时保持锁定，你将永远处于良好状态。</font></p>
</blockquote>
<h2 id="生产者消费者有界缓冲区问题" class="heading-element"><span>2 生产者—消费者（有界缓冲区）问题</span>
  <a href="#%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%9c%89%e7%95%8c%e7%bc%93%e5%86%b2%e5%8c%ba%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本概念" class="heading-element"><span>2.1 基本概念</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在本章中，我们将面对的下一个同步问题被称为<strong>生产者/消费者问题</strong>，有时也被称为<strong>有界缓冲区问题</strong>，它是由 Dijkstra 首次提出的。事实上，正是这个生产者/消费者问题促使 Dijkstra 和他的同事们发明了广义的 <code>semaphore</code>（可用作锁或条件变量）。</p>
<p>设想一个或多个生产者线程和一个或多个消费者线程。生产者生成数据项并将其放入缓冲区；消费者从缓冲区中抓取上述数据项，并以某种方式消费它们。</p>
<p>这种安排在许多实际系统中都会出现。例如，在多线程网络服务器中，生产者将 HTTP 请求放入工作队列（即有界缓冲区）；消费者线程从队列中取出请求并进行处理。</p>
<p>有界缓冲区也用于将一个程序的输出导入另一个程序，例如，<code>grep foo file.txt | wc -l</code>。此示例同时运行两个进程：<code>grep</code> 将 <code>file.txt</code> 中含有 <code>foo</code> 字符串的行写入它认为的标准输出；<code>UNIX shell</code> 将输出重定向到所谓的 <code>UNIX</code> 管道（通过<code>pipe</code>系统调用创建）。管道的另一端连接到 <code>wc</code> 进程的标准输入，该进程只需计算输入流的行数并打印出结果。因此，<code>grep</code> 进程是生产者，<code>wc</code> 进程是消费者，它们之间是一个内核有界缓冲区。</p>
<p>由于有界缓冲区是共享资源，我们当然必须要求同步访问它，以免出现竞争条件。为了更好地理解这个问题，让我们来看看一些实际的代码。我们首先需要一个共享缓冲区，生产者将数据放入缓冲区，消费者从缓冲区中取出数据。为了简单起见，我们只使用一个整数（当然，你也可以想象把一个数据结构的指针放到这个槽中），以及两个内部例程，分别用于向共享缓冲区中放入一个值，以及从缓冲区中取出一个值。代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// initially, empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>put()</code> 例程假定缓冲区为空（并通过<code>assert</code>进行检查），然后简单地将一个值放入共享缓冲区，并通过将<code>counter</code>设为 1 来标记缓冲区已满。不用担心这个共享缓冲区只有一个入口；稍后，我们将把它推广到可以容纳多个入口的队列，这将比听起来更有趣。</p>
<p>现在我们需要编写一些例程来知道何时可以访问缓冲区以将数据放入其中或从其中取出数据。其条件应该是显而易见的：仅当 <code>count</code> 为零时（即缓冲区为空时）才将数据放入缓冲区，并且仅当 <code>count</code> 为 1 时（即缓冲区已满时）从缓冲区中获取数据。如果我们编写同步代码，使得生产者将数据放入已满的缓冲区中，或者消费者从空缓冲区中获取数据，那么我们就做错了（在这段代码中，<strong>将触发<code>assert</code></strong>）。</p>
<p>这项工作将由两种类型的线程完成，其中一组我们称为<strong>生产者线程</strong>，另一组我们称为<strong>消费者线程</strong>。如下所示， 显示了生产者将整数放入共享缓冲区循环次数的代码，以及消费者从共享缓冲区中获取数据（永远）的代码，每次打印从共享缓冲区中拉出的数据项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">loops</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="一个残缺的解决方案" class="heading-element"><span>2.2 一个残缺的解决方案</span>
  <a href="#%e4%b8%80%e4%b8%aa%e6%ae%8b%e7%bc%ba%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在想象一下，我们只有一个生产者和一个消费者。显然，<code>put()</code> 和 <code>get() </code>例程都有临界区，因为 <code>put()</code> 会更新缓冲区，而 <code>get()</code> 会从缓冲区读取数据。然而，在代码周围加锁是行不通的；我们需要更多的东西。毫不奇怪，我们需要的是一些条件变量。如下代码所示：在这个（残缺的）首次尝试中，我们只有一个条件变量 <code>cond</code> 和相关的锁<code>mutex</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">loops</span><span class="p">;</span> <span class="c1">// must initialize somewhere...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">cond_t</span> <span class="n">cond</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// p4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span> <span class="c1">// p5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// c2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span> <span class="c1">// c4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span> <span class="c1">// c5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们来看看生产者和消费者之间的信号逻辑。当生产者想要填满缓冲区时，它会等待缓冲区为空（p1-p3）。消费者的逻辑完全相同，但等待的条件不同：缓冲区满（c1-c3）。如果只有一个生产者和一个消费者，上面代码就能正常工作。但是，如果我们有多个线程（例如两个消费者），解决方案就会出现两个关键问题。它们是什么？</p>
<p>让我们来了解第一个问题，它与等待之前的 <code>if</code> 语句有关。假设有两个消费者（$T_{c_1}$ 和 $T_{c_2}$）和一个生产者（$T_p$）。首先，运行消费者 ($T_{c_1}$)；它获取锁 (c1)，检查是否有缓冲区可供使用 (c2)，如果没有，则等待 (c3)（释放锁）。</p>
<p>然后运行生产者 ($T_p$)。它获取锁 (p1)，检查所有缓冲区是否已满 (p2)，如果没有，则继续填充缓冲区 (p4)。然后，生产者发出缓冲区已填满的信号（p5）。重要的是，这将第一个消费者（$T_{c_1}$ ）从条件变量的休眠状态移到就绪队列；$T_{c_1}$  现在可以运行（但尚未运行）。然后，生产者继续运行，直到发现缓冲区已满，这时它才进入休眠状态（p6, p1-p3）。</p>
<p>问题就出现在这里：另一个消费者（$T_{c_2}$ ）悄悄进入并消耗了缓冲区中的一个现有值（c1、c2、c4、c5、c6，由于缓冲区已满，跳过了 c3 处的<code>wait</code>）。现在假设 $T_{c_1}$运行，在从等待返回之前，它会重新获取锁，然后返回。然后它调用 <code>get()</code> (c4)，但没有缓冲区要使用！断言触发了，代码没有按预期运行。显然，我们应该以某种方式阻止  $T_{c_1}$ 尝试消耗，因为$T_{c_2}$ 偷偷地进入并消耗了缓冲区中产生的一个值。下图显示了每个线程执行的操作及其随时间变化的调度器状态（就绪、运行或休眠）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v1.png?size=small" data-sub-html="<h2>image-20240410111405759</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v1.png" alt="image-20240410111405759" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v1.png?size=large 2x" data-title="image-20240410111405759" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>出现问题的原因很简单：在生产者唤醒 $T_{c_1}$ 之后，但在 $T_{c_1}$ 运行之前，有界缓冲区的状态发生了变化（这要归功于 $T_{c_2}$）。向线程发出信号只能唤醒它们，因此它只是提示世界的状态已经发生了变化（在本例中，缓冲区中已经放入了一个值），但并不能保证当被唤醒的线程运行时，状态仍然如愿以偿。对信号含义的这种解释通常被称为 <strong>Mesa 语义</strong>，这是以首次以这种方式构建条件变量的研究命名的；与之相对的是 <strong>Hoare</strong> 语义，它更难构建，但能更有力地保证被唤醒的线程在被唤醒后立即运行。几乎所有已构建的系统都采用了 Mesa 语义。</p>
<h3 id="更好但仍然残缺while而不是if" class="heading-element"><span>2.3 更好，但仍然残缺：while，而不是if</span>
  <a href="#%e6%9b%b4%e5%a5%bd%e4%bd%86%e4%bb%8d%e7%84%b6%e6%ae%8b%e7%bc%bawhile%e8%80%8c%e4%b8%8d%e6%98%afif" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>幸运的是，解决方法很简单：将 <code>if</code> 改为 <code>while</code>。代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">loops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">cond_t</span> <span class="n">cond</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// p4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span> <span class="c1">// p5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// c2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span> <span class="c1">// c4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span> <span class="c1">// c5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>想一想为什么会这样：现在消费者 $T_{c_1}$ 会醒来，并（在锁定的情况下）立即重新检查共享变量 (c2) 的状态。如果此时缓冲区是空的，消费者就会继续休眠 (c3)。在生产者中，<code>if</code> 的推论也被改为 <code>while</code> (p2)。</p>
<p><font color="red">得益于 Mesa 语义，使用条件变量时要记住一条简单的规则，那就是始终使用 while 循环。</font>有时不必重新检查条件，但这样做总是安全的。</p>
<p>然而，这段代码仍然有一个错误，也就是上面提到的两个问题中的第二个。你能发现吗？它与只有一个条件变量有关。</p>
<p>当两个消费者首先运行（$T_{c_1}$  和 $T_{c_2}$ ）并都进入睡眠状态（c3）时，问题就出现了。然后，生产者运行，将一个值放入缓冲区，并唤醒其中一个消费者（例如 $T_{c_1}$ ）。然后，生产者返回循环（沿途释放并重新获取锁），并尝试将更多数据放入缓冲区；由于缓冲区已满，生产者转而等待条件（因此进入睡眠）。现在，一个消费者已准备好运行（$T_{c_1}$ ），两个线程正在等待一个条件（$T_{c_2}$  和 $T_{p}$ ）。</p>
<p>关键问题来了。然后，消费者 $T_{c_1}$  从 <code>wait()</code> 返回 (c3) 唤醒，重新检查条件 (c2)，发现缓冲区已满，于是消耗值 (c4)。重要的是，这个消费者会根据条件（c5）发出信号，只唤醒一个处于睡眠状态的线程。然而，它应该唤醒哪个线程呢？</p>
<p>因为消费者清空了缓冲区，显然应该唤醒生产者。但是，如果唤醒消费者 $T_{c_2}$（这是绝对可能的，取决于等待队列的管理方式），我们就会遇到问题。具体来说，消费者 $T_{c_2}$ 会在醒来时发现缓冲区是空的（c2），然后继续休眠（c3）。生产者$T_{p}$ 有一个值要放入缓冲区，但却处于休眠状态。另一个消费者线程 $T_{c_1}$ 也继续休眠。所有三个线程都处于休眠状态，这是一个明显的<code>bug</code>；如下图所示，显示了有关这一可怕灾难的残酷步骤。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v2.png?size=small" data-sub-html="<h2>image-20240410113350433</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v2.png" alt="image-20240410113350433" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Broken_Solution_v2.png?size=large 2x" data-title="image-20240410113350433" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>信号显然是需要的，但必须更有针对性。消费者不应唤醒其他消费者，只能唤醒生产者，反之亦然。</p>
<h3 id="单一缓冲区生产者消费者解决方案" class="heading-element"><span>2.4 单一缓冲区生产者/消费者解决方案</span>
  <a href="#%e5%8d%95%e4%b8%80%e7%bc%93%e5%86%b2%e5%8c%ba%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这里的解决方案又是一个小解决方案：使用两个条件变量而不是一个，以便在系统状态发生变化时正确地发出应该唤醒哪种类型的线程的信号。改进的代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">cond_t</span> <span class="n">empty</span><span class="p">,</span> <span class="n">fill</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的代码中，生产者线程等待条件为<code>empty</code>，并发出<code>fill</code>信号。相反，消费者线程等待<code>fill</code>并发出<code>empty</code>信号。通过这样做，上面的第二个问题在设计上就得到了避免：消费者永远不会意外唤醒消费者，生产者也永远不会意外唤醒生产者。</p>
<h3 id="最终的生产者消费者解决方案" class="heading-element"><span>2.5 最终的生产者/消费者解决方案</span>
  <a href="#%e6%9c%80%e7%bb%88%e7%9a%84%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们现在有了一个有效的生产者/消费者解决方案，尽管不是一个完全通用的解决方案。我们所做的最后一个改变是实现更高的并发性和效率；具体来说，我们添加更多的缓冲区槽，以便在睡眠前可以生成多个值，同样可以在睡眠前消耗多个值。由于只有一个生产者和消费者，这种方法更加高效，因为它减少了上下文切换；对于多个生产者或消费者（或两者），它甚至允许并发生产或消费，从而增加并发性。幸运的是，这与我们当前的解决方案相比只是一个小小的改变。</p>
<p>要实现这一正确的解决方案，首先要改变的是缓冲区结构本身以及相应的 <code>put()</code> 和 <code>get()</code>，代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define MAX 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fill_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">use_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">cond_t</span> <span class="n">empty</span><span class="p">,</span> <span class="n">fill</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">MAX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer</span><span class="p">[</span><span class="n">fill_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fill_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">use_ptr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">use_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">use_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们还稍微修改了生产者和消费者为确定是否休眠而检查的条件。下面代码显示了正确的等待和信号逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">cond_t</span> <span class="n">empty</span><span class="p">,</span> <span class="n">fill</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">MAX</span><span class="p">)</span> <span class="c1">// p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// p4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">);</span> <span class="c1">// p5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// c2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">get</span><span class="p">();</span> <span class="c1">// c4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// c5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>生产者只有在所有缓冲区都被填满的情况下才会休眠（p2）；同样，消费者只有在所有缓冲区都被清空的情况下才会休眠（c2）。这样，我们就解决了生产者/消费者的问题。</p>
<blockquote>
<center>TIP：对条件使用 WHILE（而非 IF）</center> 
<p>在多线程程序中检查条件时，使用 <code>while</code> 循环始终是正确的；而仅使用 <code>if</code> 语句可能是错误的，这取决于信号的语义。因此，始终使用 <code>while</code> 语句，你的代码就会按照预期运行。</p>
<p>在条件检查周围使用 <code>while</code> 循环还能处理发生<strong>虚假唤醒</strong>的情况。在某些线程包中，由于实现的细节问题，可能会出现两个线程被唤醒的情况，尽管只发生了一个信号。虚假唤醒是重新检查线程正在等待的条件的进一步理由。</p>
</blockquote>
<h2 id="覆盖条件" class="heading-element"><span>3 覆盖条件</span>
  <a href="#%e8%a6%86%e7%9b%96%e6%9d%a1%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现在我们再来看一个如何使用条件变量的例子。本代码研究摘自 Lampson 和 Redell 关于 Pilot 的论文 ，正是他们首次实现了上文所述的 Mesa 语义（他们使用的语言是 Mesa，因此得名）。</p>
<p>他们遇到的问题最好通过简单的示例来说明，这里的示例是一个简单的多线程内存分配库，代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// how many bytes of the heap are free?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">bytesLeft</span> <span class="o">=</span> <span class="n">MAX_HEAP_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// need lock and condition too
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">cond_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">mutex_t</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">bytesLeft</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// get mem from heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bytesLeft</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bytesLeft</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span> <span class="c1">// Signal waiting threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如你在代码中看到的，当线程调用内存分配代码时，可能需要等待更多内存被释放。反之，当线程释放内存时，就会发出更多内存可用的信号。然而，我们上面的代码有一个问题：哪个等待的线程（可能不止一个）应该被唤醒？</p>
<p>请考虑以下情况。假设空闲字节数为零；线程 $T_a$ 调用 <code>allocate(100)</code>，紧随其后的线程 $T_b$ 调用 <code>allocate(10)</code>，要求获得更少的内存。因此， $T_a$和 $T_b$ 都等待条件并进入休眠；没有足够的空闲字节来满足这两个请求。</p>
<p>这时，假设第三个线程 $T_c$调用 <code>free(50)</code>。不幸的是，当它调用 <code>signal</code> 来唤醒一个等待线程时，可能没有唤醒正确的等待线程 $T_b$，因为 $T_b$ 只等待释放 10 个字节；$T_a$ 应该继续等待，因为还没有足够的空闲内存。因此，上面的代码不起作用，因为唤醒其他线程的线程不知道该唤醒哪个（或哪些）线程。</p>
<p>Lampson 和 Redell 提出的解决方案非常简单：用调用 <code>pthread_cond_broadcast()</code> 代替上面代码中的 <code>pthread_cond_signal()</code>，唤醒所有等待的线程。这样，我们就能保证所有应该被唤醒的线程都被唤醒了。当然，这样做的缺点是可能会对性能产生负面影响，因为我们可能会不必要地唤醒许多其他不应该（尚未）被唤醒的等待线程。这些线程会简单地唤醒，重新检查条件，然后立即回到睡眠状态。</p>
<p>Lampson 和 Redell 将这种条件称为<strong>覆盖条件</strong>，因为它涵盖了（保守地）需要唤醒线程的所有情况；正如我们已经讨论过的，代价是可能会唤醒过多的线程。精明的读者可能也注意到了，我们本可以在更早的时候使用这种方法（参见只有一个条件变量的生产者/消费者问题）。不过，在这种情况下，我们有一个更好的解决方案，因此我们使用了它。一般来说，如果你发现只有当你将信号改为广播时，你的程序才能运行（但你认为它不需要这样），那么你可能遇到了一个错误；请修复它！但在类似上述内存分配器的情况下，广播可能是最直接的解决方案。</p>
]]></description></item><item><title>锁定数据结构</title><link>https://hezephyr.github.io/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 11 May 2024 20:44:53 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description><![CDATA[<p>在讨论锁之前，我们首先描述如何在一些常见的数据结构中使用锁。向数据结构添加锁以使其可由线程使用，从而使该结构成为<font color="red">线程安全</font>的。如何加锁决定了数据结构的正确性和性能。因此，我们面临着关键挑战：当给定一个特定的数据结构时，我们应该如何向它添加锁，以使其正常工作？此外，我们如何添加锁以使数据结构产生高性能，使许多线程能够同时（即并发）访问该结构？</p>
<h2 id="并发计数器" class="heading-element"><span>1 并发计数器</span>
  <a href="#%e5%b9%b6%e5%8f%91%e8%ae%a1%e6%95%b0%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>计数器是最简单的数据结构之一。它是一种常用的结构，具有简单的接口。下面代码中中定义了一个简单的非并发计数器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__counter_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">counter_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">decrement</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="简单但不可扩展" class="heading-element"><span>1.1 简单但不可扩展</span>
  <a href="#%e7%ae%80%e5%8d%95%e4%bd%86%e4%b8%8d%e5%8f%af%e6%89%a9%e5%b1%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>正如您所看到的，非并发计数器是一个简单的数据结构，需要少量的代码来实现。现在我们面临下一个挑战：如何使这段代码线程安全？下面这段代码显示了我们如何做到这一点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__counter_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">counter_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">decrement</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个并发计数器很简单并且工作正常。事实上，它遵循最简单和最基本的并发数据结构常见的设计模式：它只是添加一个锁，该锁在调用操作数据结构的例程时获取，并在从调用返回时释放。通过这种方式，它类似于使用监视器构建的数据结构，当您调用对象方法并从对象方法返回时，会自动获取和释放锁。</p>
<p>至此，你已经有了一个可以运行的并发数据结构。你可能会遇到的问题是性能。如果你的数据结构速度太慢，你需要做的就不仅仅是添加一个锁了；因此，如果需要进行此类优化，这将是本章其余部分的主题。需要注意的是，如果数据结构的运行速度不是太慢，那么你就大功告成了！如果简单的数据结构也能正常工作，那么就没必要做什么花哨的事情了。</p>
<p>为了了解简单方法的性能代价，我们运行了一个基准，其中每个线程更新单个共享计数器的次数是固定的；然后我们改变线程的数量。如下图所示，显示了在一到四个线程活动的情况下所花费的总时间；每个线程更新计数器 100 万次。本实验在配备四颗英特尔 2.7 GHz i5 CPU 的 iMac 上运行；如果激活的 CPU 越多，我们希望单位时间内完成的总工作量就越大。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Performance-Of-Traditional-vs-Approximate-Counters.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Performance-Of-Traditional-vs-Approximate-Counters.png?size=small" data-sub-html="<h2>image-20240408143721333</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Performance-Of-Traditional-vs-Approximate-Counters.png" alt="image-20240408143721333" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Performance-Of-Traditional-vs-Approximate-Counters.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Performance-Of-Traditional-vs-Approximate-Counters.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Performance-Of-Traditional-vs-Approximate-Counters.png?size=large 2x" data-title="image-20240408143721333" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从图中最上面一行（标注为 &ldquo;Precise&rdquo;）可以看出，并发计数器的性能扩展性很差。单个线程可以在极短的时间内（大约 0.03 秒）完成百万次计数器更新，而让两个线程同时更新计数器 100 万次则会导致速度大幅下降（超过 5 秒！）。线程越多，情况越糟糕。</p>
<p>理想情况下，线程在多处理器上完成的速度要和单线程在单处理器上完成的速度一样快。实现这一目标被称为<strong>完美扩展</strong>；即使要完成更多工作，也是并行完成的，因此完成任务所需的时间不会增加。</p>
<h3 id="可扩展计数器" class="heading-element"><span>1.2 可扩展计数器</span>
  <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e8%ae%a1%e6%95%b0%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>令人惊讶的是，研究人员多年来一直在研究如何构建更具可扩展性的计数器。更令人惊叹的是，可扩展计数器的重要性，正如最近在操作系统性能分析方面的工作所显示的那样；如果没有可扩展计数，在 Linux 上运行的一些工作负载在多核机器上就会出现严重的可扩展性问题。</p>
<p>为了解决这个问题，人们开发了许多技术。我们将介绍一种称为<strong>近似计数器</strong>的方法 [C06]。</p>
<p>近似计数器的工作原理是通过众多本地物理计数器（每个 CPU 内核一个）和一个全局计数器来表示一个逻辑计数器。具体来说，在一台有四个 CPU 的机器上，有四个本地计数器和一个全局计数器。除了这些计数器外，还有锁：每个本地计数器和全局计数器各有一个锁。</p>
<p>近似计数器的基本思想如下。当运行在给定内核上的线程希望递增计数器时，它会递增其本地计数器；通过相应的本地锁同步访问该本地计数器。由于每个 CPU 都有自己的本地计数器，因此跨 CPU 的线程可以无竞争地更新本地计数器，因此计数器的更新是可扩展的。</p>
<p>不过，为了保持全局计数器的最新状态（以防线程希望读取其值），本地计数器的值会定期转移到全局计数器上，方法是获取全局锁，并根据本地计数器的值递增；然后将本地计数器重置为零。</p>
<p>这种从本地到全局的转移发生频率由阈值 S 确定。S 越小，计数器的行为就越像上述不可扩展的计数器；S 越大，计数器的可扩展性就越强，但全局值可能会偏离实际计数。我们可以简单地获取所有本地锁和全局锁（按指定顺序，以避免死锁）来获得精确值，但这是不可扩展的。</p>
<p>为了说明这一点，我们来看一个例子，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Tracing-The-Approximate-Counters.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Tracing-The-Approximate-Counters.png?size=small" data-sub-html="<h2>image-20240408150033961</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Tracing-The-Approximate-Counters.png" alt="image-20240408150033961" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Tracing-The-Approximate-Counters.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Tracing-The-Approximate-Counters.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Tracing-The-Approximate-Counters.png?size=large 2x" data-title="image-20240408150033961" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在这个例子中，阈值 S 设置为 5，四个 CPU 上都有线程在更新本地计数器 L1 &hellip; L4。全局计数器值 (G) 也显示在跟踪中，随着时间的推移不断向下增加。在每个时间步长，本地计数器都可能递增；如果本地值达到阈值 S，本地值就会转移到全局计数器，然后本地计数器被重置。</p>
<p>在上图中（标注为 &ldquo;Approximate&rdquo;）的下线显示了阈值 S 为 1024 的近似计数器的性能。该计数器的性能非常出色；在四个处理器上更新计数器 400 万次所需的时间几乎不超过在一个处理器上更新计数器 100 万次所需的时间。</p>
<p>下图显示了阈值 S 的重要性，四个线程在四个 CPU 上各递增计数器 100 万次。如果 S 值较低，则性能较差（但全局计数总是相当准确）；如果 S 值较高，则性能出色，但全局计数滞后（最多滞后 CPU 数量乘以 S）。近似计数器正是通过这种精度/性能权衡实现的。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240408150613853.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240408150613853.png?size=small" data-sub-html="<h2>image-20240408150613853</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240408150613853.png" alt="image-20240408150613853" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240408150613853.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240408150613853.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240408150613853.png?size=large 2x" data-title="image-20240408150613853" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>近似计数器的粗略版本如下面这段代码所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__counter_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">global</span><span class="p">;</span> <span class="c1">// global count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_mutex_t</span> <span class="n">glock</span><span class="p">;</span> <span class="c1">// global lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">local</span><span class="p">[</span><span class="n">NUMCPUS</span><span class="p">];</span> <span class="c1">// local count (per cpu)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_mutex_t</span> <span class="n">llock</span><span class="p">[</span><span class="n">NUMCPUS</span><span class="p">];</span> <span class="c1">// ... and locks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="c1">// update frequency
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="kt">counter_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// init: record threshold, init locks, init values
</span></span></span><span class="line"><span class="cl"><span class="c1">// of all local counts and global count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">global</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">glock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUMCPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">llock</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// update: usually, just grab local lock and update local amount
</span></span></span><span class="line"><span class="cl"><span class="c1">// once local count has risen by ’threshold’, grab global
</span></span></span><span class="line"><span class="cl"><span class="c1">// lock and transfer local values to it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadID</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">threadID</span> <span class="o">%</span> <span class="n">NUMCPUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">llock</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amt</span><span class="p">;</span> <span class="c1">// assumes amt &gt; 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">threshold</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// transfer to global
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">glock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">global</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">glock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">llock</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// get: just return global amount (which may not be perfect)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">counter_t</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">glock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">global</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">glock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// only approximate!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="并发链表" class="heading-element"><span>2 并发链表</span>
  <a href="#%e5%b9%b6%e5%8f%91%e9%93%be%e8%a1%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本实现" class="heading-element"><span>2.1 基本实现</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>接下来，我们要研究一种更复杂的结构—链表。让我们再次从基本方法开始。为了简单起见，我们将省略这种列表中的一些显而易见的例程，而只关注并发插入；至于查找、删除等，我们将留给读者自己去思考或者可以在仓库中找到更详细的版本。下面显示了这种初级数据结构的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// basic node structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__node_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">__node_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">node_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// basic list structure (one used per list)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__list_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">list_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">List_Init</span><span class="p">(</span><span class="kt">list_t</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">List_Insert</span><span class="p">(</span><span class="kt">list_t</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Thread %d: Inserting %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;malloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// fail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">new</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从代码中可以看出，代码只是在进入插入例程时获取一个锁，并在退出时释放它。如果 <code>malloc()</code> 恰好失败（这种情况很少见），就会出现一个棘手的小问题；在这种情况下，代码还必须在插入失败前释放锁。</p>
<p>事实证明，这种特殊的控制流非常容易出错；最近对 Linux 内核补丁的一项研究发现，很大一部分错误（近 40%）都是在这种很少使用的代码路径上发现的。因此，我们面临着一个挑战：我们能否重写插入和查找例程，使其在并发插入时保持正确，但避免失败路径也需要我们添加<code>unlock</code>调用的情况？</p>
<p>在这种情况下，答案是肯定的。具体来说，我们可以重构一下<code>List_Insert</code>代码，使锁定和释放只围绕插入代码中的实际临界区，并在删除代码中使用共同的退出路径。前者之所以有效，是因为部分查找代码实际上无需锁定；假设 <code>malloc()</code> 和<code>printf</code>本身是线程安全的，那么每个线程都可以调用它，而不必担心出现竞争条件或其他并发错误。只有在更新共享列表时才需要加锁。有关这些修改的详细信息，请见下面这段代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// basic node structure
</span></span><span class="line"><span class="cl">typedef struct __node_t {
</span></span><span class="line"><span class="cl">    int key;
</span></span><span class="line"><span class="cl">    struct __node_t *next;
</span></span><span class="line"><span class="cl">} node_t;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// basic list structure (one used per list)
</span></span><span class="line"><span class="cl">typedef struct __list_t {
</span></span><span class="line"><span class="cl">    node_t *head;
</span></span><span class="line"><span class="cl">    pthread_mutex_t lock;
</span></span><span class="line"><span class="cl">} list_t;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void List_Init(list_t *L) {
</span></span><span class="line"><span class="cl">    L-&gt;head = NULL;
</span></span><span class="line"><span class="cl">    pthread_mutex_init(&amp;L-&gt;lock, NULL);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int List_Insert(list_t *L, int key, int thread_id) {
</span></span><span class="line"><span class="cl">    printf(&#34;Thread %d: Inserting %d\n&#34;, thread_id, key);
</span></span><span class="line"><span class="cl">    node_t *new = malloc(sizeof(node_t));
</span></span><span class="line"><span class="cl">    if (new == NULL) {
</span></span><span class="line"><span class="cl">        perror(&#34;malloc&#34;);
</span></span><span class="line"><span class="cl">        pthread_mutex_unlock(&amp;L-&gt;lock);
</span></span><span class="line"><span class="cl">        return -1; // fail
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    new-&gt;key = key;
</span></span><span class="line"><span class="cl">    pthread_mutex_lock(&amp;L-&gt;lock);
</span></span><span class="line"><span class="cl">    new-&gt;next = L-&gt;head;
</span></span><span class="line"><span class="cl">    L-&gt;head = new;
</span></span><span class="line"><span class="cl">    pthread_mutex_unlock(&amp;L-&gt;lock);
</span></span><span class="line"><span class="cl">    return 0; // success
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="扩展链表" class="heading-element"><span>2.2 扩展链表</span>
  <a href="#%e6%89%a9%e5%b1%95%e9%93%be%e8%a1%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>虽然我们又有了一个基本的并发链表，但我们又一次遇到了它不能很好扩展的情况。为了在链表中实现更多并发性，研究人员探索了一种技术，即所谓的 &ldquo;手拉手锁定&rdquo;（又称 &ldquo;锁耦合&rdquo;）。</p>
<p>这个想法非常简单。你可以为链表的每个节点添加一个锁，而不是为整个链表添加一个锁。当遍历列表时，代码会先抓取下一个节点的锁，然后释放当前节点的锁（这就是 <code>hand-over-hand</code> 名称的由来）。</p>
<p>从概念上讲，&ldquo;交手 &ldquo;链表是有一定道理的；它可以实现高度并发的操作。然而，在实践中，这种结构很难比简单的单锁方法更快，因为为遍历链表的每个节点获取和释放锁的开销太大。即使是非常大的链表和大量的线程，允许多个正在进行的遍历所带来的并发性也不可能比简单地获取单锁、执行操作和释放锁更快。也许某种混合方式（每隔几个节点就抓取一个新锁）值得研究。</p>
<blockquote>
<center>TIP：并发越多不一定越快</center>
<p>如果您设计的方案增加了很多开销（例如，频繁获取和释放锁，而不是一次性），那么它更具并发性可能就不重要了。简单的方案往往效果良好，特别是如果它们很少使用昂贵的例程。增加更多锁和复杂性可能会导致失败。尽管如此，有一种真正需要了解的方法：构建两种替代方案（<font color="red">简单但并发性较低、复杂但并发性较高</font>）并测量它们的表现。最终，您无法在性能上作弊；您的想法要么更快，要么不是。</p>
<center>警惕锁和控制流
</center>
<p>一个通用的设计提示，在并发代码以及其他地方都很有用，就是要警惕导致函数返回、退出或其他类似错误条件从而停止函数执行的控制流变化。因为许多函数会首先获取锁、分配一些内存或进行其他类似的有状态操作，<font color="red">当出现错误时，代码必须在返回之前撤销所有状态，这样容易出错。</font>因此，最好结构化代码以最小化这种模式。</p>
</blockquote>
<h2 id="并发队列" class="heading-element"><span>3 并发队列</span>
  <a href="#%e5%b9%b6%e5%8f%91%e9%98%9f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如您现在所知，制作并发数据结构总是有一个标准方法：添加一个大锁。对于队列，我们将跳过该方法，假设您可以弄清楚。</p>
<p>相反，我们将看一下由 Michael 和 Scott 设计的并发程度稍高的队列。代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__node_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">__node_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">node_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__queue_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">node_t</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_mutex_t</span> <span class="n">headLock</span><span class="p">;</span> <span class="c1">// Mutex for head pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_mutex_t</span> <span class="n">tailLock</span><span class="p">;</span> <span class="c1">// Mutex for tail pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="kt">queue_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Initialize the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Queue_Init</span><span class="p">(</span><span class="kt">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Allocate memory for a dummy node to represent the head of the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">node_t</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize the head and tail pointers to the dummy node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">q</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize mutexes for head and tail pointers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headLock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tailLock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Enqueue an element into the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Queue_Enqueue</span><span class="p">(</span><span class="kt">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Allocate memory for the new node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">node_t</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Acquire the tailLock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tailLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Insert the new node after the current tail node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">q</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Update the tail pointer to point to the new node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">q</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Release the tailLock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">tailLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Dequeue an element from the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">Queue_Dequeue</span><span class="p">(</span><span class="kt">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Acquire the headLock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Get the current head node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">node_t</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Get the next node after the head
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">node_t</span> <span class="o">*</span><span class="n">newHead</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If the queue is empty (newHead is NULL), release the headLock mutex and return -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newHead</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// queue was empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Extract the value from the node to be dequeued
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Update the head pointer to point to the next node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">q</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">newHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Release the headLock mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Free the memory of the dequeued node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Return 0 indicating successful dequeue operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果你仔细研究这段代码，你会发现有两个锁，一个用于队列的头部，一个用于队列的尾部。这两个锁的目标是实现入队和出队操作的并发。在常见情况下，入队例程将仅访问尾部锁，而出队只会访问头部锁。</p>
<p>Michael 和 Scott 使用的一个技巧是添加一个虚拟节点（在队列初始化代码中分配）；这个虚拟节点可以实现头尾操作的分离。</p>
<p>队列通常用在多线程应用程序中。然而，这里使用的队列类型（仅带有锁）通常不能完全满足此类程序的需求。一个更充分开发的有界队列，使线程能够在队列为空或过满时等待，这是条件变量可以做到的事情。</p>
<h2 id="并发哈希表" class="heading-element"><span>4 并发哈希表</span>
  <a href="#%e5%b9%b6%e5%8f%91%e5%93%88%e5%b8%8c%e8%a1%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后，我们将讨论一种简单而又广泛适用的并发数据结构—哈希表。我们将重点讨论一个不调整大小的简单哈希表，代码如下所示；处理调整大小需要做更多的工作，我们将其作为一个练习留给读者（抱歉！）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define BUCKETS (101)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__hash_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">list_t</span> <span class="n">lists</span><span class="p">[</span><span class="n">BUCKETS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">hash_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Hash_Init</span><span class="p">(</span><span class="kt">hash_t</span> <span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">List_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Hash_Insert</span><span class="p">(</span><span class="kt">hash_t</span> <span class="o">*</span><span class="n">H</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">BUCKETS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">List_Insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">bucket</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Hash_Remove</span><span class="p">(</span><span class="kt">hash_t</span> <span class="o">*</span><span class="n">H</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">BUCKETS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">List_Remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">bucket</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个并发哈希表非常简单，使用我们之前开发的并发链表构建，而且运行得非常好。它之所以性能出色，是因为它没有为整个结构设置一个锁，而是为每个哈希桶（每个哈希桶由一个链表表示）设置了一个锁。这样就可以进行许多并发操作。</p>
<p>下图 显示了哈希表在并发更新下的性能（在同一台配备四个 CPU 的 iMac 电脑上，四个线程的并发更新次数从 10,000 次到 50,000 次不等）。为便于比较，图中还显示了链表的性能（使用单锁）。从图中可以看出，这个简单的并发哈希表的扩展能力很强，而链表则不然。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaling-Hash-Tables.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaling-Hash-Tables.png?size=small" data-sub-html="<h2>image-20240408230513598</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaling-Hash-Tables.png" alt="image-20240408230513598" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaling-Hash-Tables.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaling-Hash-Tables.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaling-Hash-Tables.png?size=large 2x" data-title="image-20240408230513598" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<center>避免过早优化（KNUTH定律）</center>
<p>在构建并发数据结构时，应从最基本的方法开始，即添加一个大锁以提供同步访问。这样做，你就有可能构建一个正确的锁；如果你发现它存在性能问题，你可以对它进行改进，从而在必要时使它变得更快。正如 Knuth 的名言：&ldquo;过早优化是万恶之源&rdquo;。</p>
<p>在向多处理器过渡之初，许多操作系统都使用单锁，包括 Sun OS 和 Linux。在后者中，这种锁甚至有一个名字，即<font color="red">大内核锁（BKL</font>）。多年来，这种简单的方法一直很好，但当多 CPU 系统成为常态时，内核中每次只允许一个活动线程就成了性能瓶颈。因此，终于到了为这些系统添加改进并发性优化的时候了。在 Linux 系统中，采用了更直接的方法：用多个锁代替一个锁。而在 Sun 内部，则做出了一个更激进的决定：建立一个全新的操作系统，即 Solaris，从一开始就从根本上融入并发性。</p>
</blockquote>
]]></description></item><item><title>锁</title><link>https://hezephyr.github.io/posts/21.%E9%94%81/</link><pubDate>Sat, 11 May 2024 20:38:09 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/21.%E9%94%81/</guid><description><![CDATA[<h2 id="锁基本思想" class="heading-element"><span>1 锁：基本思想</span>
  <a href="#%e9%94%81%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>举个例子，假设我们的临界区如下所示，共享变量的规范更新：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当然，其他临界区也是可能的，例如向链表添加元素或对共享结构进行其他更复杂的更新，但我们现在只保留这个简单的示例。要使用锁，我们在临界区周围添加一些代码，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">lock_t</span> <span class="n">mutex</span><span class="p">;</span> <span class="c1">// some globally-allocated lock ’mutex’
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>锁只是一个变量，因此要使用它，您必须声明某种类型的<strong>锁变量</strong>（例如上面的<code>mutex</code>）。该锁变量（或简称“锁”）保存任意时刻锁的状态。它要么<strong>可用</strong>（或<strong>未锁定</strong>或<strong>空闲</strong>），因此没有线程持有该锁，要么<strong>已获取</strong>（或<strong>锁定</strong>或<strong>持有</strong>），因此恰好有一个线程持有该锁，并且可能位于临界区中。我们还可以在数据类型中存储其他信息，例如哪个线程持有锁，或者用于获取锁的顺序队列，但此类信息对锁的用户是隐藏的。</p>
<p><code>lock()</code> 和<code>unlock()</code> 例程的语义很简单。调用例程 <code>lock()</code> 尝试获取锁；如果没有其他线程持有该锁（即它是空闲的），则该线程将获取该锁并进入临界区；该线程有时被称为锁的<strong>所有者</strong>。如果另一个线程随后对同一个锁变量（本例中为<code>mutex</code>）调用 <code>lock()</code>，则当锁被另一个线程持有时，它不会返回；这样，当第一个持有锁的线程位于临界区时，其他线程就无法进入临界区。</p>
<p>一旦锁的所有者调用<code>unlock()</code>，锁就再次可用（空闲）。如果没有其他线程正在等待锁（即没有其他线程调用<code>lock()</code> 并被卡在其中），则锁的状态将简单地更改为空闲。如果有等待线程（卡在 lock() 中），其中一个线程将（最终）注意到（或被告知）锁状态的这一变化，获取锁，并进入临界区。</p>
<p>锁为程序员提供了对调度的最小程度的控制。一般来说，我们将线程视为由程序员创建但由操作系统以操作系统选择的任何方式调度的实体。锁将部分控制权交还给程序员；通过在一段代码周围放置一个锁，程序员可以保证该代码中最多只有一个线程处于活动状态。因此，锁有助于将传统操作系统调度的混乱转变为更受控制的活动。</p>
<h2 id="pthread-锁" class="heading-element"><span>2 Pthread 锁</span>
  <a href="#pthread-%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>POSIX 库为锁使用的名称是 <code>mutex</code>，因为它用于提供线程之间的<strong>互斥</strong>，也就是说，如果一个线程处于临界区，它将禁止其他线程进入，直到它完成该临界区。因此，当你看到下面的 POSIX 线程代码时，你应该明白它在做与上面相同的事情（我们再次使用我们的封装器，在锁定和解锁时检查错误）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// wrapper; exits on failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你可能还会注意到，POSIX 版本会通过传递一个变量来加锁和解锁，因为我们可能会使用不同的锁来保护不同的变量。这样做可以提高并发性：我们通常会使用不同的锁来保护不同的数据和数据结构，而不是在访问任何临界区时使用一个大锁（<strong>粗粒度锁定策略</strong>），从而允许更多线程同时进入锁定代码（<strong>更细粒度的方法</strong>）。</p>
<h2 id="评估锁基本标准" class="heading-element"><span>3 评估锁—基本标准</span>
  <a href="#%e8%af%84%e4%bc%b0%e9%94%81%e5%9f%ba%e6%9c%ac%e6%a0%87%e5%87%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在构建任何锁之前，我们首先应该了解我们的目标是什么，因此我们会问如何评估特定锁实现的有效性。要评估一个锁是否有效（而且效果很好），我们首先应该建立一些如下的基本标准。</p>
<ol>
<li>
<p>首先是锁是否完成了它的基本任务，即<font color="red">提供互斥</font>。基本上，锁是否能阻止多个线程进入临界区？</p>
</li>
<li>
<p>其次是<font color="red">公平性</font>。一旦锁被释放，每个争夺锁的线程是否都能公平地获得锁？另一种方法是考察更极端的情况：是否有任何线程在争夺锁的过程中陷入饥饿，从而永远无法获得锁？</p>
</li>
<li>
<p>最后一个标准是<font color="red">性能</font>，特别是使用锁所增加的时间开销。这里有几种不同的情况值得考虑。</p>
<ul>
<li>一种是无竞争的情况；当单线程运行并抓取和释放锁时，这样做的开销是多少？</li>
<li>另一种情况是多个线程在单个 CPU 上争夺锁；在这种情况下，是否存在性能问题？</li>
<li>最后，当涉及多个 CPU 且每个 CPU 上的线程都在争夺锁时，锁的性能如何？</li>
</ul>
<p>通过比较这些不同的情况，我们可以更好地了解使用各种锁技术对性能的影响。</p>
</li>
</ol>
<h2 id="控制中断" class="heading-element"><span>4 控制中断</span>
  <a href="#%e6%8e%a7%e5%88%b6%e4%b8%ad%e6%96%ad" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最早用于提供互斥的解决方案之一是禁用临界区的中断；<font color="red">这种解决方案是为单处理器系统发明的</font>。代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">DisableInterrupts</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">EnableInterrupts</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设我们正在这样的单处理器系统上运行。通过在进入临界区之前<font color="red">关闭中断</font>（使用某种特殊的硬件指令），我们可以确保临界区内的代码不会被中断，从而像原子一样执行。当我们完成后，我们<font color="red">重新启用中断</font>（再次通过硬件指令），因此程序照常进行。</p>
<p>这种方法的主要优点是它的简单性。当然，您不必绞尽脑汁就能弄清楚为什么会这样。在没有中断的情况下，线程可以确保它执行的代码将会执行，并且没有其他线程会干扰它。</p>
<p>不幸的是，负面因素有很多。首先，这种方法要求我们允许任何调用线程执行特权操作（打开和关闭中断），因此相信该设施不会被滥用。正如您所知，每当我们需要信任任意程序时，我们都可能遇到麻烦。在这里，问题以多种方式表现出来：贪婪的程序可以在执行开始时调用<code>lock()</code>，从而独占处理器；更糟糕的是，错误或恶意程序可能调用 <code>lock()</code> 并进入无限循环。在后一种情况下，操作系统永远不会重新获得对系统的控制，只有一个办法：重新启动系统。使用中断禁用作为通用同步解决方案需要对应用程序过多的信任。</p>
<p>其次，该方法不适用于多处理器。如果多个线程运行在不同的CPU上，并且每个线程都尝试进入同一个临界区，那么是否禁用中断并不重要；线程将能够在其他处理器上运行，因此可以进入临界区。由于多处理器现在很常见，我们的通用解决方案必须比这做得更好。</p>
<p>第三，长时间关闭中断可能会导致中断丢失，从而导致严重的系统问题。例如，想象一下，如果 CPU 错过了磁盘设备已完成读取请求的事实。操作系统如何知道唤醒等待所述读取的进程？</p>
<p>最后，也许也是最不重要的一点是，这种方法可能效率低下。与正常指令执行相比，现代 CPU 执行屏蔽或取消屏蔽中断的代码往往执行速度较慢。</p>
<p>由于这些原因，关闭中断仅在有限的上下文中用作互斥原语。例如，在某些情况下，操作系统本身将使用中断屏蔽来保证访问其自己的数据结构时的原子性，或者至少防止出现某些混乱的中断处理情况。这种用法是有道理的，因为信任问题在操作系统内部消失了，操作系统始终相信自己能够执行特权操作。</p>
<h2 id="失败的尝试仅使用加载存储" class="heading-element"><span>5 失败的尝试：仅使用加载/存储</span>
  <a href="#%e5%a4%b1%e8%b4%a5%e7%9a%84%e5%b0%9d%e8%af%95%e4%bb%85%e4%bd%bf%e7%94%a8%e5%8a%a0%e8%bd%bd%e5%ad%98%e5%82%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>要想超越基于中断的技术，我们就必须依靠 CPU 硬件及其提供的指令来构建适当的锁。让我们首先尝试使用一个标志变量来构建一个简单的锁。在这次失败的尝试中，我们将看到构建锁所需的一些基本思想，并明白为什么仅仅使用单个变量并通过正常的加载和存储来访问它是不够的。</p>
<p>第一次尝试的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__lock_t</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span> <span class="p">}</span> <span class="kt">lock_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 0 -&gt; lock is available, 1 -&gt; held
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">mutex</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// TEST the flag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">;</span> <span class="c1">// spin-wait (do nothing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// now SET it!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在第一次尝试中，我们的想法非常简单：使用一个简单的变量（<code>flag</code>）来指示某个线程是否拥有锁。进入临界区的第一个线程将调用 <code>lock()</code>，它将测试<code>flag</code>是否等于 1（在本例中不等于 1），然后将<code>flag</code>设置为 1，表示该线程现在持有锁。完成临界区后，线程会调用 <code>unlock()</code> 并清除<code>flag</code>，从而表明不再持有锁。</p>
<p>如果另一个线程在第一个线程处于临界区时调用了 <code>lock()</code>，那么它只需在 while 循环中自旋等待该线程调用 <code>unlock()</code>并清除<code>flag</code>。一旦第一个线程这样做了，等待的线程就会退出 <code>while</code> 循环，将自己的<code>flag</code>设置为 1，然后进入临界区。</p>
<p>不幸的是，该代码有两个问题：一个是正确性，另一个是性能。一旦您习惯于思考并发编程，正确性问题就很容易看出。想象一下下面的的代码交错；假设 <code>flag=0</code> 开始。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240407154637634.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240407154637634.png?size=small" data-sub-html="<h2>image-20240407154637634</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240407154637634.png" alt="image-20240407154637634" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240407154637634.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240407154637634.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240407154637634.png?size=large 2x" data-title="image-20240407154637634" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如您从这种交错中看到的，通过及时（不及时？）中断，我们可以很容易地产生这样一种情况：两个线程都将<code>flag</code>设置为 1，因此两个线程都能进入临界区。我们显然没有满足最基本的要求**：提供互斥**。</p>
<p>我们稍后将详细讨论的性能问题是线程等待获取已持有的锁的方式：它无休止地检查<code>flag</code>的值，这是一种称为<font color="red">自旋等待</font>的技术。自旋等待会浪费时间等待另一个线程释放锁。在单处理器上浪费非常高，其中等待者正在等待的线程甚至无法运行（至少在发生上下文切换之前）！</p>
<h2 id="用test-and-set构建工作自旋锁" class="heading-element"><span>6 用Test-And-Set构建工作自旋锁</span>
  <a href="#%e7%94%a8test-and-set%e6%9e%84%e5%bb%ba%e5%b7%a5%e4%bd%9c%e8%87%aa%e6%97%8b%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>由于禁用中断在多处理器上不起作用，而且使用加载和存储（如上所示）的简单方法也不起作用，系统设计人员开始发明硬件支持锁定。最早的多处理器系统，如 20 世纪 60 年代初的 Burroughs B5000，就提供了这种支持；如今，所有系统都提供了这种支持，即使是单 CPU 系统也不例外。</p>
<p>最简单易懂的硬件支持被称为<code>test-and-set</code>（或<font color="red">原子交换</font>）指令。我们通过下面的 C 代码片段来定义 <code>test-and-set</code> 指令的作用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">TestAndSet</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">;</span> <span class="c1">// fetch old value at old_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">old_ptr</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span> <span class="c1">// store ’new’ into old_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">old</span><span class="p">;</span> <span class="c1">// return the old value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>test-and-set</code>指令的作用如下。它返回 <code>ptr</code> 指向的<code>old</code>，同时将所述值更新为<code>new</code>。当然，关键在于这一系列操作都是以原子方式执行的。之所以称为 &ldquo;test-and-set&rdquo;，是因为它可以 &ldquo;test &ldquo;旧值（即返回值），同时将内存位置 &ldquo;设置 &ldquo;为新值；事实证明，这条功能稍强的指令足以构建一个简单的自旋锁，如下面这段代码所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__lock_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">lock_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 0: lock is available, 1: lock is held
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// spin-wait (do nothing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们先了解一下这种锁的工作原理。首先设想这样一种情况：线程调用 <code>lock()</code> 而当前没有其他线程持有锁；因此，<code>flag</code> 应为 0。当线程调用 <code>TestAndSet(flag, 1)</code> 时，例程将返回 <code>flag</code> 的旧值，即 0；因此，正在测试 <code>flag</code> 值的调用线程不会陷入 while 循环的自旋，并将获得锁。线程也会原子地将该值设置为 1，从而表明锁已被锁定。当线程完成其临界区后，会调用 unlock() 将<code>flag</code>置回 0。</p>
<p>我们可以想象的第二种情况是，一个线程已经持有锁（即<code>flag</code>为 1）。在这种情况下，该线程将调用 <code>lock()</code> 并调用 <code>TestAndSet(flag,1)</code>。这一次，<code>TestAndSet()</code> 将返回 flag 的旧值，即 1（因为锁已被持有），同时再次将其设置为 1。只要锁被另一个线程持有，<code>TestAndSet()</code> 就会反复返回 1，因此这个线程会自旋，直到锁最终被释放。当<code>flag</code>最终被其他线程设置为 0 时，该线程将再次调用 <code>TestAndSet()</code>，此时它将返回 0，同时原子地将该值设置为 1，从而获得锁并进入临界区。</p>
<p>通过将<code>test</code>（旧锁值）和 <code>set</code>（新锁值）作为单个原子操作，我们可以确保只有一个线程获得锁。这就是构建互斥原语的方法！</p>
<p>现在你可能也明白为什么这种锁通常被称为<font color="red">自旋锁</font>了。它是最简单的一种锁，只需使用 CPU 周期旋 转，直到锁可用为止。要在单处理器上正常工作，它需要一个<font color="red">抢占式调度程序（即通过定时器中断线程，以便不时运行不同的线程）</font>。如果没有抢占式调度，自旋锁在单 CPU 上的意义就不大，因为在 CPU 上旋转的线程永远不会放弃自旋锁。</p>
<h2 id="评估自旋锁" class="heading-element"><span>7 评估自旋锁</span>
  <a href="#%e8%af%84%e4%bc%b0%e8%87%aa%e6%97%8b%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了基本的自旋锁，我们现在就可以根据之前描述的标准来评估它的有效性。锁最重要的方面是<font color="red">正确性</font>：它能提供互斥吗？答案是肯定的：自旋锁每次只允许一个线程进入临界区。因此，我们拥有一个正确的锁。</p>
<p>下一个标准是<font color="red">公平性</font>。自旋锁对等待线程的公平性如何？你能保证等待线程永远不会进入临界区吗？不幸的是，自旋锁不提供任何公平性保证。事实上，一个正在自旋的线程可能会在竞争中永远自旋下去。简单的自旋锁（如前面所讨论的）是不公平的，可能会导致饥饿。</p>
<p>最后一个标准是<font color="red">性能</font>。使用自旋锁的代价是什么？为了更仔细地分析这个问题，我们建议考虑几种不同的情况。</p>
<ul>
<li>
<p>第一种情况是线程在单个处理器上竞争锁；</p>
<p>对于自旋锁，在单 CPU 的情况下，性能开销可能会相当大；想象一下持有锁的线程在临界区被抢占的情况。然后，调度程序可能会运行每个其他线程（假设有 N - 1 个其他线程），每个线程都试图获取锁。在这种情况下，每个线程在放弃 CPU 之前都会持续运行一个时间片，浪费了 CPU 周期。</p>
</li>
<li>
<p>第二种情况是线程分布在多个 CPU 上。</p>
<p>然而，在多个 CPU 上，自旋锁工作得相当好（如果线程数大致等于 CPU 数）。思路如下：想象 CPU 1 上的线程 A 和 CPU 2 上的线程 B，两者都竞争锁。如果线程 A (CPU 1) 获取锁，然后线程 B 尝试获取锁，则 B 将自旋（在 CPU 2 上）。然而，大概临界区很短，因此锁很快就变得可用，并被线程 B 获取。在这种情况下，自旋等待另一个处理器上持有的锁不会浪费很多周期，因此可能是有效的。</p>
</li>
</ul>
<h2 id="compare-and-swap" class="heading-element"><span>8 Compare-And-Swap</span>
  <a href="#compare-and-swap" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>某些系统提供的另一种硬件原语被称为 **&ldquo;compare-and-swap &ldquo;**指令（例如 SPARC 上的名称）或 **&ldquo;compare-and-exchange &ldquo;**指令（x86 上的名称）。下面是这条指令的 C 语言伪代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">actual</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">actual</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">actual</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其基本思想是，<code>compare-and-swap</code>指令测试 <code>ptr</code> 指定地址上的值是否等于预期值；如果是，则用新值更新 <code>ptr</code> 指向的内存位置。如果不相等，则什么也不做。无论哪种情况，都会返回该内存位置的实际值，从而让调用<code>compare-and-swap</code>指令的代码知道它是否成功。</p>
<p>有了<code>compare-and-swap</code>指令，我们就可以用与<code>test-and-set</code>指令类似的方式建立锁。例如，我们可以将上面的 <code>lock()</code> 例程替换为下面的例程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// spin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码的其余部分与上面的<code>test-and-set</code>示例相同。这段代码的工作原理非常相似；它只需检查<code>flag</code>是否为 0，如果为 0，则原子交换 1，从而获取锁。如果线程试图在锁被锁定时获取锁，就会被卡住，直到锁最终被释放。</p>
<p>下面是实际 C 代码（调用汇编）x86版本中显示的<code>compare-and-swap</code>的简单示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Function to perform a compare and swap operation
</span></span></span><span class="line"><span class="cl"><span class="c1">// Parameters:
</span></span></span><span class="line"><span class="cl"><span class="c1">//   ptr: pointer to the memory location where the operation will be performed
</span></span></span><span class="line"><span class="cl"><span class="c1">//   old: expected value to compare against
</span></span></span><span class="line"><span class="cl"><span class="c1">//   new: new value to store if the comparison succeeds
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns:
</span></span></span><span class="line"><span class="cl"><span class="c1">//   1 if the comparison succeeded and the value was updated, 0 otherwise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">char</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Assembly code to perform the compare and swap operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Note: sete sets a byte not the word
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__asm__</span> <span class="nf">__volatile__</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34; lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34; cmpxchgl %2,%1</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34; sete %0</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="s">&#34;=q&#34;</span> <span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="s">&#34;=m&#34;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="s">&#34;r&#34;</span> <span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">),</span> <span class="s">&#34;a&#34;</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Before successful compare and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;before successful cas: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">global</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Perform successful compare and swap operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Print result after successful compare and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;after successful cas: %d (success: %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Before failing compare and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;before failing cas: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">global</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Perform failing compare and swap operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">success</span> <span class="o">=</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Print result after failing compare and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;after failing cas: %d (old: %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最后，正如你可能已经感觉到的，<code>compare-and-swap</code>是一条比<code>test-and-set</code>功能更强大的指令。今后，当我们深入探讨<font color="red">无锁同步</font>等主题时，我们将利用这一功能。不过，如果我们只是用它构建一个简单的自旋锁，其行为与我们上面分析的自旋锁完全相同。</p>
<h2 id="load-linked-and-store-conditional" class="heading-element"><span>9 Load-Linked and Store-Conditional</span>
  <a href="#load-linked-and-store-conditional" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>一些平台提供了一对协同工作的指令来帮助构建临界区。例如，在 MIPS 架构上，<strong>加载链接指令</strong>和<strong>存储条件指令</strong>可以串联使用来构建锁和其他并发结构。这些指令的 C 伪代码如下所示。 Alpha、PowerPC 和 ARM 提供类似的指令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">LoadLinked</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">StoreConditional</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">no</span> <span class="n">update</span> <span class="n">to</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">since</span> <span class="n">LoadLinked</span> <span class="n">to</span> <span class="n">this</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// success!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// failed to update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>加载链接的操作与典型的加载指令非常相似，只是从内存中获取一个值并将其放入寄存器中。关键的区别在于条件存储，只有在没有对地址进行干预存储的情况下，条件存储才会成功（并更新存储在刚刚加载链接的地址处的值）。如果成功，<code>store-conditional</code> 返回 1 并将 ptr 处的值更新为 value；如果失败，则 ptr 处的值不会更新并返回 0。</p>
<p>下面这段代码展示了如何使用加载链接和存储条件来构建自旋锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="nf">LoadLinked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">;</span> <span class="c1">// spin until it’s zero
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">StoreConditional</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span> <span class="c1">// if set-it-to-1 was a success: all done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// otherwise: try it all over again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>lock()</code> 代码是唯一有趣的部分。首先，线程自旋，等待<code>flag</code>设置为 0（从而指示未持有锁）。一旦这样，线程尝试通过<code>store-conditional</code>获取锁；如果成功，线程会自动将<code>flag</code>的值更改为 1，从而可以进入临界区。</p>
<p>注意存储条件失败可能出现的情况。一个线程调用<code>lock()</code>并执行<code>load-linked</code>，返回0表示锁未被持有。在它尝试<code>store-conditional</code>之前，它被中断，另一个线程进入锁代码，同样执行<code>load-linked</code>指令，并得到0继续执行。此时，两个线程各自执行了<code>load-linked</code>，并且即将尝试<code>store-conditional</code>。这些指令的关键特点是这两个线程中只有一个会成功地将<code>flag</code>更新为1从而获取锁；第二个尝试<code>store-conditional</code>的线程会失败（因为另一个线程在其<code>load-linked</code>和<code>store-conditional</code>之间更新了flag值），因此必须再次尝试获取锁。</p>
<p>一种更简洁的<code>lock()</code>写法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="nf">LoadLinked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="nf">StoreConditional</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">;</span> <span class="c1">// spin until the condition does not hold
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="fetch-and-add" class="heading-element"><span>10 Fetch-And-Add</span>
  <a href="#fetch-and-add" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后一个硬件原语是<code>fetch-and-add</code>指令，它以原子方式递增一个值，同时返回特定地址上的旧值。<code>fetch-and-add</code>指令的 C 语言伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">FetchAndAdd</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>lock</code>和<code>unlock</code>代码如下所示。在这个例子中，我们将使用fetch-and-add来构建一个更有趣的票据锁，由Mellor-Crummey和Scott引入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__lock_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ticket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">lock_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock_init</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ticket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">myturn</span> <span class="o">=</span> <span class="nf">FetchAndAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span> <span class="o">!=</span> <span class="n">myturn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// spin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个解决方案不是使用单一值，而是结合使用<code>ticket</code>和<code>turn</code>变量来构建一个自旋锁。 基本操作非常简单：当线程希望获取锁时，首先对<code>ticket</code>进行原子<code>fetch-and-add</code>操作；该值现在被视为此线程的“轮次”（<code>myturn</code>）。 然后全局共享的<code>lock-&gt;turn</code>用于确定哪个线程的轮次；当给定线程的(<code>myturn == turn</code>)时，就是该线程进入临界区的机会。 <code>unlock</code>只需通过增加<code>turn</code>即可完成，以便下一个等待的线程（如果有）现在可以进入临界区。</p>
<p>请注意这种解决方案与我们之前尝试过的方法之间存在一个重要差异：它确保所有线程都能取得进展。 一旦分配了某个线程自己的<code>ticket</code>，它将在未来某个时间点被调度执行（一旦排队等候其前面已经通过临界区并释放了锁）。 在我们之前尝试过的情况下，并不存在这样保证；例如，在<code>test-and-set</code>上自旋着等待，即使其他线程获取并释放了锁也可能永远自旋下去。</p>
<h2 id="太多自旋现在怎么办" class="heading-element"><span>11 太多自旋：现在怎么办？</span>
  <a href="#%e5%a4%aa%e5%a4%9a%e8%87%aa%e6%97%8b%e7%8e%b0%e5%9c%a8%e6%80%8e%e4%b9%88%e5%8a%9e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们基于硬件的简单锁非常简单（只有几行代码），而且能正常工作，这是任何系统或代码的两个优秀特性。然而，在某些情况下，这些解决方案的效率可能很低。想象一下，你在单个处理器上运行两个线程。现在假设一个线程（线程 0）正处于临界区，因此被锁定，并不幸被中断。第二个线程（线程 1）现在试图获取锁，但发现锁已被锁定。于是，它开始不停地自旋。然后又自旋了几圈。最后，定时器中断，线程 0 再次运行，释放了锁，最后（比如说下次运行时），线程 1 就不用自旋那么多圈了，就能获得锁。因此，在这种情况下，线程一旦陷入自旋，就会浪费一整个时间片，而只是检查一个不会改变的值外，什么也不做！如果有 N 个线程在争夺一个锁，问题就更严重了；N - 1 个时间片可能会以类似的方式被浪费掉，仅仅是在自旋并等待一个线程释放锁。这就是我们的下一个问题：如何避免自旋？我们怎样才能开发出一种不会无谓地浪费时间在 CPU 上自旋的锁？仅靠硬件支持无法解决问题。我们还需要操作系统的支持！现在就让我们来看看如何实现这一点。</p>
<h2 id="一个简单的方法只需yield" class="heading-element"><span>12 一个简单的方法：只需yield</span>
  <a href="#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e6%96%b9%e6%b3%95%e5%8f%aa%e9%9c%80yield" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>硬件支持让我们取得了相当大的进展：工作锁，甚至（如票据锁）锁获取的公平性。然而，我们仍然面临一个问题：当上下文切换发生在临界区时，线程开始无休止地自旋，等待被中断的（持有锁的）线程再次运行，这时该怎么办？</p>
<p>我们首先尝试的是一种简单而友好的方法：当你要自旋时，把 CPU 让给另一个线程。或者，就像Al Davis说的那样，&ldquo;让一让，宝贝！&quot;。下面这段代码展示了这种方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">yield</span><span class="p">();</span> <span class="c1">// 放弃 CPU 控制权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这种方法中，我们假定一个线程在想要放弃 CPU 并让另一个线程运行时，可以调用操作系统原语 <code>yield()</code>。一个线程可以处于三种状态（运行、就绪或阻塞）之一；<code>yield</code> 只是一个系统调用，它将调用者从<strong>运行状态</strong>移到<strong>就绪状态</strong>，从而将另一个线程提升到<strong>运行状态</strong>。因此，<code>yield</code>过程本质上是自我取消调度的。</p>
<p>回想一下一个 CPU 上有两个线程的例子，在这种情况下，我们基于 <code>yield</code> 的方法就能很好地发挥作用。如果一个线程碰巧调用了 <code>lock()</code> 并发现锁被锁定，它就会简单地让出 CPU，这样另一个线程就会运行并完成其临界区。在这种简单的情况下，<code>yield</code>方法运行良好。</p>
<p>现在让我们考虑一下有多个线程（比如 100 个）重复争夺一个锁的情况。在这种情况下，如果一个线程获得了锁，并在释放锁之前被抢占，那么其他 99 个线程将分别调用 <code>lock()</code>，发现锁被持有，并让出 CPU。假设有某种循环调度程序，那么 99 个线程中的每一个都会在持有锁的线程再次运行之前执行这种<code>run-and-yield</code>模式。虽然这种方法比我们的 &ldquo;自旋&quot;方法要好（&ldquo;自旋 &ldquo;会浪费 99 个时间片），但上下文切换的成本可能很高，因此会造成大量浪费。</p>
<p>更糟糕的是，我们根本没有解决饥饿问题。当其他线程反复进入和退出临界区时，一个线程可能会陷入无休止的<code>yield</code>循环。显然，我们需要一种能直接解决这一问题的方法。</p>
<h2 id="使用队列睡眠而不是自旋" class="heading-element"><span>13 使用队列：睡眠而不是自旋</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%98%9f%e5%88%97%e7%9d%a1%e7%9c%a0%e8%80%8c%e4%b8%8d%e6%98%af%e8%87%aa%e6%97%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们之前的方法的真正问题在于，它们留下了太多的偶然性。调度器决定下一个运行的线程；如果调度器做出了错误的选择，运行的线程要么必须自旋等待锁（我们的第一种方法），要么立即让出 CPU（我们的第二种方法）。无论哪种方法，都有可能造成浪费，而且无法避免饥饿。</p>
<p>因此，我们必须明确控制在当前持有者释放锁后，下一个获得锁的线程。为此，我们需要更多的操作系统支持，以及一个队列来跟踪哪些线程正在等待获取锁。</p>
<p>为简单起见，我们将使用 Solaris 提供的支持，即两个调用：<code>park()</code> 用于使调用线程休眠，<code>unpark(threadID)</code> 用于唤醒<code>threadID</code> 指定的特定线程。这两个例程可以配合使用，构建一个锁，当调用者试图获取一个被锁定的锁时，该锁会使调用者休眠，而当锁被释放时，调用者会被唤醒。</p>
<p>下面这段代码实现了简单的锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__lock_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">guard</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">lock_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock_init</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">queue_init</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// 通过自旋获取 guard 锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 获取锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">queue_add</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="nf">gettid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">park</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="kt">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// 通过自旋获取 guard 锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">queue_empty</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 释放锁；没有线程要获取它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">unpark</span><span class="p">(</span><span class="nf">queue_remove</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">));</span> <span class="c1">// 保持锁（给下一个线程！）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，我们做了几件有趣的事情。首先，我们将老式的<code>test-and-set</code>思想与显式的锁等待者队列相结合，以实现更高效的锁。其次，我们使用队列来帮助控制下一个获得锁的人，从而避免饥饿。</p>
<p>你可能会注意到 <code>guard</code> 是如何使用的，它基本上是围绕锁使用的标志和队列操作的自旋锁。因此，这种方法并不能完全避免自旋等待；线程在获取或释放锁时可能会被中断，从而导致其他线程自旋等待该线程再次运行。不过，自旋所花费的时间非常有限（只是<code>lock()</code>和<code>unlock()</code>代码中的几条指令，而不是用户定义的临界区），因此这种方法可能是合理的。</p>
<p>其次，你可能会注意到，在 <code>lock()</code> 中，当一个线程无法获取锁（它已被持有）时，我们会小心地将该线程加入一个队列（通过调用 <code>gettid()</code> 函数获取当前线程的<code>threadID</code>），将 <code>guard</code> 设为 0，并让出 CPU。但如果在 <code>park()</code> 之后而不是之前释放<code>guard</code>锁，会发生什么情况？这会导致其他线程暂时无法再获得 <code>guard</code> 锁，因为该锁仍然由先前的线程持有。如果其他线程试图获取锁，则会一直自旋等待 <code>guard</code> 锁被释放。而由于无法获取<code>guard</code>锁，其他线程无法执行 <code>unlock()</code> 函数，所以即使某个线程被唤醒，也无法继续执行<code>unlock</code>操作。这就导致了死锁状态，所有线程都被阻塞，无法正常运行。</p>
<p>你可能还会注意到一个有趣的事实，那就是当另一个线程被唤醒时，<code>flag</code>不会被设置回 0。这是为什么呢？这并不是一个错误，而是一种必然！当一个线程被唤醒时，它就像从 <code>park()</code> 返回一样；然而，它在代码中的这一点上并不持有<code>guard</code>，因此甚至无法尝试将<code>flag</code>设置为 1。因此，我们只是将锁从释放锁的线程直接传递给下一个获取锁的线程；在这中间，<code>flag</code>不会被设置为 0。</p>
<p>最后，你可能会注意到在解决方案中，就在调用 <code>park()</code> 之前出现了竞争条件。例如线程B在调用<code>park()</code>之前线程A释放了锁，那么线程B可能会永远休眠，因为在调用 <code>park()</code> 之前它已经错过了唤醒的时机。这个问题有时被称为<font colo="red">唤醒/等待竞争</font>。</p>
<p>Solaris 通过添加第三个系统调用 <code>setpark()</code> 来解决这个问题。通过调用该例程，线程可以表明它即将<code>park</code>。如果线程在调用 <code>park()</code> 之前被中断（例如收到了一个信号），而另一个线程在这个时候调用了 <code>unpark()</code> 来唤醒当前线程，则当前线程下一次调用 <code>park()</code> 不会真正进入休眠状态，而是立即返回，继续执行后续的代码。<code>lock()</code>内部的代码修改很小：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">queue_add</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="nf">gettid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="nf">setpark</span><span class="p">();</span> <span class="c1">// new code , (before open guard)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>另一种不同的解决方案是将<code>guard</code>传递给内核。在这种情况下，内核可以采取预防措施，以原子方式释放锁，并将运行中的线程出列。</p>
<h2 id="不同的操作系统不同的支持" class="heading-element"><span>14 不同的操作系统，不同的支持</span>
  <a href="#%e4%b8%8d%e5%90%8c%e7%9a%84%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%8d%e5%90%8c%e7%9a%84%e6%94%af%e6%8c%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>到目前为止，我们已经看到了操作系统为在线程库中建立更高效的锁而提供的一种支持。其他操作系统也提供类似的支持，但细节各有不同。</p>
<p>例如，Linux 提供的 <strong>futex</strong> 与 Solaris 接口类似，但提供了更多内核功能。具体来说，每个 futex 都关联了一个特定的物理内存位置，以及每个 futex 的内核队列。调用者可以根据需要使用 futex 调用来休眠和唤醒。具体来说，</p>
<p>有两种调用方式可用。调用 <code>futex_wait(address,expected)</code>后，调用线程将进入休眠状态，前提是地址中的值等于预期值。如果不相等，调用将立即返回。调用例程 <code>futex_wake(address)</code> 会唤醒一个正在队列中等待的线程。这些调用在 Linux <code>mutex</code>中的用法如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mutex_lock</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Bit 31 was clear, we got the mutex (the fastpath) */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">atomic_bit_test_set</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Atomic operations increase the number of waiters on the lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">atomic_increment</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Spin waits for other threads to release the lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nf">atomic_bit_test_set</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// The current thread holds the lock and the number of waiters is reduced by 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">atomic_decrement</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* We have to wait. First make sure the futex value
</span></span></span><span class="line"><span class="cl"><span class="cm">           we are monitoring is truly negative (locked). */</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">futex_wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mutex_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Adding 0x80000000 to counter results in 0 if and
</span></span></span><span class="line"><span class="cl"><span class="cm">       only if there are not other interested threads */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">atomic_add_zero</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* There are other threads waiting for this mutex,
</span></span></span><span class="line"><span class="cl"><span class="cm">       wake one of them up. */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">futex_wake</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>nptl 库（gnu libc 库的一部分） 中 lowlevellock.h的这段 代码片段之所以有趣，有几个原因。首先，它使用一个整数来跟踪锁是否被持有（整数的高位）以及锁上等待者的数量（所有其他位）。因此，如果锁是负数，它就是被持有的（因为高位被设置，而该位决定了整数的符号）。</p>
<p>其次，代码片段展示了如何针对常见情况进行优化，特别是在没有锁竞争的情况下；只有一个线程获取和释放锁，只需完成很少的工作（原子位<code>test-and-set</code>锁定以及原子位添加释放锁）。</p>
<h2 id="两阶段锁" class="heading-element"><span>15 两阶段锁</span>
  <a href="#%e4%b8%a4%e9%98%b6%e6%ae%b5%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后一点：Linux 方法有一种旧方法的味道，这种方法已经断断续续地使用了很多年，至少可以追溯到 1960 年代初的 Dahm Locks ，现在被称为两阶段锁。两阶段锁意识到自旋可能很有用，特别是在锁即将被释放的情况下。所以在第一阶段，锁会自旋一段时间，希望能够获取到锁。</p>
<p>但是，如果在第一个自旋阶段没有获取锁，则会进入第二个阶段，调用者将进入睡眠状态，只有在锁稍后释放时才会被唤醒。上面的 Linux 锁就是这种锁的一种形式，但它只自旋一次；对此的概括可以是在使用 futex 支持进入睡眠之前循环自旋固定的时间。两阶段锁是混合方法的另一个实例，其中结合两个好的想法确实可能会产生更好的想法。当然，它是否确实在很大程度上取决于很多因素，包括硬件环境、线程数量和其他工作负载细节。与往常一样，制作一个适合所有可能用例的通用锁是一个相当大的挑战。</p>
<h2 id="dekker算法和peterson算法" class="heading-element"><span>16 Dekker算法和Peterson算法</span>
  <a href="#dekker%e7%ae%97%e6%b3%95%e5%92%8cpeterson%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>20 世纪 60 年代，Dijkstra 向他的朋友们提出了并发问题，其中一位名叫 Theodorus Jozef Dekker 的数学家提出了解决方案。与我们在此讨论的使用特殊硬件指令甚至操作系统支持的解决方案不同，Dekker 的算法仅使用加载和存储（假定它们之间是原子关系，这在早期的硬件上是正确的）。下面是Dekker算法的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="n">self</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Dekker的方法后来被Peterson改进。同样，该算法只使用加载和存储，其目的是确保两个线程不会同时进入临界区。下面是 Peterson 的算法（两个线程）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// indicate you intend to hold the lock w/ ’flag’
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// whose turn is it? (thread 0 or 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ’self’ is the thread ID of caller
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// make it other thread’s turn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">self</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// spin-wait while it’s not your turn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// simply undo your intent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">flag</span><span class="p">[</span><span class="n">self</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>出于某种原因，开发无需特殊硬件支持就能工作的锁曾风靡一时，给理论家们带来了许多难题。当然，当人们意识到假定有一点硬件支持会容易得多时，这一行就变得毫无用处了（事实上，这种支持在多进程的早期就已经存在了）。此外，类似上述的算法在现代硬件上也行不通（因为内存一致性模型被放宽了），因此它们的用处比以前更小了。然而，更多的研究已被历史尘封&hellip;&hellip;</p>
]]></description></item><item><title>线程API</title><link>https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/</link><pubDate>Sat, 11 May 2024 20:37:20 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/</guid><description><![CDATA[<h2 id="线程创建" class="heading-element"><span>1 线程创建</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e5%88%9b%e5%bb%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>编写多线程程序的第一件事就是创建新线程，因此必须有某种线程创建接口。在 POSIX 中，这很容易：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span>     <span class="kt">pthread_t</span><span class="o">*</span>              <span class="kr">thread</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                  <span class="k">const</span> <span class="kt">pthread_attr_t</span><span class="o">*</span>         <span class="n">attr</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                        <span class="kt">void</span><span class="o">*</span>                   <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">void</span><span class="o">*</span>                   <span class="n">arg</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数声明有四个参数：<code>thread</code>、<code>attr</code>、<code>start_routine</code> 和 <code>arg</code>。第一个参数 <code>thread</code> 是指向 <code>pthread_t</code> 类型结构的指针；我们将使用该结构与线程交互，因此需要将其传递给 <code>pthread_create()</code> 以对其进行初始化。</p>
<p>第二个参数 <code>attr</code> 用于指定该线程可能具有的任何属性。例如包括设置栈大小或可能有关线程的调度优先级的信息。通过单独调用 <code>pthread_attr_init()</code> 来初始化属性；有关详细信息，请参阅手册页：<code>man pthread_create</code>。然而，在大多数情况下，默认值就可以了，在这种情况下，我们将简单地传递 NULL 值。</p>
<p>第三个参数是最复杂的，但实际上只是询问：这个线程应该开始在哪个函数中运行？在 C 中，我们将其称为函数指针，这告诉我们预期的内容：函数名称（<code>start_routine</code>），它传递一个类型为 <code>void *</code> 的单个参数（如<code>start_routine</code>后面的括号中所示），以及它返回一个 <code>void *</code> 类型的值（即，一个 void 指针）。如果此例程需要整数参数而不是 void 指针，则声明将如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(...,</span> <span class="c1">// first two args are the same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="kt">void</span> <span class="o">*</span>  <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">int</span>     <span class="n">arg</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果例程的参数是一个 void 指针，但返回值是一个整数，那么就会是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(...,</span> <span class="c1">// first two args are the same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">void</span> <span class="o">*</span>  <span class="n">arg</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最后，第四个参数 <code>arg</code> 正是要传递给线程开始执行的函数的参数。你可能会问：为什么我们需要这些 void 指针？答案其实很简单：<font color="red">将 void 指针作为函数<code>start_routine</code>的参数，可以让我们传递任何类型的参数</font>；将它作为返回值，可以让线程返回任何类型的结果。</p>
<p>还有函数的返回值，如果运行正常，则返回 0（否则为错误代码：EAGAIN、EINVAL、EPERM）。</p>
<p>让我们看看下面这段代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common_threads.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">myarg_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myarg_t</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="kt">myarg_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myarg_t</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;done</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们只是创建了一个线程，它传递了两个参数，并打包成我们自己定义的单一类型（<code>myarg t</code>）。线程创建后，可以简单地将其参数转换为它所期望的类型，从而根据需要解包参数。就是这样！一旦创建了线程，你就真正拥有了另一个活生生的执行实体，它拥有自己的调用栈，与程序中当前存在的所有线程运行在同一地址空间。程序的运行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ make thread_create
</span></span><span class="line"><span class="cl">gcc -o thread_create thread_create.c -Wall -Werror -I../include -pthread
</span></span><span class="line"><span class="cl">❯ ./thread_create
</span></span><span class="line"><span class="cl"><span class="m">10</span> <span class="m">20</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="等待线程完成" class="heading-element"><span>2 等待线程完成</span>
  <a href="#%e7%ad%89%e5%be%85%e7%ba%bf%e7%a8%8b%e5%ae%8c%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>上面的例子展示了如何创建一个线程。但是，如果您想等待线程完成，会发生什么情况？你需要做一些特别的事情才能等待完成；特别是，您必须调用例程 <code>pthread_join()</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">value_ptr</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此例程需要两个参数。第一个参数的类型是 <code>pthread_t</code>，用于指定等待哪个线程。该变量由线程创建例程初始化（将指针作为参数传递给 <code>pthread create()</code>）；如果保留该变量，就可以用它来等待该线程终止。</p>
<p>第二个参数是指向你期望返回值的指针。由于该例程可以返回任何值，因此它被定义为返回 void 的指针；由于 <code>pthread_join() </code>例程会改变传入参数的值，因此你需要传入指向该值的指针，而不仅仅是该值本身。</p>
<p>让我们看下面这段代码，在代码中，再次创建了一个单线程，并通过 <code>myarg_t</code> 结构传递了几个参数。返回值使用 <code>myret_t</code> 类型。一旦线程运行完毕，一直在 <code>pthread_join() </code>例程 中等待的主线程就会返回，我们就可以访问从线程返回的值，即 <code>myret_t</code> 中的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common_threads.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">myarg_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">myret_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myarg_t</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="kt">myarg_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;args %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myret_t</span> <span class="o">*</span><span class="n">rvals</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">myret_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rvals</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rvals</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rvals</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">rvals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myret_t</span> <span class="o">*</span><span class="n">rvals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myarg_t</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rvals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;returned %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rvals</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">rvals</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">rvals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关于这个例子，有几点需要注意。首先，很多时候我们不必对参数进行这些痛苦的打包和拆包。例如，如果我们只是创建一个不带参数的线程，我们可以在创建线程时将 NULL 作为参数传递进去。同样，如果我们不关心返回值，也可以将 NULL 传递给 <code>pthread_join()</code>。</p>
<p>其次，如果我们只传递一个值（如 int），就不必将其打包为参数。</p>
<p>如下面这段代码所示，在这种情况下，我们不必将参数和返回值打包到结构内部。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;common_threads.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">rvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rvalue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;returned %lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rvalue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第三，我们应该注意，从线程返回值的方式必须非常谨慎。尤其是，千万不要返回指向线程调用栈中分配的指针。如果这样做，你觉得会发生什么？(想想吧！）下面是一段危险代码的示例，它是根据上面的示例修改的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myarg_t</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="kt">myarg_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">myret_t</span> <span class="n">r</span><span class="p">;</span> <span class="c1">// ALLOCATED ON STACK: BAD!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这种情况下，变量 r 被分配到 <code>mythread</code> 的栈中。然而，当它返回时，该值会被自动解除分配（毕竟这就是栈如此易于使用的原因！），因此，将指向已解除分配的变量的指针传回会导致各种糟糕的结果。</p>
<p>最后，你可能会注意到，使用 <code>pthread_create()</code> 创建线程，然后立即调用 <code>pthread_join()</code> 是一种非常奇怪的创建线程的方法。事实上，有一种更简单的方法可以完成这一任务，那就是<font color="red">过程调用</font>。显然，我们通常要创建不止一个线程并等待它完成，否则使用线程就没有什么意义了。</p>
<p>我们应该注意，并非所有多线程代码都使用<code>join</code>例程。例如，多线程网络服务器可能会创建许多工作线程，然后使用主线程接受请求并将请求无限期地传递给工作线程。因此，这种长寿命程序可能不需要<code>join</code>。然而，创建线程执行特定任务（并行）的并行程序可能会使用 <code>join</code> 来确保在退出或进入下一阶段计算之前，所有这些工作都已完成。</p>
<h2 id="锁" class="heading-element"><span>3 锁</span>
  <a href="#%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>除了线程创建和等待线程完成之外，POSIX 线程库提供的下一组最有用的函数可能就是那些通过<strong>锁</strong>为临界区提供互斥的函数了。为此目的使用的最基本的一对例程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>例程应该易于理解和使用。当您的代码区域是临界区，因此需要受到保护以确保正确操作时，锁非常有用。你大概可以想象代码的样子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 或者不管你的临界区是什么
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码的意图如下：如果调用 <code>pthread_mutex_lock()</code> 时没有其他线程持有锁，则该线程将获取锁并进入临界区。如果另一个线程确实持有锁，则尝试获取锁的线程将不会从调用中返回，直到它获得锁（这意味着持有锁的线程已通过unlock调用释放了锁）。当然，在给定时间，许多线程可能会卡在锁获取函数内等待；然而，只有获得锁的线程才应该调用<code>unlock</code>。</p>
<p>不幸的是，这段代码在两个重要方面被破坏了。第一个问题是<font color="red">缺乏正确的初始化</font>。所有锁都必须正确初始化，以保证它们具有正确的值，从而在调用lock和unlock时按需要工作。</p>
<p>对于 POSIX 线程，有两种初始化锁的方法。一种方法是使用 <code>PTHREAD_MUTEX_INITIALIZER</code>，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样做会将锁设置为默认值，从而使锁可用。动态方法（即在运行时）是调用 <code>pthread_mutex_init()</code>，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="err">“</span><span class="n">Error</span> <span class="n">in</span> <span class="n">mutex</span> <span class="n">init</span><span class="err">”</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该例程的第一个参数是锁本身的地址，第二个参数是一组可选属性。传递 NULL 即只需使用默认值即可。两种方法都可以，但我们通常使用动态（后一种）方法。需要注意的是，在使用完锁后，还需要调用 <code>pthread_mutex_destroy()</code>。</p>
<p>上述代码的第二个问题是，它在调用lock和unlock时没有检查错误代码。就像你在 UNIX 系统中调用的几乎所有库例程一样，这些例程也可能失败！如果你的代码没有正确检查错误代码，失败就会无声无息地发生，在这种情况下，可能会允许多个线程进入临界区段。在最低限度上，应使用包装器来断言例程成功（如下面这段代码所示）；更复杂的（非玩具）程序在出错时不能简单地退出，而应检查失败，并在lock或unlock不成功时采取适当的措施。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Use this to keep your code clean but check for failures
</span></span></span><span class="line"><span class="cl"><span class="c1">// Only use if exiting program is OK upon failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="err">“</span><span class="n">Error</span> <span class="n">in</span> <span class="n">acquire</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>lock和unlock例程并不是 <code>pthreads</code> 库中与锁交互的唯一例程。这里还有两个例程可能值得关注：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_mutex_timedlock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">abs_timeout</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这两个调用用于获取锁。如果锁已被持有，<code>trylock</code> 版本会返回失败；获取锁的 <code>timedlock</code> 版本会在超时或获取锁后返回，以先发生者为准。因此，超时后的 <code>timedlock</code> 会退化为 <code>trylock</code>。一般来说，这两种情况都应该避免；不过，在某些情况下，避免卡在（也许是无限期地）锁获取例程中是有用的。</p>
<h2 id="条件变量" class="heading-element"><span>4 条件变量</span>
  <a href="#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>任何线程库的另一个主要组成部分，当然也包括 POSIX 线程，就是<strong>条件变量</strong>的存在。<font color="red">当线程之间必须进行某种信号传递时，如果一个线程正在等待另一个线程做某事，然后才能继续，那么条件变量就非常有用</font>。希望以这种方式进行交互的程序主要使用两个例程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要使用条件变量，还必须拥有与该条件关联的锁。当调用上述任一例程时，应保持此锁。</p>
<p>第一个例程 <code>pthread_cond_wait()</code> 使调用线程进入睡眠状态，从而等待其他线程向其发出信号，通常是在程序中的某些内容发生更改而现在正在睡眠的线程可能关心的情况下。典型的用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在此代码中，在初始化相关锁和条件之后，线程检查变量<code>ready</code>是否已设置为非零的值。如果没有，该线程只需调用等待例程即可休眠，直到其他线程将其唤醒。唤醒一个线程的代码如下所示，该代码将在其他线程中运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关于这个代码序列，有几点需要注意。首先，在发送信号时（以及修改全局变量 <code>ready</code> 时），我们始终要确保<code>lock</code>。这样可以确保我们的代码不会意外引入竞争条件。</p>
<p>其次，你可能会注意到，<code>wait</code> 调用的第二个参数是锁，而 <code>signal</code> 调用只需要一个条件。造成这种差异的原因是，wait 调用除了让调用线程休眠外，还会在让调用者休眠时释放锁。试想一下，如果不这样做，其他线程怎么可能获得锁并发出信号唤醒它呢？不过，在被唤醒后返回之前，<code>pthread_cond_wait()</code> 会重新获取锁，从而确保在等待序列开始时获取锁和结束时释放锁之间的任何时间，等待线程都持有锁。</p>
<p>最后一个奇怪的现象：等待线程在 while 循环中重新检查条件，而不是简单的 if 语句。因为使用 while 循环是简单安全的做法。虽然它会重新检查条件（可能会增加一点开销），但有些 pthread 实现可能会错误地唤醒等待线程；在这种情况下，如果不重新检查，等待线程就会继续认为条件改变，即使它并没有改变。例如，如果有多个线程在等待，而只有一个线程应该抓取数据（生产者-消费者）。因此，更安全的做法是将唤醒视为可能已发生变化的提示，而不是绝对的事实。</p>
<p>需要注意的是，有时在两个线程之间使用一个简单的标志来发出信号，而不是使用条件变量和相关的锁，这很有诱惑力。例如，我们可以重写上面的等待代码，在等待代码中看起来更像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span> <span class="c1">// spin
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>相关的信号代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>永远不要这样做，原因如下。首先，它在很多情况下表现不佳（长时间自旋，即持续检查某个条件是否满足，这只会浪费 CPU 周期）。其次，容易出错。使用标志（如上所述）在线程之间进行同步时非常容易出错。</p>
<h2 id="线程api指南" class="heading-element"><span>5 线程API指南</span>
  <a href="#%e7%ba%bf%e7%a8%8bapi%e6%8c%87%e5%8d%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当你使用POSIX线程库（或者实际上，任何线程库）构建一个多线程程序时，有一些小但重要的事情需要记住。它们包括：</p>
<ul>
<li>**保持简单。**最重要的是，任何涉及线程之间的锁定或信号的代码都应尽可能简单。复杂的线程交互会导致错误。</li>
<li>**最小化线程交互。**尽量减少线程之间交互的方式。每个交互都应该经过深思熟虑，并用经过验证的方法构建。</li>
<li>**初始化锁和条件变量。**未初始化将导致代码有时能够正常工作，有时会以非常奇怪的方式失败。</li>
<li>**检查返回码。**当然，在你所做的任何C和UNIX编程中，你都应该检查每一个返回码，这在这里也是正确的。不这样做将导致奇怪且难以理解的行为。</li>
<li>**在传递参数给线程和从线程返回值时要小心。**特别是，任何时候你传递指向栈上分配的变量的引用时，你可能在做一些错误的事情。</li>
<li>**每个线程都有自己的栈。**与上面的观点相关，请记住每个线程都有自己的栈。因此，如果你在某个线程执行的函数中有一个在本地分配的变量，它基本上是私有的，其他线程无法（轻易）访问它。要在线程之间共享数据，这些值必须在堆上或者以其他全局可访问的位置。</li>
<li>**总是使用条件变量来在线程之间进行信号传递。**虽然使用简单的标志往往很诱人，但不要这样做。</li>
<li>**使用手册页面。**特别是在Linux上，pthread手册页面非常有信息量。</li>
</ul>
]]></description></item></channel></rss>