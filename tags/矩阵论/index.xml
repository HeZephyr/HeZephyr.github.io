<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>矩阵论 - 标签 | ZephyrHe</title><link>https://hezephyr.github.io/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/</link><description>矩阵论 - 标签 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Fri, 01 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/" rel="self" type="application/rss+xml"/><item><title>【矩阵论】Chapter 1—向量空间知识点总结复习</title><link>https://hezephyr.github.io/posts/01.%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/</guid><description><![CDATA[<h2 id="定义" class="heading-element"><span>1 定义</span>
  <a href="#%e5%ae%9a%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>数域定义</p>
<p>数域$F$，是至少包含$0$和$1$的数集，并满足以下性质：</p>
<ol>
<li>$\forall a\in F, -a\in F$</li>
<li>$\forall b\in F(b\neq 0), b^{-1}\in F$</li>
<li>$\forall a, b\in F, a+b\in F$</li>
<li>$\forall a,b\in F, a\cdot b\in F$</li>
</ol>
<p>矩阵论中最常用到的两个数域是$R$（实数域）和$C$（复数域）</p>
</li>
<li>
<p>代数系统定义</p>
<p>代数系统通常是定义了一些运算和运算规则的集合。描述一个代数系统需要：</p>
<ol>
<li>一组元素</li>
<li>运算</li>
<li>运算规则</li>
</ol>
</li>
<li>
<p>几何向量定义</p>
<p>有大小有方向的量，可以用有向线段表示，如$\vec{\alpha}$。有加法和数乘运算。</p>
</li>
<li>
<p>向量空间定义</p>
<p>一个域 $F$（底域）上的向量空间（线性空间或线性向量空间）$V$ 是一组元素（称为向量）以及加法和标量乘法这两种运算，并满足以下条件：</p>
<ol>
<li>
<p>闭包性</p>
<ul>
<li>
<p>$\forall x,y\in V, x+y\in V$，且$x+y$运算结果唯一</p>
</li>
<li>
<p>$\forall a\in F,x\in V, a\cdot x\in V$，且$a\cdot x$运算结果唯一</p>
</li>
</ul>
</li>
<li>
<p>加法公理</p>
<ul>
<li>交换律：$\forall x,y\in V, x+y=y+x$</li>
<li>结合律：$\forall x,y,z\in V, x+(y+z)=(x+y)+z$</li>
<li>存在零向量：$\forall x\in V,x+0=0+x=x$</li>
<li>存在相反向量：$\forall x\in V,\exist (-x)\in V,x+(-x)=0$</li>
</ul>
</li>
<li>
<p>标量乘法公理</p>
<ul>
<li>结合律：$\forall a,b\in F, x\in V,a\cdot (b\cdot x)=(ab)\cdot x$</li>
<li>分配律$1$：$\forall a\in F, x,y\in V,a\cdot(x+y)=a\cdot x+a\cdot y$</li>
<li>分配律$2$：$\forall a,b\in F, x\in V,(a+b)\cdot x=a\cdot x + b\cdot x$</li>
<li>存在单位元素：$\forall x\in V,1\cdot x=x$</li>
</ul>
</li>
</ol>
</li>
<li>
<p>向量空间重点</p>
<p>定义一个向量空间需要：<font color="red">一个集合$V$，一个数域$F$，两种运算，八种运算规则</font>。</p>
</li>
<li>
<p>常见向量空间</p>
<ol>
<li>$R^{m\times n},(R^{m\times 1}=R^m)$：$m\times n$的实数矩阵集合，在$R$上的向量空间</li>
<li>$C^{m\times n},(C^{m\times 1}=R^m)$：$m\times n$的复数矩阵集合，在$C$上的向量空间</li>
<li>$C_{[a,b]}$：闭区间上的连续函数集合，在$R$上的向量空间</li>
<li>$P_n$：次数小于 $n$ 的实多项式的集合，在$R$上的向量空间</li>
</ol>
</li>
</ul>
<h2 id="子空间" class="heading-element"><span>2 子空间</span>
  <a href="#%e5%ad%90%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>子空间定义</p>
<p>如果$S$是向量空间$V$在数域$F$上的一个非空子集，且满足闭包性，则$S$就是$V$的一个子空间。</p>
<p>由$V$的零向量所组成的自己${0}$是$V$的一个子空间，称为零子空间，向量空间$V$本身也是$V$的一个子空间，它们都称为$V$的平凡子空间，$V$的其他子空间称为非平凡子空间。</p>
</li>
<li>
<p>子空间重点</p>
<p>$V$ 的子空间 $S$ 以及 $V$ 的加法和标量乘法运算满足向量空间定义中的所有条件。因此，<font color="red">向量空间的每个子空间本身就是一个向量空间</font>。$S$ 的底层域与 $V$ 的底层域相同。</p>
</li>
<li>
<p>零空间定义</p>
<p>设$A\in F^{m\times n},N(A)={x\in F^n|Ax=0}$，则$N(A)$为$F^n$的子空间，$N(A)$称为$A$的零空间。</p>
</li>
<li>
<p>向量的线性相关性</p>
<p>设$V$是数域$F$上的线性空间，$a_1,\cdots,a_n\in F,v_1,\cdots,v_n\in V$，则$a_1v_1+\cdots+a_nv_n$就是$v_1,\cdots,v_n$的线性组合。</p>
<p>若存在$n$个不全为零的数$a_1,\cdots,a_n\in F$，使得$a_1v_1+\cdots+a_nv_n=0$，则称$v_1,\cdots,v_n$线性相关，否则就称为线性无关。</p>
<p><font color="red">线性相关的充要条件是其中有一个向量是其余向量的线性组合</font></p>
</li>
<li>
<p>生成集定义</p>
<p>$span(K)={v|v\texttt{是向量}K\texttt{的一个线性组合}}$，即为向量$K$的线性组合生成的集合。如果$K$是向量空间$V$中的有限集，那么$span(K)$也就是$V$的子空间。</p>
<p>如果$v_1,\cdots,v_n$是向量空间$V$的向量，且$V=span{v_1,\cdots,v_n}$，则集合${v_1,\cdots,v_n}$称为$V$的生成集。</p>
</li>
<li>
<p>子空间的交集、和</p>
<ol>
<li>
<p>设$U_1,U_2$为向量空间$V$的子空间，则$U_1\cap U_2={v|v\in U_1, v\in U_2}$，$U_1\cap U_2$也是$V$的子空间。</p>
</li>
<li>
<p>设$U_1,U_2$为向量空间$V$的子空间，则$U_1+U_2={v_1+v_2|v_1\in U_1,v_2\in U_2}$，$U_1+ U_2$也是$V$的子空间。</p>
<p>如果$U_1=span(u_1,\cdots_,u_k),U_2=span(w_1,\cdots,w_s)$，则$U_1+U_2=span(u_1,\cdots,u_k,w_1,\cdots,w_s)$。</p>
</li>
</ol>
</li>
<li>
<p>子空间的直和</p>
<p>设$V_1,V_2$是向量空间$V$的两个子空间，如果和$V_1+V_2$中每一个向量$\alpha$可唯一表示成$\alpha=\alpha_1+\alpha_2,\alpha_1\in V_1,\alpha_2\in V_2$，则称和$V_1+V_2$为直和，记为$V_1+V_2$。</p>
<p>和$V_1+V_2$是直和$\Longleftrightarrow$和$V_1+V_2$中零向量的表示法唯一，即若$\alpha_1+\alpha_2=0(\alpha_1\in V_1,\alpha_2\in V_2)$，则$\alpha_1=0,\alpha_2=0\Longleftrightarrow V_1\cap V_2={0}\Longleftrightarrow\dim(V_1+V_2)=\dim(V_1)+\dim(V_2)$</p>
</li>
<li>
<p>补空间定义</p>
<p>如果$V=V_1\oplus V_2 $，我们则称$V_1$和$V_2$互为补空间，即$V_1$是$V_2$的补。</p>
</li>
<li>
<p>补空间定理</p>
<p>如果$U$是$V$的子空间，则存在$V$的子空间$W$，使得$V=U\oplus W$</p>
</li>
</ul>
<h2 id="基坐标和维数" class="heading-element"><span>3 基、坐标和维数</span>
  <a href="#%e5%9f%ba%e5%9d%90%e6%a0%87%e5%92%8c%e7%bb%b4%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>基、坐标定义</p>
<p>$n$个向量$v_1,\cdots,v_n$是向量空间$V$的一组基，当且仅当：</p>
<ol>
<li>$v_1,\cdots,v_n$线性无关</li>
<li>$V=span(v_1,\cdots,v_n)$</li>
</ol>
<p><font color="red">基不是唯一的，但$V$的所有基中的向量个数是相同的</font></p>
<p>设$a$是$V$中的任一向量，则$a$可以唯一的表示为基$v_1,\cdots,v_n$的线性组合$a=k_1v_1+\cdots+k_nv_n$，其中系数$k_1,\cdots,k_n$称为$a$在基$v_1,\cdots,v_n$下的坐标，记为$(k_1,\cdots,k_n)^T$。</p>
</li>
<li>
<p>维数定义</p>
<p>如果向量空间$V$的基由$n$个向量组成，则我们称$V$的维数是$n$。</p>
</li>
<li>
<p>定理</p>
<p>在$n$维线性空间$V$中，任意一个线性无关的向量组$a_1,\cdots,a_r$都可以扩充为$V$的一组基。</p>
</li>
<li>
<p>维数公式</p>
<p>设$U_1,U_2$为向量空间$V$的两个子空间，则</p>
<p>$\dim(U_1+U_2)=\dim(U_1)+\dim(U_2)-\dim(U_1\cap U_2)$</p>
</li>
</ul>
<h2 id="基变换" class="heading-element"><span>4 基变换</span>
  <a href="#%e5%9f%ba%e5%8f%98%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>过渡矩阵</p>
<p>设$u_1,\cdots,u_n$与$v_1,\cdots,v_n$是$n$维线性空间$V$的两组基，则有如下关系
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173857707.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173857707.png?size=small" data-sub-html="<h2>image-20240728173857707</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173857707.png" alt="image-20240728173857707" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173857707.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173857707.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173857707.png?size=large 2x" data-title="image-20240728173857707" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
关系式用矩阵表示为
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173935127.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173935127.png?size=small" data-sub-html="<h2>image-20240728173935127</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173935127.png" alt="image-20240728173935127" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173935127.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173935127.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728173935127.png?size=large 2x" data-title="image-20240728173935127" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
$n$阶矩阵
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728174232941.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728174232941.png?size=small" data-sub-html="<h2>image-20240728174232941</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728174232941.png" alt="image-20240728174232941" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728174232941.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728174232941.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728174232941.png?size=large 2x" data-title="image-20240728174232941" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
称为由基$u_1,\cdots,u_n$到基$v_1,\cdots,v_n$的过渡矩阵。</p>
</li>
</ul>
<h2 id="行空间和列空间" class="heading-element"><span>5 行空间和列空间</span>
  <a href="#%e8%a1%8c%e7%a9%ba%e9%97%b4%e5%92%8c%e5%88%97%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>矩阵的秩</p>
<p>如果矩阵$A$的秩为$r$，则说明：</p>
<ol>
<li>存在一个$r×r$子矩阵，其行列式不为零；和</li>
<li>所有的 $(r+1)\times (r+1)$ 的子矩阵的行列式为零。</li>
</ol>
</li>
<li>
<p>行空间和列空间</p>
<p>设$A\in F^{m\times n}$</p>
<ol>
<li>行空间：由$A$的行向量生成的$F^{1\times n}$的子空间。（也为$A^T$的列空间）</li>
<li>列空间：由$A$的列向量生成的$F^{m\times 1}$的子空间。（也为$A^T$的行空间）</li>
</ol>
</li>
<li>
<p>行等价条件</p>
<p>矩阵$A$和$B$被称为是行等价$\Longleftrightarrow$$B$可以由$A$进行初等行变换得到。</p>
<p>特别地，对于非奇异矩阵，有充要条件是存在一个非奇异矩阵$M$使得，$MA=B$。</p>
</li>
<li>
<p>行等价性质</p>
<p>设矩阵$A,B$是两个行等价的矩阵，则：</p>
<ol>
<li>它们有相同的行空间。</li>
<li>如果$A$中的列向量$a_{i_1},\cdots,a_{i_k}$是线性无关的，则$B$中的列向量$b_{i_1},\cdots,b_{i_k}$也是线性无关的</li>
</ol>
</li>
<li>
<p>列空间性质</p>
<ol>
<li>线性系统$Ax=b$相容（有解）$\Longleftrightarrow$$b$在$A$的列空间里</li>
<li>$Ax=b$相容当且仅当$rank(A)=rank(A,b)$，即等价于$A$的列空间等于$(A,b)$的列空间</li>
<li>如果$\forall b\in F^m$，$Ax=b$相容，说明$A$的列空间是$F^m$。</li>
<li>如果$\forall b,Ax=b$至多只有一个解，说明$A$的列向量是线性无关的，则$A$的列向量是$A$的列空间的基，等价于$A$是非奇异矩阵。</li>
</ol>
</li>
<li>
<p>秩——零度定理</p>
<p>设$A$为$m\times n$矩阵，则$rank(A)+rank(N(A))=0$</p>
</li>
<li>
<p>秩和维数</p>
<p>设$A$是$m\times n$矩阵，$A$的行空间维数等于$A$的列空间维数，即$\dim(R(A^T))=\dim(R(A))$，其中$R(A^T)$表示$A^T$的列空间，即$A$的行空间。</p>
<p><font color="red">虽然矩阵$A$的行空间和列空间不相同，但是它们有相同的维数，都为$A$的秩，矩阵$A$在初等变换下秩是不变的。</font></p>
</li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 2—内积空间知识点总结复习</title><link>https://hezephyr.github.io/posts/02.%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4/</guid><description><![CDATA[<h2 id="内积空间" class="heading-element"><span>1 内积空间</span>
  <a href="#%e5%86%85%e7%a7%af%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>内积空间定义</p>
<p>设$V$是在数域$F$上的向量空间，则$V$到$F$的一个代数运算记为$(\alpha,\beta)$。如果$(\alpha,\beta)$满足以下条件：</p>
<ol>
<li>$(\alpha,\beta)=\overline{(\beta,\alpha)}$（<font color="red">$\overline{}$表示共轭符，针对复数域，为了保证复数运算的正确性</font>）</li>
<li>$(\alpha+\beta,\gamma)=(\alpha,\gamma)+(\beta,\gamma)$</li>
<li>$(k\alpha,\beta)=k(\alpha,\beta)$</li>
<li>$(\alpha,\alpha)\geq 0$，当且仅当$\alpha=0$时，$(\alpha,\alpha)=0$。</li>
</ol>
<p>其中$k\in  F,\alpha,\beta,\gamma\in V$。则称$(\alpha,\beta)$为$\alpha$和$\beta$的内积。定义了内积的向量空间$V$称为内积空间。特别地，称实数域$R$上的内积空间$V$为Euclid空间（欧式空间）；称复数域$C$上的内积空间$V$为酉空间。</p>
</li>
<li>
<p>标准内积</p>
<ol>
<li>
<p>在实数域$R$上的$n$维向量空间$R^n$中，对向量$x=(x_1,\cdots,x_n)^T,y=(y_1,\cdots,y_n)^T$，定义内积
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204404642.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204404642.png?size=small" data-sub-html="<h2>image-20240728204404642</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204404642.png" alt="image-20240728204404642" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204404642.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204404642.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204404642.png?size=large 2x" data-title="image-20240728204404642" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>在复数域$C$上的$n$维向量空间$C^n$，对向量$x=(x_1,\cdots,x_n)^T,y=(y_1,\cdots,y_n)^T$，定义内积
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204416487.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204416487.png?size=small" data-sub-html="<h2>image-20240728204416487</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204416487.png" alt="image-20240728204416487" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204416487.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204416487.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204416487.png?size=large 2x" data-title="image-20240728204416487" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$y^H$表示$y$的共轭转置。</p>
</li>
</ol>
<p>以上两个内积我们称为$R^n$或$C^n$的标准内积，一般我们探讨的也就是标准内积。</p>
</li>
<li>
<p>重要定义</p>
<p>设$u,v$是内积空间$V$的向量</p>
<ol>
<li>则$v$的长度或范数为：$||v||=\sqrt{(v,v)}$，长度为$1$的称为单位向量。如果$v\neq 0$，则$\frac{v}{||v||}$是一个单位向量</li>
<li>如果$v\neq 0$，则$u$在$v$上的数量投影被定义为：$\alpha=\frac{(u,v)}{||v||}$，$u$在$v$上的向量投影被定义为：$p=\alpha\frac{v}{||v||}=\frac{(u,v)}{(v,v)}v$</li>
<li>如果$(u,v)=0$，则称$u$和$v$正交</li>
</ol>
</li>
<li>
<p>内积的基本性质</p>
<p>设$u,v\in V$，其中$V$是内积空间，则</p>
<ol>
<li>
<p>勾股定理：如果$u\perp v$，则$||u-v||^2=||u||^2+||v||^2$
证明：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204431345.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204431345.png?size=small" data-sub-html="<h2>image-20240728204431345</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204431345.png" alt="image-20240728204431345" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204431345.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204431345.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204431345.png?size=large 2x" data-title="image-20240728204431345" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201125638852.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201125638852.png?size=small" data-sub-html="<h2>image-20231201125638852</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201125638852.png" alt="image-20231201125638852" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201125638852.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201125638852.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201125638852.png?size=large 2x" data-title="image-20231201125638852" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>柯西不等式：$|(u,v)|\leq ||u||\space ||v||$。等式成立当且仅当$u$和$v$线性相关。
证明：
如果$u,v$线性相关，则设$u=kv,k\in F$，则$(u,v)=(kv,v)=k||v||^2$
如果$u,v$线性无关，设$z=u-\frac{(u,v)}{(v,v)}v$，则$(z,v)=(u-\frac{(u,v)}{(v,v)}v,v)=(u,v)-\frac{(u,v)}{(v,v)}(v,v)=0$，则$z$和$v$正交。转换得到$u=z+\frac{(u,v)}{(v,v)}v$，根据正交性，结合勾股定理则$||u||^2=||z||^2+|\frac{(u,v)}{(v,v)}|^2||v||^2=||z||^2+\frac{|(u,v)|^2}{(||v||^2)^2}||v||^2=||z||^2+\frac{|(u,v)|^2}{||v||^2}$
又因为$||z||^2&gt; 0$（线性无关，$||z||^2$必大于$0$），则$|(u,v|&lt;||u||\space ||v||$</p>
</li>
<li>
<p>三角不等式：$||u+v||^2\leq ||u||^2+||v||^2$
证明：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204759610.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204759610.png?size=small" data-sub-html="<h2>image-20240728204759610</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204759610.png" alt="image-20240728204759610" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204759610.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204759610.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204759610.png?size=large 2x" data-title="image-20240728204759610" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>平行四边形准则：$||u+v||^2+||u-v||^2=2(||u||^2+||v||^2)$
证明：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204810900.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204810900.png?size=small" data-sub-html="<h2>image-20240728204810900</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204810900.png" alt="image-20240728204810900" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204810900.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204810900.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728204810900.png?size=large 2x" data-title="image-20240728204810900" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ol>
</li>
</ul>
<h2 id="标准正交向量集" class="heading-element"><span>2 标准正交向量集</span>
  <a href="#%e6%a0%87%e5%87%86%e6%ad%a3%e4%ba%a4%e5%90%91%e9%87%8f%e9%9b%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>正交向量集定义</p>
<p>设$v_1,\cdots,v_n$是内积空间$V$中的非零向量，如果$V$中的任意两个向量$(v_i,v_j)=0(i\neq j)$，则$V$是一个正交向量集。</p>
</li>
<li>
<p>标准正交向量集定义</p>
<p>如果$V$是一个正交向量集，且$V$中的所有向量都是单位向量，即$(v_i,v_i)=1$，则$V$是一个标准正交向量集。</p>
</li>
<li>
<p>正交向量集性质</p>
<p>如果$v_1,\cdots,v_n$是内积空间$V$的一个正交向量集，则$v_1,\cdots,v_n$都是线性无关的。</p>
</li>
<li>
<p>正交基和标准正交基</p>
<p>在$n$维内积空间中，由$n$个正交向量组成的基称为正交基，由$n$个标准正交向量组成的基称为标准正交基。</p>
</li>
<li>
<p>标准正交基表示向量坐标</p>
<p>设$u_1,\cdots,u_n$是内积空间$V$的一个标准正交基，如果$v=\sum_{i=1}^nc_iu_i$，则$c_i=(v,u_i)$其中$c_i$为向量$v$在向量$u_i$的标量投影。</p>
</li>
<li>
<p>Parseval公式</p>
<p>设$u_1,\cdots,u_n$是内积空间$V$的一个标准正交基，如果$u=\sum_{i=1}^na_iu_i,v=\sum_{i=1}^nb_iu_i$，则$(u,v)=\sum_{i=1}^na_i\bar{b_i}$。并且，$||v||^2=\sum_{i=1}^n b_i\bar{b_i}=\sum_{i=1}^n|b_i|^2$。</p>
</li>
<li>
<p>正交投影向量定义</p>
<p>如果$S$是内积空间$V$的子空间，令$b\in V$，如果存在向量$p\in S,q$，使得$q\perp S,b=p+q$，则称$p$是$b$在子空间$S$上的正交投影向量。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201142420065.png" alt="image-20231201142420065" style="zoom: 33%;" />
<p>设$u_1,\cdots ,u_n$为$S$的标准正交基，如果$p=\sum_{i=1}^n(b,u_i)u_i$，则</p>
<ol>
<li>
<p>$b-p$与$s$的任意一个向量正交</p>
</li>
<li>
<p>$p$是$S$中唯一一个最接近$b$的向量。也就是说$\forall y\in S,y \neq p$，有$||y-b||&gt;||p-b||$。向量$p$是$b$在子空间$S$上的正交投影向量。</p>
 <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201143528483.png" alt="image-20231201143528483" style="zoom:33%;" />
</li>
</ol>
</li>
<li>
<p>投影矩阵</p>
<p>设$S$是内积空间$F^n$的非零子空间，$b\in F^n$，$u_1,\cdots,u_n$为$S$的标准正交基，$U={u_1,\cdots,u_n}$，则$b$在子空间$S$的正交投影$p=UU^Hb$，其中$U$则是投影矩阵。</p>
</li>
</ul>
<h2 id="gram-schmidt正交化方法" class="heading-element"><span>3 Gram-Schmidt正交化方法</span>
  <a href="#gram-schmidt%e6%ad%a3%e4%ba%a4%e5%8c%96%e6%96%b9%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>设$\alpha_1,\cdots,\alpha_n$是向量空间$V$的线性无关向量组。我们按照以下步骤标准正交化得到标准正交向量组$\beta_1,\cdots,\beta_n$</p>
<ol>
<li>单位化向量$\alpha_1$，得到$\beta_1=\frac{\alpha_1}{||\alpha_1||}$。易知$span(\alpha_1)=span(\beta_1)$。</li>
<li>找到$\alpha_2$在$span(\beta_1)$上的向量投影$p_1=(\alpha_2,\beta_1)\beta_1$，根据推导可知$\alpha_2-p_1$和$span(\beta_1)$正交。我们对其单位化得到$\beta_2=\frac{\alpha_2-p_1}{||\alpha_2-p_1||}$。易得$span(\alpha_1,\alpha_2)=span(\beta_1,\beta_2)$。</li>
<li>找到$\alpha_3$在$span(\beta_1,\beta_2)$上的向量投影$p_2=(\alpha_3,\beta_1)\beta_1+(\alpha_3,\beta_2)\beta_2$，根据推导可知$\alpha_3-p_2$和$span(\beta_1,\beta_2)$正交。我们对其单位化得到$\beta_3=\frac{\alpha_3-p_2}{||\alpha_3-p_2||}$。易得$span(\alpha_1,\alpha_2,\alpha_3)=span(\beta_1,\beta_2,\beta_3)$。</li>
<li>如上进行操作，$\alpha_i$在$S_{i-1}=span(\alpha_1,\cdots,\alpha_i)=span(\beta_1,\cdots,\beta_i)$的向量投影$p_{i-1}=(\alpha_i,\beta_1)\beta_1+\cdots+(\alpha_i,\beta_{i-1})\beta_{i-1}$，则$\alpha_i-p_{i-1}$和$S_{i-1}$正交。所以对其单位化得到$\beta_i=\frac{\alpha_i-p_{i-1}}{||\alpha_i-p_{i-1}||}$。易得$span(\alpha_1,\cdots,\alpha_{i})=span(\beta_1,\cdots,\beta_{i})$。</li>
<li>直到求得$\beta_n$，得到标准正交向量组$\beta_1,\cdots,\beta_n$</li>
</ol>
<h2 id="正交子空间" class="heading-element"><span>4 正交子空间</span>
  <a href="#%e6%ad%a3%e4%ba%a4%e5%ad%90%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>正交子空间定义</p>
<p>$X,Y$是内积空间$V$的子空间，如果$\forall x\in X,y\in Y$，$(x,y)=0$，则$X$和$Y$正交，我们记作$X\perp Y$。</p>
</li>
<li>
<p>正交补定义</p>
<p>设$Y$是内积空间$V$的子空间，则$V$中与$Y$的每个向量正交的所有向量称为$Y^{\perp}$，$Y^\perp ={x\in V|\forall y\in Y,(x,y)=0 }$。</p>
</li>
<li>
<p>正交子空间定理</p>
<p>如果$V_1$和$V_2$正交，则$V_1+V_2$的和为直和。</p>
</li>
<li>
<p>正交补性质</p>
<p>设$S$为有限维内积空间$V$的子空间，则：</p>
<ol>
<li>$V=S\oplus S^\perp$。并且如果$V=S\oplus W,W\perp S$，则$W=S^\perp$。</li>
<li>$(S^{\perp})^{\perp}=S$</li>
</ol>
</li>
<li>
<p>向量到子空间的最小距离</p>
<p>设$S$为有限维内积空间$V$的子空间，$\forall b\in V$，则$S$ 中的给定向量 $p$ 与给定向量$b$ 最接近，当且仅当$b-p\perp S^{\perp}$。即$p$是$b$在$S$上的向量投影。</p>
</li>
<li>
<p>矩阵的基本子空间</p>
<p>设$A$为$m\times n$矩阵，则</p>
<p>$N(A)={x\in F^n|Ax=0}$：$A$的零空间，$F^n$的子空间。</p>
<p>$R(A)={Ax|x\in F^n}$：$A$的列空间，$F^m$的子空间。</p>
<p>$N(A^H)$：$A^H$的零空间，$F^m$的子空间。</p>
<p>$R(A^H)$：$A^H$的列空间，$F^n$的子空间。</p>
<p><font color="red">$N(A)=R(A^H)^\perp,N(A^h)=R(A)^\perp$</font></p>
<p><font color="red">$F^n=N(A)\oplus N(A)^\perp=N(A)\oplus R(A^H)$</font></p>
<p><font color="red">$\dim(F^n)=\dim(N(A))+\dim(R(A^H))$</font></p>
</li>
</ul>
<h2 id="最小二乘问题" class="heading-element"><span>5 最小二乘问题</span>
  <a href="#%e6%9c%80%e5%b0%8f%e4%ba%8c%e4%b9%98%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>问题定义</p>
<p>设线性系统$Ax=b$，其中$A\in F^{m\times n}$，可能不相容（无解）。我们能否找到一个最佳解，即向量$\hat{x}$使得$A\hat{x}-b=\min_{x\in F^n}||Ax-b||$</p>
</li>
<li>
<p>问题核心</p>
<p>找到向量$\hat{x}$即是使得$A\hat{x}$等于$b$在$R(A)$上的向量投影。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231201154345326.png" alt="image-20231201154345326" style="zoom: 33%;" />
</li>
<li>
<p>最小二乘解等价条件</p>
<ol>
<li>$\hat{x}$是$Ax=b$的最小二乘解</li>
<li>$A\hat{x}-b=\min_{x\in F^n}||Ax-b||$</li>
<li>$A\hat{x}$等于$b$在$R(A)$上的正交向量投影</li>
<li>$A\hat{x}-b\in R(A)^\perp =N(A^H)$</li>
<li>$A^H(A\hat{x}-b)=0$</li>
<li><font color="red">$A^HA\hat{x}=A^Hb$（正规方程）</font></li>
</ol>
</li>
<li>
<p>正规方程的相容性</p>
<p>设$A\in F^{m\times n}$，则正规方程$A^HAx=A^Hb$有解，其为$Ax=b$的最小二乘解。</p>
<p><font color="red">最小二乘解不唯一，但是对于任意解$x,y$，$Ax=Ay$，且$Ax$和$Ay$都是$b$在$R(A)$上的向量投影。</font></p>
</li>
<li>
<p>最小二乘解唯一解</p>
<p>设$A\in F^{m\times n}$，且$rank(A)=n$（列满秩），$b\in F^n$，则正规方程$A^HAx=A^Hb$有唯一解$\hat{x}=(A^HA)^{-1}A^Hb$。$\hat{x}$为$Ax-b$的唯一最小二乘解。</p>
</li>
</ul>
<h2 id="正交矩阵和酉矩阵" class="heading-element"><span>6 正交矩阵和酉矩阵</span>
  <a href="#%e6%ad%a3%e4%ba%a4%e7%9f%a9%e9%98%b5%e5%92%8c%e9%85%89%e7%9f%a9%e9%98%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>正交矩阵定义</p>
<p>设$A\in R^{n\times n}$，$A$的所有列向量构成$R^n$的标准正交集，具有$R^n$上的标准内积。</p>
</li>
<li>
<p>酉矩阵定义</p>
<p>设$A\in C^{n\times n}$，$A$的所有列向量构成$C^n$的标准正交集，具有$C^n$上的标准内积。</p>
<p>易知，正交矩阵也是酉矩阵。</p>
</li>
<li>
<p>正交矩阵和酉矩阵的充要条件</p>
<p>$A$是正交矩阵当且仅当$A^TA=I$</p>
<p>$A$是酉矩阵当且仅当$A^HA=I$</p>
</li>
<li>
<p>若$A\in C^{n\times n}$，则以下条件等价</p>
<ol>
<li>$A$是酉矩阵</li>
<li>$A$的列向量构成$C^n$的标准正交集</li>
<li>$A^HA=I$</li>
<li>$A^{-1}=A^H$</li>
<li>$\forall x,y \in C^n,(Ax,Ay)=(x,y)$</li>
<li>$\forall x\in C^n,(Ax,Ax)=(x,x)$</li>
</ol>
</li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 3—线性映射和线性变换知识点总结复习</title><link>https://hezephyr.github.io/posts/03.%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%92%8C%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%92%8C%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/</guid><description><![CDATA[<h2 id="线性映射及其矩阵表示" class="heading-element"><span>1 线性映射及其矩阵表示</span>
  <a href="#%e7%ba%bf%e6%80%a7%e6%98%a0%e5%b0%84%e5%8f%8a%e5%85%b6%e7%9f%a9%e9%98%b5%e8%a1%a8%e7%a4%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>映射定义</p>
<p>设$A,B$是两个集合，如果存在一个规则$f$，使得对于$A$中的元素$x$都有$B$中唯一的元素$y$与之对应，则称$f$是从$A$到$B$的映射，记作：$f:A\rightarrow B$。在映射$f:A\rightarrow B$中，$A$的元素$x$被映射到$B$的元素$y$，我们通常写作$f(x)=y$，</p>
<p>如果$\forall x_1,x_2\in A,x_1\neq x_2,f(x_1)\neq f(x_2)$，则称映射$f:A\rightarrow B$是<strong>单射</strong>的；</p>
<p>如果$\forall y\in B,\exist x\in A,f(x)=y$，则称映射$f:A\rightarrow B$是<strong>满射</strong>的；</p>
<p>如果映射$f:A\rightarrow B$既满足单射又满足满射，则称映射$f:A\rightarrow B$是<strong>双射</strong>的。</p>
</li>
<li>
<p>线性映射定义</p>
<p>设$V,W$是在数域$F$上的向量空间，如果$\forall v_1,v_2\in V,\forall \alpha_1,\alpha_2\in F$有$\sigma(\alpha_1v_1+\alpha_2v_2)=\alpha_1\sigma(v_1)+\alpha_2\sigma(v_2)$，则从$V$到$W$的映射$\sigma$称为线性映射。</p>
</li>
<li>
<p>线性映射定理</p>
<p>设$\sigma,\gamma$是线性空间$V$到$W$的线性映射，则：</p>
<ol>
<li>
<p>$\sigma(0)=0$</p>
</li>
<li>
<p>$\forall x\in V_1,\sigma(-x)=-\sigma(x)$</p>
</li>
<li>
<p>如果$x_1,\cdots,x_n$是$V_1$的一组向量，$k_1,\cdots,k_n\in F$，则有</p>
<p>$\sigma(k_1x_1+\cdots+k_nx_n)=k_1\sigma(x_1)+\cdots+k_n\sigma(x_n)$</p>
</li>
<li>
<p>如果$x_1,\cdots,x_n$是$V_1$的一组线性相关向量，则$\sigma(x_1),\cdots,\sigma(x_n)$是$V_2$中的一组线性相关向量；并且当且仅当$\sigma$是一一映射时，$V_1$中的线性无关向量组的像（<font color="red">像即是线性映射的值域</font>）是$V_2$中的线性无关向量组。</p>
</li>
<li>
<p>如果$v_1,\cdots,v_n$是$V$的一组基，且$\sigma(v_i)=\gamma(v_i)(1\leq i\leq n)$，则$\sigma=\gamma$。<font color="red">说明线性映射由基像组唯一确定。</font></p>
</li>
</ol>
</li>
<li>
<p>线性映射运算</p>
<p>设$V_1$到$V_2$的所有线性映射组成的集合记为$\varphi(V_1,V_2)$，类似地，$\varphi(V_1,V_3),\varphi(V_2,V_3)$分别表示$V_1$到$V_3$的所有线性映射组成的集合和$V_2$到$V_3$的所有线性映射组成的集合</p>
<p>设$\sigma,\gamma \in \varphi(V_1,V_2)$，定义它们的和$\sigma+\gamma$为$(\sigma+\gamma)(x)=\sigma(x)+\gamma(x),\forall x\in V_1$。</p>
<ol>
<li>$\sigma,\gamma \in \varphi(V_1,V_2)$，则$\sigma+\gamma \in \varphi(V_1,V_2)$</li>
<li>$\sigma\in \varphi(V_1,V_2),\gamma \in \varphi(V_2,V_3)$，则$\sigma \gamma \in \varphi(V_1,V_2)$</li>
</ol>
<p>线性映射的加法适合交换律和结合律，乘法适合结合律，标量乘法适合结合律，分配律。</p>
</li>
<li>
<p>重要定理</p>
<p>设$\sigma \in \varphi(V_1,V_2)$，如果$\sigma$是可逆映射，则$\sigma^{-1}\in \varphi(V_2,V_1)$。</p>
</li>
<li>
<p>线性映射的矩阵表示</p>
<p>设$\sigma:U\rightarrow V$是一个线性映射，$[u_1,\cdots,u_n]$是$U$的一组基，$\sigma$完全由$\sigma(u_1),\cdots,\sigma(u_n)$确定，如果$u=x_1u_1+\cdots,x_nu_n$，则$\sigma(u)=x_1\sigma(u_1)+\cdots+x_n\sigma(u_n)$。</p>
<p>设$v_1,\cdots,v_m$是$V$的一组基，则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210304150.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210304150.png?size=small" data-sub-html="<h2>image-20240728210304150</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210304150.png" alt="image-20240728210304150" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210304150.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210304150.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210304150.png?size=large 2x" data-title="image-20240728210304150" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
故$[\sigma(u_1),\cdots,\sigma(u_n)]=[v_1,\cdots,v_m]A$，其中<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png" alt="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png?size=large 2x" data-title="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>。
矩阵$A$称为线性映射$\sigma$在$U$的基$[u_1,\cdots,u_n]$和$V$的基$[v_1,\cdots,v_n]$下的表示矩阵。</p>
</li>
<li>
<p>重要定理</p>
<p>设设$\sigma$为数域$F$上线性空间$U$到$V$的线性映射，其中$u_1,\cdots,u_n$是$U$的一组基，$v_1,\cdots,v_m$是$V$的一组基，$\sigma$在这对基下的矩阵是$A$，$\forall \alpha =\sum_{i=1}^nx_iu_i$，有$\sigma(\alpha)=\sum_{i=1}^my_iv_i$，则$[y_i,\cdots,y_m]^T=A[x_1,\cdots,x_n]$。</p>
</li>
<li>
<p>线性映射在不同基下的矩阵之间的关系</p>
<p><font color="red">同一个线性映射在不同基下的矩阵一般是不同的</font></p>
<p>设$\sigma$为数域$F$上$n$维线性空间$U$到$n$维线性空间$V$的线性映射，其中$u_1,\cdots,u_n$和$u_1&rsquo;,\cdots,u&rsquo;_n$是$U$的两组基，由$u_1,\cdots,u_n$到$u_1&rsquo;,\cdots,u&rsquo;_n$的过渡矩阵是$Q$，$v_1,\cdots,v_m$和$v_1&rsquo;,\cdots,v_m&rsquo;$是$V$的两组基，由$v_1,\cdots,v_m$到$v_1&rsquo;,\cdots,v_m&rsquo;$的过渡矩阵是$P$，$\sigma$在基$u_1,\cdots,u_n$与基$v_1,\cdots,v_m$下的矩阵是$A$，而在基$u_1&rsquo;,\cdots,u&rsquo;_n$与基$v_1&rsquo;,\cdots,v_m&rsquo;$的矩阵为$B$，则$B=P^{-1}AQ$。</p>
<p>推导：</p>
<p>因为：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210330175.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210330175.png?size=small" data-sub-html="<h2>image-20240728210330175</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210330175.png" alt="image-20240728210330175" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210330175.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210330175.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210330175.png?size=large 2x" data-title="image-20240728210330175" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
则把式子代入得到：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210404961.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210404961.png?size=small" data-sub-html="<h2>image-20240728210404961</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210404961.png" alt="image-20240728210404961" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210404961.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210404961.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728210404961.png?size=large 2x" data-title="image-20240728210404961" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
因为线性映射$\sigma$的矩阵由基唯一确定，所以$B=P^{-1}AQ$。</p>
</li>
<li>
<p>相抵</p>
<p>设$A,B\in F^{m\times n}$，如果存在数域$F$上的$m$阶非奇异矩阵$P$和$n$阶非奇异矩阵$Q$使得$B=PAQ$，则称$A$与$B$相抵（等价）。</p>
<p><font color="red">如果$A$与$B$相抵，则它们可作为$n$维线性空间$U$到$m$维线性空间$V$的同一线性映射在两对基所对应的矩阵。</font></p>
<p>相抵的充分必要条件是它们有相同的秩。</p>
</li>
</ul>
<h2 id="线性映射的值域像和核" class="heading-element"><span>2 线性映射的值域（像）和核</span>
  <a href="#%e7%ba%bf%e6%80%a7%e6%98%a0%e5%b0%84%e7%9a%84%e5%80%bc%e5%9f%9f%e5%83%8f%e5%92%8c%e6%a0%b8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>值域（像）和核的定义</p>
<p>设$\sigma$为数域$F$上线性空间$U$到$V$的线性映射，令$R(\sigma)=I_m(\sigma)={\sigma(x)| x\in U}$，$Ker(\sigma)=N(\sigma)={x\in U|\sigma(x)=0}$。</p>
<p>称$R(\sigma)$是线性映射$\sigma$的值域（也称像），$Ker(\sigma)$是线性映射$\sigma$的核。</p>
<p>易知$R(\sigma)$是$V$的一个子空间，$Ker(\sigma)$是$U$的一个子空间。</p>
</li>
<li>
<p>值域（像）和核理解</p>
<p>值域（像）是映射所能到的空间，它包含了所有在映射过程中真实映射到的点，描述了映射的覆盖范围。值域（像）是目标空间 $W$的一个子空间。</p>
<p>核是映射的零空间，它包含了所有被映射到零的输入向量，描述了映射的非单射性，即存在映射到同一个元素的不同输入。核是定义在$V$上的一个子空间。</p>
</li>
<li>
<p>定理</p>
<p>设$\sigma$为数域$F$上$n$维线性空间$U$到$n$维线性空间$V$的线性映射，其中$u_1,\cdots,u_n$是$U$的一组基，$v_1,\cdots,v_m$是$V$的一组基，$\sigma$在这对基下的矩阵是$A$，则</p>
<ol>
<li>$R(\sigma)=span(\sigma(u_1),\cdots,\sigma(u_n))$</li>
<li>$rank(\sigma)=rank(A)$</li>
<li>$dim(R(\sigma))+dim(Ker(\sigma))=n$</li>
</ol>
</li>
<li>
<p>一般求法</p>
<p>$R(\sigma)=R[x])_3$</p>
<p>$Ker(\sigma)={0}$</p>
</li>
</ul>
<h2 id="线性变换" class="heading-element"><span>3 线性变换</span>
  <a href="#%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$V$是数域$F$上的线性空间，$V$到自身的线性映射称为$V$上的线性变换。</p>
</li>
<li>
<p>$n$维线性空间$V$上的线性变换与矩阵之间的关系</p>
<p>设$\sigma$是在$V$上的线性变换，$v_1,\cdots,v_n$是一组基，则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213739259.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213739259.png?size=small" data-sub-html="<h2>image-20240728213739259</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213739259.png" alt="image-20240728213739259" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213739259.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213739259.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213739259.png?size=large 2x" data-title="image-20240728213739259" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
故$[\sigma(v_1),\cdots,\sigma(v_n)]=[v_1,\cdots,v_m]A$，其中。矩阵$A$称为线性变换$\sigma$在$U$的基$[v_1,\cdots,v_n]$下的表示矩阵。</p>
</li>
<li>
<p>重要定理</p>
<p>设$n$维线性空间$V$上线性变换$\sigma$在基$v_1,\cdots,v_n$和$v_1&rsquo;,\cdots,v_n&rsquo;$下的矩阵分别为$A$和$B$，由基$v_1,\cdots,v_n$到基$v_1&rsquo;,\cdots,v_n&rsquo;$的过渡矩阵为$P$，则$B=P^{-1}AP$</p>
<p>推导：</p>
<p>因为
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213814264.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213814264.png?size=small" data-sub-html="<h2>image-20240728213814264</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213814264.png" alt="image-20240728213814264" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213814264.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213814264.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213814264.png?size=large 2x" data-title="image-20240728213814264" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
则代入得到
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213934744.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213934744.png?size=small" data-sub-html="<h2>image-20240728213934744</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213934744.png" alt="image-20240728213934744" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213934744.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213934744.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728213934744.png?size=large 2x" data-title="image-20240728213934744" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>所以$AP=PB$，左乘$P^{-1}$，得$B=P^{-1}AP$。</p>
</li>
<li>
<p>相似</p>
<p>设$A,B\in F^{m\times n}$，如果存在可逆矩阵$P\in F^{n\times n}$使得$B=P^{-1}AB$，则称$A$与$B$相似。</p>
</li>
</ul>
<h2 id="酉变换和正交变换" class="heading-element"><span>4 酉变换和正交变换</span>
  <a href="#%e9%85%89%e5%8f%98%e6%8d%a2%e5%92%8c%e6%ad%a3%e4%ba%a4%e5%8f%98%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$V$是$n$维酉（欧式）空间（一个在复数（实数）域上的内积空间），$\sigma:V\rightarrow V$是线性变换，如果
$$
\forall x\in V,||\sigma(x)||=||x||
$$
$\sigma$就称为酉（正交）变换</p>
</li>
<li>
<p>定理</p>
<ol>
<li>设$V$是$n$维酉（欧式）空间（一个在复数（实数）域上的内积空间），如果$\sigma:V\rightarrow V$是酉（正交）变换，则
$$
\forall x,y\in V,(\sigma(x),\sigma(y))&gt;=(x,y)
$$</li>
</ol>
</li>
</ul>
<ol start="2">
<li>
<p><font color="red">即酉（正交变换）保持向量的内积。</font></p>
</li>
<li>
<p>如果$v_1,\cdots,v_n$是$V$的一组标准正交基，则$\sigma(v_1),\cdots,\sigma(v_n)$也是$V$的一组标准正交基。</p>
</li>
<li>
<p>$\sigma$在$V$的任意一组标准正交基下的矩阵是酉（正交）矩阵。</p>
</li>
<li>
<p>设$v=[v_1,\cdots,v_n]$是酉（欧式）空间$V$的一组标准正交基，$A$维$\sigma: V\rightarrow V$在基$v$的表示矩阵为$A$，则$\sigma$是一个酉（正交）变换当且仅当$A^HA=I(A^T=I)$。</p>
<p>即，$A$的列向量组成了$C^{n}(R^n)$的标准正交基。</p>
</li>
</ol>
<h2 id="同态和同构" class="heading-element"><span>5 同态和同构</span>
  <a href="#%e5%90%8c%e6%80%81%e5%92%8c%e5%90%8c%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$V$和$W$是在相同数域$F$上的两个向量空间，$\sigma:V\rightarrow W$是线性变换（也称为同态）。如果$\sigma$是一一对应的，则称为同构。</p>
<p>如果存在从$V$到$W$的同构，则称$V$与$W$同构。</p>
<p><font color="red">对于同构$\sigma:  V\rightarrow W,ker(\sigma)={0} \space and \space \sigma(V)=W$。</font></p>
</li>
<li>
<p>定理</p>
<ol>
<li>设$V$和$W$是在相同数域$F$上的两个向量空间，$\sigma$是从$V$到$W$的同构，$S$为$V$的子空间，则$\dim(S)=\dim(\sigma(S))$。<font color="red">即，两个同构空间有相同的维数（充要条件）。</font></li>
<li>设$\sigma$是从$V$到$W$的同构，则$\sigma^{-1}$是从$W$到$V$的同构</li>
<li>数域 $F$ 上任意一个 $n$维 向量空间$V$同构于向量空间 $F^n$。</li>
</ol>
</li>
<li>
<p>性质</p>
<p>同构具有如下性质：</p>
<ol>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
</ol>
</li>
</ul>
<h2 id="不变子空间" class="heading-element"><span>6 不变子空间</span>
  <a href="#%e4%b8%8d%e5%8f%98%e5%ad%90%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$\sigma:V\rightarrow V$是线性变换，如果$V$的子空间$S$满足$\forall x\in S, \sigma(x)\in S$，即$\sigma(x)\subset S$，则称$S$是一个不变子空间。</p>
<p><font color="red">当说到不变子空间时，要指明是在什么映射下是不变的。</font>利用$\sigma$-不变子空间，我们可以简化$\sigma$的表示矩阵。</p>
</li>
<li>
<p>矩阵的不变子空间</p>
<p>设$A\in F^{n\times n}$，$\sigma_A:F^n\rightarrow F^n$被定义为：$\sigma_A(x)=Ax$，$F^n$的子空间$S$如果满足$\forall x\in S, Ax\in S$，则称$S$是$\sigma $-不变子空间。</p>
</li>
<li>
<p>定理</p>
<ol>
<li>设$\sigma:V\rightarrow V$是线性变换，则两个$\sigma$-不变子空间的交、和、直和也是$\sigma$-不变子空间。</li>
<li>设$\sigma$是在向量空间$V$上的线性变换，$W=span{x_1,\cdots,x_k}$是$V$的$\sigma$-不变子空间当且仅当$\sigma(x_i)\in W(i=1,2,\cdots,k)$。</li>
<li>设$\sigma$是数域$F$上$n$维向量空间$V$上的线性变换，则$\sigma$可以对角化的充要条件是$V$可以分解成$\sigma$的<font color="red">一维</font>不变子空间的直和。</li>
<li>设$\sigma$是数域$F$上$n$维向量空间$V$上的线性变换，则$\sigma$在$V$的一组基下的矩阵为形如<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214118238.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214118238.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214118238.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214118238.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214118238.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214118238.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
的块上三角矩阵的充要条件是$\sigma$的非平凡的不变子空间。</li>
<li>设$\sigma$是数域$F$上$n$维向量空间$V$上的线性变换，则$\sigma$在$V$的一组基下的矩阵为块对角巨好着呢的充要条件是$V$可以分解成$\sigma$的<font color="red">若干个非平凡不变子空间</font>的直和。</li>
</ol>
</li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 4—特征值和特征向量知识点总结复习</title><link>https://hezephyr.github.io/posts/04.%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</guid><description><![CDATA[<h2 id="特征值和特征向量" class="heading-element"><span>1 特征值和特征向量</span>
  <a href="#%e7%89%b9%e5%be%81%e5%80%bc%e5%92%8c%e7%89%b9%e5%be%81%e5%90%91%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$\sigma$为数域$F$上线性空间$V$上的一个线性变换，一个非零向量$v\in V$，如果存在一个$\lambda \in F$使得$\sigma(v)=\lambda v$，则$\lambda$称为$\sigma$的<font color="red">特征值</font>。$\sigma$的特征值的集合称为$\sigma$的<font color="red">谱</font>。并称$v$为$\sigma$的属于（或对应于）特征值$\lambda $的特征向量。</p>
</li>
<li>
<p>特征值和特征向量的求法</p>
<p>设$V$是数域$F$上的$n$维线性空间，$v_1,\cdots,v_n$是$V$的一组基，线性变换$\sigma$在这组基下的矩阵为$A$，如果$\lambda$是$\sigma$的特征值，$\alpha$是相应的特征向量。则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214456334.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214456334.png?size=small" data-sub-html="<h2>image-20240728214456334</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214456334.png" alt="image-20240728214456334" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214456334.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214456334.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214456334.png?size=large 2x" data-title="image-20240728214456334" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
将上式代入$\sigma(v)=\lambda v$得到
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214504280.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214504280.png?size=small" data-sub-html="<h2>image-20240728214504280</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214504280.png" alt="image-20240728214504280" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214504280.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214504280.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214504280.png?size=large 2x" data-title="image-20240728214504280" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
由于$v_1,\cdots,v_n$线性无关，所以
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214513307.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214513307.png?size=small" data-sub-html="<h2>image-20240728214513307</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214513307.png" alt="image-20240728214513307" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214513307.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214513307.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214513307.png?size=large 2x" data-title="image-20240728214513307" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
则说明特征向量$\alpha$的坐标<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214617384.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214617384.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214617384.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214617384.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214617384.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728214617384.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>满足齐次线性方程组$(\lambda I-A)x=0$。</p>
<p>因为$\alpha\neq 0$，则$x\neq 0$，即齐次线性方程组$(\lambda I-A)x=0$有非零解。有非零解的充要条件是它的系数矩阵它的系数矩阵行列式$|\lambda I-A|=0$。</p>
</li>
<li>
<p>相关定义</p>
<p>设$A$是数域$F$上的$n$阶矩阵，$\lambda$是一个符号，也是未知的<strong>特征值</strong>，矩阵$\lambda I-A$称为$A$的<strong>特征矩阵</strong>，其行列式$|\lambda I-A|$称为$A$的<strong>特征多项式</strong>。方程$|\lambda I-A|=0$称为$A$的特征方程，它的根（即$\lambda$的值）称为$A$的特征根（或特征值）。以$A$的特征值$\lambda$代入$Ax=\lambda x$中所得到的非零解$x$称为$A$对应于$\lambda$的<strong>特征向量</strong>。</p>
</li>
<li>
<p>定理</p>
<p>设$A$为$n\times n$矩阵，$\lambda$是一个数值，以下命题等价：</p>
<ol>
<li>$\lambda$是$A$的特征值</li>
<li>$(\lambda I-A)x=0$有一个非平凡的解（即有非零向量的解）</li>
<li>$N(\lambda I-A)\neq{0}$</li>
<li>$\lambda I-A$矩阵是奇异矩阵</li>
<li>$\det(\lambda I-A)=0$</li>
</ol>
</li>
<li>
<p>特征多项式的系数</p>
<p>如果
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214711778.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214711778.png?size=small" data-sub-html="<h2>image-20240728214711778</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214711778.png" alt="image-20240728214711778" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214711778.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214711778.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214711778.png?size=large 2x" data-title="image-20240728214711778" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
则$c_k(1\leq k\leq n)$是所有$k$阶主子式（选择$k$行$k$列形成的行列式）的和，特别的，$c_1=\text{tr}(A),c_n=\text{det}(A)$。</p>
</li>
<li>
<p>定理</p>
<ol>
<li>
<p>设$A\in C^{n\times n}$，如果$A$有特征值$\lambda_1,\cdots,\lambda_n$，则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214759252.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214759252.png?size=small" data-sub-html="<h2>image-20240728214759252</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214759252.png" alt="image-20240728214759252" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214759252.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214759252.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728214759252.png?size=large 2x" data-title="image-20240728214759252" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>如果$A$相似$B$，则两个矩阵有相同的特征值和特征多项式。</p>
</li>
<li>
<p>设$A\in C^{m\times n}$，则$A^HA$和$AA^H$特征值都是非负实数，<font color="red">且它们都有相同的非零特征值和相同的重数，并且非零特征值（包含重数）的数量等于$\text{rank}(A)$。</font></p>
</li>
</ol>
</li>
</ul>
<h2 id="对角化" class="heading-element"><span>2 对角化</span>
  <a href="#%e5%af%b9%e8%a7%92%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设矩阵$A\in F^{n\times n}$，如果存在一个非奇异矩阵$P\in F^{n\times n}$和一个对角矩阵$D\in F^{n\times n}$，使得$P^{-1}AP=D$，则称$A$可被对角化。</p>
</li>
<li>
<p>定理</p>
<ol>
<li>$A$可以被对角化当且仅当$A$有$n$个线性无关的特征向量</li>
<li>$\lambda_1,\cdots,\lambda_k$是$A$的不同的特征值，则对应的特征向量$x_1,\cdots,x_k$它们是线性无关的</li>
<li>由以上两条定理即可推出如果$A$有$n$个不同的特征值，则$A$可被对角化</li>
<li>不同特征值对应的特征向量的集合的并集是线性无关的。即取每个特征值的所有特征向量，无论这些向量属于哪个特征值，它们的并集都是线性无关的。</li>
</ol>
</li>
<li>
<p>代数重数</p>
<p>设$A\in F^{n\times n}$，如果$\det(\lambda I-A)=(\lambda -\lambda_i)^{r_1}\cdots(\lambda-\lambda_k)^{r_k}$，其中$\lambda_1,\cdots,\lambda_k$是$A$的特征值，它们是不同的。则特征值$\lambda_i$的代数重数是$r_i$，即特征值$\lambda_i$出现的次数。</p>
</li>
<li>
<p>几何重数</p>
<p>与特征值$\lambda_i$对应的特征子空间是$N(\lambda_i I-A)$，则特征值$\lambda_i$的几何重数为$\dim(N(\lambda_i I-A))$。</p>
<p><font color="red">几何重数$\leq $代数重数</font></p>
</li>
<li>
<p>几何重数看可对角化</p>
<p>矩阵$A\in F^{n\times n}$可对角化当且仅当$A$中不同特征值的几何重数和等于$n$（即每个特征值的代数重数都要等于几何重数）</p>
</li>
</ul>
<h2 id="schur定理和正规矩阵" class="heading-element"><span>3 Schur定理和正规矩阵</span>
  <a href="#schur%e5%ae%9a%e7%90%86%e5%92%8c%e6%ad%a3%e8%a7%84%e7%9f%a9%e9%98%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>酉（正交）相似定义</p>
<p>设$A\in C^{n\times n}(R^{n\times n})$，如果存在一个酉（正交）矩阵$U$使得$U^HAU=B\space\space\space(U^H=U^{-1})$，则可称$A$酉（正交）相似$B$</p>
</li>
<li>
<p>Schur定理</p>
<p>$\forall A\in C^{n\times n}$，$A$都与上三角矩阵相似，且存在酉矩阵$U$和上三角矩阵$T$使得$U^HAU=U^{-1}AU=T$。</p>
<p><font color="red">仅适用于复数域，实数域上不一定适用</font></p>
</li>
<li>
<p>正规矩阵定义</p>
<p>设$A\in C^{n\times n}$，如果$A$满足$A^HA=AA^H$，则称$A$是正规矩阵。</p>
<p><font color="red">Hermite矩阵，酉（正交）矩阵都是正规矩阵</font></p>
</li>
<li>
<p>谱定理</p>
<p>设$A\in C^{n\times n}$，如果$A$是Hermite矩阵，则$A$酉相似于一个实对角矩阵，换句话说，<font color="red">Hermite矩阵的特征值都是实数。</font></p>
</li>
<li>
<p>引理</p>
<p>设$A\in C^{n\times n}$，$A$是正规矩阵当且仅当$\forall \lambda,x$使得$||Ax-\lambda x||=||A^Hx-\bar{\lambda}x||$。</p>
</li>
<li>
<p>同时对角化</p>
<p>设$A,B$都是相同阶数的正规矩阵，则存在一个酉矩阵可以同时酉对角化$A,B$当且仅当$AB=BA$</p>
</li>
</ul>
<h2 id="python求解" class="heading-element"><span>4 Python求解</span>
  <a href="#python%e6%b1%82%e8%a7%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Matrix</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义符号变量</span>
</span></span><span class="line"><span class="cl"><span class="n">lambda_</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;lambda&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 求特征矩阵</span>
</span></span><span class="line"><span class="cl"><span class="n">characteristic_matrix</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">lambda_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;关于 lambda 的特征矩阵:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">characteristic_matrix</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算特征多项式</span>
</span></span><span class="line"><span class="cl"><span class="n">characteristic_polynomial</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="n">lambda_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;关于 lambda 的特征多项式:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">characteristic_polynomial</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 求特征值</span>
</span></span><span class="line"><span class="cl"><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 打印特征值、其代数重数、特征向量和几何重数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;特征值 </span><span class="si">%s</span><span class="s2"> 的代数重数为 </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;特征值 </span><span class="si">%s</span><span class="s2"> 的几何重数为 </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()[</span><span class="nb">list</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)][</span><span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;特征值 </span><span class="si">%s</span><span class="s2"> 的特征向量为 </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()[</span><span class="nb">list</span><span class="p">(</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)][</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># 判断A是否可对角化，如果可以，打印出对角化矩阵</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">is_diagonalizable</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;A可对角化&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;对角化矩阵为:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">diagonalize</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 求A的行空间、列空间、零空间</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;A的行空间为:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rowspace</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;A的列空间为:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">columnspace</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;A的零空间为:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">nullspace</span><span class="p">())</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>【矩阵论】Chapter 5—lambda矩阵与Jordan 标准型</title><link>https://hezephyr.github.io/posts/05.lambda%E7%9F%A9%E9%98%B5%E4%B8%8Ejordan%E6%A0%87%E5%87%86%E5%9E%8B/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/05.lambda%E7%9F%A9%E9%98%B5%E4%B8%8Ejordan%E6%A0%87%E5%87%86%E5%9E%8B/</guid><description><![CDATA[<h1 id="lambda矩阵与jordan-标准型" class="heading-element"><span>$\lambda$矩阵与Jordan 标准型</span>
  <a href="#lambda%e7%9f%a9%e9%98%b5%e4%b8%8ejordan-%e6%a0%87%e5%87%86%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><h2 id="lambda-矩阵关键概念" class="heading-element"><span>1 $\lambda $矩阵关键概念</span>
  <a href="#lambda-%e7%9f%a9%e9%98%b5%e5%85%b3%e9%94%ae%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>$\lambda$矩阵定义</p>
<p>设$a_{ij}(\lambda)(1\leq i \leq m,1\leq j \leq n)$是数域$P$上的多项式，以$a_{ij}(\lambda)$为元素的$m\times n$矩阵
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png" alt="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png?size=large 2x" data-title="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215156702.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
成为多项式矩阵或$\lambda$矩阵，多项式$a_{ij}(\lambda)(1\leq i \leq m,1\leq j \leq n)$中的最高次数成为$A(\lambda)$的次数，则数字矩阵显然是$\lambda$矩阵，为$0$次；数字矩阵$A$的特征矩阵$\lambda I-A$就是$1$次$\lambda$矩阵。</p>
<p>设$A(\lambda)$矩阵的次数为$k$，则$A(\lambda)$可表示为
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215410590.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215410590.png?size=small" data-sub-html="<h2>image-20240728215410590</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215410590.png" alt="image-20240728215410590" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215410590.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215410590.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215410590.png?size=large 2x" data-title="image-20240728215410590" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$A_i(0\leq i \leq k)$是数字矩阵，并且$A_k\neq 0$。</p>
</li>
<li>
<p>$\lambda$矩阵性质</p>
<ol>
<li><font color="red">$\lambda$矩阵也可以进行初等变换</font></li>
<li>若$A(\lambda)$可以经过有限次初等变换化为$B(\lambda)$，则称$\lambda$矩阵$A(\lambda)$和$B(\lambda)$相抵，记为$A(\lambda)\cong B(\lambda)$</li>
</ol>
</li>
<li>
<p>$\lambda$矩阵定理</p>
<p>设$A(\lambda)=(a_{ij}(\lambda))\in P[\lambda]^{m\times n}$，且$rank(A(\lambda))=r$，则$A(\lambda)$相似于如下的对角矩阵
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215421201.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215421201.png?size=small" data-sub-html="<h2>image-20240728215421201</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215421201.png" alt="image-20240728215421201" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215421201.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215421201.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215421201.png?size=large 2x" data-title="image-20240728215421201" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$d_i(\lambda)(1\leq i \leq r)$是首项系数为$1$的多项式，并且$d_i(\lambda)|d_{i+1}(\lambda)(1\leq i \leq r-1)$</p>
</li>
<li>
<p>$Smith$标准型</p>
<p>$\lambda$矩阵定理中的对角矩阵就称为$\lambda $矩阵$A(\lambda)$在相抵下的标准型或者$Smith$标准型。</p>
<p><font color="red">$Smith$标准型是唯一的</font></p>
</li>
<li>
<p>不变因子、行列式因子、初等因子</p>
<p><font color="red">重要性质：相抵的$\lambda$矩阵具有相同的秩、相同的各阶行列式因子、相同的不变因子</font></p>
<p>$Smith$标准型“主对角线”上非零元$d_1(\lambda),d_2(\lambda),\dots,d_r(\lambda)$称为$A(\lambda)$的<font color="red">不变因子</font>；</p>
<p>$A(\lambda)$的全部$k$阶子式的最大公因式称为$A(\lambda)$的<font color="red">$k$阶行列式因子</font>，记为$D_k(\lambda)$；</p>
<p>其中$d_k(\lambda)=\frac{D_{k+1}(\lambda)}{D_k(\lambda)}$</p>
<p>初等因子是从不变因子分解得来的，具体如下：</p>
<p>假设不变因子为
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215634714.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215634714.png?size=small" data-sub-html="<h2>image-20240728215634714</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215634714.png" alt="image-20240728215634714" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215634714.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215634714.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215634714.png?size=large 2x" data-title="image-20240728215634714" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
则所有指数大于$0$的因子$(\lambda -\lambda _ {j})^ {e_ {ij}}(1\leq i \leq r,1\leq j\leq k)$称为$\lambda $矩阵$A(\lambda)$的<font color="red">初等因子</font></p>
</li>
</ul>
<h2 id="矩阵相似的条件" class="heading-element"><span>2 矩阵相似的条件</span>
  <a href="#%e7%9f%a9%e9%98%b5%e7%9b%b8%e4%bc%bc%e7%9a%84%e6%9d%a1%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$A$为$n$阶数字矩阵，其特征矩阵$\lambda I-A$的行列式因子，不变因子和初等因子分别称为矩阵$A$的行列式因子，不变因子和初等因子。</p>
</li>
<li>
<p>相似的充分必要条件</p>
<p>$n$阶矩阵$A$和$B$相似$\Longleftrightarrow $存在一个可逆矩阵 $P$，使得$B = P^{-1} A P $$\Longleftrightarrow $它们的特征矩阵$\lambda I-A$和$\lambda I-B$相抵$\Longleftrightarrow $它们具有相同的行列式因子或者它们有相同的不变因子$\Longleftrightarrow $它们具有相同的初等因子</p>
</li>
</ul>
<h2 id="矩阵的jordan标准型" class="heading-element"><span>3 矩阵的Jordan标准型</span>
  <a href="#%e7%9f%a9%e9%98%b5%e7%9a%84jordan%e6%a0%87%e5%87%86%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><code>Jordan</code>块和<code>Jordan</code>标准型</p>
<p><code>Jordan</code>块分<code>上Jordan</code>块和<code>下Jordan</code>块，我们一般用上<code>Jordan</code>块。</p>
<p>如果$(\lambda -a)^d$是$A$的初等因子，我们则可以构建一个$d\times d$的矩阵形式
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215730639.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215730639.png?size=small" data-sub-html="<h2>image-20240728215730639</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215730639.png" alt="image-20240728215730639" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215730639.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215730639.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215730639.png?size=large 2x" data-title="image-20240728215730639" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
这个矩阵我们称为<code>上Jordan</code>块。<code>下Jordan</code>块则为
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215737635.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215737635.png?size=small" data-sub-html="<h2>image-20240728215737635</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215737635.png" alt="image-20240728215737635" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215737635.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215737635.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215737635.png?size=large 2x" data-title="image-20240728215737635" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
那由若干个<code>Jordan</code>块为对角块组成的块对角矩阵称为<code>Jordan</code>标准型</p>
</li>
<li>
<p>性质</p>
<ol>
<li><code>Jordan</code>块被它的初等因子唯一确定</li>
<li><code>Jordan</code>标准型的全部初等因子由它的全部<code>Jordan</code>块的初等因子组成</li>
<li>每个$n$阶矩阵都相似于它的<code>Jordan</code>标准型</li>
<li><code>Jordan</code>标准型不唯一，其内部<code>Jordan</code>块的顺序可以随意，但每个<code>Jordan</code>块唯一，如果除去其中<code>Jordan</code>块排列的次序外是被矩阵$A$唯一确定的</li>
</ol>
</li>
<li>
<p>求$n$阶方阵$A$的<code>Jordan</code>标准型</p>
<ol>
<li>得到$(\lambda I-A)$矩阵，求它的各阶行列式因子$D_k(\lambda)$</li>
<li>根据公式$d_1(\lambda)=D_1(\lambda)$，$d_k(\lambda)=\frac{D_{k+1}(\lambda)}{D_k(\lambda)}(2\leq k\leq n)$得到不变因子</li>
<li>从不变因子分解得到初等因子</li>
<li>根据初等因子构成<code>Jordan</code>块$J_i$，再组成<code>Jordan</code>标准型$J$</li>
</ol>
</li>
<li>
<p>求可逆矩阵$P$，使得$P^{-1}AP=J$</p>
<ol>
<li>
<p>根据上一个方法求出矩阵$A$的<code>Jordan</code>标准型$J$</p>
</li>
<li>
<p>左右两边左乘$P^{-1}$变换公式得到$AP=PJ$</p>
</li>
<li>
<p>设$P=(P_1,..,P_n)$，根据公式构造
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215825948.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215825948.png?size=small" data-sub-html="<h2>image-20240728215825948</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215825948.png" alt="image-20240728215825948" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215825948.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215825948.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728215825948.png?size=large 2x" data-title="image-20240728215825948" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$J_{(i,i+1)}$的取值只能为$0\space or\space 1$，$J_{ii}$的取值即为对角线元素。根据方程从而解得$P$。</p>
</li>
</ol>
<p><font color="red">注意：$P$不唯一，但是我们在设$P$元素的时候一定要保证$P$可逆，即$rank(P)=n$。可以自己进行初等变换验证一下是否正确！</font></p>
</li>
<li>
<p><code>Python</code>求解$J$和可逆矩阵$P$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">P</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">jordan_form</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 验证P^-1 * A * P = J</span>
</span></span><span class="line"><span class="cl"><span class="k">assert</span> <span class="n">P</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">P</span> <span class="o">==</span> <span class="n">J</span><span class="p">,</span> <span class="s2">&#34;P^-1 * A * P != J&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;P:&#34;</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;J:&#34;</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="cayley-hamilton-定理与最小多项式" class="heading-element"><span>4 Cayley-Hamilton 定理与最小多项式</span>
  <a href="#cayley-hamilton-%e5%ae%9a%e7%90%86%e4%b8%8e%e6%9c%80%e5%b0%8f%e5%a4%9a%e9%a1%b9%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>Cayley-Hamilton 定理</p>
<p>设$A$是$n$阶矩阵，$f(\lambda)$是$A$的特征多项式，则$f(A)=0$</p>
</li>
<li>
<p>相关定义</p>
<p>设$A$为$n$阶矩阵，如果存在多项式$\varphi(\lambda)$使得$\varphi(A)=0$，则称$\varphi(\lambda)$为$A$的<font color="red">化零多项式</font>。易知$f(\lambda)$为$A$的化零多项式，且$g(\lambda)f(\lambda)$也为$A$的化零多项式，故$A$的化零多项式有无穷多个</p>
<p>$A$的所有化零多项式中，次数最低，且首项系数为$1$的多项式称为$A$的最小多项式。<font color="red">$A$的最小多项式是唯一的</font></p>
</li>
<li>
<p>结论</p>
<p>$A$的最小多项式就是$d_n(\lambda)$，即$A$的第$n$个不变因子</p>
</li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 6—矩阵分解知识点总结复习（附Python实现）</title><link>https://hezephyr.github.io/posts/06.%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/06.%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</guid><description><![CDATA[<h1 id="矩阵分解" class="heading-element"><span>矩阵分解</span>
  <a href="#%e7%9f%a9%e9%98%b5%e5%88%86%e8%a7%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><h2 id="满秩分解full-rank-factorization" class="heading-element"><span>1 满秩分解（Full-Rank Factorization）</span>
  <a href="#%e6%bb%a1%e7%a7%a9%e5%88%86%e8%a7%a3full-rank-factorization" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>满秩分解定理</p>
<p>设$m\times n$矩阵$A$的秩为$r&gt;0$，则存在$m\times r$矩阵$B$（列满秩矩阵）和$r\times n$矩阵$C$（行满秩矩阵）使得
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220206575.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220206575.png?size=small" data-sub-html="<h2>image-20240728220206575</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220206575.png" alt="image-20240728220206575" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220206575.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220206575.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220206575.png?size=large 2x" data-title="image-20240728220206575" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
并且$rank(B)=rank(C)=r$</p>
<p><font color="red">满秩分解不唯一</font></p>
<blockquote>
<p>定理：设$A$为$m\times n$矩阵，且$rank(A)=r$，存在$m$阶可逆矩阵$P$和$n$阶可逆矩阵$Q$，使得<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220849504.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220849504.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220849504.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220849504.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220849504.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220849504.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>。</p>
<p>证明满秩分解定理：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220911303.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220911303.png?size=small" data-sub-html="<h2>Latex公式渲染之后的图片</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220911303.png" alt="Latex公式渲染之后的图片" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220911303.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220911303.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220911303.png?size=large 2x" data-title="Latex公式渲染之后的图片" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220933074.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220933074.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220933074.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220933074.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220933074.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220933074.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>则令<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728221106084.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728221106084.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728221106084.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728221106084.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728221106084.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728221106084.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>，可得到$A=BC$</p>
<p>$\because$ $P,C$是可逆矩阵，$B$的$r$个列是$P$的前$r$列；$C$的$r$个行是$Q$的前$r$行</p>
<p>$\therefore$ $rank(B)=rank(C)=r$</p>
</blockquote>
</li>
<li>
<p>满秩分解步骤</p>
<ol>
<li>设$A$为$m\times n$矩阵，首先求$rank(A)$</li>
<li>取$A$的$j_1,j_2,&hellip;j_r$列构成$B_{m\times r}$</li>
<li>取$A$的<code>Hermite</code>标准型（即行最简行矩阵）$H$的前$r$行构成矩阵$C_{r\times n}$</li>
<li>则$A=BC$就是矩阵$A$的一个满秩分解</li>
</ol>
</li>
<li>
<p><code>Python</code>求解满秩分解</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">Full-Rank Factorization
</span></span></span><span class="line"><span class="cl"><span class="s1">@params: A Matrix
</span></span></span><span class="line"><span class="cl"><span class="s1">@return: F, G Matrix
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">full_rank</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">A_arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 求解A的最简行阶梯矩阵，要转换成list，再转换成array</span>
</span></span><span class="line"><span class="cl">    <span class="n">A_rref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rref</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 存储被选中的列向量的下标</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 遍历A_rref的行</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_rref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 遍历A_rref的列</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_rref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 遇到1就说明找到了A矩阵的列向量的下标</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 这些下标的列向量组成F矩阵，然后再找下一行</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">A_rref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 通过选中的列下标，构建F矩阵       </span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A_arr1</span><span class="p">[:,</span><span class="n">k</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># G就是取行最简行矩阵A的前r行构成的矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">C</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A_rref</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 表示矩阵A</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">full_rank</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B:&#34;</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;C:&#34;</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="三角分解triangular-factorization" class="heading-element"><span>2 三角分解（Triangular Factorization）</span>
  <a href="#%e4%b8%89%e8%a7%92%e5%88%86%e8%a7%a3triangular-factorization" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>$LU$分解定义</p>
<p>如果有一个矩阵$A$，我们能表示下三角矩阵$L$和上三角矩阵$U$的乘积，称为$A$的三角分解或$LU$分解。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172046678-2067287514.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172046678-2067287514.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172046678-2067287514.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172046678-2067287514.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172046678-2067287514.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172046678-2067287514.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>更进一步，我们希望下三角矩阵的对角元素都为$1$</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172059738-678872282.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172059738-678872282.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172059738-678872282.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172059738-678872282.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172059738-678872282.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/1203675-20180829172059738-678872282.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>$LU$分解定理</p>
<p>若$A$是<font color="red">$n$阶非奇异矩阵</font>，则存在<font color="red">唯一</font>的单位下三角矩阵$L$和上三角矩阵$U$使得$A=LU$的充分必要条件是$A$的所有顺序主子式均非零（这一条件保证了对角线元素非零），即$\Delta_k\neq 0(k=1,&hellip;,n-1)$</p>
</li>
<li>
<p>$LU$分解步骤</p>
<p>设$A$为$n\times n$矩阵</p>
<ol>
<li>进行初等行变换（<font color="red">注意：不涉及行交换的初等变换</font>），从第$1$行开始，到第$n$行结束。将第$i$行第$i$列以下的元素全部消为$0$</li>
<li>这样操作后得到的矩阵即为$U$</li>
<li>构造对角线元素全为$1$的单位下三角矩阵$L$，$L$的剩余元素通过构建方程组的形式来求解。</li>
</ol>
</li>
<li>
<p><code>Python</code>求解$LU$分解</p>
</li>
<li>
<p>$LU$分解的实际意义</p>
<ul>
<li>
<p>解线性方程组</p>
<blockquote>
<p>假设我们有一个线性方程组$Ax=b$，其中$A$是一个非奇异矩阵，而$b$是一个列向量。通过$LU$分解，我们可以将方程组转化为两个简化的方程组$Ly=b$和$Ux=y$，其中$L$是下三角矩阵，$U$是上三角矩阵。这两个方程组分别易于求解。</p>
<p>具体：</p>
<p>首先，通过前代法（forward substitution）解$Ly=b$，然后通过回代法（backward substitution）解$Ux=y$。这样，我们就得到了方程组的解。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>$LDU$分解定理</p>
<p>设$A$是<font color="red">$n$阶非奇异矩阵</font>，则存在<font color="red">唯一</font>的单位下三角矩阵$L$，对角矩阵$D=diag(d_1,d_2,&hellip;,d_n)$和上三角矩阵$U$使得$A=LDU$的充分必要条件是$A$的所有顺序主子式均非零（这一条件保证了对角线元素非零），即$\Delta_k\neq 0(k=1,&hellip;,n-1)$并且$d_1=a_{11},d_k=\frac{\Delta_k}{\Delta_{k+1}},k=2,&hellip;,n$</p>
</li>
<li>
<p>$LDU$分解步骤</p>
<p>设$A$为$n\times n$矩阵</p>
<ol>
<li>先求$LU$分解</li>
<li>将$U$的对角线元素提出来构成对角矩阵$D$</li>
<li>$U$中的元素$u_{ij}$除以$d_i$，其中$d_i$表示第$i$个对角元素。这样操作得到变换后的$U$</li>
</ol>
</li>
<li>
<p><code>Python</code>求解$LDU$分解</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EPSILON</span> <span class="o">=</span> <span class="mf">1e-8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EPSILON</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">LU</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 断言A必须是非奇异方阵A</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="s2">&#34;Matrix A must be a square matrix&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">det</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&#34;Matrix A must be a nonsingular matrix&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">rows</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="o">=</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 构建出U矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将U转换成list，再转换成array</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 遍历U的每一行利用高斯消元法</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 判断U[i][i]是否为0</span>
</span></span><span class="line"><span class="cl">        <span class="k">assert</span> <span class="ow">not</span> <span class="n">is_zero</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&#34;主元为0，无法进行LU分解&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 对i+1行到n行进行消元</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 计算消元因子</span>
</span></span><span class="line"><span class="cl">            <span class="n">factor</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 对第j行进行消元</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="n">U</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 消元后的矩阵U则是最终U矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 根据LU = A，得到L矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">U</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">LDU</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">LU</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">D</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">U</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">U</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">U</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">    # test LU分解
</span></span></span><span class="line"><span class="cl"><span class="s1">    L, U = LU(A)
</span></span></span><span class="line"><span class="cl"><span class="s1">    pprint.pprint(&#34;L:&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">    pprint.pprint(L)
</span></span></span><span class="line"><span class="cl"><span class="s1">    pprint.pprint(&#34;U:&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">    pprint.pprint(U)
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># test LDU分解</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">LDU</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;L:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;D:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;U:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">U</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>$PLU$分解</p>
<p>PLU 分解是将矩阵$A$分解成一个置换矩阵$P$、单位下三角矩阵$L$和上三角矩阵$U$的乘积，即
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220231616.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220231616.png?size=small" data-sub-html="<h2>image-20240728220231616</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220231616.png" alt="image-20240728220231616" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220231616.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220231616.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220231616.png?size=large 2x" data-title="image-20240728220231616" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
之前$LU$分解中限制了行交换，如果不可避免的必须进行行互换，我们就需要进行$PLU$分解。</p>
<p>实际上只需要把$A = LU$变成$P^{-1}A = P^{-1}PLU$就可以了，实际上所有的$A = LU$都可以写成$P^{-1}A = LU$的形式，由于左乘置换矩阵$P^{-1}$是在交换行的顺序，所以由$P^{-1}A = P^{-1}PLU$推得适当的交换$A$的行的顺序，即可将$A$ 做 $LU$ 分解。当$A$没有行互换时，$P$就是单位矩阵。</p>
<p>事实上，所有的方阵都可以写成 $PLU$ 分解的形式，事实上，$PLU$ 分解有很高的数值稳定性，因此实用上是很好用的工具。</p>
<p>有时为了计算上的方便，会同时间换行与列的顺序，此时会将 $A$ 分解成
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220240133.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220240133.png?size=small" data-sub-html="<h2>image-20240728220240133</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220240133.png" alt="image-20240728220240133" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220240133.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220240133.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220240133.png?size=large 2x" data-title="image-20240728220240133" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中 $P$、$L$、$U$ 同上，$Q$ 是一个置换矩阵。</p>
</li>
</ul>
<h2 id="正交三角分解qr-factorization" class="heading-element"><span>3 正交三角分解（QR Factorization）</span>
  <a href="#%e6%ad%a3%e4%ba%a4%e4%b8%89%e8%a7%92%e5%88%86%e8%a7%a3qr-factorization" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>$QR$分解定理</p>
<p>设$A$是$m\times n$实（复）矩阵，$m\ge n$且其$n$个列向量线性无关，则存在$m$阶正交（酉）矩阵$Q$和$n阶$非奇异实（复）上三角矩阵$R$使得
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220319602.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220319602.png?size=small" data-sub-html="<h2>image-20240728220319602</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220319602.png" alt="image-20240728220319602" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220319602.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220319602.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220319602.png?size=large 2x" data-title="image-20240728220319602" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>$QR$分解步骤</p>
<p>设$A$为$3\times 3$矩阵，即$A=(\alpha_1, \alpha_2,\alpha_3)$。则：</p>
<ol>
<li>
<p>正交化：$\beta_1=\alpha_1$，$\beta_2=\alpha_2-k_{21}\beta_1$，$\beta_3=\alpha_3-k_{31}\beta_1-k_{32}\beta_2$，其中$k_{21}=\frac{&lt;\alpha_2,\beta_1&gt;}{&lt;\beta_1,\beta_1&gt;}$，$k_{31}=\frac{&lt;\alpha_3,\beta_1&gt;}{&lt;\beta_1,\beta_1&gt;}$，$k_{31}=\frac{&lt;\alpha_3,\beta_2&gt;}{&lt;\beta_2,\beta_2&gt;}$。</p>
</li>
<li>
<p>单位化得到矩阵$Q$：$Q=(\frac{\beta_1}{||\beta_1||},\frac{\beta_2}{||\beta_2||},\frac{\beta_3}{||\beta_3||})$</p>
</li>
<li>
<p>计算得到矩阵$R$：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220329407.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220329407.png?size=small" data-sub-html="<h2>image-20240728220329407</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220329407.png" alt="image-20240728220329407" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220329407.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220329407.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220329407.png?size=large 2x" data-title="image-20240728220329407" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>这样，$A=QR$</p>
</li>
</ol>
</li>
<li>
<p><code>Python</code>求解$QR$分解</p>
<p>常规计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sympy</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#正交三角分解（QR）</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">     <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># a = [[1,1,-1],</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                   [1,0,0],</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                   [0,1,0],</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                   [0,0,1]]</span>
</span></span><span class="line"><span class="cl"><span class="n">A_mat</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="c1">#α向量组成的矩阵A</span>
</span></span><span class="line"><span class="cl"><span class="c1"># A_gs= GramSchmidt(A_mat)</span>
</span></span><span class="line"><span class="cl"><span class="n">A_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_mat</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_mat</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1">#求Q</span>
</span></span><span class="line"><span class="cl"><span class="n">A_gs</span> <span class="o">=</span> <span class="n">GramSchmidt</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="c1">#α的施密特正交化得到β</span>
</span></span><span class="line"><span class="cl"><span class="n">A_gs_norm</span> <span class="o">=</span> <span class="n">GramSchmidt</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span><span class="c1">#β的单位化得到v</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_gs_norm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="c1">#把数排成一行</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">A_arr</span> <span class="o">=</span> <span class="n">A_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span><span class="c1">#用reshape重新排列（‘F’为竖着写）</span>
</span></span><span class="line"><span class="cl"><span class="c1">#得到最后的Q</span>
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A_arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#求R</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_gs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_mat</span><span class="p">[:,</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_gs_norm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#             print(n)</span>
</span></span><span class="line"><span class="cl">            <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># C_final为R          </span>
</span></span><span class="line"><span class="cl"><span class="n">C_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># print(C_arr)</span>
</span></span><span class="line"><span class="cl"><span class="n">C_arr</span> <span class="o">=</span> <span class="n">C_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">A_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">C_arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;Q:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;R:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用库函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="c1"># 求矩阵A的QR分解，保留根号</span>
</span></span><span class="line"><span class="cl"><span class="n">Q_</span><span class="p">,</span> <span class="n">R_</span> <span class="o">=</span> <span class="n">A_mat</span><span class="o">.</span><span class="n">QRdecomposition</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;Q_:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">Q_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="s2">&#34;R_:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">R_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">assert</span> <span class="n">Q_</span> <span class="o">==</span> <span class="n">Q</span><span class="p">,</span> <span class="s2">&#34;Q_ != Q&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">assert</span> <span class="n">R_</span> <span class="o">==</span> <span class="n">R</span><span class="p">,</span> <span class="s2">&#34;R_ != R&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="奇异值分解svd" class="heading-element"><span>4 奇异值分解（SVD）</span>
  <a href="#%e5%a5%87%e5%bc%82%e5%80%bc%e5%88%86%e8%a7%a3svd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>$SVD$定理</p>
<p>设$A$是$m\times n$矩阵，且$rank(A)=r$，则存在$m$阶酉矩阵$U$和$n$阶酉矩阵$V$使得
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220417133.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220417133.png?size=small" data-sub-html="<h2>image-20240728220417133</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220417133.png" alt="image-20240728220417133" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220417133.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220417133.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220417133.png?size=large 2x" data-title="image-20240728220417133" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$\Sigma=diag(\sigma_1,&hellip;,\sigma_r)$，且$\sigma_1\geq &hellip;\geq \sigma_r&gt;0$。</p>
<p>$\sigma$为$A$的奇异值，具体含义这里不在叙述，但需要记住的是$\sigma^2$是$A^HA$的特征值，也是$AA^H$的特征值，且：</p>
<ol>
<li><font color="red">$A^HA$与$AA^H$的特征值均为非负数</font></li>
<li><font color="red">$A^HA$与$AA^H$的非零特征值相同，并且非零特征值的个数（重特征值按重数计算）等于$rank(A)$</font></li>
</ol>
<p>所以我们求$\Sigma$就转换成求这两个矩阵其中一个的特征值。</p>
</li>
<li>
<p>$SVD$分解步骤</p>
<ol>
<li>
<p>求$A^HA$的$n$个特征值，即计算$|\lambda I-A^HA|=0$。得到特征值：$\lambda_1,&hellip;,\lambda_r,\lambda_{r+1}=0,&hellip;,\lambda_n=0$，其中$r=rank(A)$。</p>
</li>
<li>
<p>将$r$个奇异值（即非零特征值开根号）从大到小排列组成对角矩阵，再添加额外的$0$构成$\Sigma_{m\times n}$矩阵。
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220426625.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220426625.png?size=small" data-sub-html="<h2>image-20240728220426625</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220426625.png" alt="image-20240728220426625" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220426625.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220426625.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728220426625.png?size=large 2x" data-title="image-20240728220426625" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>求特征值：$\lambda_1,&hellip;,\lambda_r,\lambda_{r+1}=0,&hellip;,\lambda_n=0$对应的特征向量$\xi_1,&hellip;,\xi_n$：当$\lambda=\lambda_1$时，$(\lambda I-A^HA)\times \xi_1=0$，解得$\xi_1$，同理，计算其余特征向量。</p>
</li>
<li>
<p>因为$\xi_1,&hellip;,\xi_n$相互正交，我们还需要进行单位化，得到$v_1,&hellip;,v_n$，即$v_1=\frac{\xi_1}{||\xi_1||},&hellip;,v_n=\frac{\xi_n}{||\xi_n||}$。则$V=(v_1,&hellip;,v_n)$。</p>
</li>
<li>
<p>根据$A=U_{m\times m}\Sigma_{m\times n}V_{n\times n}^H$，可得$U_1=AV_{n\times n}\Sigma_{r\times n}^{-1}$（注意，$\sigma$此时为$\Sigma_{m\times n}$的前$r$行），易知$U_1$为$m\times r$的矩阵，我们还需要扩充$U_2$，其为$m\times (m-r)$矩阵。</p>
</li>
<li>
<p>取$U_1^HU_2=0$，取$U_2$，必须要单位化$U_2$，这样$U=[U_1:U_2]$</p>
</li>
<li>
<p>则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220652431.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220652431.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220652431.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220652431.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220652431.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728220652431.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ol>
</li>
<li>
<p><code>Python</code>求解奇异值分解</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pprint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 求A的奇异值分解</span>
</span></span><span class="line"><span class="cl"><span class="n">U</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;U:&#34;</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;sigma:&#34;</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;VT:&#34;</span><span class="p">,</span> <span class="n">VT</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 7—Hermite矩阵与正定矩阵知识点总结复习</title><link>https://hezephyr.github.io/posts/07.hermite%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/07.hermite%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/</guid><description><![CDATA[<h2 id="hermite矩阵" class="heading-element"><span>1 Hermite矩阵</span>
  <a href="#hermite%e7%9f%a9%e9%98%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$A$为$n$阶方阵，如果称$A$为Hermite矩阵，则需满足$A^H=A$，其中$A^H$表示$A$的共轭转置，也称Hermite转置，具体操作如下：</p>
<ol>
<li>将矩阵的每个元素取共轭。对于复数$a+bi$，它的共轭是$a-bi$，其中$a$和$b$ 是实部和虚部</li>
<li>将矩阵的行和列互换</li>
</ol>
<p>Hermite矩阵与实对称矩阵的性质和证明方法都十分相似</p>
</li>
<li>
<p>Hermite矩阵性质</p>
<p>若$A,B$为$n$阶Hermite矩阵，则</p>
<ol>
<li>$A$的所有特征值全是实数</li>
<li>$A$的不同特征值所对应的特征向量是相互正交的</li>
<li><font color="red">对正整数$k$，$A^k$也是Hermite矩阵</font></li>
<li>若$A$可逆，则$A^{-1}$也是Hermite矩阵</li>
<li>对实数$k,p,kA+pB$也是Hermite矩阵</li>
</ol>
</li>
<li>
<p>Hermite矩阵充分必要条件</p>
<p>设$A\in C^{n\times n},B\in C^{n\times n}$</p>
<ol>
<li>
<p>$A$是Hermite矩阵的充要条件是存在酉矩阵$U$使得
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221312946.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221312946.png?size=small" data-sub-html="<h2>image-20240728221312946</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221312946.png" alt="image-20240728221312946" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221312946.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221312946.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221312946.png?size=large 2x" data-title="image-20240728221312946" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$\lambda_1,&hellip;,\lambda_n$均为实数。实对称矩阵则是存在正交矩阵$U&hellip;$</p>
</li>
<li>
<p>A是Hermite矩阵的充要条件是对任意方阵$S$，$S^HAS$是Hermite矩阵</p>
</li>
<li>
<p>如果$A,B$是Hermite阵，则$AB$是Hermite矩阵的充要条件是$AB=BA$</p>
</li>
</ol>
</li>
<li>
<p>相合标准形</p>
<p>设$A$为$n$阶Hermite矩阵，则$A$相合矩阵
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221321107.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221321107.png?size=small" data-sub-html="<h2>image-20240728221321107</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221321107.png" alt="image-20240728221321107" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221321107.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221321107.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728221321107.png?size=large 2x" data-title="image-20240728221321107" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$r=rank(A)$，$s$是$A$的正特征值（重特征值按重数计算）的个数。矩阵$D_0$则称为$n$阶Hermite矩阵$A$的相合标准形。</p>
</li>
<li>
<p>Sylvester惯性定律</p>
<p>设$A,B$为$n$阶Hermite矩阵，则$A$与$B$相合的充要条件是
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224214169.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224214169.png?size=small" data-sub-html="<h2>image-20240728224214169</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224214169.png" alt="image-20240728224214169" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224214169.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224214169.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224214169.png?size=large 2x" data-title="image-20240728224214169" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$In(A)$称为$A$的惯性，$In(A)={\pi(A),v(A),\delta(A)}$。其中$\pi(A)$,$v(A)$,$\delta(A)$分别表示$A$的正、负和零特征值的个数（重特征值按重数计算）。则$A$非奇异的充要条件为$\delta(A)=0$且$\pi(A)+v(A)=rank(A)$。</p>
</li>
</ul>
<h2 id="hermite二次型" class="heading-element"><span>2 Hermite二次型</span>
  <a href="#hermite%e4%ba%8c%e6%ac%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>Hermite二次型定义</p>
<p>由$n$个复变量$x_1,&hellip;,x_n$，系数为负数的二次齐式
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240728224222638.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240728224222638.png?size=small" data-sub-html="<h2>image-20240728224222638</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240728224222638.png" alt="image-20240728224222638" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240728224222638.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240728224222638.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240728224222638.png?size=large 2x" data-title="image-20240728224222638" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$a_{ij}=a_{ji}$，称为Hermite二次型。Hermite二次型可写为$f(x)=x^HAx$，我们称$A$的秩就为Hermite二次型的秩。</p>
</li>
<li>
<p>Hermite二次型的标准形定理</p>
<p>对Hermite二次型$f(x)=x^HAx$，存在酉线性变换$x=Uy$（其中$U$是酉矩阵）使得Hermite二次型$f(x)$变成标准形（只包含平方项的二次型）
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224347301.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224347301.png?size=small" data-sub-html="<h2>image-20240728224347301</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224347301.png" alt="image-20240728224347301" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224347301.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224347301.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224347301.png?size=large 2x" data-title="image-20240728224347301" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$\lambda_1,&hellip;,\lambda_n$为$A$的特征值。</p>
</li>
<li>
<p>Hermite二次型化标准形（酉线性变换）</p>
<p>设$f(x)=x^HAx$，其中$A$为$n$阶Hermite矩阵</p>
<ol>
<li>
<p>求出二次型矩阵$A$的特征值$\lambda_1,&hellip;\lambda_n$和特征向量$v_1,&hellip;,v_n$，并将特征向量$v_1,&hellip;,v_n$规范正交</p>
</li>
<li>
<p>令$U=(v_1,&hellip;,v_n),x=Uy$，则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224515501.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224515501.png?size=small" data-sub-html="<h2>image-20240728224515501</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224515501.png" alt="image-20240728224515501" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224515501.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224515501.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224515501.png?size=large 2x" data-title="image-20240728224515501" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ol>
</li>
<li>
<p>Hermite二次型规范形定理</p>
<p>对二次型$f(x)=x^HAx$，存在可逆线性变换$x=Py$使得Hermite二次型$f(x)$化为
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224525189.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224525189.png?size=small" data-sub-html="<h2>image-20240728224525189</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224525189.png" alt="image-20240728224525189" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224525189.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224525189.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224525189.png?size=large 2x" data-title="image-20240728224525189" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>其中$r=rank(A),s=\pi(A)$。上式则为Hermite二次型$f(x)$的规范形，其中$s$和$(r-s)$分别称为Hermite二次型的正惯性指数和负惯性指数。</p>
</li>
<li>
<p>二次型化规范形</p>
<p>设$f(x)=x^HAx$，其中$A$为$n$阶Hermite矩阵</p>
<ol>
<li>
<p>将二次型化为标准形，得到标准形$f(x)=y^H\Lambda y$和酉矩阵$U$</p>
</li>
<li>
<p>将对角线元素提取出来，即只保留$\lambda_i$的正负性，则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224533141.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224533141.png?size=small" data-sub-html="<h2>image-20240728224533141</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224533141.png" alt="image-20240728224533141" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224533141.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224533141.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224533141.png?size=large 2x" data-title="image-20240728224533141" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$\Lambda_1$为对角矩阵，对角线元素为$\sqrt {|\lambda_i}|(1\leq i \leq n)$。</p>
</li>
<li>
<p>令$y=\Lambda_1^{-1} z$，则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224647270.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224647270.png?size=small" data-sub-html="<h2>image-20240728224647270</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224647270.png" alt="image-20240728224647270" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224647270.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224647270.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224647270.png?size=large 2x" data-title="image-20240728224647270" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>故$x=U\Lambda^{-1}z$，可逆矩阵$P=U\Lambda^{-1}$</p>
</li>
</ol>
</li>
<li>
<p>正定相关概念</p>
<p>设$f(x)=x^HAx$为Hermite二次型</p>
<ol>
<li>如果$f(x)&gt;0$（等价$s=r=n$），则称$f(x)$为正定的；</li>
<li>如果$f(x)\geq0$（等价$s=r&lt;n$），则称$f(x)$为半正定（非负定的）的；</li>
<li>如果$f(x)&lt;0$（等价$s=0,r=n$），则称$f(x)$为负定的；</li>
<li>如果$f(x)\leq0$（等价$s=0,r&lt;n$），则称$f(x)$为半负定的；</li>
<li>如果$f(x)$有时为正有时为负（等价$0&lt;s&lt;r\leq n$），则称$f(x)$为不定的；</li>
</ol>
</li>
</ul>
<h2 id="hermite正定非负定矩阵" class="heading-element"><span>3 Hermite正定（非负定矩阵）</span>
  <a href="#hermite%e6%ad%a3%e5%ae%9a%e9%9d%9e%e8%b4%9f%e5%ae%9a%e7%9f%a9%e9%98%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>根据Hermite二次型的正定（非负定）可以定义Hermite矩阵的正定（非负定）。</p>
<p>设$A$为$n$阶Hermite矩阵，$f(x)=x^HAx$</p>
<ol>
<li>如果$f(x)&gt;0$，则称$A$为正定的，记作$A&gt;0$；</li>
<li>如果$f(x)\geq0$，则称$A$为半正定（非负定的）的，记作$A\geq 0$；</li>
<li>如果$f(x)&lt;0$，则称$A$为负定的，记作$A&lt;0$；</li>
<li>如果$f(x)\leq0$，则称$A$为半负定的，记作$A\leq 0$；</li>
<li>如果$f(x)$有时为正有时为负，则称$A$为不定的；</li>
</ol>
</li>
<li>
<p>判断$n$阶Hermite矩阵$A$正定</p>
<ol>
<li>通过正定矩阵的定义</li>
<li>$A$的$n$个特征值均为正数</li>
<li>$A$的顺序主子式<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/seq_format?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/seq_format?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/seq_format" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/seq_format?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/seq_format?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/seq_format?size=large 2x" data-title="img" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>均为正数</li>
<li>$A$的所有主子式全大于$0$</li>
<li>存在$n$阶非奇异下三角矩阵$L$，使得$A=LL^H$（该分解称为Cholesky分解）</li>
<li>存在$n$阶非奇异矩阵，使得$A=B^HB$</li>
<li>存在$n$阶非奇异Hermite矩阵$A=S^2$</li>
</ol>
</li>
<li>
<p>判断$n$阶Hermite矩阵$A$半正定</p>
<ol>
<li>通过半正定矩阵的定义</li>
<li>$A$的$n$个特征值均为非负数</li>
<li>$A$的所有主子式均非负</li>
</ol>
</li>
<li>
<p>定理证明</p>
<p>设$A,B$均为$n$阶Hermite矩阵，且$B&gt;0$，则存在非奇异矩阵$P$使得
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224719159.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224719159.png?size=small" data-sub-html="<h2>image-20240728224719159</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224719159.png" alt="image-20240728224719159" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224719159.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224719159.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224719159.png?size=large 2x" data-title="image-20240728224719159" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
其中$\lambda_1,&hellip;,\lambda_n$是广义特征值问题的特征值</p>
<blockquote>
<p>证明：</p>
<p>$\because B &gt;0$</p>
<p>$\therefore $存在非奇异矩阵$P_1$使得$P_1^HBP_1=I$</p>
<p>又$\because P_1^HAP_1$仍为<code>Hermite</code>矩阵</p>
<p>$\therefore$酉矩阵$U$使得
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224738600.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224738600.png?size=small" data-sub-html="<h2>image-20240728224738600</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224738600.png" alt="image-20240728224738600" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224738600.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224738600.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728224738600.png?size=large 2x" data-title="image-20240728224738600" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
令$P=P_1U$</p>
<p>$\because P$非奇异，根据定理$P^HBP=I$</p>
<p>$\therefore P^HBP=(P_1U)^HB(P_1U)=U^HP_1^HBP_1U=I$</p>
<p>又$\because P_1$非奇异，使得$P_1^HBP_1=I$</p>
<p>$\therefore$
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225741717.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225741717.png?size=small" data-sub-html="<h2>image-20240728225741717</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225741717.png" alt="image-20240728225741717" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225741717.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225741717.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225741717.png?size=large 2x" data-title="image-20240728225741717" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
$\therefore$
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225750405.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225750405.png?size=small" data-sub-html="<h2>image-20240728225750405</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225750405.png" alt="image-20240728225750405" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225750405.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225750405.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225750405.png?size=large 2x" data-title="image-20240728225750405" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
$\therefore$我们可以对$(12)$右乘$P^{-1}$和$B^{-1}$，得到
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225801602.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225801602.png?size=small" data-sub-html="<h2>image-20240728225801602</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225801602.png" alt="image-20240728225801602" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225801602.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225801602.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225801602.png?size=large 2x" data-title="image-20240728225801602" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
$\therefore $将$(14)$代入$(13)$中得到
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225809654.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225809654.png?size=small" data-sub-html="<h2>image-20240728225809654</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225809654.png" alt="image-20240728225809654" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225809654.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225809654.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240728225809654.png?size=large 2x" data-title="image-20240728225809654" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
即$B^{-1}A$相似于对角矩阵，故$\lambda_1,&hellip;,\lambda_n$是矩阵$B^{-1}A$的特征值，即$\lambda_1,&hellip;,\lambda_n)$是广义特征值问题的特征值。</p>
<p>广义特征值问题$Ax=\lambda Bx$，左乘$B^{-1}$，即为$B^{-1}Ax=\lambda x$</p>
</blockquote>
</li>
</ul>
<h2 id="矩阵不等式" class="heading-element"><span>4 矩阵不等式</span>
  <a href="#%e7%9f%a9%e9%98%b5%e4%b8%8d%e7%ad%89%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定义</p>
<p>设$A,B$都是$n$阶Hermite矩阵，如果$A-B\geq 0$则称$A$大于或等于$B$（或称$B$小于等于$A$），记作$A\geq B$（或$B\leq A$），<font color="red">即$A-B$半正定</font>；如果$A-B&gt;0$，则称$A$大于$B$（或称$B$小于$A$），记作$A&gt;B$（或$B&lt;A$），即<font color="red">$A-B$正定</font>。</p>
</li>
<li>
<p>性质</p>
<p>设$A,B,C$均为$n$阶Hermite矩阵，则</p>
<ol>
<li>$A\geq B(A&gt;B) \Longleftrightarrow-A\leq -B(-A&lt;-B)\Longleftrightarrow$对任意$n$阶可逆矩阵$P$都有$P^HAP\geq P^HBP(P^HAP&gt;P^HBP)$</li>
<li>若$A&gt;0(A\geq 0),C&gt;0(C\geq 0)$，且$AC=CA$，则$AC&gt;0(AC\geq 0)$</li>
<li>若$A&gt;B$，$P$为$n\times m$<font color="red">列满秩矩阵</font>，则$P^HAP&gt;P^HBP$</li>
<li>若$A\geq B$，$P$为$n\times m$矩阵，则$P^HAP\geq P^HBP$</li>
</ol>
</li>
<li>
<p>定理</p>
<p>设$A,B$都是$n$阶Hermite矩阵，且$A\geq 0,B&gt;0$，则</p>
<ol>
<li>$B\geq A$的充要条件是$\rho(AB^{-1})\leq 1$</li>
<li>$B&gt;A$的充要条件是$\rho(AB^{-1})&lt;1$</li>
</ol>
<p>设$A$是$n$阶Hermite矩阵，则$\lambda_{min}(A)I\leq A\leq\lambda_{max}I$，这时$\lambda_{min}$和$\lambda_{max}$分别表示$A$的最大和最小特征值。</p>
<p>设$A,B$均为$n$阶Hermite正定矩阵，则</p>
<ol>
<li>若$A\geq B&gt;0$，则$B^{-1}\geq A^{-1}&gt;0$</li>
<li>若$A&gt;B&gt;0$，则$B^{-1}&gt;A^{-1}&gt;0$</li>
</ol>
<p>设$A,B$均为$n$阶Hermite正定矩阵，且$AB=BA$，则</p>
<ol>
<li>
<p>若$A\geq B$，则$A^2\geq B^2$</p>
<p>证明：$A^2-B^2=(A-B)(A+B)=(A+B)(A-B)$，易知$(A-B)\geq0,A+B&gt;0$，则克制</p>
</li>
<li>
<p>若$A\geq B$，则$A^2&gt; B^2$</p>
<p>同理得证</p>
</li>
</ol>
<p>设$A$是$m\times n$行满秩矩阵，$B$是$n\times k$矩阵，则
$$
B^HB\geq (AB)^H(AA^H)^{-1}(AB)
$$
等号成立当且仅当存在一个$m\times k$矩阵$C$使得$B=A^HC$</p>
</li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 8—范数与极限知识点总结复习</title><link>https://hezephyr.github.io/posts/08.%E8%8C%83%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/08.%E8%8C%83%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</guid><description><![CDATA[<h2 id="向量范数" class="heading-element"><span>1 向量范数</span>
  <a href="#%e5%90%91%e9%87%8f%e8%8c%83%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>向量范数定义</p>
<p>设$V$是数域$P$上的线性空间，$||x||$是以$V$中的向量$x$为自变量的非负实值函数，如果满足以下三个条件：</p>
<ol>
<li>非负性：$||x||\geq 0$，且$||x||=0$当且仅当$x=0$</li>
<li>齐次性：$\forall \alpha \in P,x\in V$，有$||\alpha x||=|\alpha|||x||$</li>
<li>三角不等式：$\forall x,y \in V$，有$||x+y||\leq ||x||+||y||$</li>
</ol>
<p>则称$||x||$为向量$x$的范数，并称定义了范数的线性空间为赋范线性空间。</p>
</li>
<li>
<p>$1$范数，$2$范数、$\infty$范数和$p$范数</p>
<p>在$n$维向量空间$C^n$中，对任意向量$x=(x_1,&hellip;,x_n)^T\in C^n$</p>
<p>$1$范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231038637.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231038637.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231038637.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231038637.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231038637.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231038637.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>$2$范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231104768.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231104768.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231104768.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231104768.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231104768.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231104768.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>$\infty$范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231143973.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231143973.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231143973.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231143973.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231143973.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231143973.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>$p$范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231210069.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231210069.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231210069.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231210069.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231210069.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231210069.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>利用已知范数构造新范数</p>
<p>设<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231314464.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231314464.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231314464.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231314464.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231314464.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231314464.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>是$C^m$上的向量范数，$A\in C^{m\times n}$且$rank(A)=n$，则由<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231404979.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231404979.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231404979.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231404979.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231404979.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231404979.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>所定义的$||\cdot||$是$C^n$上的向量范数</p>
</li>
<li>
<p>性质</p>
<ol>
<li>向量范数的等价具有自反性、对称性和传递性</li>
<li>有限维线性空间$V$上的任意两个向量范数都是等价的</li>
</ol>
</li>
</ul>
<h2 id="矩阵范数" class="heading-element"><span>2 矩阵范数</span>
  <a href="#%e7%9f%a9%e9%98%b5%e8%8c%83%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>矩阵范数定义</p>
<p>设$||A||$是以$C^{m\times n}$中的矩阵$A$为自变量的非负实值函数，如果满足以下四个条件：</p>
<ol>
<li>非负性：$||A||\geq 0$，且$||A||=0$当且仅当$A=0$</li>
<li>齐次性：$\forall \alpha \in C,A\in C^{m\times n}$，有$||\alpha A||=|\alpha|||A||$</li>
<li>三角不等式：$\forall A,B \in C^{m\times n}$，有$||A+B||\leq ||A||+||B||$</li>
<li>相容性：$\forall A,B \in C^{m\times n}$，有$||AB||\leq ||A||\space ||B||$</li>
</ol>
<p>则称$||A||$为$m\times n$矩阵$A$的范数</p>
</li>
<li>
<p>定理</p>
<p>设$A=(a_{ij})\in C^{n\times n}$，则由$l_1,l_2,l_{\infty}$向量范数各自推导得到的矩阵范数<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231734631.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231734631.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231734631.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231734631.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231734631.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231734631.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li>行和范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231510964.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231510964.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231510964.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231510964.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231510964.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231510964.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></li>
<li>列和范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231540989.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231540989.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231540989.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231540989.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231540989.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231540989.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></li>
<li>谱范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231610865.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231610865.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231610865.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231610865.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231610865.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231610865.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></li>
<li>$F$范数：<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231637792.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231637792.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231637792.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231637792.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231637792.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728231637792.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></li>
</ol>
</li>
<li>
<p>Python求解矩阵范数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 表示复数矩阵[[1, -1, 1], [-i, 0, 2i], [1, 1, 1]]</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 求A的矩阵范数，ord分别为1，2，np.inf，F</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A范数&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A的1范数（列和范数）：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A的2范数（谱范数）：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A的无穷范数（行和范数）：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A的F范数：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B范数&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B的1范数（列和范数）：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B的2范数（谱范数）：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B的无穷范数（行和范数）：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B的F范数：&#34;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="矩阵序列" class="heading-element"><span>3 矩阵序列</span>
  <a href="#%e7%9f%a9%e9%98%b5%e5%ba%8f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>矩阵序列的收敛</p>
<p>设有矩阵序列${A^{(k)}}$，其中$A^{(k)}=(a_{ij}^{(k)})\in C^{m\times n}$，如果当$k\rightarrow \infty$时，矩阵$A^{(k)}$的每一个元素$a_{ij}^{(k)}$都有极限$a_{ij}$，即
$$
\lim_{k\rightarrow \infty}a_{ij}^{(k)}=a_{ij},1\leq i\leq m;1\leq j\leq n
$$
则称矩阵序列${A^{(k)}}$是收敛的，并把矩阵$A=(a_{ij})\in C^{m\times n}$称为${A^{(k)}}$的极限。</p>
</li>
<li>
<p>定理</p>
<p>设$A\in C^{n\times n}$，$\lim_{k\rightarrow \infty}A^k=0$的充要条件是$\rho(A)&lt;1$。其中$\rho(A)$为$A$的谱半径，即所有特征值的绝对值的最大值。</p>
</li>
</ul>
<h2 id="矩阵级数" class="heading-element"><span>4 矩阵级数</span>
  <a href="#%e7%9f%a9%e9%98%b5%e7%ba%a7%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>矩阵级数定义</p>
<p>设有矩阵序列${A^{(k)}}\in C^{m\times n}$，则无穷和$A^{(1)}+A^{(2)}+&hellip;+A^{(k)}+&hellip;$称为矩阵级数，记为$\sum_{k=1}^{\infty}A^{(k)}$。由定义可知，矩阵级数收敛的充要条件是$mn$个数项级数$\sum_{k=1}^\infty a_{ij}^{(k)}(1\leq i\leq m, 1\leq j \leq n)$都收敛，如果它们都绝对收敛，则称矩阵级数绝对收敛。</p>
</li>
<li>
<p>定理</p>
<p>矩阵级数$\sum_{k=1}^{\infty}A^{(k)}$绝对收敛的充要条件是数项级数$\sum_{k=1}^{\infty}||A^{(k)}||$，其中$||\cdot ||$是$C^{m\times n}$上的任一矩阵范数。</p>
</li>
<li>
<p>矩阵幂级数定义</p>
<p>设$A\in C^{n\times n}$，形如
$$
\sum_{k=0}^{\infty}c_kA^{k}=c_0I+c_1A+c_2A^2+\cdots+c_kA^k+\cdots
$$
的矩阵级数称为矩阵幂级数。</p>
</li>
<li>
<p>定理</p>
<p>设$A\in C^{n\times n}$，并且幂级数$\sum_{k=0}^{\infty}c_kx^k$的收敛半径为$R$，如果$\rho(A)&lt;R$，则矩阵幂级数$\sum_{k=0}^{\infty}c_kA^k$绝对收敛；如果$\rho(A)&gt;R$，则矩阵幂级数$\sum_{k=0}^{\infty}c_kA^k$发散。</p>
</li>
<li>
<p>求收敛半径</p>
<p>设幂级数$\sum_{k=0}^{\infty}c_kx^k$</p>
<ol>
<li>
<p>比值法</p>
<p>$R=\lim_{n\rightarrow \infty}|\frac{a_n}{a_{n+1}}|$</p>
</li>
<li>
<p>根式法</p>
<p>$R=\lim_{n\rightarrow \infty}|\frac{1}{\sqrt[n]{a_n}}|$</p>
</li>
</ol>
</li>
<li>
<p>例题</p>
<blockquote>
<p>Given <a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232330986.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232330986.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232330986.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232330986.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232330986.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232330986.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>For $T&gt;0$, find the radius of covergence for
$$
s(z)=\sum_{k=0}^{\infty}\frac{1}{(T^3+\frac{3}{k^2+3})^{\frac{k}{3}}}z^k
$$
Let $h(z)=s(2z-T)$. Decide when the matrix power series $h(A)$ converges absolutely.</p>
<p>Solution:</p>
<p>For $s(z)$:  $R=\lim_{k\rightarrow \infty}\frac{(T^3+\frac{3}{(k+1)^2+3})^{\frac{k+1}{3}}}{(T^3+\frac{3}{k^2+3})^{\frac{k}{3}}}=\lim_{k\rightarrow \infty}\frac{(T^3)^{\frac{k+1}{3}}}{(T^3)^\frac{k}{3}}=T$</p>
<p>So for matrix $2A-TI$, we can determine $|\lambda I-2A+TI|=(\lambda -2+T)^2(\lambda -6 + T)=0$, The eigenvalues are solved as: $2-T,2-T,6-T$.</p>
<p>From <a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.php%3Ffmt%3D?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.php%3Ffmt%3D?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.php%3Ffmt%3D" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.php%3Ffmt%3D?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.php%3Ffmt%3D?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex.php%3Ffmt%3D?size=large 2x" data-title="img" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a> , so when $T&gt;3$, $h(A)$ converges absolutly.</p>
</blockquote>
</li>
</ul>
<h2 id="矩阵函数" class="heading-element"><span>5 矩阵函数</span>
  <a href="#%e7%9f%a9%e9%98%b5%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>矩阵函数定义</p>
<p>设$A\in C^{n\times n}$，一元函数$f(z)$能够展开为$z$的幂级数$f(z)=\sum_{k=0}^\infty c_kz^k$，并且该幂级数的收敛半径为$R$。当矩阵$A$的谱半径$\rho(A)&lt;R$时，则将收敛矩阵幂级数$\sum_{k=0}^{\infty}c_kA^k$的和定义为矩阵函数，记为$f(A)$，即$f(A)=\sum_{k=0}^{\infty}c_kA^k$。</p>
</li>
<li>
<p>常见矩阵函数</p>
<ol>
<li>矩阵指数函数：$e^A=\sum_{k=0}^\infty \frac{1}{k!}A^k=I+A+\frac{1}{2!}+\cdots+\frac{1}{n!}A^n+\cdots$</li>
<li>矩阵正弦函数：$sinA=\sum_{k=0}^\infty \frac{(-1)^k}{(2k+1)!}A^{2k+1}=A-\frac{1}{3!}A^3+\frac{1}{5!}A^5-\cdots+(-1)^n\frac{1}{(2n+1)!}A^{2n+1}$</li>
<li>矩阵余弦函数：$cosA=\sum_{k=0}^\infty \frac{(-1)^k}{(2k)!}A^{2k}=A-\frac{1}{2!}A^2+\frac{1}{4!}A^4-\cdots+(-1)^n\frac{1}{(2n)!}A^{2n}$</li>
</ol>
</li>
<li>
<p>定理</p>
<p>设$A,B\in C^{n\times n}$，如果$AB=BA$，则$e^Ae^B=e^Be^A=e^{A+B}$。</p>
</li>
<li>
<p>利用Jordan标准型求矩阵函数$f(A)$</p>
<ol>
<li>求出矩阵$A$的若当标准型$J$和可逆矩阵$P,P^{-1}$，其中$J=diag(J_1,J_2,\cdots,J_s)$</li>
<li>计算
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232628643.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232628643.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232628643.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232628643.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232628643.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232628643.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></li>
<li>则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232712903.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232712903.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232712903.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232712903.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232712903.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728232712903.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></li>
</ol>
</li>
</ul>
]]></description></item><item><title>【矩阵论】Chapter 9—广义逆矩阵知识点总结复习</title><link>https://hezephyr.github.io/posts/09.%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/09.%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/</guid><description><![CDATA[<p><font color="red">Hermite标准型实际上就是行最简行</font></p>
<h2 id="广义逆矩阵定义" class="heading-element"><span>1 广义逆矩阵定义</span>
  <a href="#%e5%b9%bf%e4%b9%89%e9%80%86%e7%9f%a9%e9%98%b5%e5%ae%9a%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>广义逆矩阵$G$的定义：对任意$m\times n$矩阵的$A$，如果存在某个$n\times m$的矩阵$G$，满足<code>Penrose</code>方程的一部分或全部，则称$G$为$A$的广义逆矩阵</p>
<blockquote>
<p><code>Penrose</code>方程的四个条件：</p>
<ol>
<li>$AGA=A$;</li>
<li>$GAG=G$;</li>
<li>$(AG)^T=AG$;</li>
<li>$(GA)^T=GA$</li>
</ol>
<p>满足第$i$个条件，则把$G$记为$A^{(i)}$，这类矩阵的全体记为$A{i}$，所以$A^{i}\in A{i}$</p>
<p>类似，满足第$i,j$个条件：$A^{i,j}\in A{i,j}$</p>
<p>根据以上，满足$1$个，$2$个，$3$个，$4$个<code>Penrose</code>方程的广义逆矩阵有$C_4^1+C_4^2+C_4^3+C_4^4=4+6+4+1=15$，但应用最多的，也就是我们所学的以下四种：</p>
<ol>
<li>减号逆或者$g$逆：$A^-=A^{(1)}$</li>
<li>最小二乘广义逆：$A_l^-=A^{(1,3)}$</li>
<li>极小范数广义逆：$A_m^-=A^{(1,4)}$</li>
<li>加号逆或<code>Moore-Penrose</code>广义逆：$A^+=A^{(1,2,3,4)}$</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="减号逆" class="heading-element"><span>2 减号逆</span>
  <a href="#%e5%87%8f%e5%8f%b7%e9%80%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>$A^-$的性质</p>
<p>设$A$为$m\times n$矩阵，$P$和$Q$分别是$m$阶和$n$阶非奇异方阵，且$B=PAQ$，$A^-$为A的减号逆，则：</p>
<ol>
<li>$rank(A)\leq rank(A^-)$</li>
<li>$AA^-$和$A^-A$是幂等矩阵，并且$rank(AA^-)=rank(A^-A)=rank(A)$</li>
<li>$Q^{-1}A^-P^{-1}\in B{1}$</li>
<li>$A^T{1}={G^T|G\in A{1}}$</li>
</ol>
</li>
<li>
<p>（<code>Penrose</code>定理）</p>
<p>设$A,B,C$分别为$m\times n,p\times q,m\times q$矩阵，则矩阵方程：
$$
AXB=C
$$
有解的充分必要条件是：
$$
AA^-CB^-B=C
$$
并且在有解的情况下，其通解为：
$$
X=A^-CB^-+Y-A^-AYBB^-
$$
其中$Y\in R^{n\times p}$是任意的矩阵。</p>
</li>
<li>
<p>求解$A^-$</p>
<p>$A$为$m\times n$矩阵
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233037081.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233037081.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233037081.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233037081.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233037081.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233037081.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
，其中$P,Q,E_r$通过对$A$进行如下操作得到，$G_{12},G_{21},G_{22}$均为常数矩阵，每一项均用$g_{ij}$表示常数，且$Q,P$维度均为$m\times n$，$E_r$是一个$r \times r$ 的对角矩阵，其中$r$是矩阵$A$的秩，$G_{12}$维度为$m \times (n-r)$ ，$G_{21}$维度为$(m-r) \times n$，$G_{22}$是一个$ (m-r) \times (n-r)$的矩阵。</p>
<p>例子<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233212366.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233212366.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233212366.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233212366.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233212366.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233212366.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>初等行变换化为行最简阶梯形矩阵，则<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233255489.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233255489.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233255489.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233255489.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233255489.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233255489.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233335693.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233335693.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233335693.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233335693.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233335693.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233335693.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
再进行列变换化为$E_r$得到<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233427741.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233427741.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233427741.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233427741.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233427741.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233427741.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233458270.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233458270.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233458270.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233458270.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233458270.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233458270.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
则
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233541449.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233541449.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233541449.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233541449.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233541449.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233541449.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a>
令$g_{ij}=0$，则<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233612330.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233612330.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233612330.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233612330.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233612330.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240728233612330.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
<li>
<p>利用$A^-$求解线性方程组$Ax=b$</p>
<p>$Ax=b$有解的充分必要条件是$AA^-b=b$，这时特解$x_0=A^-b$，通解$x=A^-b+(I-A^-A)y,\forall y\in C^n$</p>
<p>这里不给出$A^-$，感兴趣的读者可以自己去实现，具体的算法如下：</p>
<blockquote>
<ol>
<li><strong>构造水平增广矩阵</strong>： 将原矩阵和单位矩阵水平拼接，形成增广矩阵。</li>
<li><strong>初等行变换</strong>： 利用初等行变换将增广矩阵转化为最简行阶梯形式。</li>
<li><strong>提取$P$</strong>：变换后的单位矩阵就是$P$</li>
<li><strong>构造垂直增广矩阵</strong>：再将最简行阶梯形与单位矩阵垂直拼接，形成增广矩阵。</li>
<li><strong>初等列变换，提取$G$</strong>：变换后的单位矩阵就是$G$</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="最小二乘广义逆" class="heading-element"><span>3 最小二乘广义逆</span>
  <a href="#%e6%9c%80%e5%b0%8f%e4%ba%8c%e4%b9%98%e5%b9%bf%e4%b9%89%e9%80%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定理1</p>
<p>设$A\in  C^{m\times n}$，$G\in A{1,3}$的充分必要条件是$G$满足
$$
A^HAG=A^H
$$</p>
<p>这即为$A{1,3}$（最小二乘广义逆）的通式</p>
</li>
<li>
<p>定理2</p>
<p>设$A\in  C^{m\times n}$，$A_l^-$是$A$的任一最小二乘广义逆，则
$$
A{1,3}={G\in C^{n\times m}|AG=AA_l^-}
$$</p>
</li>
<li></li>
<li>
<p>定理3</p>
<p>设$A$是$m\times n$矩阵，则$G\in A{1,3}$（即G为最小二乘广义逆）的充分必要条件为$x=Gb$是<font color="red">不相容线性方程组</font>$Ax=b$的最小二乘解。</p>
</li>
<li>
<p>利用$A_l^-$求解线性方程组$Ax=b$</p>
<p>$x$是不相容线性方程组$Ax=b$的最小二乘解当且仅当$x$是相容线性方程组
$$
Ax=AA_l^-b
$$
的解，并且$Ax=b$的最小二乘解的通式为$x=A_l^-b+(I-A^-A)y,\forall y\in C^n$</p>
</li>
</ul>
<h2 id="极小范数广义逆" class="heading-element"><span>4 极小范数广义逆</span>
  <a href="#%e6%9e%81%e5%b0%8f%e8%8c%83%e6%95%b0%e5%b9%bf%e4%b9%89%e9%80%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>定理1</p>
<p>设$A\in  C^{m\times n}$，$G\in A{1,4}$的充分必要条件是$G$满足
$$
GAA^H=A^H
$$</p>
<p>这即为$A{1,4}$（极小范数广义逆）的通式</p>
</li>
<li>
<p>定理2</p>
<p>设$A\in  C^{m\times n}$，$A_m^-$是$A$的任一极小范数广义逆，则
$$
A{1,4}={G\in C^{n\times m}|GA=A_m^-A}
$$</p>
</li>
<li>
<p>定理$3$</p>
<p>设$A$是$m\times n$矩阵，则$G\in A{1,4}$（即G为极小范数广义逆）的充分必要条件为$x=Gb$是<font color="red">相容</font>线性方程组$Ax=b$的极小范数解。</p>
</li>
<li>
<p>利用$A_m^-$求解线性方程组$Ax=b$</p>
<p>设$A$是$m\times n$矩阵，则$G\in A{1,4}$的充分必要条件为$x=Gb$是相容线性方程组$Ax=b$的极小范数解，即$x=A_m^-b$为相容线性方程组$Ax=b$的极小范数解</p>
</li>
</ul>
<p><font color="red">注意：极小范数解是唯一的，而最小二乘解不唯一</font></p>
<h2 id="moore-penrose加号逆" class="heading-element"><span>5 Moore-Penrose（加号逆）</span>
  <a href="#moore-penrose%e5%8a%a0%e5%8f%b7%e9%80%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231127225725016.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231127225725016.png?size=small" data-sub-html="<h2>image-20231127225725016</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231127225725016.png" alt="image-20231127225725016" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231127225725016.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231127225725016.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20231127225725016.png?size=large 2x" data-title="image-20231127225725016" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ul>
<li>
<p>$A^+$的性质</p>
<ul>
<li><font color="red">$A^+$存在且唯一</font></li>
<li>$A^+=A_m^-AA_l^-$</li>
</ul>
</li>
<li>
<p>定理1</p>
<p>设$A$是$m\times n$矩阵，则$G$是加号逆$A^+$的充分必要条件为$x=Gb$是不相容线性方程组$Ax=b$的极小最小二乘解。</p>
</li>
<li>
<p><font color="red">重点</font></p>
<p>因为加号逆满足四个条件，所以它也是减号逆、最小二乘广义逆、极小范数广义逆。所以：</p>
<ol>
<li>
<p>当$b\in R(A)$时，$Ax=b$的通解为：
$$
x=A^+b+(I-A^+A)y,\forall y\in R^n
$$</p>
</li>
<li>
<p>当$b\in R(A)$时，$Ax=b$的极小范数解为：
$$
x=A^+b
$$
<font color="red">极小范数解是唯一的</font></p>
</li>
<li>
<p>对于$\forall b$，$Ax=b$的最小二乘解为：
$$
x=A^+b+(I-A^+A)y,\forall y\in R^n
$$</p>
</li>
<li>
<p>对于$\forall b$，$Ax=b$的具有极小范数的最小二乘解为：
$$
x=A^+b
$$</p>
</li>
</ol>
</li>
<li>
<p>求解$A^+$</p>
<ol>
<li>若$A$为行满秩矩阵，则：$A^+=A^H(AA^H)^{-1}$</li>
<li>若$A$为列满秩矩阵：则：$A^+=(A^HA)^{-1}A^H$</li>
<li>否则利用满秩分解求解：$A^+=G^+F^+=G^H(GG^H)^{-1}(F^HF)^{-1}F^H$</li>
</ol>
<p>Python代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Symbol</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_A_plus</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">A_plus</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 判断A是行满秩还是列满秩，如果都不是则利用满秩分解求解A_plus</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A为行满秩矩阵&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">A_plus</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">A</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A为列满秩矩阵&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">A_plus</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">H</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A为非满秩矩阵&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 利用满秩分解求解A_plus，full_rank在另一篇矩阵论复习博客中</span>
</span></span><span class="line"><span class="cl">        <span class="n">F</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="n">full_rank</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">A_plus</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="p">((</span><span class="n">G</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">())</span> <span class="o">*</span> <span class="p">((</span><span class="n">F</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">())</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">H</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">A_plus</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>利用$A^+$求解线性方程组$Ax=b$</p>
<ol>
<li>$Ax=b$有解（相容）的充要条件是$AA^+b=b$</li>
<li>$x=A^+b+(I-A^+A)y,\forall y\in C^n$是相容方程组$Ax=b$的通解，或是不相容方程组$Ax=b$的全部最小二乘解</li>
<li>$x_0=A^+b$是相容方程组$Ax=b$的唯一极小范数解，或是不相容方程组$Ax=b$的唯一极小范数最小二乘解</li>
</ol>
<p>Python代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Symbol</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_solution</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">A_plus</span> <span class="o">=</span> <span class="n">get_A_plus</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 单位矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">I</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">A_plus</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;I:&#34;</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 生成符号列表</span>
</span></span><span class="line"><span class="cl">    <span class="n">symbols_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;y</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_plus</span><span class="o">.</span><span class="n">rows</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 生成符号矩阵</span>
</span></span><span class="line"><span class="cl">    <span class="n">symbols_matrix</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">symbols_list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;symbols_matrix:&#34;</span><span class="p">,</span> <span class="n">symbols_matrix</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">A</span> <span class="o">*</span> <span class="n">A_plus</span> <span class="o">*</span> <span class="n">b</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Ax = b有解&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;通解为：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">A_plus</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">A_plus</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">A_plus</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">symbols_matrix</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;唯一极小范数解为：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">A_plus</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Ax = b无解&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;全部最小二乘解为：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">A_plus</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">A_plus</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">A_plus</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">symbols_matrix</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;唯一极小范数最小二乘解：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">A_plus</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">get_solution</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></description></item></channel></rss>