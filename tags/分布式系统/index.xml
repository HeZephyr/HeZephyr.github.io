<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>分布式系统 - 标签 | ZephyrHe</title><link>https://hezephyr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link><description>分布式系统 - 标签 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Mon, 14 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="self" type="application/rss+xml"/><item><title>分布式系统理论详解：CAP、BASE、PACELC</title><link>https://hezephyr.github.io/posts/10.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/</link><pubDate>Mon, 14 Oct 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/10.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/</guid><description><![CDATA[<h2 id="cap理论" class="heading-element"><span>1 CAP理论</span>
  <a href="#cap%e7%90%86%e8%ae%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>CAP理论是分布式系统领域中被广泛讨论的一个理论，由 Eric Brewer 在 2000 年提出，一般系统架构师会把其作为衡量系统设计的准则，其中CAP是一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）的缩写。</p>
<ul>
<li><strong>一致性（C）</strong>：这里特指强一致性，即任何时刻都可以读到最近一次成功更新的副本数据。</li>
<li><strong>可用性（A）</strong>：指系统中一部分节点故障后，系统还能提供服务。</li>
<li><strong>分区容错性（P）</strong>：指系统能够在网络分区（网络故障导致不同节点分布在不同的子网络，各个子网络内网络正常）的情况下还能提供服务。</li>
</ul>
<p>它指出在一个分布式系统中，<font color="red">C、A和P这三个特性不能同时被满足，最多只能同时满足其中的两个</font>。</p>
<blockquote>
<p>反证例子：</p>
<p>该系统由 A、B、C 三个节点构成，因 C 节点故障引发网络分区问题。若要完全满足 CAP 理论中的一致性要求，当客户端进行数据写入时，A 节点必须等待 C 节点同步完成，方可向客户端返回写入成功。</p>
<p>然而此时 C 节点已故障，数据注定无法写入。在此情况下，若出现读取该数据的请求，仅有两种应对之策：</p>
<ol>
<li>放弃可用性，即等待所有节点数据达成一致状态，确保任意节点返回的数据相同，但此时系统必然无法及时响应；</li>
<li>放弃一致性，向客户端返回已写入 A、B 节点的新数据，不过后续 C 节点恢复后，当请求到达 C 节点时，会出现读取到的数据不一致的情况。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014210027442.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014210027442.png?size=small" data-sub-html="<h2>image-20241014210027442</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014210027442.png" alt="image-20241014210027442" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014210027442.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014210027442.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014210027442.png?size=large 2x" data-title="image-20241014210027442" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
<p>所以在实际的分布式系统设计中，我们需要根据具体的业务需求来进行取舍。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014205142852.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014205142852.png?size=small" data-sub-html="<h2>image-20241014205142852</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014205142852.png" alt="image-20241014205142852" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014205142852.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014205142852.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014205142852.png?size=large 2x" data-title="image-20241014205142852" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li><font color="red">选择 AP 意味着舍弃强一致性，以保证高可用性和分区容错性</font>。这种设计在大部分分布式系统中较为常见，在 AP 架构下，系统能够快速响应客户端的请求，即使在网络分区的情况下，也能尽量保证部分节点可用，从而为用户提供不间断的服务。然而，由于放弃了强一致性，可能会导致不同节点上的数据在同一时刻不一致，但可以通过后续的同步过程逐渐达到最终一致性。</li>
<li><font color="red">选择 CP 意味着舍弃高可用性，以保证强一致性和分区容错性</font>。在这种架构下，系统会优先确保数据的一致性，即使在网络分区的情况下，也会暂停部分节点的服务以保证数据的一致性。例如，一些数据库会在网络分区发生时，停止对不一致数据的读写操作，直到所有节点的数据达成一致。这种架构适用于对数据一致性要求极高的场景，如金融交易系统等。</li>
<li><font color="red">选择CA意味着舍弃P，以保证高可用性和强一致性</font>。这种情况在分布式系统中几乎不存在，因为网络分区在分布式系统中是必然的，P是分布式系统的前提。</li>
</ol>
<blockquote>
<p>从图中我们可以发现，关系型数据库多为CA架构，<font color="red">因为关系型数据库通常采用集中式或主从复制的架构，在设计上更注重数据的一致性和事务的完整性，对于可用性也有较高的要求</font>，所以传统的关系型数据库通常在单一数据中心或较小规模的环境下运行，网络分区的情况相对较少。而在分布式系统中，由于节点众多且分布在不同的物理位置，网络分区的可能性大大增加，所以很难同时保证高可用性和强一致性，因此在 AP 和 CP 中较少出现关系型数据库。</p>
</blockquote>
<h2 id="base-理论" class="heading-element"><span>2 BASE 理论</span>
  <a href="#base-%e7%90%86%e8%ae%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>BASE理论是由 eBay 的架构师 Dan Pritchett 在 2008 年提出的，能适用于大型高可用可扩展的分布式系统。该理论提出了三个概念：</p>
<ol>
<li><code>BA</code>：<code>Basically Available</code>（基本可用）。当系统出现故障或意外情况时，允许放弃掉部分可用性，保证核心功能可用，例如大促时降级策略等。</li>
<li><code>S</code>：<code>Soft state</code>（软状态）。允许系统存在中间状态，并且该中间状态不会影响系统整体可用性。</li>
<li><code>E</code>：<code>Eventually consistent</code>（最终一致性）。指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。<font color="red">即意味着中间状态，只会短暂存在，在一定时间后，肯定会变成最终状态</font>。</li>
</ol>
<blockquote>
<p>在彻底认识BASE理论之前，我们需要回顾传统关系型数据库的<code>ACID</code>理论，即：</p>
<ul>
<li><strong>“Atomicity”（原子性）</strong>：将组成事务的多个操作视作一个不可分割的整体，要么全部成功，要么全部失败，不能仅部分生效。</li>
<li><strong>“Consistency”（一致性）</strong>：事务执行前后，数据库只能从一个一致状态转变为另一个一致状态，即事务执行对整体数据产生的变化是一致的。</li>
<li><strong>“Isolation”（隔离性）</strong>：多事务并发执行时，各事务之间不能被其他事务干扰，就如同每个事务都在独立的沙箱中执行。</li>
<li><strong>“Durability”（持久性）</strong>：一旦事务提交，无论发生何种状况（如故障、宕机等），该事务对数据的变更都会永久保存。</li>
</ul>
</blockquote>
<p>BASE不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p>
<blockquote>
<p>如果<code>ACID</code>为分布式数据库提供了一致性选择，那如何在分布式数据库里保证可用性呢？一个答案就是<code>BASE</code>理论。</p>
</blockquote>
<p>所以很多人会认BASE理论是在CAP基础上，满足AP后对C方面的拓展与延伸，但这其实并不完全正确，<font color="red">BASE并非CAP的延伸理论，它是分布式场景中ACID理论的替代品</font>。CAP的一致性，关注的是数据一致性；BASE的一致性，关注的是状态一致性，与ACID中的一致性是相同概念。</p>
<h2 id="pacelc理论" class="heading-element"><span>3 PACELC理论</span>
  <a href="#pacelc%e7%90%86%e8%ae%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>PACELC（前者是CAP，后者是ELC，else-&gt;latency or consistency）理论才是CAP理论的扩展，由Daniel J. Abadi提出，进一步拓展了CAP理论。它考虑的是这样一个问题：系统在大部分时间下，分区都是平稳运行的，并不会出错，在这种情况下，系统设计要均衡的其实就是延迟与数据一致性的问题，为了保证数据一致性，写入与读取的延迟就会增高。这就引出了 PACELC 理论。</p>
<blockquote>
<p>如果有分区(P)，系统就必须在可用性（A）和一致性（C）之间权衡; 否则当系统运行在无分区情况下,系统需要在延迟（L）和 一致性（C）之间权衡。</p>
</blockquote>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014231953269.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014231953269.png?size=small" data-sub-html="<h2>image-20241014231953269</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014231953269.png" alt="image-20241014231953269" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014231953269.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014231953269.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241014231953269.png?size=large 2x" data-title="image-20241014231953269" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如今的分布式系统设计指导理论应该采用PACELC理论，来替代CAP理论，因为它不仅关注网络分区的极端情况，还涵盖了系统在正常运行时的表现。即使没有网络分区，系统设计依然要考虑在延迟和一致性上的取舍。对于现代分布式系统而言，延迟与一致性之间的平衡往往是影响用户体验和系统性能的关键问题。</p>
]]></description></item><item><title>【论文阅读笔记】Bigtable: A Distributed Storage System for Structured Data</title><link>https://hezephyr.github.io/posts/11.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0bigtable/</link><pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/11.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0bigtable/</guid><description><![CDATA[<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Bigtable 是 Google 设计的用于<font color="red">管理结构化数据</font>的分布式存储系统，可扩展到数千台服务器存储 PB 级数据。<font color="red">它不是关系数据库，而是一种稀疏、分布式、持久性多维排序映射（K/V）</font>。</p>
<p>Bigtable被 60 多个 Google 产品使用，涵盖不同数据规模和延迟要求的应用，这得益于 BigTable 提供的简单数据模型可以使<strong>客户端动态控制</strong>数据的<strong>布局和格式</strong>。</p>
<h2 id="数据模型" class="heading-element"><span>2 数据模型</span>
  <a href="#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>一个 Bigtable 就是一个<strong>稀疏、分布式、持久</strong>的<strong>多维有序</strong>映射表（map），数据通过<strong>行键、列键和一个时间戳</strong>进行索引，表中的每个数据项都是<strong>不作理解的字节数组</strong>。形如：</p>
<blockquote>
<p><code>(row:string, column:string, time:int64) -&gt; string</code></p>
</blockquote>
<p>假设我们想要拷贝一个可能被很多项目都使用的、很大的网页集合以及相关的信息，让我们把这个特定的表称为Webtable。在Webtable当中，我们用网页的 URL 作为行键，网页某些信息作为列键，将网页内容存储在 <code>contents:</code> 列，并记录抓取网页时对应的时间戳，最终存储布局如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_data_model?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_data_model?size=small" data-sub-html="<h2>image-20241013134206507</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_data_model" alt="image-20241013134206507" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_data_model?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_data_model?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_data_model?size=large 2x" data-title="image-20241013134206507" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="行" class="heading-element"><span>2.1 行</span>
  <a href="#%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>行键为任意字符串（最大64KB，多数用户使用的在10 - 100字节），<font color="red">单行数据读/写操作是原子的</font>，这里类似Mysql的行锁，锁粒度并没有达到列级别，便于推断并发更新同一行时系统行为。</p>
<p>Bigtable按行键的字典序组织数据，动态划分行范围，<strong>每个行范围是一个tablet</strong>，作为请求分散和负载均衡的最小单位，这样读取小行范围高效，只需与少量机器通信，而且可以选择合适的行键有效的利用数据的位置相关性。</p>
<p>例如Webtable中，反转URL的hostname字段，相同域的页面存为连续行，如<code>www.google.com</code>存为<code>com.google.www</code>，可提高主机和域分析效率。</p>
<h3 id="列族" class="heading-element"><span>2.2 列族</span>
  <a href="#%e5%88%97%e6%97%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>多个列键可以组织成列族，<font color="red">列族是访问控制的基本单位</font>。一般来说，存放在同一列族的数据通常都属于同一类型。</p>
<p>必须先创建一个列族，才能向这个列族内的列写入数据，创建完成后，就可以使用其中的列键。一张tablet的列族最多几百个，且很少改变，但列的数量没有限制。</p>
<p><strong>列键的格式</strong>：<code>列族:限定词</code>。例如Webtable中有一个<strong>列族</strong>是<code>anchor</code>，这个列族的每一个列键代表一个锚链接，<code>anchor</code>列族的<strong>限定值</strong>是引用这个网页的站点名，对应的数据项内容是链接的文本。</p>
<p><strong>访问控制、磁盘和内存记账都是在列族层面做的</strong>。</p>
<h3 id="时间戳" class="heading-element"><span>2.3 时间戳</span>
  <a href="#%e6%97%b6%e9%97%b4%e6%88%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">Bigtable中的每个数据均可存储多个版本，不同版本通过时间戳索引</font>。 时间戳为64位整数，可由Bigtable指定，此时为毫秒级的真实时间戳；也可由客户端应用指定，为避免冲突，应用必须确保时间戳的唯一性。</p>
<p>为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，使Bigtable能够自动进行垃圾回收。</p>
<ul>
<li>保留最后的$N$个版本；</li>
<li>保留最近某段时间内的版本。</li>
</ul>
<p>在Webtable中，每个页面的时间戳为该页面被爬取时的时间，我们设置只保留最后的3个版本。</p>
<h2 id="api" class="heading-element"><span>3 API</span>
  <a href="#api" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Bigtable API提供了创建和删除表和列族的功能。它还提供用于修改集群、表和列族元数据的功能，比如如访问控制权限。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_API?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_API?size=small" data-sub-html="<h2>image-20241013155434953</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_API" alt="image-20241013155434953" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_API?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_API?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/Bigtable_API?size=large 2x" data-title="image-20241013155434953" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>Bigtable还支持一些其它的特性，利用这些特性，用户可以对数据进行更复杂的处理。</p>
<ol>
<li>支持单行上的事务处理。</li>
<li>允许把数据项做整数计数器：<code>Increment(row_key, column_key, increment)</code>。</li>
<li>Bigtable允许用户在服务器地址空间上执行脚本程序。</li>
<li>Bigtable提供一些Wrapper类，其可以作为MapReduce框架的输入输出。</li>
</ol>
<h2 id="基础构建" class="heading-element"><span>4 基础构建</span>
  <a href="#%e5%9f%ba%e7%a1%80%e6%9e%84%e5%bb%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Bigtable 构建在其他几个 Google 的基础设施之上。</p>
<ul>
<li>GFS</li>
<li>SSTable</li>
<li>Chubby</li>
</ul>
<h3 id="gfs" class="heading-element"><span>4.1 GFS</span>
  <a href="#gfs" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Bigtable使用GFS<strong>存储日志文件和数据文件</strong>，<font color="red">Bigtable集群通常和其他一些分布式应用共享一个服务器资源池</font>，依靠集群管理系统做任务调度、资源管理、故障处理和机器监控等。</p>
<h3 id="sstable" class="heading-element"><span>4.2 SSTable</span>
  <a href="#sstable" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Bigtable <strong>内部使用 Google 的 SSTable 格式存储数据</strong>。SSTable是一个持久化、排序的、不可更改的Map结构。从内部看，SSTable是一系列的数据块，并通过块索引（存储在SSTable的末尾）定位，块索引在打开SSTable时加载到内存中，一次查询只需要一次磁盘寻址：首先在<strong>内存</strong>中通过二分查找找到块索引，然后定位到数据块在<strong>磁盘</strong>中的位置，从<strong>磁盘</strong>读取相应的数据。<font color="red">也可以直接将整个SSTable映射到内存</font>，这样查询就不需要磁盘操作了。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013160712962.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013160712962.png?size=small" data-sub-html="<h2>image-20241013160712962</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013160712962.png" alt="image-20241013160712962" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013160712962.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013160712962.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013160712962.png?size=large 2x" data-title="image-20241013160712962" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="chubby" class="heading-element"><span>4.3 Chubby</span>
  <a href="#chubby" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Bigtable还依赖一个<strong>高可用的、持久的分布式锁服务Chubby</strong>（类Zookeeper）。Chubby服务维护5个活动副本，其中一个选为Master并对外提供服务，并通过Paxos算法来保证副本一致性。</p>
<p>另外Chubby提供一个包含<strong>目录和小文件</strong>命名空间，<strong>每个目录或文件都可以作为一个锁</strong>，读或写一个文件是<strong>原子的</strong>。Chubby客户端维护了这些文件的一致性缓存。</p>
<p>每个 Chubby 客户端都会和 Chubby 服务维持一个 Session。当一个客户端的租约到期 并且无法续约时，这个 Session 就失效了，失效会失去它之前的锁和打开的文件句柄。Chubby 客户端还可以在 Chubby 文件和目录上注册回调函数，当文件/目录有变化或者 Session 过期时，就会收到通知。</p>
<p>Bigtable使用Chubby来完成几个任务：</p>
<ol>
<li>确保任意时间只有一个活动Master副本。</li>
<li>存储数据的引导位置（根tablet）。</li>
<li>发现Tablet服务器并最终确定tablet服务器死亡。</li>
<li>存储Bigtable模式信息（每个表的列族信息）。</li>
<li>存储访问控制列表等</li>
</ol>
<blockquote>
<p><font color="red">Chubby不可用 = Bigtable不可用</font></p>
</blockquote>
<h2 id="实现" class="heading-element"><span>5 实现</span>
  <a href="#%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Bigtable包括3个主要的组件：</p>
<ol>
<li>链接到每个客户端的库。</li>
<li>1个master服务器。</li>
<li>多个tablet服务器。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/BigTable_Component?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/BigTable_Component?size=small" data-sub-html="<h2>image-20241013203213146</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/BigTable_Component" alt="image-20241013203213146" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/BigTable_Component?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/BigTable_Component?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/BigTable_Component?size=large 2x" data-title="image-20241013203213146" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>master服务器职责：</p>
<ul>
<li>将tablet分配给tablet服务器。</li>
<li>检测tablet服务器的过期及添加事件。</li>
<li>对tablet服务器负载均衡。</li>
<li>对GFS中的文件的进行垃圾回收。</li>
<li>处理模式变化，如创建表、创建 / 删除列族。</li>
</ul>
<p>tablet服务器职责：</p>
<ul>
<li>管理一组tablets（10~1000个tablet）。</li>
<li>处理对 tablets 的读写请求。</li>
<li>当 tablets 增长过大（100 - 200MB）时进行分裂。</li>
</ul>
<p><font color="red">客户端不依赖master获取 tablet 位置信息，直接与 tablet 服务器进行读写通信</font>，故Master的负载很低。</p>
<p>每个 Bigtable 集群会有很多张 table，每张 table 会有很多 tablets，每个 tablets 包 含一个行键范围内的全部数据。 初始时每个 table 只包含一个 tablet。当 table 逐渐变大时，它会自动分裂成多个 tablets，<strong>默认情况下每个 tablet 大约 100-200MB</strong>。</p>
<h3 id="tablet-位置" class="heading-element"><span>5.1 Tablet 位置</span>
  <a href="#tablet-%e4%bd%8d%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用<font color="red">类似B+树的三层结构</font>存储Tablet的位置信息，如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013204350023.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013204350023.png?size=small" data-sub-html="<h2>image-20241013204350023</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013204350023.png" alt="image-20241013204350023" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013204350023.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013204350023.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013204350023.png?size=large 2x" data-title="image-20241013204350023" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ul>
<li>第一层：存储在<strong>Chubby 中的文件</strong>，其中包含了根tablet的位置。所以一旦Chubby服务不可用，整个Bigtable丢失了根tablet的位置，整个服务就不可用。</li>
<li>第二层：<strong>根tablet</strong>，实际上就是元数据表的第一个tablet，保存着元数据表其他tablet的位置信息，根tablet很特殊，为了保证整个树的深度不变，根tablet从不分裂。</li>
<li>第三层：<strong>其他元数据表的tablet</strong>，每个都包含了一组用户tablet位置信息集合。这些tablet与根tablet共同构成整个元数据表。</li>
</ul>
<p>在元数据表内，<font color="red">每个Tablet的位置信息都存储在一个行键下，行键是通过tablet所在表的标识符和最后一行生成的</font>。</p>
<p>元数据表每一行都存储约1KB内存数据，即在一个128MB的元数据表中，采用这种3层存储结构，可寻址$2^34$个Tablets。</p>
<p>用户程序使用的库会缓存Tablet的位置信息，如果某个Tablet位置信息没有缓存或缓存失效，那么客户端会在树状存储结构中递归查询tablet位置信息，包括：</p>
<ol>
<li>请求Chubby提供根tablet位置。</li>
<li>请求根tablet提供其他元数据tablet位置。</li>
<li>请求元数据tablet获取用户tablet位置。</li>
</ol>
<p>尽管tablet的位置信息是存放在内存里的，对它的操作不必访问GFS文件系统，但通常还是会预取Tablet地址来进一步减少访问的开销。</p>
<h3 id="tablet-分配" class="heading-element"><span>5.2 Tablet 分配</span>
  <a href="#tablet-%e5%88%86%e9%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><strong>每个 tablet 每次只会分配给一个 tablet服务器</strong>。这个由master来控制分配，master会跟踪：</p>
<ul>
<li>tablet服务器集的存活状态（通过Chubby跟踪，启动时会在<strong>在特定的 Chubby 目录下创建和获取一个名字唯一的独占锁</strong>。 master 通过<strong>监听这个目录</strong>来发现 tablet服务器集）。</li>
<li>tablet到tablet服务器的当前分配。</li>
<li>当前为分配的tablet。</li>
</ul>
<p>当某个 Tablet 未分配时，master 通过向可用的tablet服务器发送加载请求，将tablet分配给该tablet服务器。</p>
<p>当tablet服务器不提供服务时，master会通过<font color="red">轮询Chubby上tablet服务器文件锁的状态</font>检查出来，确认后会删除其在Chubby上的文件锁，使其不再提供服务。删除后，master就把之前分配给它的所有的tablet放入未分配的tablet集合中。</p>
<p>当集群管理系统启动了一个master服务器之后，master首先要了解当前tablet的分配状态，之后才能够修改分配状态。master服务器在启动的时候执行以下步骤：</p>
<ol>
<li>从Chubby获取一个唯一的master锁，保证Chubby只有一个master实例。</li>
<li>扫描Chubby的<code>servers</code>目录，获取当前正在运行的服务器列表。</li>
<li>和所有的正在运行的tablet服务器通信，获取每个tablet服务器上tablet的分配信息。</li>
<li>扫描元数据表获取所有的tablet的集合。在扫描的过程中，如果发现还有未分配的tablet，master就将这个tablet加入未分配的tablet集合并等待合适的时机分配。</li>
</ol>
<p><font color="red">一个复杂的情况是在分配元数据tablet之前，无法对元数据表表进行扫描</font>。</p>
<p>因此，如果在步骤3中发现根tablet还没有被分配出去，那master就要先把它放到未分配的tablet集合，然后去执行步骤4，这样就保证了根tablet会被分配出去。</p>
<p>由于根tablet包括了所有元数据tablet的名字，因此master服务器扫描完根tablet以后，就得到了所有的元数据表表的Tablet的名字了。</p>
<p>只有在发生以下情况时，当前的 tablets 集合才会有变化：</p>
<ol>
<li>创建或删除一个 table。</li>
<li>两个 tablets 被合并了</li>
<li>一个 tablet 分裂成两个小的tablet。</li>
</ol>
<p>Master可以跟踪记录所有这些事件，因为除了最后一个事件外的两个事件都是由它启动的。</p>
<p><font color="red">tablet分裂事件需要特殊处理，因为它是由Tablet服务器启动</font>。在分裂操作完成之后，tablet服务器将新的tablet信息记录到元数据表，然后提交这次分裂。提交后，master会收到通知。如果通知丢失（由于tablet服务器或者master挂掉），master会在它下次要求一个tablet服务器加载tablet时发现，这个 tablet 服务器会将这次分裂信息通知给 master，因为它在元数据表中发现的 tablets 项只覆盖 master 要求它加载的 tablets 一部分。</p>
<h3 id="为-tablet-提供服务" class="heading-element"><span>5.3 为 tablet 提供服务</span>
  <a href="#%e4%b8%ba-tablet-%e6%8f%90%e4%be%9b%e6%9c%8d%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>如下图所示，Tablet的持久化状态信息保存在GFS上。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013215922693.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013215922693.png?size=small" data-sub-html="<h2>image-20241013215922693</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013215922693.png" alt="image-20241013215922693" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013215922693.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013215922693.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013215922693.png?size=large 2x" data-title="image-20241013215922693" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>更新会提交到一个提交日志文件，其中保存了redo记录，更新操作分2类：</p>
<ul>
<li>最近提交的更新操作会存放在一个排序缓存中，称为<code>memtable</code>。</li>
<li>其他老一些的更新存储在 SSTable 中，落地在GFS上。</li>
</ul>
<p>为了恢复一个tablet，tablet服务器从元数据表当中读取这个tablet的元数据。《这个元数据包含了SSTable列表，<font color="red">其中每个SSTable都包括一个tablet和一个重做点（redo point）的集合，这些redo point是一些指针，它们指向那些可能包含tablet所需数据的重做日志</font>。服务器把SSTable索引读入内存，执行重做点以后的所有已经提交的更新来重建memtable。</p>
<p>当一个写操作到达tablet服务器时，它会检查写操作是否格式正确且发送者是否有权限执行此操作。鉴权的实现方式是<font color="red">从Chubby文件读取允许的写者列表</font>，这个Chubby文件通常总能够在Chubby客户端缓存中找到。</p>
<p>一个有效的变更会被写入提交日志中。批量提交是为了优化许多小变更操作的吞吐量。<font color="red">在写操作已经被提交以后，它的内容就会被插入到memtable</font>。</p>
<p>一次读操作到达 tablet server 时，也会执行类似的格式检查和鉴权。一个有效地读操作是在一系列SSTable和memtable的合并视图上执行的（都是字典序排序，可高效生成合并视图）。</p>
<p><font color="red">当tablet发生合并或分裂操作时，正在到达的读写操作仍然可以继续进行</font>。</p>
<h3 id="压缩" class="heading-element"><span>5.4 压缩</span>
  <a href="#%e5%8e%8b%e7%bc%a9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>####.1 小压缩</p>
<p>当<code>memtable</code>大小达到一个阈值时，<code>memtable</code>会被冻结，并创建一个新的<code>memtable</code>，这个冻结的<code>memtable</code>会转换为SSTable并写入GFS，这个过程称为<font color="red">小压缩</font>。</p>
<p>小压缩过程为了减少tablet服务器的内存使用量，以及减少在灾难恢复时从提交日志读取的数据量。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013221244565.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013221244565.png?size=small" data-sub-html="<h2>image-20241013221244565</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013221244565.png" alt="image-20241013221244565" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013221244565.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013221244565.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013221244565.png?size=large 2x" data-title="image-20241013221244565" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>####.2 主压缩</p>
<p>每次小压缩都会创建一个新SSTable，如果不加额外处理，SSTable数量过多而影响读操作（需要合并多个SSTable才能读到需要的内容）。所以Bigtable会定期合并SSTable文件来限制其数量，这个过程称为<font color="red">主压缩</font>。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013222419239.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013222419239.png?size=small" data-sub-html="<h2>image-20241013222419239</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013222419239.png" alt="image-20241013222419239" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013222419239.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013222419239.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013222419239.png?size=large 2x" data-title="image-20241013222419239" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>非主压缩所产生的SSTable会包含特殊的删除信息（entry），用于标记其中已经被删除的数据 —— 实际上这些数据还没有被真正删除，只是标记为已删除。而 主压缩产生的 SSTable 不会包含这些删除信息或者已删除的数据。</p>
<p>BigTable定期检查它的所有tablet，并执行主压缩操作。<font color="red">这些主压缩过程可以允许BigTable及时回收被删除数据占用的资源，并且保证被删除数据在一定时间内就可以及时的从系统中消失</font>，这对于一些存储敏感数据的服务来说是非常重要的。</p>
<h2 id="优化" class="heading-element"><span>6 优化</span>
  <a href="#%e4%bc%98%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="局部性组" class="heading-element"><span>6.1 局部性组</span>
  <a href="#%e5%b1%80%e9%83%a8%e6%80%a7%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端可以将多个列族组合成一个局部性组，<font color="red">每个tablet会为每个局部性组生成一个单独的SSTable</font>，将一般不会一起访问的列族划分到不同的局部性组能提高读取效率。</p>
<p>此外，可以基于局部性组<strong>专门设定一些调优参数</strong>，如是否存储于内存等。</p>
<h3 id="压缩-1" class="heading-element"><span>6.2 压缩</span>
  <a href="#%e5%8e%8b%e7%bc%a9-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端可以控制某个局部性组的SSTable 是否需要压缩，以及用什么格式压缩。很多客户端都使用一种自定义的双通压缩算法：</p>
<ul>
<li>先使用 Bentley-Mcilroy 算法压缩大窗口内的长公共前缀。</li>
<li>再使用一个快速算法压缩 16KB 窗口内的重复字符串。</li>
</ul>
<h3 id="缓存" class="heading-element"><span>6.3 缓存</span>
  <a href="#%e7%bc%93%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>tablet服务器可以使用二级缓存策略来提高读操作性能。两级的缓存针对性不同：</p>
<ul>
<li>第一级缓存为<strong>扫描缓存</strong>：缓存tablet服务器通过SSTable接口获取的Key-Value对（时间局部性：适用于<strong>频繁访问相同数据</strong>的应用）</li>
<li>第二级缓存为<strong>块缓存</strong>：缓存从GFS读取的SSTable块（空间局部性：适用于<strong>连续访问相邻（相近）数据</strong>的应用。）</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013224524700.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013224524700.png?size=small" data-sub-html="<h2>image-20241013224524700</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013224524700.png" alt="image-20241013224524700" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013224524700.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013224524700.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013224524700.png?size=large 2x" data-title="image-20241013224524700" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="布隆过滤器" class="heading-element"><span>6.4 布隆过滤器</span>
  <a href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个读操作必须读取构成tablet状态的所有SSTable数据，故如果这些SSTable不在内存便需多次访问磁盘。我们通过允许客户端对特定局部性组的SSTable指定布隆过滤器来降低访问次数。<strong>Bloom 过滤器可以判断一个 SSTable 是否包含指定行/列对对应的 数据</strong>。对于特定的应用来说，给 tablet服务器增加少量内存用于存储 Bloom 过滤器，就 可以<strong>极大地减少读操作的磁盘访问</strong>。</p>
<p>使用Bloom过滤器也可以隐式的达到了当查询的行和列不存在时，不需要访问磁盘。</p>
<h3 id="commit日志实现" class="heading-element"><span>6.5 Commit日志实现</span>
  <a href="#commit%e6%97%a5%e5%bf%97%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>如果每个tablet操作的Commit日志单独写一个文件，会导致日志文件数过多，会导致底层 GFS 大量文件的并发写。另外，每个 tablet 一个 log 文件的设计还会降低组提交（group commit，批量提交）优化的有效性，因为每个组都会很小。</p>
<p>因此，为了克服以上问题，<font color="red">我们为每个 tablet服务器维护一个commit log，将属于这个 tablet服务器的不同的 tablet 操作都写入这同一个物理上的 log 文件</font>。</p>
<p>这种方式使得常规操作的性能得到了很大提升，但是，它使 tablet 恢复过程变得复杂。当一台tablet服务器挂了，需要将其上面的tablet均匀恢复到其他Tablet服务器，则其他服务器都得读取完整的Commit日志。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013225806000.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013225806000.png?size=small" data-sub-html="<h2>image-20241013225806000</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013225806000.png" alt="image-20241013225806000" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013225806000.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013225806000.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241013225806000.png?size=large 2x" data-title="image-20241013225806000" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了避免多次读Commit日志，我们将日志按关键字<code>(table; row name; log sequence number)</code>排序，让同一个tablet的操作日志连续存放。</p>
<h3 id="tablet恢复提速" class="heading-element"><span>6.6 Tablet恢复提速</span>
  <a href="#tablet%e6%81%a2%e5%a4%8d%e6%8f%90%e9%80%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>master转移Tablet时，源tablet服务器会对这个Tablet做一次小压缩，在此压缩后，源tablet服务器停止为tablet服务。在卸载tablet之前，源tablet服务器会执行另一个（非常快）的小压缩，<font color="red">以消除在第一个小压缩时到达的tablet服务器日志中任何未经压缩的状态</font>。然后tablet就可以装载到新的tablet服务器上了，并且不需要从日志中进行恢复。</p>
<h3 id="利用不变性" class="heading-element"><span>6.7 利用不变性</span>
  <a href="#%e5%88%a9%e7%94%a8%e4%b8%8d%e5%8f%98%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于生成的所有SSTables都是不可变的，因此Bigtable系统的各个部分都得到了简化。</p>
<ul>
<li>从SStable读取时无需同步$\rightarrow$对行进行简单的并发控制。</li>
<li>读取和写入访问的唯一可变数据结构是<code>memtable</code>$\rightarrow$每个<code>memtable</code>行使用写时复制并允许读取和写入并行进行。</li>
<li>每个 tablet 的 SSTable 会注册到元数据表。master 会对过期的 SSTable 进行先标记后清除，其中元数据表记录了这些 SSTable 的对应的 tablet 的 root。</li>
<li>最后，<strong>SSTable 的不可变性使得 tablet 分裂过程更快</strong>。我们直接让子 tablet 共享父 tablet 的 SSTable ，而不是为每个子 tablet 分别创建一个新的 SSTable。</li>
</ul>
]]></description></item><item><title>【论文阅读笔记】The Chubby lock service for loosely-coupled distributed systems</title><link>https://hezephyr.github.io/posts/10.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0chubby/</link><pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/10.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0chubby/</guid><description><![CDATA[<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Chubby是一个<strong>面向松耦合分布式</strong>系统的锁服务，被广泛应用于Google内部的多个关键系统中，如GFS（Google文件系统）和Bigtable。在GFS中，Chubby用于指定主服务器；而在Bigtable中，它不仅支持主服务器选举、帮助主服务器发现其所管理的子服务器以及协助客户端定位主服务器，还充当了少量元数据存储的角色。
Chubby允许客户端同步活动并就环境基本信息达成一致。主要目标包括可靠性、对大量客户端的可用性以及易于理解的语义，吞吐量和存储容量是次要考虑因素。
值得注意的是，Chubby并非基于全新的算法理论构建而成，而是将已有的Paxos一致性算法作为实现基础，通过工程上的优化来满足实际应用场景下的需求。
Chubby向用户暴露了一套类似于UNIX文件系统的API接口，应用不仅能对Chubby服务器上的整个文件进行读写操作，还可以添加对文件节点的锁控制。此外，Chubby还引入了事件订阅机制，允许客户端注册监听某些类型的数据变更通知，一旦相关文件或目录发生更新，则会立即接收到由服务端推送的通知消息。</p>
<h2 id="设计目标" class="heading-element"><span>2 设计目标</span>
  <a href="#%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Chubby最初的设计者并没有将它实现为一个包含Paxos算法的协议库，而是将Chubby设计成一个需要访问中心节点（Master）的分布式锁服务，这一决策基于以下几个优势：
能像插件一样增加到现有系统中。开发者一开始可能未对高可用性做规划，锁服务器更易维护现有程序结构和通信模式。
许多服务需要一种机制来公布选举主服务器或划分数据的结果，想比name service，基于所服务的一致性客户端缓存更适合存储和获取少量数据。
基于锁的接口对程序员更熟悉。
分布式共识算法需多个副本实现高可用性，而锁服务嵌入到客户端，只需要一个机器，就能达成共识。
为了满足实际需求，Chubby设定了以下设计目标：
提供一个完整的、独立运作的分布式锁服务，而不仅仅是一个一致性协议的客户端实现。
提供粗粒度的锁服务。
除了基本的锁服务外，还支持对小文件进行读写操作。
具备高可用性和可靠性，保证即使在网络分区或硬件故障的情况下也能持续稳定运行。
引入了一种高效的事件订阅模型，允许客户端实时接收关于所关注文件变更的通知信息。这样不仅增强了系统的响应速度，也使得应用程序能够更好地适应动态变化的环境。</p>
<h2 id="chubby设计" class="heading-element"><span>3 Chubby设计</span>
  <a href="#chubby%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="系统结构" class="heading-element"><span>3.1 系统结构</span>
  <a href="#%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Chubby包含两个基本组件，一个服务器和客户端应用链接的库，通过 RPC 通信，还有第三个可选组件——代理服务器。Chubby 单元由少量服务器（通常为 5 个）组成，这些服务器称为副本，使用分布式共识协议选举Master。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012144319063.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012144319063.png?size=small" data-sub-html="<h2>image-20241012144319063</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012144319063.png" alt="image-20241012144319063" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012144319063.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012144319063.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012144319063.png?size=large 2x" data-title="image-20241012144319063" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>集群中每个服务器都维护一份服务端数据库的副本，但只有Master负责读写数据库，其他副本复制主服务器的更新。客户端通过 DNS 找到Master，Master故障时其他副本重新选举。副本故障可由替换系统选择新机器替换。</p>
<h3 id="文件目录句柄" class="heading-element"><span>3.2 文件、目录、句柄</span>
  <a href="#%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95%e5%8f%a5%e6%9f%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Chubby 的文件系统接口类似 UNIX 但更简单，是严格的文件和目录树结构，有特定命名规则。与 UNIX 不同之处在于便于分布，不暴露某些操作，不维护部分时间信息，命名空间只有文件和目录（节点），无符号或硬链接。</p>
<p>节点分永久（需显式删除）和临时（无引用则删，可检测 client 存活），可作读写锁，有相关元数据和访问控制列表（ACLs），用于控制节点的读、写和更改ACL权限。除非被覆盖，否则节点在创建时将继承其父目录的ACL名称。每个节点的元数据包含四个单调递增的 64 位数字，便于客户端轻松检测变化：</p>
<ul>
<li>
<p><strong>实例编号</strong>：用于标识创建该数据节点的顺序</p>
</li>
<li>
<p><strong>文件内容编号</strong>：用于标识文件内容的变化情况，该编号会在文件内容被写入时增加</p>
</li>
<li>
<p><strong>锁编号</strong>：用于标识节点锁状态变更情况，该编号会在节点锁从自由状态转换到被持有状态时增加</p>
</li>
<li>
<p><strong>ACL编号</strong>：用于标识节点的ACL信息变更情况，该编号会在节点的ACL配置信息被写入时增加</p>
</li>
</ul>
<p>同时，Chubby还会标识一个64位的文件内容校验码，以便客户端能够识别出文件是否变更。</p>
<p>客户端打开节点可获取类似 UNIX 文件描述符的句柄，具有以下特点：</p>
<ul>
<li>通过句柄数字，防止在创建期间的操作，只有在创建节点时才会检查，而UNIX是在打开时检查，读/写不检查</li>
<li>允许master 能够判断句柄是自身生成还是其他 master 生成。</li>
<li>若旧句柄在新 master 打开节点时出现，master 会重新创建该句柄。</li>
</ul>
<h3 id="锁和序列器" class="heading-element"><span>3.3 锁和序列器</span>
  <a href="#%e9%94%81%e5%92%8c%e5%ba%8f%e5%88%97%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Chubby 提供两种锁：写锁（排斥模式）和读锁（共享模式）。强制锁会使未持有锁的对象无法访问锁定对象，但 Chubby 未采用，而是使用建议锁，也就是说，它们只与获取同一把锁的其他尝试发生冲突：持有一个名为F的锁既不是访问文件F所必需的，也不会阻止其他客户端这样做。因为 Chubby 经常保护其他服务实现的资源，不只是与锁关联的文件，且在用户调试或管理文件时，不希望强制用户关闭应用，同时开发人员可以通过传统断言检查锁持有情况，强制检查价值不大。</p>
<p><font color="red">在分布式系统中，由于网络通信的不确定性，导致在分布式系统中锁机制变得非常复杂，消息的延迟或是乱序都有可能会引起锁的失效</font>。目前可通过虚拟时间、虚拟同步解决，但 Chubby 未采用这些复杂方式。</p>
<p>Chubby采用了序列器和锁延迟两种机制来解决上述问题，序列器指锁的持有者向Chubby服务端请求一个序列器（是一个不透明的字节串，包括锁的名称、锁的模式以及锁的生成号），然后之后在需要使用锁的时候将该序列器一并发给 Chubby 服务器，服务端检查序列器的有效性。虽然序列器机制只需要向受影响的消息添加字符串，但重要的协议发展缓慢。</p>
<p>而延迟就是客户端在非正常情况下释放锁的话，那么Chubby服务器会允许该客户端在锁延迟时间内一直持有不释放这个锁，在这段时间内，其他客户端无法获取到这个锁，可以减少由网络延迟造成的问题。</p>
<h3 id="事件通知机制和缓存" class="heading-element"><span>3.4 事件通知机制和缓存</span>
  <a href="#%e4%ba%8b%e4%bb%b6%e9%80%9a%e7%9f%a5%e6%9c%ba%e5%88%b6%e5%92%8c%e7%bc%93%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了避免大量客户端轮询Chubby服务端状态所带来的压力，Chubby提供了事件通知机制。客户端可以向服务端注册事件通知，当触发这些事件时，服务端就会异步地向客户端发送对应的事件通知。常见的Chubby事件如下：</p>
<ul>
<li><strong>文件内容变更</strong>：监视通过文件发布的服务的位置。</li>
<li><strong>节点的增加、删除、修改</strong>：用于实现镜像，发现新文件以及监视临时文件。</li>
<li><strong>Master失败</strong>：警告客户端其他事件可能已经丢失，因此需要重新扫描数据。</li>
<li><strong>句柄、或者锁变得无效了</strong>：这通常表明存在通信问题。</li>
<li><strong>锁获取成功</strong>：可用于确定Master何时被选举。</li>
<li><strong>锁获取冲突</strong>：允许锁缓存。</li>
</ul>
<p>为了减少网络I/O，Chubby的客户端使用了缓存，可以缓存文件数据和元数据。<font color="red">Chubby借助租约来保证客户端和服务端缓存的一致性</font>，每个客户端的缓存都有一个租约，一旦该租约到期，客户端就需要向服务端续订租约才能够保证缓存的有效性。</p>
<p>当文件数据或者元数据被修改时，Chubby服务端首先会阻塞该修改操作，然后由Master通知所有缓存了该信息的客户端，等到Master收到了客户端对该过期消息的应答后，再进行修改操作。Chubby通过缓存机制保证了数据的强一致性，在缓存机制下，Chubby就能够保证可回单要么从缓存中会总访问到一致的数据，要么访问出错。</p>
<h3 id="session-和-keepalive" class="heading-element"><span>3.5 Session 和 KeepAlive</span>
  <a href="#session-%e5%92%8c-keepalive" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个Chubby Session是Chubby Cell和客户端通过定期的KeepAlive握手维护的一个关系，当Session有效时，除非客户端通知Master，客户端的句柄、锁、缓存都是有效的。</p>
<p><font color="red">Master在收到一个KeepAlive RPC时，通常会阻塞该RPC直到该Client的前一个租约接近过期，然后Master再允许该RPC返回给客户端，同时告知客户端新的租约过期时间</font>。Master可以任意地延长过期时间，默认的演唱时间时12s。</p>
<p>但是一个负载过高的Master可能会使用一个更高的值来减少它所需要处理的KeepAlive RPC调用。客户端在收到响应后，就会马上发起一个新的KeepAlive，因此几乎总是有一个KeepAlive被阻塞在Master。这个KeepAlive 回复也可以用来给客户端传递事件和过期缓存，如果事件或者缓存失效发生了，Master则允许KeepAlive立即返回，同时客户端维护了一个本地租约过期时间，是Master租约过期时间的近似（为了防止Master已经关闭Session了），如果客户端本地缓存租约过期了，但此时无法确定Master是否已经结束了这个Session，客户端就需要清空并禁用它的缓存，此时Session处于jeopardy状态，客户端则会继续等待一个称为宽限期的时长，默认为45s。如果在宽限期结束之前，客户端和Master又完成了一次成功的KeepAlive交互，那么客户端就会再次使它的缓存有效，否则，客户端就假设Session已过期。</p>
<h3 id="故障转移" class="heading-element"><span>3.6 故障转移</span>
  <a href="#%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一旦Master挂了或者失去Master身份时，它就会丢掉关于它的Session，在内存中的句柄、锁、状态都没了， 转而运行一个Session本地租约计时器，等待新的Master选举出来，如果一个Master选举很快完成，客户端就可以在租约计时器过期之前联系新的Master，否则，客户端的本地超时过期后，客户端可以利用宽限期来让Session在故障转移期间得到维持，其宽限期增加了客户端的租约超时时间。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012231123862.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012231123862.png?size=small" data-sub-html="<h2>image-20241012231123862</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012231123862.png" alt="image-20241012231123862" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012231123862.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012231123862.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241012231123862.png?size=large 2x" data-title="image-20241012231123862" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>新的Master需重建其前任Master的内存状态，这一过程部分通过硬盘上存储的数据实现，部分从客户端获取状态，还有部分通过保守估计完成。数据库会记录每个Session、持有的锁以及临时文件。新当选的Master需按以下流程操作：</p>
<ol>
<li>采用一个新的epoch编号并反馈给客户端，拒绝来自旧epoch编号的客户端请求，以防新Master对发送给旧Master的陈旧数据包做出响应。</li>
<li>新Master可响应Master定位请求，但不会处理与Session相关的请求。</li>
<li>依据数据库重建Session状态和锁信息等，并延长最大的Session时间，即进行故障转移。</li>
<li>接收客户端的KeepAlive，但不响应其他操作。</li>
<li>向所有客户端发送故障转移事件，客户端会因此清空缓存（因可能已过期），并警示应用程序可能丢失了其他事件。</li>
<li>Master等待每个客户端确认故障转移事件，或者客户端Session超时。</li>
<li>Master允许所有操作正常进行。</li>
<li>若客户端使用旧句柄，新Master会在内存中重建新句柄；若重建的句柄已关闭，Master会保存该句柄，确保在其任期内无法再次重建相同句柄。</li>
<li>经过一段时间，Master会删除无句柄打开的临时文件，所以客户端需在此期间刷新临时文件的句柄。若文件上最后一个客户端在故障转移过程中丢失Session，则该文件不会立即被删除。</li>
</ol>
<h3 id="数据库实现" class="heading-element"><span>3.7 数据库实现</span>
  <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最初使用的是Berkeley DB的复制版本，它采用B +树机制，其中键为字节字符串，值可以是任意二进制数据。在Berkeley DB之上，添加了一个用于对路径名称数量进行排序的比较函数，从而使相邻节点紧密排列。Berkeley DB使用分布式共识算法来复制数据库日志。</p>
<p>后来由于维护风险等因素，自行编写了简单数据库，运用了预写日志（WAL）和快照技术。</p>
<h3 id="备份和镜像" class="heading-element"><span>3.8 备份和镜像</span>
  <a href="#%e5%a4%87%e4%bb%bd%e5%92%8c%e9%95%9c%e5%83%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个 Chubby 单元的主服务器每隔几小时将数据库快照写入不同建筑的 GFS 文件服务器，用于灾难恢复和初始化新替换副本的数据库。</p>
<p>Chubby允许文件集合从一个单元镜像到另一个单元，利用事件机制快速更新，常用于复制配置文件到全球各地的计算集群。</p>
<h2 id="扩展机制" class="heading-element"><span>4 扩展机制</span>
  <a href="#%e6%89%a9%e5%b1%95%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>单个Master可以服务9W个客户端，因为每个单元只有一个Master，所以Master的压力会很大。因此，最有效的扩展机制在很大程序上能减少与主机的通信，有以下几种方法：</p>
<ul>
<li>
<p>可创建任意数量的 Chubby 单元，客户端通常使用附近单元，减少对远程机器的依赖。</p>
</li>
<li>
<p>主服务器在负载重时可增加租约时间，减少需处理的KeepAlive RPC 数量。</p>
</li>
</ul>
<ul>
<li>
<p>Chubby客户端缓存文件数据、元数据、文件缺失情况和打开句柄，减少对服务器的调用。</p>
</li>
<li>
<p>使用协议转换服务器将 Chubby 协议转换为较简单的协议，如 DNS 等。</p>
</li>
</ul>
<p>还有以下两种机制，代理和分区。</p>
<h3 id="代理" class="heading-element"><span>4.1 代理</span>
  <a href="#%e4%bb%a3%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>可由受信任进程代理 Chubby 协议，代理连接了客户端和Chubby Master，两边保持一致即可。这样可以减少服务器负载，主要处理KeepAlive和读请求，对写流量影响小。代理增加了写和首次读的 RPC，但可显著增加客户端数量，同时也带来一些潜在问题，如增加单元不可用的频率，原故障转移策略对代理不理想。</p>
<h3 id="分区" class="heading-element"><span>4.2 分区</span>
  <a href="#%e5%88%86%e5%8c%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Chubby 的接口设计允许按目录对单元的命名空间进行分区，每个分区有自己的副本和主服务器。但元数据不会划分，分区旨在实现大型 Chubby 单元且分区之间通信少，虽有一些操作需跨分区通信，但影响预计不大。</p>
<p>分区可减少给定分区上的读写流量，但不一定减少KeepAlive流量。如果要支持更多客户端，策略是代理、分区一起使用。</p>
]]></description></item><item><title>【MIT 6.5840(6.824)】 Lab 4:Fault-tolerant KVService 设计实现</title><link>https://hezephyr.github.io/posts/09.mit-6.58406.824-lab4-fault-tolerant-kvservice/</link><pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/09.mit-6.58406.824-lab4-fault-tolerant-kvservice/</guid><description><![CDATA[<h2 id="实验要求" class="heading-element"><span>1 实验要求</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">本实验旨在利用lab 3中的Raft库，构建一个具备容错能力的键值存储服务</font>。服务将作为一个复制状态机，由多个服务器组成，各服务器通过Raft协议同步数据库状态。即使在部分故障或网络隔离的情况下，只要大多数服务器正常，服务仍需继续响应客户端请求。在lab 4完成后，你将实现图中Raft交互的所有部分（Clerk、Service和Raft）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=small" data-sub-html="<h2>x</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png" alt="x" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=large 2x" data-title="x" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>客户端通过Clerk与键值服务交互，发送RPC请求，支持Put、Append和Get三种操作。服务需确保这些操作线性化，如果逐个调用，这些方法应表现得好像系统只有一个状态副本，每个调用都应观察到前序调用序列对状态的修改。对于并发调用，返回值和最终状态必须与操作按某种顺序逐个执行时相同。如果调用在时间上重叠，则认为是并发调用。</p>
<p>为单一服务器提供线性化相对容易，但如果服务是复制的，则较为困难，因为所有服务器必须为并发请求选择相同的执行顺序，避免使用过时的状态回复客户端，并在故障恢复时以保留所有确认的客户端更新为前提。Raft 作者的<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf"target="_blank" rel="external nofollow noopener noreferrer">博士论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>的第 6.3 小节介绍了如何实现线性化语义，在知乎上也有关于这方面的<a href="https://www.zhihu.com/question/278551592"target="_blank" rel="external nofollow noopener noreferrer">讨论<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，可以参考 dragonboat 作者的回答。</p>
<p>实验分为两个阶段：A阶段实现基于Raft的键值服务，不使用快照；B阶段则集成快照功能，优化日志管理。</p>
<p>我的实验代码仓库：https://github.com/HeZephyr/MIT6.5840/tree/main/src/kvraft，已通过压力测试，代码严格遵守上述按要求实现。</p>
<p><font color="red">注意：下述所贴代码为了简洁以及分块，进行了一定程度的删减，如果需要复现，可以前往仓库。</font></p>
<h2 id="实验设计" class="heading-element"><span>2 实验设计</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="思路" class="heading-element"><span>2.1 思路</span>
  <a href="#%e6%80%9d%e8%b7%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>lab4需要我们基于lab3实现的Raft，实现一个可用的KV服务，这意味着我们需要保证线性一致性（要求从外部观察者的角度来看，所有操作都按照某个全局顺序执行，并且结果与这些操作按该顺序串行执行的结果相同）。尽管 Raft 共识算法本身支持线性化语义，但要真正保证线性化语义在整个系统中生效，仍然需要上层服务的配合。</p>
<p>例如，在下面这张图中：x初始值为0，client1发送put请求(x,1)，client2发送put请求(x,2)，并在put请求前后发送get请求，此时如果put请求因为超时不断重发，如果在client2的put请求之后才被应用，则导致最后client2读到的是1，RaftKV的结果也是1，这就违背了线性一致性。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240822144442922.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240822144442922.png?size=small" data-sub-html="<h2>image-20240822144442922</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240822144442922.png" alt="image-20240822144442922" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240822144442922.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240822144442922.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240822144442922.png?size=large 2x" data-title="image-20240822144442922" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是因为当客户端向服务端提交command时，服务端在Raft层中同步、提交并应用后，客户端因为没有收到请求回复，会重试此操作，这种重试机制会导致相同的命令被执行多次。<font color="red">注意，这里讨论的都是写请求，因为读请求不会改变系统状态，可以重复执行多次。</font></p>
<p>为了解决重复执行命令导致线性一致性破坏的问题，Raft 作者提出了一种解决方案：客户端为每个命令分配一个唯一的序列号。状态机会记录每个客户端的最新序列号及其对应的执行结果。如果一个命令的序列号已经被处理过，则系统会直接返回先前的结果，而不会重新执行该命令。这样可以确保每个命令只被应用到状态机一次，避免了重复执行可能带来的线性一致性问题。</p>
<p>在这个lab中，我们可以按照如下机制具体实现：</p>
<ol>
<li><strong>客户端命令唯一化</strong>：每个客户端发送给服务端的每个<code>command</code>请求都携带一个由<code>ClientId</code>和<code>CommandId</code>组成的二元组。<code>ClientId</code>是客户端的唯一标识符，<code>CommandId</code>是一个递增的整数，用于唯一标识客户端发出的每一个命令。</li>
<li><strong>服务器端状态记录</strong>：在服务器端，维护一个映射表，这个映射表以<code>ClientId</code>作为主键，其值是一个结构体包含：
<ul>
<li>最近执行的来自该客户端的<code>CommandId</code>。</li>
<li>对应的命令执行结果。</li>
</ul>
</li>
<li><strong>重复命令检测与处理</strong>：
<ul>
<li>当一个新命令到达时，首先检查映射表中是否存在对应的<code>ClientId</code>条目。</li>
<li>如果存在，则比较新命令的<code>CommandId</code>与映射表中记录的<code>CommandId</code>。
<ul>
<li>如果新命令的<code>CommandId</code>小于或等于记录的<code>CommandId</code>，则说明这是一个重复命令，服务器可以直接返回之前存储的结果。</li>
<li>如果新命令的<code>CommandId</code>大于记录的<code>CommandId</code>，则说明这是新的命令，服务器应该正常处理这个命令，并更新映射表中对应<code>ClientId</code>的<code>CommandId</code>及结果。</li>
</ul>
</li>
<li>如果不存在对应的<code>ClientId</code>条目，则将此命令视为首次出现的命令进行处理，并添加一个新的条目到映射表中。</li>
</ul>
</li>
</ol>
<h3 id="lab4a无快照" class="heading-element"><span>2.2 lab4A：无快照</span>
  <a href="#lab4a%e6%97%a0%e5%bf%ab%e7%85%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>整体的时序图如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240829224033039.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240829224033039.png?size=small" data-sub-html="<h2>image-20240829224033039</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240829224033039.png" alt="image-20240829224033039" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240829224033039.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240829224033039.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240829224033039.png?size=large 2x" data-title="image-20240829224033039" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>####.1 客户端</p>
<p>对于客户端，需要有<code>(clientId, commandId)</code>来标识唯一命令，对于<code>clientId</code>，通过lab提供的随机数生成器<code>nrand</code>生成即可，对于<code>commandId</code>，可以采用递增的方式进行管理。这意味着每当客户端发送一个新的命令时，<code>commandId</code>都会递增一次，从而确保每个命令都有一个唯一的标识符，这样也需要保证如果这条命令没处理完（请求的server不是leader或者请求超时）需重复执行的时候，不能改变commandId。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CommandArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>       <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span>     <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Op</span>        <span class="nx">OpType</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ClientId</span>  <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CommandId</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CommandReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Err</span>   <span class="nx">Err</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Clerk</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">servers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span>
</span></span><span class="line"><span class="cl">	<span class="nx">leaderId</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">clientId</span>  <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">commandId</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ck</span><span class="p">.</span><span class="nf">ExecuteCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">CommandArgs</span><span class="p">{</span><span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">Op</span><span class="p">:</span> <span class="nx">OpGet</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nf">ExecuteCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">CommandArgs</span><span class="p">{</span><span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">Op</span><span class="p">:</span> <span class="nx">OpPut</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nf">ExecuteCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">CommandArgs</span><span class="p">{</span><span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">Op</span><span class="p">:</span> <span class="nx">OpAppend</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">ExecuteCommand</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">CommandArgs</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CommandId</span> <span class="p">=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">clientId</span><span class="p">,</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">commandId</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">servers</span><span class="p">[</span><span class="nx">ck</span><span class="p">.</span><span class="nx">leaderId</span><span class="p">].</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.ExecuteCommand&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="o">||</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">ErrWrongLeader</span> <span class="o">||</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">ErrTimeout</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ck</span><span class="p">.</span><span class="nx">leaderId</span> <span class="p">=</span> <span class="p">(</span><span class="nx">ck</span><span class="p">.</span><span class="nx">leaderId</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ck</span><span class="p">.</span><span class="nx">servers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ck</span><span class="p">.</span><span class="nx">commandId</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>####.2 服务端</p>
<p><code>KVServer</code>结构体被设计成一个基于Raft一致性协议实现的键值存储服务。为了确保客户端请求的幂等性，并且能够正确地处理来自客户端的重复请求，<code>lastOperations</code>映射表用于跟踪每个客户端（由<code>clientId</code>标识）的最后已应用的<code>commandId</code>以及相应的<code>reply</code>。这使得服务器能够在接收到重复请求时返回之前的结果而无需再次执行相同的命令。</p>
<p>状态机<code>stateMachine</code>在此处被实现为内存中的键值对存储<code>MemoryKV</code>，这意味着所有的键值对数据都保存在内存中，这对于快速读写操作是非常有效的，但可能不是持久化存储的最佳选择，因为如果服务器重启或崩溃，所有数据都会丢失。</p>
<p><code>lastApplied</code>字段被用来记录最后应用到状态机的日志条目的索引，以此来避免处理那些已经被应用过的过期日志条目。</p>
<p><code>notifyChs</code>是一个映射，它的键是日志条目的索引，值是一个<code>channel</code>。用于通知Raft的处理结果（机即复制到大多数副本并且应用到状态机之后）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KVServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">me</span>      <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span>      <span class="o">*</span><span class="nx">raft</span><span class="p">.</span><span class="nx">Raft</span>
</span></span><span class="line"><span class="cl">	<span class="nx">applyCh</span> <span class="kd">chan</span> <span class="nx">raft</span><span class="p">.</span><span class="nx">ApplyMsg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dead</span>    <span class="kt">int32</span> <span class="c1">// set by Kill()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxraftstate</span> <span class="kt">int</span> <span class="c1">// snapshot if log grows this big
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lastApplied</span>  <span class="kt">int</span> <span class="c1">//record the last applied index to avoid duplicate apply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">stateMachine</span>   <span class="nx">KVStateMachine</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastOperations</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="nx">OperationContext</span>
</span></span><span class="line"><span class="cl">	<span class="nx">notifyChs</span>      <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">CommandReply</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KVStateMachine</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="nx">Err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Err</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Append</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OperationContext</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MaxAppliedCommandId</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">LastReply</span>           <span class="o">*</span><span class="nx">CommandReply</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>ExecuteCommand</code>RPC实现如下，这段首先检查是否不是Get请求且为重复的命令，如果是则返回上次的结果，否则通过Raft的<code>Start</code>方法复制并应用日志，如果<code>Start</code>方法返回结果告知当前server不是Leader，则返回<code>ErrWrongLeader</code>，否则，去注册一个channel去阻塞等待执行结果（因为Start返回只是代表日志被复制到大多数节点中，有没有应用还不知道），这个执行结果由<code>applier</code>协程push。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">ExecuteCommand</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">CommandArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">CommandReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">OpGet</span> <span class="o">&amp;&amp;</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">isDuplicatedCommand</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastReply</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">].</span><span class="nx">LastReply</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">lastReply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">lastReply</span><span class="p">.</span><span class="nx">Err</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">index</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">isLeader</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">Command</span><span class="p">{</span><span class="nx">args</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">isLeader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrWrongLeader</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getNotifyCh</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">result</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Err</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">ExecuteTimeout</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrTimeout</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nf">deleteNotifyCh</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>####.3 applier</p>
<p><code>applier</code>协程实现如下，主要是监控<code>applyCh</code>，根据Raft的应用结果来进行响应处理，需要注意的就是检测是否为重复的命令，如果不是，则需要应用到状态机，并保存最近的响应结果。最后，如果当前节点是领导者，并且该日志条目属于当前任期，则通知相关的客户端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">applier</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">kv</span><span class="p">.</span><span class="nx">applyCh</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} tries to apply message %v&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandValid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span> <span class="o">&lt;=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} discards outdated message %v because a newer snapshot which lastApplied is %v has been restored&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="k">continue</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">command</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">Command</span><span class="p">.(</span><span class="nx">Command</span><span class="p">)</span> <span class="c1">// type assertion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">OpGet</span> <span class="o">&amp;&amp;</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">isDuplicatedCommand</span><span class="p">(</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">command</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} doesn&#39;t apply duplicated message %v to stateMachine because maxAppliedCommandId is %v for client %v&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">],</span> <span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">].</span><span class="nx">LastReply</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyLogToStateMachine</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">OpGet</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">]</span> <span class="p">=</span> <span class="nx">OperationContext</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">							<span class="nx">MaxAppliedCommandId</span><span class="p">:</span> <span class="nx">command</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							<span class="nx">LastReply</span><span class="p">:</span>           <span class="nx">reply</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="c1">// just notify related channel for currentTerm&#39;s log when node is leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">isLeader</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetState</span><span class="p">();</span> <span class="nx">isLeader</span> <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandTerm</span> <span class="o">==</span> <span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getNotifyCh</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="lab4b有快照" class="heading-element"><span>2.3 lab4B：有快照</span>
  <a href="#lab4b%e6%9c%89%e5%bf%ab%e7%85%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>实现了lab4A，lab4B就好做了，只需要修改<code>applier</code>，每次应用了<code>command</code>之后，都需要检查是否达到<code>maxraftstate</code>，如果达到，则调用<code>snapshot</code>来制作快照，需要注意，快照中，不仅需要保存状态机的状态，还需要包含用来去重的<code>lastOperations</code>，这也是为了防止应用快照后的节点成为leader后，由于没有<code>lastOperations</code>导致重复执行命令。</p>
<p>然后，<code>applyCh</code>中还有Leader发来的快照，我们需要进行验证，如果有效，则需要更新相应的状态，具体实现代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">applier</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">kv</span><span class="p">.</span><span class="nx">applyCh</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} tries to apply message %v&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandValid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span> <span class="o">&lt;=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} discards outdated message %v because a newer snapshot which lastApplied is %v has been restored&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="k">continue</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">command</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">Command</span><span class="p">.(</span><span class="nx">Command</span><span class="p">)</span> <span class="c1">// type assertion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">OpGet</span> <span class="o">&amp;&amp;</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">isDuplicatedCommand</span><span class="p">(</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">command</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} doesn&#39;t apply duplicated message %v to stateMachine because maxAppliedCommandId is %v for client %v&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">],</span> <span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">].</span><span class="nx">LastReply</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyLogToStateMachine</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">OpGet</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">command</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">]</span> <span class="p">=</span> <span class="nx">OperationContext</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">							<span class="nx">MaxAppliedCommandId</span><span class="p">:</span> <span class="nx">command</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							<span class="nx">LastReply</span><span class="p">:</span>           <span class="nx">reply</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">						<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="c1">// just notify related channel for currentTerm&#39;s log when node is leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">isLeader</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetState</span><span class="p">();</span> <span class="nx">isLeader</span> <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandTerm</span> <span class="o">==</span> <span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getNotifyCh</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">needSnapshot</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nf">takeSnapshot</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotValid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">CondInstallSnapshot</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotTerm</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotIndex</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nf">restoreStateFromSnapshot</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotIndex</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Invalid ApplyMsg %v&#34;</span><span class="p">,</span> <span class="nx">message</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="压测结果" class="heading-element"><span>3 压测结果</span>
  <a href="#%e5%8e%8b%e6%b5%8b%e7%bb%93%e6%9e%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>网上提供了一个<a href="https://gist.github.com/JJGO/0d73540ef7cc2f066cb535156b7cbdab"target="_blank" rel="external nofollow noopener noreferrer">测试脚本<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，功能强大。我的压测结果如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240820095009785.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240820095009785.png?size=small" data-sub-html="<h2>image-20240820095009785</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240820095009785.png" alt="image-20240820095009785" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240820095009785.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240820095009785.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240820095009785.png?size=large 2x" data-title="image-20240820095009785" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>【论文阅读笔记】Grove: a Separation-Logic Library for Verifying Distributed Systems (Extended Version)</title><link>https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/</link><pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/</guid><description><![CDATA[<h2 id="介绍" class="heading-element"><span>1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>大型应用在分布式系统中遭遇多重挑战，如并发控制、故障恢复、网络不稳定及服务器时钟异步等。形式化验证则是一种严格确立系统正确性的方法，帮助处理边缘情况。</p>
<p>租约是分布式系统中的关键技术，用于保证系统某方面在一定时间内不变，GFS、Chubby和DynamoDB都具有类似的机制。例如租约允许领导者高效执行只读查询，无需频繁验证自身领导权，然而，这一机制的有效性验证却是一项艰巨任务。</p>
<p>Grove，作为前沿的并发分离逻辑（Concurrent Separation Logic, CSL）库，首开先河地解决了基于时间的租约验证问题，包括其与系统重新配置、故障恢复、线程级并发以及不可靠网络通信之间的复杂交互。</p>
<p>CSL的应用精髓在于，通过将系统状态细分为独立资源，并借助同步原语转移资源所有权，从而实现模块化且精确的推理分析。</p>
<p>Grove的创新亮点可概括如下：</p>
<ol>
<li><strong>时间有界不变性推理</strong>：引入新颖的时间维度，有效解析租约的有效期及其对系统状态的影响。</li>
<li><strong>扩展Crash Hoare逻辑</strong>：强化逻辑体系，使之能妥善应对分布式环境下的节点崩溃情形。</li>
<li><strong>抽象机制</strong>：提供工具集，支持对仅附加日志及单调时钟计数器的精准推理，增强系统的时间一致性。</li>
</ol>
<p><a href="https://github.com/mit-pdos/perennial"target="_blank" rel="external nofollow noopener noreferrer">Grove code<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="常见组件-grove案例研究" class="heading-element"><span>2 常见组件-Grove案例研究</span>
  <a href="#%e5%b8%b8%e8%a7%81%e7%bb%84%e4%bb%b6-grove%e6%a1%88%e4%be%8b%e7%a0%94%e7%a9%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="rpc库" class="heading-element"><span>2.1 RPC库</span>
  <a href="#rpc%e5%ba%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>RPC是分布式系统的重要构建模块，它允许客户端在远程服务器上调用过程。例如，客户端调用<code>rpcClient.Call(&quot;f&quot;, args)</code>将在与<code>rpcClient</code>相连的服务器上调用<code>f(args)</code>。RPC库提供的是不可靠的RPC，意味着客户端的一次调用可能导致服务器运行对应的函数一次、零次或多于一次。这是因为底层网络可能会丢弃、重排或复制数据包。应用程序通常不会直接调用RPC，而是使用各种代理（clerk），它们封装了RPC并附加额外的处理（如添加请求ID、重试等）。</p>
<h3 id="复制状态机库" class="heading-element"><span>2.2 复制状态机库</span>
  <a href="#%e5%a4%8d%e5%88%b6%e7%8a%b6%e6%80%81%e6%9c%ba%e5%ba%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>vRSM复制由应用程序提供的状态机，具体的接口如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=small" data-sub-html="<h2>image-20240830211745211</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png" alt="image-20240830211745211" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=large 2x" data-title="image-20240830211745211" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>vRSM由多个组件实现，每个组件处理状态机复制的不同方面，例如持久性可以与复制协议分开实现。</p>
<ol>
<li>
<p><strong>副本服务器：写入复制</strong></p>
<ul>
<li>副本组件管理被复制的状态机的副本。</li>
<li>主要角色包括主服务器(Primary)和备份服务器(Backup)。主服务器处理来自客户端的写请求，备份服务器则处理读请求。</li>
<li>主服务器在收到操作后，会先在本地应用，然后复制到所有备份服务器，最后回复客户端。复制操作时，主服务器会生成线程以并发方式向每个备份发送RPC，并使用Go WaitGroup等待所有线程完成，确保操作被所有副本服务器应用。</li>
</ul>
</li>
<li>
<p><strong>使用configservice重新配置</strong></p>
<p>利用<code>epochs</code>和<code>configservice</code>来管理服务器的添加或移除。系统通过epoch来跟踪不同的服务器配置。每个epoch对应一组特定的服务器配置，包括一个主服务器和多个备份服务器。时代分为活跃epoch和保留epoch，后者指未实际运行的配置。<code>configservice</code> 负责维护当前系统的最新epoch和配置信息。它允许客户端获取当前配置，并在重新配置过程中提供原子操作以更新配置。</p>
<p>在重新配置期间，客户端可能向旧配置发送操作，这可能导致新配置中遗漏操作。为解决此问题，重新配置过程首先会封闭旧配置中的一个服务器，使其不再接受写操作，直到进入新的epoch。</p>
<p><strong>重新配置步骤</strong> 包括：</p>
<ol>
<li>原子性地创建新epoch</li>
<li>从旧配置中获取状态</li>
<li>在新服务器上初始化状态</li>
<li>更新configservice中的配置信息</li>
<li>激活新主服务器。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Reserve a new epoch number for reconfiguration, and return the current configuration (set of servers).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">ReserveEpochAndGetConfig</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Return current configuration, used by clients to determine what servers to talk to.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">GetConfig</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Address</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//  Set new configuration, making epoch live, as long as no higher-numbered epoch has been reserved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">TryWriteConfig</span><span class="p">(</span><span class="nx">epoch</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">config</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">Error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get a lease for specified epoch, as long as it’s the current epoch, returning the new lease expiration time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">GetLease</span><span class="p">(</span><span class="nx">epoch</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">Error</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Reconfigure</span><span class="p">(</span><span class="nx">newServers</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newEpoch</span><span class="p">,</span> <span class="nx">oldServers</span> <span class="o">:=</span> <span class="nx">configClerk</span><span class="p">.</span><span class="nf">ReserveEpochAndGetConfig</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// get state from a server from old config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldClerk</span> <span class="o">:=</span> <span class="nf">MakeClerk</span><span class="p">(</span><span class="nx">oldServers</span><span class="p">[</span><span class="nf">Rand</span><span class="p">()</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">oldServers</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl">    <span class="nx">oldState</span> <span class="o">:=</span> <span class="nx">oldClerk</span><span class="p">.</span><span class="nf">GetStateAndSeal</span><span class="p">(</span><span class="nx">newEpoch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// make clerks to all of the new servers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">newClerks</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Clerk</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newServers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newServers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newClerks</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">MakeClerk</span><span class="p">(</span><span class="nx">newServers</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// set state on all the new servers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">WaitGroup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newClerks</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newClerks</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">SetNewEpochState</span><span class="p">(</span><span class="nx">newEpoch</span><span class="p">,</span> <span class="nx">oldState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// write new addresses to config service
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">configClerk</span><span class="p">.</span><span class="nf">TryWriteConfig</span><span class="p">(</span><span class="nx">newEpoch</span><span class="p">,</span> <span class="nx">newServers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// activate the new primary server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newClerks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">BecomePrimary</span><span class="p">(</span><span class="nx">newEpoch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在网络分区的情况下，configservice通过仅接受最高编号的新epoch来避免创建多个冲突的系统实例。</p>
</li>
<li>
<p><strong>副本服务器：基于租约的读取</strong></p>
<p>副本服务器（主服务器和备份服务器）利用租约提供线性化读取服务，无需跨服务器通信。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">ApplyReadonly</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="nx">Result</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">leaseExpiry</span> <span class="p">&gt;</span> <span class="nf">GetTimeRange</span><span class="p">().</span><span class="nx">latest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">e</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">epoch</span>
</span></span><span class="line"><span class="cl">        <span class="nx">idx</span><span class="p">,</span> <span class="nx">res</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">stateLogger</span><span class="p">.</span><span class="nf">LocalRead</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果在此期间发生重新配置，服务器会通知客户端重试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">waitForCommitted</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">op</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">ErrRetry</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">ErrRetry</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>租约机制</strong>：
<ul>
<li>租约防止重新配置时返回过时数据，确保各服务器同步。</li>
<li>后台线程定期更新租约，承诺配置不变，直至租约到期（如1秒后）。</li>
</ul>
</li>
<li><strong>读取流程</strong>：
<ul>
<li>服务器收到只读请求且租约有效时，根据本地状态计算响应。本地状态包含所有已提交操作，可能含未提交的写操作。</li>
<li>读取依赖的前序写操作需全部提交，方能向客户端发送结果。</li>
</ul>
</li>
</ul>
<p>Grove使用类似TrueTime的<code>GetTimeRange()</code>API，提供当前时间的上下限，解决时钟偏移问题。</p>
</li>
<li>
<p><strong>存储库：状态日志器</strong></p>
<p>副本服务器使用存储库管理持久状态，提供“状态日志器”用于在追加型文件中持久化新操作。状态日志器在内存中缓冲追加操作，后台线程异步追加并同步缓冲区到文件，以提升性能。存储库提供 <code>Wait()</code> 函数，允许等待直到文件的前缀部分被持久化。副本库在回复 RPC 之前使用 <code>Wait()</code> 确保变更被持久存储。</p>
</li>
<li>
<p><strong>基于Paxos的容错配置服务</strong></p>
<p><strong>Paxos 库</strong>用于处理配置服务自身的服务器故障，是一个简单的基于 Paxos 一致性算法的复制库。Paxos在固定服务器集上运行，仅需要多数服务器处理请求，使用 leader 协调操作，但在 leader 崩溃时允许更换。与主-备份复制的差异：</p>
<ul>
<li>Paxos 自行选择新的epoch编号，因为服务器集不会在运行时改变。</li>
<li>仅要求多数服务器提交操作，新 leader 必须从多数服务器获取最新状态。</li>
<li>Paxos 较为简单，不使用租约，每次更新都写入整个状态到磁盘，而非追加操作到日志。</li>
<li>写操作性能较低，但对于配置服务是可接受的；提供快速但弱一致性的读取。</li>
</ul>
<p>Paxos提供的接口如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 返回当前Paxos实例中的复制状态。可能过时或未提交，GetConfig 使用 WeakRead 以确保快速响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Paxos</span><span class="p">)</span> <span class="nf">WeakRead</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 开始一个新的提议过程。它返回当前的复制状态和一个commit回调函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Paxos</span><span class="p">)</span> <span class="nf">Begin</span><span class="p">()</span> <span class="p">(</span><span class="nx">oldstate</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">commit</span> <span class="kd">func</span><span class="p">(</span><span class="nx">newstate</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 尝试使当前节点成为领导者。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Paxos</span><span class="p">)</span> <span class="nf">TryBecomingLeader</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要执行写操作，如下面这段代码所示，configserver使用<code>Begin()</code>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 参数args在此处未使用，通常用于接收客户端请求的参数。
</span></span></span><span class="line"><span class="cl"><span class="c1">// reply 是方法的输出，它将包含操作的结果状态以及预留的新epoch和配置信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConfigService</span><span class="p">)</span> <span class="nf">ReserveEpochAndGetConfig</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从Paxos实例开始一个新的提议，获取当前状态和提交函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 应该在当前的领导者上调用此方法，否则提议无法成功提交。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldstate</span><span class="p">,</span> <span class="nx">commit</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">paxos</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 反序列化旧状态，以便修改。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">st</span> <span class="o">:=</span> <span class="nf">unmarshal</span><span class="p">(</span><span class="nx">oldstate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新状态中的预留epoch字段，准备进入下一个epoch。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">st</span><span class="p">.</span><span class="nx">reservedEpoch</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">reservedEpoch</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 序列化更新后的状态，准备提交。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newstate</span> <span class="o">:=</span> <span class="nf">marshal</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用从Begin获得的提交函数尝试提交新状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 此操作会与其他服务器通信，以确保新状态被复制到大多数服务器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">commit</span><span class="p">(</span><span class="nx">newstate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查提交是否成功。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果提交失败，将错误状态编码并写入reply。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="nx">reply</span> <span class="p">=</span> <span class="nx">marshal</span><span class="p">.</span><span class="nf">WriteInt</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">STAT_ERROR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果提交成功，将OK状态编码并写入reply。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="nx">reply</span> <span class="p">=</span> <span class="nx">marshal</span><span class="p">.</span><span class="nf">WriteInt</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">STAT_OK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 编码并写入新的预留epoch到reply。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="nx">reply</span> <span class="p">=</span> <span class="nx">marshal</span><span class="p">.</span><span class="nf">WriteInt</span><span class="p">(</span><span class="o">*</span><span class="nx">reply</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">reservedEpoch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 编码并写入当前配置到reply。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="nx">reply</span> <span class="p">=</span> <span class="nx">marshal</span><span class="p">.</span><span class="nf">WriteBytes</span><span class="p">(</span><span class="o">*</span><span class="nx">reply</span><span class="p">,</span> <span class="nf">encode_cfg</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">config</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>版本化状态机API</strong></p>
<p>开发者需实现如下所示的版本化状态机接口，以便在 vRSM 上构建应用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">VersionedStateMachine</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Apply</span>		<span class="kd">func</span><span class="p">(</span><span class="nx">op</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">idx</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Read</span>		<span class="kd">func</span><span class="p">(</span><span class="nx">op</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SetState</span> 	<span class="kd">func</span><span class="p">(</span><span class="nx">snap</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">idx</span> <span class="kt">uint64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">GetState</span> 	<span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>操作执行：
<ul>
<li><code>Apply()</code>：执行应用级别的读写操作。</li>
<li><code>Read()</code>：对当前内存状态执行应用级别的读操作。</li>
</ul>
</li>
<li>状态管理：
<ul>
<li><code>SetState()</code> 和 <code>GetState()</code>：允许序列化内存状态。</li>
<li>vRSM 库：负责状态的磁盘检查点和新副本的状态复制。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>vRSM客户端库（clerk）</strong></p>
<p>vRSM 提供客户端库，简化了通过网络向 vRSM 发送请求的复杂性。Clerk 从配置服务获取并缓存副本服务器地址。</p>
<p>操作执行：</p>
<ul>
<li><code>clerk.Apply(op)</code>：向主服务器发送读写操作。</li>
<li><code>clerk.Read(op)</code>：向任何副本发送只读操作。</li>
</ul>
<p>若服务器不再为主服务器或副本服务器，Clerk 会请求新服务器信息并重试。由于重试，可能导致一个操作被应用许多次，需要更高级库处理操作去重。</p>
</li>
<li>
<p><strong>exactlyonce库</strong></p>
<p>确保使用 vRSM 的应用操作仅执行一次。组件构成：</p>
<ul>
<li>新型 Clerk：包装 vRSM Clerk，通过添加唯一请求 ID 防止操作重复。</li>
<li>状态机转换器：为应用级状态机添加回复表，追踪已应用请求及其回复。</li>
</ul>
<p>操作处理：</p>
<ul>
<li>新请求：调用状态机的 <code>Apply()</code> 并存储回复。</li>
<li>重复请求：不调用状态机，直接返回先前回复。</li>
<li>只读操作：忽略回复表，直接调用状态机的 <code>Read()</code>。</li>
</ul>
</li>
</ol>
<h3 id="vrsm上层应用" class="heading-element"><span>2.3 vRSM上层应用</span>
  <a href="#vrsm%e4%b8%8a%e5%b1%82%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p><strong>vKV实现</strong></p>
<ul>
<li><strong>vKV 架构</strong>：基于 vRSM 和 exactlyonce 库实现。</li>
<li><strong>服务器端</strong>：实现 vRSM 期望的状态机接口。</li>
<li><strong>客户端</strong>：基于 exactlyonce clerk 实现的 clerk，提供简化的 API（<code>Put</code>、<code>CondPut</code>、<code>Get</code>）。</li>
<li><strong>实现细节</strong>：vKV 实现简单，包括 (反)序列化方法和内存映射的读写函数。</li>
<li><strong>性能优化</strong>：vKV 存储键到值的映射以及键的最后修改操作索引，利用 vRSM 的版本化状态机接口提升读取性能。</li>
</ul>
</li>
<li>
<p><strong>基于租约的客户端缓存-cachekv</strong></p>
<p>cachekv 库通过在 vKV 中存储数据和租约到期时间实现基于租约的客户端缓存。GetAndCache 函数如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">k</span> <span class="o">*</span><span class="nx">CacheKv</span><span class="p">)</span> <span class="nf">GetAndCache</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cachetime</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// first attempt to read from the local cache, and if not cached, call vKV&#39;s Get.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">old</span> <span class="o">:=</span> <span class="nx">k</span><span class="p">.</span><span class="nx">kv</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">newExpiration</span> <span class="o">:=</span> <span class="nb">max</span><span class="p">(</span><span class="nf">GetTimeRange</span><span class="p">().</span><span class="nx">latest</span><span class="o">+</span><span class="nx">cachetime</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">leaseExpiration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">new</span><span class="p">.</span><span class="nx">leaseExpiration</span> <span class="p">=</span> <span class="nx">newExpiration</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Try to update the lease expiration time on the backend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">k</span><span class="p">.</span><span class="nx">kv</span><span class="p">.</span><span class="nf">CondPut</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">resp</span> <span class="o">==</span> <span class="s">&#34;ok&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">k</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nx">k</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">cacheValue</span><span class="p">{</span><span class="nx">v</span><span class="p">:</span> <span class="nx">old</span><span class="p">.</span><span class="nx">v</span><span class="p">,</span> <span class="nx">l</span><span class="p">:</span> <span class="nx">newLeaseExpiration</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">k</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">old</span><span class="p">.</span><span class="nx">v</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>它返回指定键的值，并在内部缓存，使用 <code>CondPut</code> （确保仅在租约过期时更改值）原子增加租约持续时间，确保并发修改不会改变值。</p>
</li>
<li>
<p><strong>锁服务</strong></p>
<p><strong>锁服务接口</strong>基于 vKV 实现，使用 vKV 的 CondPut() 操作实现锁。每个锁对应一个键值对，提供 Acquire() 和 Release() 方法的规范，支持应用实现独占锁。锁服务的规范与传统的并发分离逻辑锁规范不同，简化了资源保护。</p>
</li>
<li>
<p><strong>银行事务</strong></p>
<p>顶层应用，使用基于 vKV clerk 和锁服务接口构建的事务。</p>
<ul>
<li><strong>账户状态存储</strong>：使用 vKV 实例存储账户状态，每个账户余额用一对键值存储。</li>
<li><strong>并发访问控制</strong>：使用锁服务处理账户的并发访问，每次转账操作获取两个锁，确保并发转账的安全执行。</li>
<li><strong>审计功能 (Audit)</strong>：获取所有账户的锁，计算总余额，并释放锁。</li>
<li><strong>容错处理</strong>：若银行节点崩溃，锁服务中的锁将保持锁定状态，恢复需要某种形式的撤销或重做日志，但原型中未实现。</li>
</ul>
</li>
</ol>
<h2 id="grove性能评估" class="heading-element"><span>3 Grove性能评估</span>
  <a href="#grove%e6%80%a7%e8%83%bd%e8%af%84%e4%bc%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ol>
<li>
<p><strong>实验目的</strong>：</p>
<ul>
<li>
<p>证明 Grove 能够验证现实世界中高性能的分布式系统。</p>
</li>
<li>
<p><font color="red">展示 vKV 原型通过 Grove 验证后能够实现高性能</font>。</p>
</li>
<li>
<p>特别强调租约在 vKV 中实现高性能读取的重要性。</p>
</li>
</ul>
</li>
<li>
<p><strong>baseline性能对比</strong>：将vKV与Redis进行比较，后者是高性能键值服务器，以C语言编写。为了使Redis与vKV在持久化保障上可比，Redis开启appendfsync always选项，而vKV运行于单核并禁用备份副本。结果显示，vKV吞吐量为Redis的67%-73%，请求延迟相当，多核下vKV吞吐量更高（例如，8核下YCSB 5%写入情况下，吞吐量提升5.1倍）。</p>
</li>
<li>
<p><strong>重新配置能力</strong>：通过添加新服务器进行系统重配置，同时继续正确处理客户端请求的能力。实验中，主服务器在 10 秒时被杀掉，开始重配置过程。使用 YCSB 工作负载变体，100 个客户端持续写入，100 个客户端持续读取。重配置期间，写入操作会阻塞，但读取可以继续。实验结果显示 vKV 可以在重配置期间继续提供读取服务。</p>
</li>
<li>
<p><strong>租约对读取性能的影响</strong>：<strong>写入密集型工作负载</strong>（50%或100%写入），增加副本会降低性能，因为写入在主服务器遇到更多开销，且其它副本处理的读取不足以抵消成本。对于<strong>读取密集型工作负载</strong>，增加副本可以提升性能，例如，YCSB 5%和0%写入情况下，3台服务器分别达到单服务器1.7倍和2.3倍的吞吐量。</p>
</li>
</ol>
<h2 id="总结" class="heading-element"><span>4 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="grovekv系统" class="heading-element"><span>4.1 GroveKV系统</span>
  <a href="#grovekv%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GroveKV特点：</p>
<ul>
<li>容错、线性化的键值（KV）服务。</li>
<li>操作（Put/Get）exactlyonce。</li>
<li>崩溃安全且可重配置。</li>
</ul>
<p>要进行重配置，GroveKV使用configservice管理服务器更改。如果没有configservice，类似VMWare-FT的问题，即两个备份可能是网络的彼此分区并且都想成为主分区。这可以通过ZooKeeper之类的配置服务解决。</p>
<p>lab3也是一个容错KV服务，但GroveKV使用主/备份复制而不是Raft。<strong>关键操作</strong>如下：</p>
<ol>
<li>复制：Primary使用goroutines复制到其他服务器，基于RPC。执行操作时需要持有锁。</li>
<li>重配置：封闭当前的服务器组，从中获取状态副本，安装到新服务器。使用epoch编号处理并发重配置。</li>
<li>基于租约的读取：服务器不跟任何人协调回复<code>Get</code>请求。</li>
</ol>
<h3 id="grove核心" class="heading-element"><span>4.2 Grove核心</span>
  <a href="#grove%e6%a0%b8%e5%bf%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在正式验证领域，Grove 的核心在于证明代码在所有可能场景下均能表现得当，这一过程要求对代码执行的数学模型有深刻理解，以及对系统行为“正确”的明确定义。通过引入机械证明检查器，Grove 大幅降低了开发者在证明过程中犯错的可能性。</p>
<p>在 Grove 中，规范由前条件和后条件构成，用于描述操作前后的系统状态。以 GroveKV 为例，Put 和 Get 操作的规范不仅限定了操作的预期结果，还明确了数据所有权的转移。</p>
<p>Concurrent Separation Logic（CSL）是一种针对并发程序的形式化验证方法，Grove 对其进行了创新性的拓展，使之适用于分布式系统。CSL 强调基于资源所有权的代码分析，其中“堆指向”是一个典型的例子，它确保了数据的一致性不受并发访问的影响。</p>
<p>在 Grove 中，不变量指的是系统运行中必须始终保持为真的属性，而时间有界不变量（tinv）则进一步限制了特定资源的有效期。例如，<code>GetTimeRange</code> 函数允许在租约未到期的情况下，临时访问底层资源，这在处理基于租约的读取时尤为关键。</p>
<p>尽管正式验证能够显著减少某些类型的错误，但它并非万能药。验证不能保证所有实际中可能遇到的问题都被解决，特别是那些涉及系统活性性的问题，如死锁或饥饿。此外，编写高质量的证明和测试同样需要大量时间和精力，与开发代码无异，甚至有时还需经历重构的过程。</p>
]]></description></item><item><title>【MIT 6.5840(6.824) 】Lab3:Raft 设计实现</title><link>https://hezephyr.github.io/posts/08.mit-6.58406.824-lab3-raft/</link><pubDate>Sun, 11 Aug 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/08.mit-6.58406.824-lab3-raft/</guid><description><![CDATA[<h2 id="实验要求" class="heading-element"><span>1 实验要求</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在本实验中，要求实现Raft，这是一种复制状态机协议，用于构建一个容错的键/值存储系统。实验的具体要求如下：</p>
<ol>
<li><strong>实现Raft</strong>：
<ul>
<li>将Raft实现为一个Go语言的对象类型，包含相关的方法，以便作为更大服务的一个模块使用。</li>
<li>Raft实例之间通过RPC通信，以维持复制的日志一致性。</li>
<li>支持无限数量的编号命令（日志条目），并能处理这些条目的提交。当一个特定索引的日志条目被提交后，Raft实现应将该条目发送给更大的服务执行。</li>
</ul>
</li>
<li><strong>遵循论文设计</strong>：
<ul>
<li>遵循<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf"target="_blank" rel="external nofollow noopener noreferrer">Raft论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>的设计，重点参考图2。</li>
<li>实现论文中描述的大部分功能，包括持久状态的保存和恢复，即使在节点故障和重启后也能保证数据的完整性。</li>
<li>不需要实现集群成员变更的部分（论文第六节）。</li>
</ul>
</li>
</ol>
<p>论文图2:</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160616514.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160616514.png?size=small" data-sub-html="<h2>image-20240811160616514</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160616514.png" alt="image-20240811160616514" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160616514.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160616514.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160616514.png?size=large 2x" data-title="image-20240811160616514" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>Raft交互图：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=small" data-sub-html="<h2>image-20240811160802518</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png" alt="image-20240811160802518" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811160802518.png?size=large 2x" data-title="image-20240811160802518" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我的实验代码仓库：https://github.com/HeZephyr/MIT6.5840/tree/main/src/raft，已通过压力测试，代码严格遵守上述按要求实现。</p>
<p><font color="red">注意：下述所贴代码为了简洁以及分块，进行了一定程度的删减，如果需要复现，可以前往仓库</font>。</p>
<h2 id="实验设计" class="heading-element"><span>2 实验设计</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="整体结构" class="heading-element"><span>2.1 整体结构</span>
  <a href="#%e6%95%b4%e4%bd%93%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>此Raft结构体基于论文图2，基本上都是其中介绍的字段以及lab自带的字段，其中其他属性论文中也间接简述和支持，以确保Raft节点能够高效、稳定地运作。如选举定时器和心跳定时器，被明确地纳入了Raft结构体中。这些定时器对于触发关键的系统行为至关重要——选举定时器确保在必要时发起选举过程，而心跳定时器则维持着领导者与跟随者之间的连接，防止不必要的选举。</p>
<p>条件变量（<code>sync.Cond</code>）的引入则是为了精妙地控制两个核心后台goroutine的操作节奏：日志应用goroutine（<code>applier</code>，只需要一个，<font color="red">专门用于监控日志条目的提交状态，一旦日志条目被确认提交，它将负责将这些条目应用到状态机中</font>。）和日志复制goroutine（<code>replicator</code>，<font color="red">负责进行日志条目的同步</font>。考虑到集群中每个peer都需要与除了自身以外的其它peer进行日志同步，这意味着我们需要<code>len(peers) - 1</code>个<code>replicator</code> goroutines来分别处理与每个peer的交互）。</p>
<p>此外，还有一个goroutine <code>ticker</code>负责定期检查选举和心跳的超时，确保在适当的时间间隔内触发选举过程或发送心跳信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Raft</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>        <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>        <span class="c1">// Lock to protect shared access to this peer&#39;s state, to use RWLock for better performance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">peers</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span> <span class="c1">// RPC end points of all peers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">persister</span> <span class="o">*</span><span class="nx">Persister</span>          <span class="c1">// Object to hold this peer&#39;s persisted state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">me</span>        <span class="kt">int</span>                 <span class="c1">// this peer&#39;s index into peers[]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dead</span>      <span class="kt">int32</span>               <span class="c1">// set by Kill()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Persistent state on all servers(Updated on stable storage before responding to RPCs)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">currentTerm</span> <span class="kt">int</span>        <span class="c1">// latest term server has seen(initialized to 0 on first boot, increases monotonically)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">votedFor</span>    <span class="kt">int</span>        <span class="c1">// candidateId that received vote in current term(or null if none)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">logs</span>        <span class="p">[]</span><span class="nx">LogEntry</span> <span class="c1">// log entries; each entry contains command for state machine, and term when entry was received by leader(first index is 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Volatile state on all servers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">commitIndex</span> <span class="kt">int</span> <span class="c1">// index of highest log entry known to be committed(initialized to 0, increases monotonically)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lastApplied</span> <span class="kt">int</span> <span class="c1">// index of highest log entry applied to state machine(initialized to 0, increases monotonically)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Volatile state on leaders(Reinitialized after election)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nextIndex</span>  <span class="p">[]</span><span class="kt">int</span> <span class="c1">// for each server, index of the next log entry to send to that server(initialized to leader last log index + 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">matchIndex</span> <span class="p">[]</span><span class="kt">int</span> <span class="c1">// for each server, index of highest log entry known to be replicated on server(initialized to 0, increases monotonically)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// other properties
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">state</span>          <span class="nx">NodeState</span>     <span class="c1">// current state of the server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">electionTimer</span>  <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>   <span class="c1">// timer for election timeout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">heartbeatTimer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>   <span class="c1">// timer for heartbeat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">applyCh</span>        <span class="kd">chan</span> <span class="nx">ApplyMsg</span> <span class="c1">// channel to send apply message to service
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">applyCond</span>      <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Cond</span>    <span class="c1">// condition variable for apply goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">replicatorCond</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Cond</span>  <span class="c1">// condition variable for replicator goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Make</span><span class="p">(</span><span class="nx">peers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span><span class="p">,</span> <span class="nx">me</span> <span class="kt">int</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">persister</span> <span class="o">*</span><span class="nx">Persister</span><span class="p">,</span> <span class="nx">applyCh</span> <span class="kd">chan</span> <span class="nx">ApplyMsg</span><span class="p">)</span> <span class="o">*</span><span class="nx">Raft</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Raft</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mu</span><span class="p">:</span>             <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">peers</span><span class="p">:</span>          <span class="nx">peers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">persister</span><span class="p">:</span>      <span class="nx">persister</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">me</span><span class="p">:</span>             <span class="nx">me</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dead</span><span class="p">:</span>           <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">currentTerm</span><span class="p">:</span>    <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">votedFor</span><span class="p">:</span>       <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logs</span><span class="p">:</span>           <span class="nb">make</span><span class="p">([]</span><span class="nx">LogEntry</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">// dummy entry at index 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">commitIndex</span><span class="p">:</span>    <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastApplied</span><span class="p">:</span>    <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nextIndex</span><span class="p">:</span>      <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">peers</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">matchIndex</span><span class="p">:</span>     <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">peers</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">state</span><span class="p">:</span>          <span class="nx">Follower</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">electionTimer</span><span class="p">:</span>  <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nf">RandomElectionTimeout</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">heartbeatTimer</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nf">StableHeartbeatTimeout</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">applyCh</span><span class="p">:</span>        <span class="nx">applyCh</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">replicatorCond</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Cond</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">peers</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// initialize from state persisted before a crash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nf">readPersist</span><span class="p">(</span><span class="nx">persister</span><span class="p">.</span><span class="nf">ReadRaftState</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// should use mu to protect applyCond, avoid other goroutine to change the critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">applyCond</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// initialize nextIndex and matchIndex, and start replicator goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">peer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">peers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">],</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getLastLog</span><span class="p">().</span><span class="nx">Index</span><span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">peer</span> <span class="o">!=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">replicatorCond</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// start replicator goroutine to send log entries to peer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">replicator</span><span class="p">(</span><span class="nx">peer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// start ticker goroutine to start elections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">ticker</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// start apply goroutine to apply log entries to state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">applier</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">rf</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="lab3a领导者选举" class="heading-element"><span>2.2 lab3A：领导者选举</span>
  <a href="#lab3a%e9%a2%86%e5%af%bc%e8%80%85%e9%80%89%e4%b8%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>此任务需要实现Raft领导人选举和心跳（通过不附加日志条目的RPC）。对于这个要求，论文中其实给出了状态转移图，指导我们怎么去做。这个选举流程逻辑如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader?size=small" data-sub-html="<h2>image-20240811140525050</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader" alt="image-20240811140525050" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader?size=large 2x" data-title="image-20240811140525050" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<p>在lab3A实现过程中，需要注意如下几点：</p>
<ul>
<li>当发起投票时，务必使用goroutine并行发起RPC调用，以避免阻塞<code>ticker</code>协程。这样，即使在等待投票响应期间，候选者（Candidate）仍能响应新的选举超时，从而有机会自增任期并启动新一轮的选举。</li>
<li>有两种常见的实现投票统计的方式：一种是在函数作用域内定义一个局部变量，并利用闭包来维护投票计数；另一种是在<code>Raft</code>结构体中维护一个全局的<code>voteCnt</code>变量。为了保持<code>Raft</code>结构体的简洁，推荐采用局部变量和闭包的方案。</li>
<li>对于过期的RPC请求回复，应直接忽略，不作任何处理。这是因为Raft协议假设网络环境不可靠，可能发生的延迟或重播不应影响当前的决策流程。</li>
<li>如果在RPC通信中，节点A发现其任期小于节点B的任期，不论节点A当前的角色如何，都应立即转换为跟随者（Follower）。这是为了维护任期的权威性，确保集群的一致性。</li>
<li>为防止多个节点几乎同时启动选举，导致资源浪费和潜在的领导权争夺，应为选举超时设置一个随机的误差范围（如150~300ms），以拉长不同节点选举的时间间隔，这里采用时间戳作为随机种子。<font color="red">且每一次一个节点重置自己的选举定时器时，都需要重新选择一个随机的超时时间。避免服务器会以极小的概率选择相同的随机超时时间，那么会永远处于分割选票的场景中</font>。</li>
<li>Go RPC 仅发送名称以大写字母开头的结构体字段。子结构还必须具有大写的字段名称（例如数组中日志记录的字段）。这 <code>labgob</code> 软件包会警告您这一点；不要忽视警告。</li>
<li>在同一个任期内，Follower只能投出一票，这是为了防止出现多个Leader的情况。票数的刷新应在任期转换时进行，以确保投票的有效性和一致性。</li>
<li>为了提高并发性能，应尽量缩短临界区的长度。合理的锁使用策略是只在真正需要保护共享资源的最小时间内使用锁。</li>
</ul>
</blockquote>
<p>核心的Ticker实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">ticker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rf</span><span class="p">.</span><span class="nx">electionTimer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Candidate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// start election
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">rf</span><span class="p">.</span><span class="nf">StartElection</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">electionTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">RandomElectionTimeout</span><span class="p">())</span> <span class="c1">// reset election timer in case of split vote
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rf</span><span class="p">.</span><span class="nx">heartbeatTimer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">Leader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// should send heartbeat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">rf</span><span class="p">.</span><span class="nf">BroadcastHeartbeat</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">rf</span><span class="p">.</span><span class="nx">heartbeatTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">StableHeartbeatTimeout</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>StartElection</code>函数实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">StartElection</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">genRequestVoteArgs</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grantedVotes</span> <span class="o">:=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">peer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">peer</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">peer</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">RequestVoteReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">sendRequestVote</span><span class="p">(</span><span class="nx">peer</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="o">&amp;&amp;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">Candidate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">grantedVotes</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">						<span class="c1">// check over half of the votes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="k">if</span> <span class="nx">grantedVotes</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">							<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Leader</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">							<span class="nx">rf</span><span class="p">.</span><span class="nf">BroadcastHeartbeat</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">						<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Follower</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">						<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">peer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>RequestVote</code>RPC严格按照图2描述实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">RequestVote</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">RequestVoteArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">RequestVoteReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v}&#39;s state is {state %v, term %v}} after processing RequestVote,  RequestVoteArgs %v and RequestVoteReply %v &#34;</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Reply false if term &lt; currentTerm(§5.1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// if the term is same as currentTerm, and the votedFor is not null and not the candidateId, then reject the vote(§5.2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&lt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="o">||</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="o">&amp;&amp;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="o">!=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Follower</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// if candidate&#39;s log is not up-to-date, reject the vote(§5.4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">rf</span><span class="p">.</span><span class="nf">isLogUpToDate</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">LastLogIndex</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastLogTerm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CandidateId</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">electionTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">RandomElectionTimeout</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="lab3b日志" class="heading-element"><span>2.3 lab3B：日志</span>
  <a href="#lab3b%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Lab3B阶段，我们的目标转向实现Raft协议中至关重要的日志复制机制。其中入口是<code>Start</code>函数（应用程序与Raft的接口）。具体的日志复制流程：</p>
<ul>
<li>一旦Leader接收到新的日志条目，它首先会在自己的日志中追加这个条目。</li>
<li>随后，Leader通过<code>BroadcastHeartbeat</code>函数将这个日志条目广播至集群中的所有Peer，确保所有节点都能同步最新的状态。此过程涉及对日志条目的校验与冲突解决，确保每个Peer的日志保持一致且最新。</li>
<li>在日志条目被发送给Peers后，Leader会等待来自Peer的确认回复。只有当Leader收到大多数Peer（即超过半数）的确认，表明这些Peer已经成功复制了日志条目，Leader才能认为该日志条目已经被安全地复制。这是Raft协议中“多数原则”的体现，确保了即使在部分节点失败的情况下，系统仍然能够达成一致。<font color="red">当然，也需要根据回复确认自己Leader的地位，如果不再是Leader，需要更改为Follower</font>。</li>
<li>一旦日志条目被确认复制到了大多数节点，Leader就会标记这个条目为已提交（committed）。随后，Leader会通过<code>AppendEntries</code> RPC将最新的<code>LeaderCommit</code>信息广播给所有Peer，指示它们哪些日志条目现在可以被提交并应用到各自的状态机中。每个Peer根据接收到的<code>LeaderCommit</code>值来决定其日志中哪些条目可以被提交，从而确保所有活跃Peer的状态机保持一致。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader_election?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader_election?size=small" data-sub-html="<h2>image-20240811144321194</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader_election" alt="image-20240811144321194" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader_election?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader_election?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/leader_election?size=large 2x" data-title="image-20240811144321194" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<p>在lab3B实现过程中，需要注意如下几点：</p>
<ul>
<li>在发送RPC、接收RPC、推送和接收channel时，绝对不要持有锁，否则极易引发死锁。这在locking博客中有详细介绍，应时刻牢记。<font color="red">使用读写锁时，对于只读操作，只需持有读锁，避免不必要的写锁持有，以提高并发性能</font>。</li>
<li>对于过期的RPC请求回复，应直接忽略，避免执行任何业务逻辑</li>
<li>根据图2的规定，Raft Leader只能提交属于当前任期的日志条目，不得提交前任期的日志。在根据<code>matchIndex[]</code>判断是否可以提交日志时，必须检查该日志的任期是否与当前Leader的任期相匹配。</li>
<li>Follower对Leader的<code>leaderCommit</code>应无条件服从，无需额外判断。</li>
<li>Leader需维护好<code>matchIndex[]</code>（跟踪Follower的提交状态）和<code>nextIndex[]</code>（追踪Follower的日志复制进度），并在Leader崩溃后正确地初始化这两个数组。</li>
<li>当Follower接收到日志时，需检查RPC中Leader认定的当前Follower的<code>prevLogIndex</code>和<code>prevLogTerm</code>，判断日志是否存在冲突，若存在冲突，需由Leader从冲突点开始强制覆盖Follower的日志。</li>
<li>新的Leader的日志需确保包含了所有已提交的日志条目。Follower可能在Leader提交日志期间进入不可用状态，从而导致被选为新Leader的Follower可能覆盖已提交的日志条目。为避免这种情况，选举时需加入Leader限制机制，即Follower只给任期和日志更新的Candidate投票，具体规则如下：
<ul>
<li>如果任期号不同，任期号较大的Candidate更新；</li>
<li>如果任期号相同，日志索引值较大（即日志更长）的Candidate更新。</li>
</ul>
</li>
</ul>
</blockquote>
<p>核心的<code>AppendEntries</code> RPC实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">AppendEntries</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">AppendEntriesArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">AppendEntriesReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Your code here (3A, 3B).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v}&#39;s state is {state %v, term %v}} after processing AppendEntries,  AppendEntriesArgs %v and AppendEntriesReply %v &#34;</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Reply false if term &lt; currentTerm(§5.1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&lt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// indicate the peer is the leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Follower</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">electionTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">RandomElectionTimeout</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm(§5.3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span> <span class="p">&lt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// check the log is matched, if not, return the conflict index and term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// if an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it(§5.3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">rf</span><span class="p">.</span><span class="nf">isLogMatched</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogTerm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastLogIndex</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getLastLog</span><span class="p">().</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// find the first index of the conflicting term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">lastLogIndex</span> <span class="p">&lt;</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// the last log index is smaller than the prevLogIndex, then the conflict index is the last log index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictIndex</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictTerm</span> <span class="p">=</span> <span class="nx">lastLogIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">firstLogIndex</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// find the first index of the conflicting term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">index</span> <span class="o">:=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">firstLogIndex</span> <span class="o">&amp;&amp;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="nx">index</span><span class="o">-</span><span class="nx">firstLogIndex</span><span class="p">].</span><span class="nx">Term</span> <span class="o">==</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">index</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictIndex</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictTerm</span> <span class="p">=</span> <span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogTerm</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// append any new entries not already in the log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">firstLogIndex</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// find the junction of the existing log and the appended log.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Index</span><span class="o">-</span><span class="nx">firstLogIndex</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">)</span> <span class="o">||</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="nx">entry</span><span class="p">.</span><span class="nx">Index</span><span class="o">-</span><span class="nx">firstLogIndex</span><span class="p">].</span><span class="nx">Term</span> <span class="o">!=</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Term</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[:</span><span class="nx">entry</span><span class="p">.</span><span class="nx">Index</span><span class="o">-</span><span class="nx">firstLogIndex</span><span class="p">],</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="nx">index</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry) (paper)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">newCommitIndex</span> <span class="o">:=</span> <span class="nf">Min</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">LeaderCommit</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getLastLog</span><span class="p">().</span><span class="nx">Index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">newCommitIndex</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">=</span> <span class="nx">newCommitIndex</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">applyCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>replicateOnceRound</code>用来调用<code>AppendEntries</code>RPC，并根据<code>reply</code>继续相应处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">replicateOnceRound</span><span class="p">(</span><span class="nx">peer</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">Leader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">prevLogIndex</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">genAppendEntriesArgs</span><span class="p">(</span><span class="nx">prevLogIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">AppendEntriesReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">sendAppendEntries</span><span class="p">(</span><span class="nx">peer</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="o">&amp;&amp;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">Leader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">reply</span><span class="p">.</span><span class="nx">Success</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// indicate current server is not the leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Follower</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// decrease nextIndex and retry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">rf</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictIndex</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictTerm</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">firstLogIndex</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">						<span class="k">for</span> <span class="nx">index</span> <span class="o">:=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">firstLogIndex</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">							<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="nx">index</span><span class="o">-</span><span class="nx">firstLogIndex</span><span class="p">].</span><span class="nx">Term</span> <span class="o">==</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">ConflictTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">								<span class="nx">rf</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">								<span class="k">break</span>
</span></span><span class="line"><span class="cl">							<span class="p">}</span>
</span></span><span class="line"><span class="cl">						<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">rf</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">PrevLogIndex</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Entries</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">rf</span><span class="p">.</span><span class="nx">nextIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// advance commitIndex if possible
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">rf</span><span class="p">.</span><span class="nf">advanceCommitIndexForLeader</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Leader应用已提交log的<code>advanceCommitIndexForLeader</code>函数实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">advanceCommitIndexForLeader</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sortMatchIndex</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">copy</span><span class="p">(</span><span class="nx">sortMatchIndex</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">matchIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">sortMatchIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// get the index of the log entry with the highest index that is known to be replicated on a majority of servers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">newCommitIndex</span> <span class="o">:=</span> <span class="nx">sortMatchIndex</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="p">(</span><span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">newCommitIndex</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">isLogMatched</span><span class="p">(</span><span class="nx">newCommitIndex</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">=</span> <span class="nx">newCommitIndex</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">applyCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>每个peer应用已提交的goroutine <code>applier</code>实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">applier</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// check the commitIndex is advanced
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="o">&lt;=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// need to wait for the commitIndex to be advanced
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">rf</span><span class="p">.</span><span class="nx">applyCond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// apply log entries to state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">firstLogIndex</span><span class="p">,</span> <span class="nx">commitIndex</span><span class="p">,</span> <span class="nx">lastApplied</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">lastApplied</span>
</span></span><span class="line"><span class="cl">		<span class="nx">entries</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">LogEntry</span><span class="p">,</span> <span class="nx">commitIndex</span><span class="o">-</span><span class="nx">lastApplied</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">copy</span><span class="p">(</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="nx">lastApplied</span><span class="o">-</span><span class="nx">firstLogIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="nx">commitIndex</span><span class="o">-</span><span class="nx">firstLogIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// send the apply message to applyCh for service/State Machine Replica
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">entries</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">rf</span><span class="p">.</span><span class="nx">applyCh</span> <span class="o">&lt;-</span> <span class="nx">ApplyMsg</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">CommandValid</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="nx">Command</span><span class="p">:</span>      <span class="nx">entry</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="nx">CommandIndex</span><span class="p">:</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// use commitIndex rather than rf.commitIndex because rf.commitIndex may change during the Unlock() and Lock()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">rf</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">commitIndex</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="lab3c持久化" class="heading-element"><span>2.4 lab3C：持久化</span>
  <a href="#lab3c%e6%8c%81%e4%b9%85%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>如果基于 Raft 的服务器重新启动，它应该从中断处恢复服务。这要求 Raft 保持在重启后仍然存在的持久状态。论文的图 2 提到了哪种状态应该是持久的，即<code>logs</code>、<code>currentTerm</code>和<code>votedFor</code>。在Lab3C中，我们的任务便是实现<code>persist()</code>和<code>readPersist()</code>这两个核心函数，前者负责保存Raft的状态，后者则是在Raft启动时恢复之前保存的数据。</p>
<p><code>readPersist</code>函数实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">readPersist</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">data</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// bootstrap without any state?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewBuffer</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">labgob</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">votedFor</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">logs</span> <span class="p">[]</span><span class="nx">LogEntry</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">currentTerm</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">votedFor</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">logs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} fails to decode persisted state&#34;</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span> <span class="p">=</span> <span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">votedFor</span><span class="p">,</span> <span class="nx">logs</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">lastApplied</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>persist</code>函数实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">encodeState</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">labgob</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">persist</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">persister</span><span class="p">.</span><span class="nf">SaveStateAndSnapshot</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nf">encodeState</span><span class="p">(),</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实现好后，我们只需要在入口处<code>Make</code>调用<code>readPersist</code>即可，关键需要在什么时候保存状态呢？其实很简单，只需要对我们需要持久化的三个字段修改的时候就进行<code>persist</code>操作。即<code>persist()</code>操作应当在以下几种情况下被触发：</p>
<ul>
<li><strong>日志条目更新</strong>：当有新的日志条目被添加到<code>logs</code>中，或是已有条目被删除或替换时。</li>
<li><strong>任期变更</strong>：当<code>currentTerm</code>发生变化，比如在选举期间或接收到更高任期的领导者信息时。</li>
<li><strong>投票行为</strong>：当<code>votedFor</code>字段被更新，意味着节点投出了新的一票或取消了之前的投票。</li>
</ul>
<h3 id="lab3d日志压缩" class="heading-element"><span>2.5 lab3D：日志压缩</span>
  <a href="#lab3d%e6%97%a5%e5%bf%97%e5%8e%8b%e7%bc%a9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>按照目前的情况，重新启动的服务器会重放完整的 Raft 日志以恢复其状态。然而，对于一个长期运行的服务来说，永远记录完整的 Raft 日志是不切实际的。需要使用快照服务配合，此时Raft会丢弃快照之前的日志条目。lab3D就是需要我们实现日志压缩，具体来说是核心是<code>Snapshot</code>（快照保存函数）以及<code>InstallSnapshot</code>RPC，快照压缩的流程：</p>
<ol>
<li>每个peer都会通过<code>Snapshot</code>捕获当前系统状态的一个快照。这通常包括但不限于状态机的当前状态、任何必要的元数据、以及快照生成时的任期信息。</li>
<li>当Leader认为有必要向Follower发送快照时，它将发起<code>InstallSnapshot</code>RPC调用。这通常发生在Follower的日志状态与Leader严重脱节时，例如日志冲突无法通过常规的<code>AppendEntries</code>RPC解决。</li>
<li>Follower接收到快照后，会验证其完整性和一致性，然后应用快照以替换其当前状态和日志。这包括清除快照点之前的所有日志条目，并将状态机恢复到快照所表示的状态。</li>
<li>Follower在成功应用快照后，应通过RPC回复向Leader确认，表明快照已被正确安装。Leader据此更新其<code>matchIndex</code>和<code>nextIndex</code>数组，以反映Follower的最新状态。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811144255744.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811144255744.png?size=small" data-sub-html="<h2>image-20240811144255744</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811144255744.png" alt="image-20240811144255744" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811144255744.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811144255744.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811144255744.png?size=large 2x" data-title="image-20240811144255744" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<p>在lab3D实现过程中，需要注意以下几点：</p>
<ol>
<li>在更新 <code>lastApplied</code> 时，必须采用前一时刻的 <code>commitIndex</code> 值，而非实时的 <code>rf.commitIndex</code>。这是因为，在执行 <code>push applyCh</code> 过程中，<code>rf.commitIndex</code> 可能因其他操作而动态变化，使用其历史值可以保证 <code>lastApplied</code> 更新的准确性。</li>
<li>需要注意使用<code>CondInstallSnapshot</code>来验证快照的有效性。</li>
<li>在修剪log的时候注意留一个dummy log</li>
<li>使用 <code>Max(rf.lastApplied, commitIndex)</code> 而不是直接使用 <code>commitIndex</code> 来避免并发 InstallSnapshot RPC 导致 <code>lastApplied</code> 回滚</li>
</ol>
</blockquote>
<p><code>InstallSnapshot</code> RPC实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">InstallSnapshot</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">InstallSnapshotArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">InstallSnapshotReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// reply immediately if term &lt; currentTerm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&lt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nf">persist</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nf">ChangeState</span><span class="p">(</span><span class="nx">Follower</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">electionTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nf">RandomElectionTimeout</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// check the snapshot is more up-to-date than the current log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastIncludedIndex</span> <span class="o">&lt;=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">applyCh</span> <span class="o">&lt;-</span> <span class="nx">ApplyMsg</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">SnapshotValid</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Snapshot</span><span class="p">:</span>      <span class="nx">args</span><span class="p">.</span><span class="nx">Data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">SnapshotTerm</span><span class="p">:</span>  <span class="nx">args</span><span class="p">.</span><span class="nx">LastIncludedTerm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">SnapshotIndex</span><span class="p">:</span> <span class="nx">args</span><span class="p">.</span><span class="nx">LastIncludedIndex</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Snapshot</code>函数实现如下，它接收客户端创建的快照。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">Snapshot</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">snapshot</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">snapshotIndex</span> <span class="o">:=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">index</span> <span class="o">&lt;=</span> <span class="nx">snapshotIndex</span> <span class="o">||</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getLastLog</span><span class="p">().</span><span class="nx">Index</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;{Node %v} rejects replacing log with snapshotIndex %v as current snapshotIndex %v is larger in term %v&#34;</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">snapshotIndex</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// remove log entries up to index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="nx">index</span><span class="o">-</span><span class="nx">snapshotIndex</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Command</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">persister</span><span class="p">.</span><span class="nf">SaveStateAndSnapshot</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nf">encodeState</span><span class="p">(),</span> <span class="nx">snapshot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>还有一个<code>CondInstallSnapshot</code>，用来peer判断leader发过来的快照是否满足条件，如果满足，则安装快照。这个需要修改到<code>config.go</code>文件中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">CondInstallSnapshot</span><span class="p">(</span><span class="nx">lastIncludedTerm</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">lastIncludedIndex</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">snapshot</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// outdated snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">lastIncludedIndex</span> <span class="o">&lt;=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// need dummy entry at index 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">lastIncludedIndex</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getLastLog</span><span class="p">().</span><span class="nx">Index</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">LogEntry</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span> <span class="p">=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="nx">lastIncludedIndex</span><span class="o">-</span><span class="nx">rf</span><span class="p">.</span><span class="nf">getFirstLog</span><span class="p">().</span><span class="nx">Index</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Command</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">logs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">lastIncludedTerm</span><span class="p">,</span> <span class="nx">lastIncludedIndex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">commitIndex</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">lastIncludedIndex</span><span class="p">,</span> <span class="nx">lastIncludedIndex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rf</span><span class="p">.</span><span class="nx">persister</span><span class="p">.</span><span class="nf">SaveStateAndSnapshot</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nf">encodeState</span><span class="p">(),</span> <span class="nx">snapshot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="压测脚本" class="heading-element"><span>3 压测脚本</span>
  <a href="#%e5%8e%8b%e6%b5%8b%e8%84%9a%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我自己实现了一个压测脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># check the number of arguments</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$#</span><span class="s2">&#34;</span> -ne <span class="m">2</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;Usage: </span><span class="nv">$0</span><span class="s2"> &lt;test_type&gt; &lt;iterations&gt;&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;test_type must be one of 3A, 3B, 3C, 3D&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">test_type</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl"><span class="nv">iterations</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># check the test_type</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[[</span> <span class="s2">&#34;</span><span class="nv">$test_type</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;3A&#34;</span> <span class="o">&amp;&amp;</span> <span class="s2">&#34;</span><span class="nv">$test_type</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;3B&#34;</span> <span class="o">&amp;&amp;</span> <span class="s2">&#34;</span><span class="nv">$test_type</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;3C&#34;</span> <span class="o">&amp;&amp;</span> <span class="s2">&#34;</span><span class="nv">$test_type</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;3D&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;Invalid test_type: </span><span class="nv">$test_type</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;test_type must be one of 3A, 3B, 3C, 3D&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># check the iterations is a positive integer</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> ! <span class="o">[[</span> <span class="s2">&#34;</span><span class="nv">$iterations</span><span class="s2">&#34;</span> <span class="o">=</span>~ ^<span class="o">[</span>0-9<span class="o">]</span>+$ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;Invalid iterations: </span><span class="nv">$iterations</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;iterations must be a positive integer&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;go test -run </span><span class="nv">$test_type</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>1<span class="p">;</span> i&lt;<span class="o">=</span>iterations<span class="p">;</span> i++<span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;Running test iteration </span><span class="nv">$i</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nv">output</span><span class="o">=</span><span class="k">$(</span>go <span class="nb">test</span> -run <span class="nv">$test_type</span> 2&gt;<span class="p">&amp;</span>1<span class="k">)</span> <span class="c1">#&gt;&amp;1 redirects stderr to stdout</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Error in iteration </span><span class="nv">$i</span><span class="s2">:&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$output</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="k">fi</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><p>网上也提供了一个<a href="https://gist.github.com/JJGO/0d73540ef7cc2f066cb535156b7cbdab"target="_blank" rel="external nofollow noopener noreferrer">测试脚本<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，功能更为强大。压测结果如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811175403947.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811175403947.png?size=small" data-sub-html="<h2>image-20240811175403947</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811175403947.png" alt="image-20240811175403947" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811175403947.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811175403947.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811175403947.png?size=large 2x" data-title="image-20240811175403947" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="优化" class="heading-element"><span>4 优化</span>
  <a href="#%e4%bc%98%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ol>
<li>
<p>如果我们使用的空间少于数组的一半，我们就替换该数组。这个数字是相当任意的，选择它是为了平衡内存使用与分配数量，这个数字可能还可以改进。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">shrinkEntries</span><span class="p">(</span><span class="nx">entries</span> <span class="p">[]</span><span class="nx">LogEntry</span><span class="p">)</span> <span class="p">[]</span><span class="nx">LogEntry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">const</span> <span class="nx">lenMultiple</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span><span class="o">*</span><span class="nx">lenMultiple</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newEntries</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">LogEntry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nb">copy</span><span class="p">(</span><span class="nx">newEntries</span><span class="p">,</span> <span class="nx">entries</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">newEntries</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">entries</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>因为日志的索引是单调递增的，而term则是非递减的。所以这里应该可以使用二分优化。</p>
</li>
</ol>
]]></description></item><item><title>【论文阅读笔记】ZooKeeper: Wait-free coordination for Internet-scale systems</title><link>https://hezephyr.github.io/posts/08.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0zookeeper-wait-free-coordination-for-internet-scale-systems/</link><pubDate>Sun, 11 Aug 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/08.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0zookeeper-wait-free-coordination-for-internet-scale-systems/</guid><description><![CDATA[<h2 id="摘要" class="heading-element"><span>1 摘要</span>
  <a href="#%e6%91%98%e8%a6%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>这篇论文介绍了ZooKeeper，一个用于协调分布式应用进程的服务。<font color="red">ZooKeeper旨在提供一个简单且高性能的内核，用于构建更复杂的客户端协调原语。</font>它整合了组消息传递、共享寄存器和分布式锁服务的元素，形成了一个复制的、集中式的服务。Zookeeper提供了一个接口，具有共享寄存器的无等待特性和类似分布式文件系统缓存失效的事件驱动机制，以提供简单而强大的协调服务。ZooKeeper还保证了每个客户端请求的FIFO执行和所有更改ZooKeeper状态的请求的线性化。</p>
<h2 id="介绍" class="heading-element"><span>2 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><strong>分布式系统中的基本协调机制</strong>：</p>
<ul>
<li><strong>配置</strong>：最基本的形式，可能是静态或动态的操作参数列表。</li>
<li><strong>组成员资格和领导者选举</strong>：进程需要了解其他进程的状态及职责。</li>
<li><strong>锁</strong>：实现对临界区的互斥访问的强大协调原语。</li>
</ul>
<p>一种协调方法是为每种不同的协调需求（如队列服务、领导者选举服务）开发服务。也可以使用更强大的服务来实现其他原语（如Chubby是一种具有强同步保证的锁服务，它可以用于实现领导者选举、组成员资格等）。</p>
<p><strong>ZooKeeper的设计原则</strong>：</p>
<ol>
<li><font color="red">API暴露</font>。使开发人员能够实现自己的原语，而不是在服务器端实现特定原语。</li>
<li><font color="red">无等待数据对象</font>。避免使用阻塞原语（如锁），使系统性能更高、容错性更好。</li>
<li><font color="red">操作顺序保证</font>。实现FIFO客户端排序和可线性化写入。</li>
</ol>
<p>Zookeeper实现了一个API，用于操作<strong>像文件系统那样层次化组织</strong>的简单无等待数据对象。ZooKeeper服务由一组使用复制来实现高可用性和高性能的服务器组成，并且使用流水线架构实现，该架构支持大量未完成请求，保持低延迟。这样的流水线自然地支持了单个客户端按FIFO顺序执行操作。保证FIFO客户端顺序使得客户端可以异步提交操作。通过异步操作，客户端可以同时有多个未完成的操作。</p>
<p>为了保证更新操作满足可线性化，作者实现了一个基于领导者的原子广播协议，称为Zab。<font color="red">然而，Zookeeper应用程序的典型工作负载主要是读操作，因此需要进行读操作优化，即不使用Zab对它们进行全序排序，而是本地处理读操作，利用客户端缓存和监视机制（只缓存不直接管理）提高性能。</font>Chubby直接管理客户端缓存，其使用租约来防止故障客户端无限期地阻塞系统。然而，租约只能限制慢或故障客户端的影响，而ZooKeeper的监视机制则完全避免了这个问题。</p>
<h2 id="zookeeper服务" class="heading-element"><span>3 Zookeeper服务</span>
  <a href="#zookeeper%e6%9c%8d%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>客户端通过ZooKeeper客户端库的API向ZooKeeper服务提交请求，该库不仅提供了服务接口，还负责管理客户端与服务器之间的网络连接。客户端在连接ZooKeeper时建立<strong>会话</strong>，并通过会话句柄发送请求。</p>
<p>相关术语：</p>
<ul>
<li><strong>客户端</strong>：ZooKeeper服务的用户</li>
<li><strong>服务器</strong>：提供ZooKeeper服务的进程</li>
<li><strong>znode</strong>：ZooKeeper数据中的内存数据节点，该数据节点组织在称为<strong>数据树</strong>的分层命名空间中</li>
<li><strong>&ldquo;update&quot;和&quot;write&rdquo;</strong>：来指代任何修改数据树状态的操作。</li>
</ul>
<h3 id="服务概述" class="heading-element"><span>3.1 服务概述</span>
  <a href="#%e6%9c%8d%e5%8a%a1%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ZooKeeper服务为客户端提供了数据节点（znodes）的抽象概念，这些节点在层次命名空间中组织，类似于文件系统（如/A/B/C表示znode C的路径，其中C父节点是B），便于用户理解和组织数据。每个znode都存储数据，除了临时znode外，都可以有子节点。客户端可以创建两种类型znode：</p>
<ul>
<li><strong>常规znode</strong>：客户端显示创建和删除</li>
<li><strong>临时znode</strong>：客户端显示创建和删除，或者在创建它们的会话终止后由系统自动删除。、</li>
</ul>
<p>创建znode时，可以设置顺序标志，使用顺序标志创建的znode在其名称后附加一个单调递增的计数器值，确保节点名称的唯一性。</p>
<p><font color="red">ZooKeeper的监视机制允许客户端在变更发生时接收通知，无需轮询</font>。这种机制是一次性的，与会话关联，触发后或会话关闭时取消。<font color="red">客户端通过监视事件得知数据变化，但不会获得变化的具体内容</font>。</p>
<p>ZooKeeper的数据模型本质是一个简化API的文件系统或具有层次键的键值表，<font color="red">层次化命名空间对于不同应用程序的命名空间分配子树和设置这些子树的访问权限非常有用</font>。znode不是为一般数据存储设计，而是作为客户端应用协调的抽象。</p>
<p>例如，在下图中，有两个子树，一个用于app1（<code>/app1</code>），另一个用于app2（<code>/app2</code>）。app1的子树实现了一个简单的组成员协议：每个客户端进程<code>p_i</code>在<code>/app1</code>下创建一个znode <code>p_i</code>，该znode在进程运行期间持续存在。ZooKeeper允许客户端用znode存储一些可以用于分布式计算的元数据或配置的信息（例如当前领导者信息）。znode还包含时间戳和版本计数器，使客户端能够追踪变更并执行条件更新。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811214958210.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811214958210.png?size=small" data-sub-html="<h2>image-20240811214958210</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811214958210.png" alt="image-20240811214958210" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811214958210.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811214958210.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811214958210.png?size=large 2x" data-title="image-20240811214958210" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>客户端与ZooKeeper的会话具有超时机制，超时未收到信息即认为客户端故障。当客户端显式关闭会话句柄或ZooKeeper检测到客户端故障时，会话结束。<font color="red">会话期间，客户端可以跨服务器透明迁移，保持状态连续性</font>。</p>
<h3 id="客户端api" class="heading-element"><span>3.2 客户端API</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%afapi" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>以下是ZooKeeper API的相关子集：</p>
<ul>
<li><code>create(path, data, flags)</code>：创建一个具有路径名<code>path</code>的znode，存储<code>data[]</code>，并返回新znode的名称。<code>flags</code>使客户端可以选择znode的类型：常规、临时，并设置顺序标志。</li>
<li><code>delete(path, version)</code>：如果znode的版本与预期版本匹配，则删除路径为<code>path</code>的znode。</li>
<li><code>exists(path, watch)</code>：如果路径为<code>path</code>的znode存在，则返回true，否则返回false。<code>watch</code>标志允许客户端在znode上设置监视。</li>
<li><code>getData(path, watch)</code>：返回与znode关联的数据和元数据（如版本信息）。<code>watch</code>标志的工作方式与<code>exists()</code>相同，只是如果znode不存在，ZooKeeper不会设置监视。</li>
<li><code>setData(path, data, version)</code>：如果znode的版本号是当前版本，则将<code>data[]</code>写入路径为<code>path</code>的znode。</li>
<li><code>getChildren(path, watch)</code>：返回znode的子节点名称集合。</li>
<li><code>sync(path)</code>：等待在操作开始时挂起的所有更新传播到客户端连接的服务器。当前忽略路径。</li>
</ul>
<p>所有方法在API中都有同步和异步版本。当应用程序需要执行单个ZooKeeper操作且没有并发任务时，使用同步API，使其阻塞直到完成。而异步API允许应用程序执行多个ZooKeeper操作和其他任务，ZooKeeper客户端保证按顺序调用每个操作的相应回调。</p>
<blockquote>
<p>ZooKeeper不使用句柄访问znode。每个请求都包括被操作的znode的完整路径。这不仅简化了API（没有<code>open()</code>或<code>close()</code>方法），还消除了服务器需要维护的额外状态。每个更新方法都接受一个预期版本号，如果znode的实际版本号与预期版本号不匹配，更新将失败并返回版本错误。<font color="red">如果版本号为-1，则不进行版本检查。</font></p>
</blockquote>
<h3 id="zookeeper保证" class="heading-element"><span>3.3 Zookeeper保证</span>
  <a href="#zookeeper%e4%bf%9d%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ZooKeeper通过两项基本的顺序保证来确保操作的一致性和可预测性：</p>
<ul>
<li><strong>线性化写入</strong>：所有更新ZooKeeper状态的请求都是可序列化的，并且遵循优先级。</li>
<li><strong>FIFO客户端顺序</strong>：来自同一客户端的所有请求按照它们被发送的顺序执行。</li>
</ul>
<p>ZooKeeper的线性化定义扩展了Herlihy的原始定义，称为异步线性化，允许客户端有多个未完成的操作，并保证这些操作的FIFO顺序。</p>
<p>这种顺序保证对于分布式系统中的领导者选举和配置更新至关重要。例如，当新领导者需要更新大量配置参数时，可以利用ZooKeeper的顺序保证来确保配置的一致性和完整性。新领导者通过创建一个<code>ready</code> znode来控制配置的更新，其他进程只有在该znode存在时才会采用新的配置。新领导者通过删除<code>ready</code>、更新各种配置znode和创建<code>ready</code>来进行配置更改。<font color="red">所有这些更改可以流水线处理，并异步发布，以快速更新配置状态</font>。</p>
<p>此外，ZooKeeper的通知机制确保了客户端能够及时接收到变更通知，而sync操作则允许客户端在需要时强制更新读取，以获取最新的系统状态。</p>
<p>ZooKeeper的设计允许它在保持高吞吐量的同时，也保证了系统的<strong>活性和持久性</strong>。只要大多数服务器处于活动状态并能够通信，服务就能保持可用。<font color="red">而且，一旦服务成功响应了更改请求，那么只要法定数量的服务器能够恢复，这些更改能在任何数量的故障中持久化</font>。</p>
<h3 id="原语示例" class="heading-element"><span>3.4 原语示例</span>
  <a href="#%e5%8e%9f%e8%af%ad%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ZooKeeper API提供了实现复杂原语的能力，这些原语完全在客户端实现，服务端并不感知。无论是配置管理、汇合点、组成员关系还是锁机制，ZooKeeper都能通过其API提供支持。ZooKeeper的顺序保证允许高效地推理系统状态，而监视则允许高效地等待。</p>
<ul>
<li>
<p><strong>配置管理</strong>：最简单的形式是将配置存储在一个 znode（$z_c$）中。进程启动时获取 $z_c$ 的完整路径名。启动的进程通过读取 $z_c$ 并将监视标志设置为 true 来获得其配置。如果 $z_c$ 中的配置被更新，进程会收到通知并读取新配置，重新设置监视标志为 true。</p>
<blockquote>
<p>在这种方案中，尽管有很多次变化，但通常进程只会收到一次，这并不会影响进程的行为，因为监视是用来通知进程它已经知道的信息：它所拥有的 $z_c$ 信息是过时的。</p>
</blockquote>
</li>
<li>
<p><strong>汇合点</strong>：在分布式系统中，有时并不总是能事先明确最终的系统配置。可以使用 ZooKeeper 处理这种情况，通过一个称为汇合点的 znode（$z_r$），这是由客户端创建的节点。客户端将 $z_r$ 的完整路径名作为启动参数传递给主进程和工作进程。当主进程启动时，它会将其使用的地址和端口信息填充到 $z_r$ 中。当工作进程启动时，它们会读取 $z_r$ 并将监视设置为 true。如果 $z_r$ 尚未填充，工作进程将等待被通知 $z_r$ 更新。如果 $z_r$ 是一个临时节点，主进程和工作进程可以监视 $z_r$ 的删除，并在客户端结束时进行清理。</p>
</li>
<li>
<p><strong>组成员关系</strong>：我们利用临时节点允许查看创建该节点的会话状态。首先指定一个 znode（$z_g$）来代表组。当组中的一个进程成员启动时，它会在 $z_g$ 下创建一个临时子 znode。如果每个进程都有唯一的名称或标识符，则该名称用于子 znode 的名称；否则，进程将使用 <code>SEQUENTIAL</code> 标志创建 znode 以获得唯一的名称分配。</p>
<p><font color="red">进程可以将进程信息放入子 znode 的数据中，例如进程使用的地址和端口</font>。在 $z_g$ 下创建子 znode 后，进程正常启动，不需要做其他任何事情。如果进程失败或结束，代表它的 znode 在 $z_g$ 下自动移除。进程可以通过列出 $z_g$ 的子节点来获取组信息。如果进程想监视组成员变动，可以将监视标志设置为 true，并在收到变动通知时刷新组信息（始终将监视标志设置为 true）。</p>
</li>
<li>
<p><strong>简单锁</strong>：尽管 ZooKeeper 不是一个锁服务，但它可以用来实现锁，以实现各种通用同步原语。最简单的锁实现使用“锁文件”。锁由一个 znode 表示。</p>
<ul>
<li>要获取锁，客户端尝试创建带有 <code>EPHEMERAL</code> 标志的指定 znode。如果创建成功，客户端持有锁。否则，客户端可以读取 znode 并设置监视标志，以便在当前持有锁的客户端死亡时收到通知。</li>
<li>客户端在死亡或显式删除 znode 时释放锁。等待锁的其他客户端在观察到 znode 被删除后再次尝试获取锁。</li>
</ul>
<p>虽然这种简单的锁协议有效，但它确实存在一些问题。</p>
<ul>
<li><font color="red">它遭受群体效应</font>。如果有许多客户端等待获取锁，当锁被释放时，它们都会争夺锁，尽管只有一个客户端可以获取锁。</li>
<li><font color="red">它只实现了独占锁</font>。</li>
</ul>
<p>以下两个原语展示了如何克服这两个问题。</p>
</li>
<li>
<p><strong>无群体效应的简单锁</strong>：我们定义一个锁 znode（$l$）来实现这样的锁。直观上，我们将所有请求锁的客户端排队，每个客户端按请求到达的顺序获取锁。因此，客户端希望获取锁时执行以下操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Lock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 SEQUENTIAL 标志将客户端获取锁的尝试按与其他所有尝试的顺序排列。n代表Zookeeper自动分配的唯一序列号</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="n">n</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="err">“</span><span class="o">/</span><span class="n">lock</span><span class="o">-</span><span class="err">”</span><span class="p">,</span> <span class="n">EPHEMERAL</span><span class="o">|</span><span class="n">SEQUENTIAL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 获取锁路径下所有子节点的列表。</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="n">C</span> <span class="o">=</span> <span class="n">getChildren</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 如果当前创建的节点 n 是子节点列表 C 中最小的一个，即没有其他节点有更小的序号，那么这个客户端获得了锁，退出。</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">lowest</span> <span class="n">znode</span> <span class="ow">in</span> <span class="n">C</span><span class="p">,</span> <span class="n">exit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 果当前节点 n 不是最小的，找到列表中直接排在 n 前面的节点 p。（即每个都等待前一个，这样避免了群体效应，因为只有一个进程在锁被释放或锁请求被放弃时被唤醒）</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="n">p</span> <span class="o">=</span> <span class="n">znode</span> <span class="ow">in</span> <span class="n">C</span> <span class="n">ordered</span> <span class="n">just</span> <span class="n">before</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 检查节点 p 是否仍然存在。由于节点是临时的，如果持有锁的客户端断开了连接，节点 p 将被自动删除。</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">	<span class="c1"># 设置一个监视器，等待节点 p 的状态变化事件</span>
</span></span><span class="line"><span class="cl">	<span class="n">wait</span> <span class="k">for</span> <span class="n">watch</span> <span class="n">event</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 如果 p 不存在，说明那个客户端已经释放了锁，仍然有一个更低序列号的 znode 正在等待或持有锁，所以当前客户端应该再次检查自己是否是最小的节点。</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="n">goto</span> <span class="mi">2</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Unlock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="n">delete</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种锁方案具有以下优点：</p>
<ol>
<li><font color="red">znode 的删除只会唤醒一个客户端</font>，因为每个 znode 只有一个其他客户端在监视，所以我们没有群体效应；</li>
<li>没有轮询或超时；</li>
<li>由于我们实现锁的方式，<font color="red">我们可以通过浏览 ZooKeeper 数据查看锁争用情况、破坏锁和调试锁问题</font>。</li>
</ol>
</li>
<li>
<p><strong>读/写锁</strong>：为了实现读/写锁，我们稍微更改了锁过程，并有单独的读锁和写锁过程。解锁过程与全局锁的情况相同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Write Lock</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="n">n</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="err">“</span><span class="o">/</span><span class="n">write</span><span class="o">-</span><span class="err">”</span><span class="p">,</span> <span class="n">EPHEMERAL</span><span class="o">|</span><span class="n">SEQUENTIAL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="n">C</span> <span class="o">=</span> <span class="n">getChildren</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">lowest</span> <span class="n">znode</span> <span class="ow">in</span> <span class="n">C</span><span class="p">,</span> <span class="n">exit</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="n">p</span> <span class="o">=</span> <span class="n">znode</span> <span class="ow">in</span> <span class="n">C</span> <span class="n">ordered</span> <span class="n">just</span> <span class="n">before</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">event</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="n">goto</span> <span class="mi">2</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Read Lock</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="n">n</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="err">“</span><span class="o">/</span><span class="n">read</span><span class="o">-</span><span class="err">”</span><span class="p">,</span> <span class="n">EPHEMERAL</span><span class="o">|</span><span class="n">SEQUENTIAL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="n">C</span> <span class="o">=</span> <span class="n">getChildren</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="k">if</span> <span class="n">no</span> <span class="n">write</span> <span class="n">znodes</span> <span class="n">lower</span> <span class="n">than</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">C</span><span class="p">,</span> <span class="n">exit</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="n">p</span> <span class="o">=</span> <span class="n">write</span> <span class="n">znode</span> <span class="ow">in</span> <span class="n">C</span> <span class="n">ordered</span> <span class="n">just</span> <span class="n">before</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">event</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="n">goto</span> <span class="mi">3</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此锁过程与之前的锁略有不同。写锁仅在命名上有所不同。读锁第 3 行和第 4 行有所不同，因为只有较早的写锁 znode 会阻止客户端获取读锁。看起来当有多个客户端等待读锁时，会出现“群体效应”，并在较低序列号的“write-” znode 被删除时收到通知；实际上，这正是我们所期望的行为。<font color="red">一旦写锁被释放，所有等待读锁的客户端都应该被唤醒，因为它们现在有可能共同持有读锁</font>。这是因为读锁是可以共享的，一旦没有任何写锁存在，所有的读锁请求都可以被满足，所有等待读锁的客户端都能继续它们的操作，无需再等待。这种机制确保了读操作的高并发性，同时保证了写操作的独占性，从而维护了数据的一致性和完整性。</p>
</li>
<li>
<p><strong>双重屏障</strong>：双重屏障机制为客户端提供了一种优雅的方式来同步计算阶段的启动与终止，确保所有参与方在统一的信号下协同行动。当加入屏障的进程数量超过屏障阈值时，标志着计算活动的开启；而随着各进程完成任务并相继退出，屏障亦随之解除。在这一机制中，屏障自身以ZooKeeper中的 znode 表示，我们将其命名为 $b$。</p>
<p>每当进程 $p$ 欲进入屏障，它首先通过在 $b$ 下创建一个子 znode 来进行注册，表明自身已加入计算预备队列；而当进程准备撤离屏障，即宣告任务完成之时，它将移除先前创建的子 znode，以此来注销。<font color="red">屏障的激活与释放，分别对应于 $b$ 下子节点数目越过阈值及全部子节点被清除这两个条件</font>。</p>
<p>为了确保进程高效等待进入与退出条件的达成，Zookeeper巧妙地运用了监视器。在进程寻求进入屏障时，它会设置监视器以监听 $b$ 的某个子 znode 的存在状态——这个子 znode 是由导致子节点数量首次超越屏障阈值的那个进程创建的。如此一来，进程得以实时知晓屏障开启的瞬间。相反，在进程意欲退出屏障之际，它将监视某个特定的子 znode 的消失，只有当这个标记着屏障即将解除的子 znode 被移除后，进程才检查是否满足退出条件，进而安全有序地脱离屏障环境。</p>
</li>
</ul>
<h2 id="zookeeper应用" class="heading-element"><span>4 ZooKeeper应用</span>
  <a href="#zookeeper%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>ZooKeeper作为一种强大的协调服务，在多种应用程序中发挥着关键作用。</p>
<ul>
<li>Yahoo!的抓取服务（FS）利用ZooKeeper来<strong>管理配置元数据</strong>、<strong>进行领导者选举</strong>，并从主进程故障中恢复，确保服务的高可用性。此外，ZooKeeper的监视机制允许FS在不直接与服务器通信的情况下，通过读取ZooKeeper中的状态信息来向健康的服务器发送请求。</li>
<li>Katta作为一个非Yahoo!的分布式索引器，使用ZooKeeper进行协调，通过分片来分配索引工作。Katta使用ZooKeeper来跟踪主从服务器的状态（<strong>组成员关系</strong>），并处理主服务器的故障转移（<strong>领导者选举</strong>）。Katta还使用ZooKeeper来跟踪和管理分片分配给从服务器的分配（<strong>配置管理</strong>）。</li>
<li>Yahoo!消息代理（YMB）是一个分布式发布-订阅系统。该系统管理数千个主题，客户端可以发布消息并接收消息。为了提供可扩展性，主题分布在一组服务器中。每个主题都使用主-备方案进行复制，确保消息被复制到两台机器上，以确保可靠地消息传递。构成YMB的服务器使用无共享分布式架构，这使得协调对于正确操作至关重要。<font color="red">YMB使用ZooKeeper来管理主题的分配（配置元数据），处理系统中机器的故障（故障检测和组成员关系），以及控制系统操作</font>。YMB的znode数据布局显示了如何通过ZooKeeper实现对活跃服务器的负载和状态信息的监控，以及如何通过集中控制实现对服务的管理和协调。</li>
</ul>
<h2 id="zookeeper实现" class="heading-element"><span>5 Zookeeper实现</span>
  <a href="#zookeeper%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>ZooKeeper通过在构成其服务的每台服务器上进行数据复制来保障高可用性。这一设计考虑到了服务器可能发生的故障，同时假设故障服务器在后期能够恢复。为了维持服务的连续性和一致性，ZooKeeper采用了所下图所展示的一系列关键组件，确保了即使在单个服务器故障的情况下，整体服务仍能继续运行。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811220635787.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811220635787.png?size=small" data-sub-html="<h2>image-20240811220635787</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811220635787.png" alt="image-20240811220635787" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811220635787.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811220635787.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240811220635787.png?size=large 2x" data-title="image-20240811220635787" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当ZooKeeper服务器接收到请求时，首先通过请求处理器进行预处理。如果请求涉及服务器间的协作（如写操作），则会启动一个基于原子广播协议的共识机制。这种机制确保所有服务器最终将请求导致的变更同步至完全复制的数据库中，从而维护数据的一致性。对于只读请求，则可以直接从服务器本地的数据库副本中获取数据并形成响应，无需触发复杂的共识过程，这大大提升了读取操作的效率。</p>
<p>数据库是内存中的，包含整个数据树，每个znode默认存储最大1MB的数据，但此值可配置。为了确保可恢复性，更新高效地记录到磁盘，且在应用于内存数据库前，强制写入磁盘。<font color="red">如同Chubby，我们维护一个重播日志，即写前日志，记录已提交的操作，并定期生成内存数据库的快照</font>。</p>
<p>每个ZooKeeper服务器服务于客户端，客户端连接至某一台服务器提交请求。读请求从各服务器本地数据库的副本中服务，而写请求则通过共识协议处理。作为共识协议的一部分，写请求被转发至被称为领导者的单一服务器。其余服务器，即跟随者，接收来自领导者的状态变更提议，并对状态变更达成一致。</p>
<h3 id="请求处理" class="heading-element"><span>5.1 请求处理</span>
  <a href="#%e8%af%b7%e6%b1%82%e5%a4%84%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于消息层的原子性，Zookeeper保证本地副本不会分歧，尽管任一时刻某些服务器可能应用了更多事务。不同于客户端发出的请求，事务是幂等的。当领导者接收到写请求时，它计算出写操作应用后的系统状态，并转换为捕捉新状态的事务。必须计算未来状态，因为可能有尚未应用到数据库的待处理事务。例如，客户端执行条件<code>setData</code>操作，如果请求中的版本号与待更新znode的未来版本号匹配，服务生成包含新数据、新版本号和更新时间戳的<code>setDataTXN</code>。若出现错误，如版本号不匹配或待更新的znode不存在，将生成<code>errorTXN</code>。</p>
<h3 id="原子广播" class="heading-element"><span>5.2 原子广播</span>
  <a href="#%e5%8e%9f%e5%ad%90%e5%b9%bf%e6%92%ad" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>所有更新ZooKeeper状态的请求均转发至领导者。领导者执行请求并通过Zab，一种原子广播协议，广播状态变更。接收客户端请求的服务器在交付相应状态变更时响应客户端。<font color="red">Zab默认使用简单多数票机制决定提案，因此Zab和ZooKeeper仅在多数服务器正常（即在$2f+1$服务器中可容忍$f$次故障）时工作</font>。</p>
<p>为了实现高吞吐量，ZooKeeper尽力保持请求处理管道满载，可能有成千上万的请求处于管道的不同部分。由于状态变更依赖于先前状态变更的应用，Zab提供了比常规原子广播更强的顺序保证：</p>
<ul>
<li>由领导者广播的变更按照发送顺序交付</li>
<li>所有来自之前领导者的变更在新领导者广播自身变更前交付。</li>
</ul>
<p><font color="red">使用TCP作为传输层简化了实施，因为消息顺序由网络维护</font>。Zab选出的领导者同时也是ZooKeeper的领导者，创建事务的同时也提议事务。使用日志作为内存数据库的写前日志，避免了两次写磁盘。Zab在常规操作中确实按顺序和恰好一次交付所有消息，但由于Zab未持久记录每个已交付消息的ID，因此在恢复过程中可能重传消息。由于使用了幂等事务，只要按顺序交付，多次交付是可以接受的。</p>
<h3 id="复制数据库" class="heading-element"><span>5.3 复制数据库</span>
  <a href="#%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e5%ba%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个副本在内存中保存一份ZooKeeper状态的拷贝。当服务器从崩溃中恢复，需要恢复此内部状态。重放所有已交付的消息以恢复状态可能耗时过长，故ZooKeeper使用周期性快照，仅要求重传自快照开始以来的消息。<font color="red">我们称ZooKeeper快照为模糊快照，因为不锁定ZooKeeper状态来生成快照；相反，进行深搜，原子读取每个znode的数据和元数据，写入磁盘</font>。但是，由于快照的生成并非瞬时完成，这意味着在快照生成的过程中，新的状态变更可能会发生。因此，最终的快照可能包含了部分已提交但未被快照捕获的状态变更，导致快照中的数据并不完全反映某个时间点的系统状态。<font color="red">然而，由于状态变更是幂等的，我们可以按顺序重复应用它们。</font></p>
<p>例如，假设ZooKeeper数据树中两个节点<code>/foo</code>和<code>/goo</code>分别具有值<code>f1</code>和<code>g1</code>，且版本均为$1$，当模糊快照开始时，以下状态变更流<code>&lt;transactionType, path, value, new-version&gt;</code>到达：</p>
<ul>
<li><code>&lt;SetDataTXN, /foo, f2, 2&gt;</code></li>
<li><code>&lt;SetDataTXN, /goo, g2, 2&gt;</code></li>
<li><code>&lt;SetDataTXN, /foo, f3, 3&gt;</code></li>
</ul>
<p>处理这些状态变更后，<code>/foo</code>和<code>/goo</code>的值分别为<code>f3</code>和<code>g2</code>，版本为$3$和$2$。然而，模糊快照可能记录了<code>/foo</code>和<code>/goo</code>的值为<code>f3</code>和<code>g1</code>，版本为$3$和$1$，即第一个变更和第三个变更被快照捕获，但第二个变更之前快照生成完成，这不是ZooKeeper数据树的有效状态。</p>
<p><font color="red">当服务器崩溃并重新启动时，它会从最近的快照恢复，然后重放自该快照之后的所有事务日志。由于事务是幂等的，即使快照中的状态与实际的某时刻状态不完全一致，重放事务日志也能确保服务器恢复到最后一致的状态</font>。</p>
<h3 id="客户端-服务器交互" class="heading-element"><span>5.4 客户端-服务器交互</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af-%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%ba%a4%e4%ba%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ZooKeeper通过客户端-服务器交互实现高效的分布式协调。服务器在处理写请求时，会发送并清除相关监视通知，保证通知的顺序性。服务器顺序处理写请求，而读请求则在本地服务器上独立处理，每个读请求都会标记一个zxid，代表服务器已看到的最后事务，从而确保读写请求的部分顺序性。</p>
<p>本地处理读请求带来了出色的读取性能，因为它仅仅是本地服务器上的内存操作，无需磁盘活动或运行协议。然而，这种快速读取可能不保证读操作的顺序性，可能会返回过时的数据。为了解决这个问题，<font color="red">ZooKeeper提供了同步操作<code>sync()</code>，通过领导者异步执行并排序，客户端只需读取后立即调用<code>sync()</code>，确保读操作能够返回最新（<code>sync</code>之前所有的变更）的数据</font>。</p>
<p>ZooKeeper服务器使用FIFO顺序处理客户端请求，并在响应中包含相关的zxid，确保客户端即使在服务器间切换时也能看到最新的数据（需要检查zxid）。此外，<font color="red">ZooKeeper使用超时机制来检测客户端会话故障，客户端通过发送心跳消息（包含最后一个zxid）来维持会话，如果无法与当前服务器通信，会自动切换到其他服务器</font>。</p>
<h2 id="评估" class="heading-element"><span>6 评估</span>
  <a href="#%e8%af%84%e4%bc%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>ZooKeeper展现出了卓越的性能，其<strong>高吞吐量和低请求延迟</strong>在多个基准测试中得到了证明。在模仿Chubby基准的测试中，即使处理的数据量增加，ZooKeeper的吞吐量也达到了Chubby的三倍以上。具体来说，单个工作进程在三个服务器上的平均请求延迟仅为1.2毫秒，在九个服务器上为1.4毫秒。</p>
<p>在屏障性能测试中，ZooKeeper处理屏障操作的能力随着屏障数量和客户端数量的增加而线性增长，显示出对并发访问的高效管理，并没有出现意外的延迟。即使在高比例的读操作下（80%），ZooKeeper的屏障操作吞吐量也保持在每秒1,950到3,100次之间，远高于实际应用中所需的性能。</p>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】Raft</title><link>https://hezephyr.github.io/posts/07.raft/</link><pubDate>Thu, 25 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/07.raft/</guid><description><![CDATA[<h2 id="脑裂" class="heading-element"><span>1 脑裂</span>
  <a href="#%e8%84%91%e8%a3%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>许多容错系统使用一个单主节点来决定主副本。</p>
<ul>
<li><strong>MapReduce</strong>：由单主节点控制计算复制。</li>
<li><strong>GFS</strong>：主备复制数据，并由单主节点确定主拷贝的位置。</li>
<li><strong>VMware FT</strong>：主虚机和备份虚机之间复制指令，需要单点的Test-and-Set服务确认主虚机。</li>
</ul>
<p>这三个例子都是一个多副本系统，<font color="red">系统容错的关键点转移到这个主节点上</font>。</p>
<p>使用单主节点，我们则需要避免<strong>脑裂（Split-Brain）问题</strong>。脑裂指的是在多副本系统中，因网络分裂导致多个副本都认为自己是主副本，从而出现数据不一致或功能冲突的问题。</p>
<p>这里有两种<strong>解决方案</strong></p>
<ol>
<li>构建高可靠网络：如果网络完全不出现故障，客户端无法访问的服务器即被认为是关机，这样可以排除脑裂的可能。<font color="red">但需要大量资金和控制物理环境</font>。</li>
<li>人工解决问题：客户端默认等待两个服务器的响应。如果只收到一个响应，需人工检查两个服务器的状态。<font color="red">人工检查虽然能解决问题，但可能不够及时</font>。</li>
</ol>
<h2 id="过半票决" class="heading-element"><span>2 过半票决</span>
  <a href="#%e8%bf%87%e5%8d%8a%e7%a5%a8%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在构建能自动恢复，同时又避免脑裂的多副本系统时，关键点在于<strong>过半票决（Majority Vote）</strong>，这是Raft论文中提出的一个基本概念，<font color="red">即在一个多副本系统中，任何操作必须得到超过一半的服务器同意才能完成</font>。为了有效使用过半票决，服务器数量应该是奇数。这样在出现网络分区时，一个分区无法拥有超过半数的服务器，从而避免脑裂。对于过半票决，可以用下面这个通用方程来描述：</p>
<p>如果系统有$2\times F+1$个服务器，那么系统最多可以接受$F$个服务器出现故障。</p>
<p>Raft协议依赖过半票决来进行Leader选举和日志提交。每个操作需要过半的服务器批准。任何两个操作的过半服务器至少有一个重叠。</p>
<ul>
<li><strong>Leader选举</strong>：新选出的Leader必然获得过半服务器的选票，而这些服务器与旧Leader的服务器有重叠，因此知道旧Leader的任期号。</li>
<li><strong>日志一致性</strong>：新Leader的过半服务器包含了旧Leader的操作，确保日志一致性。</li>
</ul>
<h2 id="raft概述" class="heading-element"><span>3 Raft概述</span>
  <a href="#raft%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft协议作为库（Library）存在于服务中，每个Raft副本包含应用程序代码和Raft库。<font color="red">应用程序代码处理RPC或其他客户端请求，Raft库负责同步多副本之间的操作</font>。</p>
<p><strong>操作流程</strong>如下：</p>
<ol>
<li>
<p><strong>客户端请求</strong>：客户端发送请求（如Put或Get）到Raft集群的Leader节点。</p>
</li>
<li>
<p><strong>请求处理</strong>：</p>
<ul>
<li><strong>Raft层</strong>：Leader节点将请求操作传递给Raft层，要求将操作写入日志。Raft节点之间的交互确保操作被过半节点复制。当Leader节点确认过半副本都有操作的拷贝后，通知应用程序层执行操作。</li>
</ul>
<ul>
<li><strong>应用程序层</strong>：仅在收到Raft层的确认后才执行操作（更新数据库或读取值）。</li>
</ul>
</li>
<li>
<p><strong>操作提交</strong>：</p>
<ul>
<li><strong>Raft层</strong>：通知应用程序层，操作已在过半副本中复制完成，可以执行。</li>
<li><strong>应用程序层</strong>：执行操作并最终返回结果给客户端。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>为何不需要拷贝到所有节点？</strong></p>
<p>为了容错，系统只需过半的副本即可完成操作，这样即使部分服务器故障，系统仍能继续工作。</p>
<p><strong>除了Leader节点，其他节点的应用程序层会有什么样的动作？</strong></p>
<p>在操作在Leader节点提交后，其他副本的Raft层将操作传递给本地应用程序层，确保所有副本的操作序列一致，状态最终保持一致。</p>
</blockquote>
<h2 id="日志" class="heading-element"><span>4 日志</span>
  <a href="#%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如下图所示，展示了Raft协议在处理客户端请求时的消息交互流程，AE代表<code>AppendEntries</code> RPC。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=small" data-sub-html="<h2>image-20240724224709014</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png" alt="image-20240724224709014" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=large 2x" data-title="image-20240724224709014" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li><strong>客户端请求</strong>：客户端发送一个Put请求到当前Raft集群的Leader节点（S1）。</li>
<li><strong>Leader节点处理</strong>：S1的Raft层发送AppendEntries RPC到其他两个副本节点（S2、S3）。S1等待至少一个Follower节点（S2或S3）的响应以达到过半节点的响应。</li>
<li><strong>Follower节点响应</strong>：S2、S3接收AppendEntries RPC并返回响应给Leader（S1）。S1只需等待一个Follower节点的正确响应即可。</li>
<li><strong>操作提交</strong>：一旦S1收到过半节点的正确响应（包括自己），S1执行客户端请求并返回结果给客户端。</li>
<li><strong>通知其他副本</strong>：S2、S3在收到AppendEntries后不确定请求是否被Leader提交。Leader需要在下一次AppendEntries或心跳消息中通知其他副本请求已被commit。其他副本收到此消息后，更新本地状态，执行已提交的请求。</li>
</ol>
<p>Raft系统对Log的关注有几个关键原因：</p>
<ol>
<li><strong>操作排序</strong>：所有副本不仅要执行相同的操作，还要以相同的顺序执行这些操作。Log由编号的槽位（类似一个数组）组成，槽位的数字表示了Leader选择的顺序。</li>
<li><strong>临时存储</strong>：Follower收到操作但还未执行时，需要将操作存放在某处，直到收到Leader发送的commit号。Log就是这个临时存储的地方。Follower在操作commit前不确定这些操作是否会被执行，有时这些操作可能会被丢弃。</li>
<li><strong>重传机制</strong>：Leader记录操作在其Log中，因为这些操作可能需要重传给Follower。如果Follower短时间离线或丢失了一些消息，Leader需要能够向Follower重传丢失的Log消息。即使是已commit的请求，为了向丢失相应操作的副本重传，Leader也需要在Log中存储这些操作。</li>
<li><strong>状态恢复</strong>：Log帮助重启的服务器恢复状态。故障重启后的服务器使用存储在磁盘中的Log，从头执行其中的操作，重建故障前的状态并继续运行。每个Raft节点都需要将Log写入磁盘，确保故障重启后Log能保留，帮助服务器恢复状态。</li>
</ol>
<h2 id="应用层接口" class="heading-element"><span>5 应用层接口</span>
  <a href="#%e5%ba%94%e7%94%a8%e5%b1%82%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在Raft集群中，每一个副本上，应用层（如key-value数据库）和Raft层之间主要有两个接口。这两个接口分别用于转发客户端请求给Raft层，以及Raft层通知应用层请求已被commit。</p>
<p>第一个接口是key-value层用来转发客户端请求的接口—Start函数。当客户端发送请求给key-value层时，key-value层会将请求转发给Raft层，并告诉Raft层将请求存放在Log中。Start函数只接收一个参数，即客户端请求。Start函数的返回值包括：</p>
<ul>
<li>请求在Log中的位置（index）</li>
<li>当前的任期号（term number）</li>
<li>其他信息</li>
</ul>
<p>第二个接口是<code>applyCh</code> channel，<font color="red">以Go <code>channel</code>中的一条消息形式存在</font>。Raft层会通过发送ApplyMsg消息给applyCh来通知key-value层哪些请求已经commit，key-value层读取这些消息。ApplyMsg包含：</p>
<ul>
<li>请求（command）</li>
<li>对应的Log位置（index）</li>
</ul>
<p>所有的副本都会收到ApplyMsg消息，知道应该执行请求并应用在本地状态中。Leader需要知道ApplyMsg中的请求对应哪个客户端请求，以便响应客户端请求。</p>
<h2 id="leader-选举" class="heading-element"><span>6 Leader 选举</span>
  <a href="#leader-%e9%80%89%e4%b8%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>引入Leader的原因：</p>
<ul>
<li>
<p>有Leader系统效率更高，因为请求只需一轮消息即可获得过半认可。</p>
</li>
<li>
<p>无Leader系统需要一轮消息确认临时Leader，再一轮确认请求，效率较低。</p>
</li>
</ul>
<p>Raft使用任期号（term number）区分不同的Leader。每个任期最多有一个Leader。Followers只需知道当前的任期号。</p>
<p>Leader选举过程如下：</p>
<ol>
<li>如果Follower在选举定时器时间内未收到Leader消息，会认为Leader下线，开始选举。</li>
<li>当前节点增加任期号，发起选举。</li>
<li>节点发送<code>RequestVote</code> RPC给其他节点，自己投票给自己。</li>
<li>节点需要获得过半服务器的认可投票才能成为Leader。</li>
</ol>
<p>任期内每个节点只投一次票，就不可能有两个候选人同时获得过半的选票，确保每个任期最多一个Leader。成功当选后，Leader立即发送<code>AppendEntries</code>消息（心跳）通知其他节点自己当选。</p>
<p>如果Leader在网络分区中少数服务器内，无法获得过半认可，不能commit请求。旧Leader在小分区内运行，但不能执行客户端请求，只能发送心跳。</p>
<blockquote>
<p><strong>有没有可能出现极端的情况，导致单向的网络出现故障，进而使得Raft系统不能工作？</strong></p>
<p>如果当前Leader的网络单边出现故障，Leader可以发出心跳，但是又不能收到任何客户端请求。它发出的心跳被送达了，因为它的出方向网络是正常的，那么它的心跳会抑制其他服务器开始一次新的选举。但是它的入方向网络是故障的，这会阻止它接收或者执行任何客户端请求。这个场景是Raft并没有考虑的众多极端的网络故障场景之一。</p>
<p>可以通过一个双向的心跳机制来解决。即Leader发送心跳，Follower要响应这个心跳，如果Leader没有收到响应，则会决定卸任。</p>
</blockquote>
<p>所有Raft节点收到任何一条AppendEntries消息都会重置其选举定时器。只要Leader以合理的速率发送心跳或其他AppendEntries消息，Followers就会重置选举定时器，阻止其他节点成为候选人。在没有网络故障或丢包的情况下，<font color="red">连续的心跳消息会防止新的选举发生</font>。</p>
<p>如果出现<strong>服务器故障或网络问题</strong>或者<strong>分割选票（多个候选人几乎同时竞选，选票分散）</strong>，可能导致无法凑齐过半服务器，无法选出Leader，这次选举就失败了。</p>
<p>Raft不能完全避免分割选票问题，但可以大大降低发生概率。通过随机选择选举定时器的超时时间，减少同步超时的概率。</p>
<p><strong>超时时间设置</strong>：</p>
<ul>
<li><strong>下限</strong>：至少大于Leader的心跳间隔，多次心跳间隔更好（例如3次心跳间隔）。</li>
<li><strong>上限</strong>：远小于服务器两次故障之间的平均时间。</li>
<li><strong>时间差</strong>：足够大以确保第一个超时节点能够完成一轮选举，至少需要大于发送一条RPC的往返时间。</li>
</ul>
<blockquote>
<center>lab tip
</center>
<p><font color="red">每一次一个节点重置自己的选举定时器时，都需要重新选择一个随机的超时时间。</font>避免服务器会以极小的概率选择相同的随机超时时间，那么会永远处于分割选票的场景中</p>
</blockquote>
<h2 id="日志恢复" class="heading-element"><span>7 日志恢复</span>
  <a href="#%e6%97%a5%e5%bf%97%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><strong>Leader正常运行时</strong>，Follower必须同意并接收Leader的日志。但<strong>Leader故障后</strong>，新Leader需要整理各副本可能不一致的日志。</p>
<p>新Leader会发送包含<code>prevLogIndex</code>和<code>prevLogTerm</code>的AppendEntries RPC。</p>
<p>Follower检查本地日志是否匹配：</p>
<ul>
<li><strong>不匹配</strong>：拒绝AppendEntries，Leader减少nextIndex并重试。</li>
<li><strong>匹配</strong>：接受AppendEntries，更新本地日志。</li>
</ul>
<blockquote>
<p><strong>为什么Raft系统可以安全的删除不一致的日志？</strong></p>
<p>如果日志条目未存在于过半服务器中，旧Leader不可能commit该条目，也就不可能将它应用到应用程序的状态中，安全删除无影响。<font color="red">并且如果客户端未收到回复，将重发请求，确保请求最终被处理</font>。</p>
<p><strong>为什么总是删除Followers的Log的结尾部分？</strong></p>
<p>Leader具有完整的Log记录，可以在任何需要的时候填充Followers的日志。如果系统刚启动，或发生反常情况，Leader能够从第一条记录开始恢复Followers的日志，因为它有所有必要的信息。</p>
</blockquote>
<h2 id="选举约束" class="heading-element"><span>8 选举约束</span>
  <a href="#%e9%80%89%e4%b8%be%e7%ba%a6%e6%9d%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了保证系统的正确性，并非任意节点都可以成为Leader。不是说第一个选举定时器超时了并触发选举的节点，就一定是Leader。Raft对于谁可以成为Leader，存在一些限制。限制条件如下：</p>
<ul>
<li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号；</li>
<li>或者，候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录长度。</li>
</ul>
<p>所以Raft更倾向于选择拥有更高任期号记录的候选人，确保系统一致性。</p>
<h2 id="快速恢复" class="heading-element"><span>9 快速恢复</span>
  <a href="#%e5%bf%ab%e9%80%9f%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>基于上述介绍，Leader<strong>现行机制</strong>是每次回退一条Log条目来解决日志冲突。如果Follower长时间关机，错过大量AppendEntries消息。Leader重启后需逐条RPC回退Log条目，耗时较长。</p>
<p>Raft论文中提供了一个快速恢复方法。<font color="red">Follower返回足够信息给Leader，使Leader能按任期（Term）为单位回退，而非逐条回退</font>。Follower拒绝AppendEntries消息时，返回以下3个信息：</p>
<ul>
<li><strong>XTerm</strong>：Follower中与Leader冲突的Log条目的任期号。</li>
<li><strong>XIndex</strong>：Follower中，任期号为XTerm的第一条Log条目的槽位号。</li>
<li><strong>XLen</strong>：Follower中空白Log槽位数。</li>
</ul>
<blockquote>
<p>可以使用二分查找等更高效的方法进一步加速。</p>
</blockquote>
<h2 id="持久化" class="heading-element"><span>10 持久化</span>
  <a href="#%e6%8c%81%e4%b9%85%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在Raft协议中，持久化存储（persistence）和非持久化存储（volatile）的区别在于服务器重启时的状态保持。持久化存储确保服务器重启后能够恢复到之前的状态，从而保证服务的连续性和数据的一致性。持久化存储通常使用磁盘或电池供电的RAM来保存数据。</p>
<p>根据Raft论文图2，以下三个数据需要持久化存储：</p>
<ul>
<li><strong>Log</strong>：保存所有的日志条目，是唯一记录应用程序状态的地方。</li>
<li><strong>currentTerm</strong>：当前的任期号，用于确保每个任期只有一个Leader。</li>
<li><strong>votedFor</strong>：记录当前任期投票给了哪个服务器，用于确保每个任期内只有一个Leader被选举出来。</li>
</ul>
<p>每当Log、currentTerm或votedFor发生变化时，服务器必须将这些数据写入磁盘以确保其持久化。这可以通过调用系统的<code>write</code>和<code>fsync</code>函数来实现，其中<code>fsync</code>确保数据在磁盘上安全存储。</p>
<p>为了提高性能，可以采用批量操作的方法。例如，当Leader接收到多个客户端请求时，可以累积这些请求，然后一次性持久化存储多个Log条目，减少持久化存储的次数。</p>
<h2 id="日志快照" class="heading-element"><span>11 日志快照</span>
  <a href="#%e6%97%a5%e5%bf%97%e5%bf%ab%e7%85%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在Raft一致性算法中，日志条目（Log entries）会随着系统运行时间的延长而不断增加。这会带来两个问题：</p>
<ol>
<li><strong>存储空间</strong>：日志条目数量过多，会占用大量的内存和磁盘空间。</li>
<li><strong>系统重启</strong>：如果服务器重启，需要重放所有日志条目来恢复状态，耗时较长。</li>
</ol>
<p>为了应对上述问题，Raft引入了快照机制。快照是对应用程序状态的压缩表示。通过创建快照，可以丢弃部分已应用的日志条目，减少存储空间，并加快重启时的恢复过程。</p>
<p>Raft会将应用程序创建的快照存储在磁盘上，确保数据的持久性。服务器重启时，Raft会从磁盘读取最近的快照，并将其传递给应用程序，恢复到快照对应的状态。然后，从快照之后的日志条目开始继续恢复。</p>
<p>如果某个Follower的日志比Leader的短，且短于Leader快照的起始位置，那么Leader无法通过发送日志条目来同步Follower的日志。Raft引入了<code>InstallSnapshot</code> RPC。当Follower的日志长度不够时，Leader会发送快照给Follower，然后继续通过<code>AppendEntries</code> RPC发送后续的日志条目。</p>
<p>快照的生成和恢复需要应用程序与Raft组件之间的紧密协同。应用程序负责生成和吸纳快照，Raft负责管理快照和日志条目的持久化存储。Leader可能并发发送多个RPC消息，包括<code>AppendEntries</code>和<code>InstallSnapshot</code>，需要处理可能的乱序和冗余消息。</p>
<blockquote>
<p><strong>快照生成是否依赖应用程序</strong></p>
<p>是的，快照生成函数是应用程序的一部分，应用程序负责生成和恢复快照。只有应用程序自己才知道自己的状态（进而能生成快照）。而通过快照反向生成应用程序状态的函数，同样也是依赖应用程序的。</p>
</blockquote>
<h2 id="课程qa" class="heading-element"><span>12 课程QA</span>
  <a href="#%e8%af%be%e7%a8%8bqa" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li><strong>Raft 通常用于什么？是否用于实际软件中？</strong></li>
</ol>
<p>Raft（以及 Paxos）主要用于构建容错的“配置服务”，跟踪在大型部署中的服务器职责分配。这种服务对复制部署尤为重要，可以避免脑裂问题。Raft 还被一些数据库（如 Spanner、CockroachDB）用于数据复制。</p>
<p>有多个实际应用使用 Raft，如 Docker、etcd 和 MongoDB。许多基于 Paxos 的系统（如 Chubby、ZooKeeper）也在实际生产环境中使用。</p>
<ol start="2">
<li><strong>Raft 如何与 VMware FT 比较？</strong></li>
</ol>
<p>Raft 更具容错性，没有单点故障，而 VMware FT 存在一个测试和设置服务器作为单点故障。Raft 用作库集成在应用软件中，而 VMware FT 可用于任何虚拟机。</p>
<ol start="3">
<li><strong>Raft 如何防止恶意攻击？</strong></li>
</ol>
<p>Raft 默认没有防御恶意攻击的机制。实际部署中需要通过防火墙保护，或使用加密验证 Raft 数据包。</p>
<ol start="4">
<li><strong>Raft 的“非拜占庭”条件是什么？</strong></li>
</ol>
<p>Raft 假设服务器要么按协议运行，要么停止运行。拜占庭故障指计算机执行错误操作，这可能导致 Raft 发送不正确的结果。</p>
<ol start="5">
<li><strong>Raft 可以在地理分布的数据中心中使用吗？</strong></li>
</ol>
<p>通常，Raft 部署在单一数据中心。<font color="red">跨数据中心的系统（如 Spanner）更适合无领导协议，以便客户可以与本地副本通信</font>。</p>
<ol start="6">
<li><strong>Raft 的日志为何是从 1 开始编号的？</strong></li>
</ol>
<p>日志从零编号，但第一个条目（索引为 0）具有Term 0，使得初始 AppendEntries RPC 可以包含有效的 PrevLogIndex。</p>
<ol start="7">
<li><strong>Raft 的副本优化是什么？</strong></li>
</ol>
<p>副本优化通过在服务快照时使用 fork()，实现了“写时复制”。操作系统会延迟实际的内存复制，优化了性能。</p>
<ol start="8">
<li><strong>为什么新领导在其任期开始时需要提交一个无操作（no-op）日志条目？</strong></li>
</ol>
<p>新领导提交无操作日志条目可以确保其日志中所有之前的条目都是已提交的。这是为了防止新领导在自己失败时，前一个领导的日志条目未被提交，从而保持系统一致性。</p>
<ol start="9">
<li><strong>使用心跳机制提供租约（leases）进行只读操作是如何工作的？为什么需要时间同步？</strong></li>
</ol>
<p>领导者通过在心跳消息中暗示下一段时间内不能选举新领导，从而提供只读操作的租约。为了保证安全，服务器的时钟需要保持同步，确保租约时间的准确性。</p>
<ol start="10">
<li><strong>在 Raft 的配置变更过程中，如何理解旧配置（$C_\text{old}$）到新配置（$C_\text{new}$）的过渡？</strong></li>
</ol>
<p>在联合共识阶段（$C_\text{old,new}$），领导者需要获得旧配置和新配置的多数支持。配置变更日志条目需要同时被旧配置和新配置的多数服务器确认。</p>
<ol start="11">
<li><strong>快照（snapshot）的创建和恢复过程中的数据是否需要压缩？</strong></li>
</ol>
<p>快照通常会对数据进行压缩，以减少传输和存储成本。压缩方案应根据具体应用的数据类型来选择，如使用 JPEG 压缩图像数据，或使用通用压缩算法如 ZIP。</p>
<ol start="12">
<li><strong>领导者如何决定什么时候向跟随者发送快照？</strong></li>
</ol>
<p>领导者会在跟随者的 <code>matchIndex</code> 小于其日志开始索引时发送快照，以确保跟随者能够赶上最新的日志状态。</p>
<ol start="13">
<li><strong>在 Raft 中，添加日志条目是否算作执行操作？</strong></li>
</ol>
<p>不算。仅当领导者将日志条目标记为已提交后，服务器才会执行日志条目中的操作。执行操作指的是将日志条目交给实际服务进行处理。</p>
</blockquote>
]]></description></item><item><title>【论文阅读笔记】In Search of an Understandable Consensus Algorithm (Extended Version)</title><link>https://hezephyr.github.io/posts/03.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0in-search-of-an-understandable-consensus-algorithm-extended-version/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0in-search-of-an-understandable-consensus-algorithm-extended-version/</guid><description><![CDATA[<h2 id="介绍" class="heading-element"><span>1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式一致性共识算法指的是在分布式系统中，使得所有节点对同一份数据的认知能够达成共识的算法。且算法允许所有节点像一个整体一样工作，即使其中一些节点出现故障也能够继续工作。之前的大部分一致性算法实现都是基于Paxos，但Paxos难以理解和实现，为此作者开始寻找一种新的易于理解的一致性算法，Raft则是作者工作的产出。</p>
<p>在设计Raft的过程中，作者采用了一系列策略来增强其可理解性，包括：</p>
<ul>
<li><strong>算法分解</strong>：Raft将核心功能模块化，<font color="red">分离出领导人选举、日志复制和安全性三个关键部分</font>，使每个部分的逻辑更加清晰。</li>
<li><strong>状态空间缩减</strong>：相比于Paxos，Raft减少了不确定性和服务器间的不一致性状态，简化了状态机模型，从而降低了理解和实现的难度。</li>
</ul>
<p>Raft 算法在许多方面和现有的一致性算法都很相似，但是它也有一些特性：</p>
<ul>
<li><strong>强领导人机制</strong>：Raft采用了更强的领导人角色，<font color="red">所有日志条目仅由领导人发送给其他服务器</font>，这种集中控制方式简化了日志管理，增强了算法的直观性。</li>
<li><strong>领导人选举</strong>：<font color="red">Raft使用随机计时器来触发领导人选举</font>，这种机制在心跳机制的基础上增加了少许复杂性，<strong>但有效地解决了选举冲突，实现了快速而简单的决策过程</strong>。</li>
<li><strong>成员关系调整</strong>：Raft 使用一种<strong>联合共识</strong>的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li>
</ul>
<h2 id="复制状态机" class="heading-element"><span>2 复制状态机</span>
  <a href="#%e5%a4%8d%e5%88%b6%e7%8a%b6%e6%80%81%e6%9c%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>复制状态机是共识算法的核心应用背景，它是指一组服务器上的状态机生成相同状态的副本，即使部分服务器宕机也能持续运行。这种架构在大规模分布式系统中尤其重要，因为它能够解决一系列容错问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是<font color="red">一个独立的复制状态机去管理领导人选举和存储配置信息并且在领导人宕机的情况下也要存活下来</font>。比如 Chubby 和 ZooKeeper。</p>
<p>复制状态机通常都是基于复制日志实现的，如图 1。每个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。所有日志都包含相同的指令序列，确保状态机一致，因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">一致性算法的任务是保证复制日志的一致</font>性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p>
<p>实际系统中使用的一致性算法主要有以下特性：</p>
<ul>
<li>安全性保证（绝对不会返回一个错误的结果）。</li>
<li>即使部分服务器失败，只要多数服务器运行，系统依然可用。</li>
<li>不依赖于时序，能够应对时钟错误和消息延迟。</li>
<li>大多数情况下，指令可以在一轮远程过程调用后完成，不受少数慢节点影响。</li>
</ul>
<h2 id="paxos的问题" class="heading-element"><span>3 Paxos的问题</span>
  <a href="#paxos%e7%9a%84%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ol>
<li>
<p>Paxos极其难以理解。</p>
</li>
<li>
<p>没有为构建实际系统实现提供良好的基础。</p>
</li>
</ol>
<h2 id="为了可理解性的设计" class="heading-element"><span>4 为了可理解性的设计</span>
  <a href="#%e4%b8%ba%e4%ba%86%e5%8f%af%e7%90%86%e8%a7%a3%e6%80%a7%e7%9a%84%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>设计Raft算法的初衷：</p>
<ol>
<li>
<p>必须提供一个完整的实际的系统实现基础，减少开发者工作量；</p>
</li>
<li>
<p>必须在任何情况下都是安全的并且在大多数的情况下都是可用的；</p>
</li>
<li>
<p>它的大部分操作必须是高效的；</p>
</li>
<li>
<p>可理解性，它必须保证对于普遍的人群都可以十分容易的去理解；</p>
</li>
<li>
<p>便于系统构建者形成直观理解，便于实际应用和扩展；</p>
</li>
</ol>
<p>Raft设计原则：</p>
<ol>
<li>
<p><strong>问题分解</strong>：将复杂问题拆解为独立、易于理解和解决的子问题。例如，Raft 的领导人选举、日志复制、安全性和成员变更。</p>
</li>
<li>
<p><strong>状态空间简化</strong>：减少状态数量，降低系统复杂性并在可能的时候消除不确定性。确保日志无空洞，限制日志不一致的可能性。</p>
</li>
<li>
<p><strong>随机化应用</strong>：在领导人选举中使用随机化，简化机制，快速解决冲突。</p>
</li>
</ol>
<h2 id="raft一致性算法" class="heading-element"><span>5 Raft一致性算法</span>
  <a href="#raft%e4%b8%80%e8%87%b4%e6%80%a7%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 是一种管理复制日志的一致性算法，通过选举领导人并由其管理日志来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。这一决策过程无需与其他服务器进行商议，从而简化了整个复制日志的管理流程，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。</p>
<p>Raft算法的一致性问题被巧妙地分解为三个关键子问题：</p>
<ul>
<li><strong>领导选举</strong>：当领导人发生故障的时候, 一个新的领导人需要被选举出来，确保系统的连续性和稳定性（5.2）</li>
<li><strong>日志复制</strong>：领导人必须从客户端接收日志条目然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。</li>
<li><strong>安全性</strong>：Raft通过特定的机制（5.4）确保一旦日志条目被应用到某个服务器的状态机中，其他服务器不会在同一日志索引位置应用不同的指令，从而保障了系统状态的一致性和安全性。</li>
</ul>
<h3 id="raft基础" class="heading-element"><span>5.1 Raft基础</span>
  <a href="#raft%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 Raft 集群由若干个服务器节点构成，如常见的 5 节点配置，能容忍最多 2 个节点失效。节点有以下三种状态：</p>
<ul>
<li>
<p>领导人：唯一决策者，处理所有客户端请求，并且管理复制日志。</p>
</li>
<li>
<p>跟随者：被动角色，仅响应领导人和候选人的请求。</p>
</li>
<li>
<p>候选人：竞选状态，用于选举新领导人</p>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图4.jpeg?size=small" data-sub-html="<h2>server_state</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg" alt="server_state" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=large 2x" data-title="server_state" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">跟随者在收不到消息时，升级为候选人，启动选举；获得多数票的候选人成为领导人；领导人宕机或发现任期过期，降级为跟随者。</font></p>
<p>Raft 通过任期来划分时间，每个任期都始于一次选举。任期用整数标记，每段任期有其选举过程。如果选举成功，选出的领导人将负责管理集群，直到该任期结束。任期在Raft中充当逻辑时钟的作用，帮助节点检测过期信息，如过期的领导人。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图5.jpeg?size=small" data-sub-html="<h2>Term_Figure</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg" alt="Term_Figure" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=large 2x" data-title="Term_Figure" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>每个节点维护一个当前任期号，通信时交换任期号，节点自动更新至较大值，领导人或候选人如果发现任期号过期，会恢复为跟随者；节点拒绝过期任期请求。</p>
<p>在 Raft 算法中，节点间的通信依赖于RPC。基本的一致性算法主要使用两种类型的 RPCs：</p>
<ul>
<li>
<p><strong>请求投票RPC</strong>：候选人发起，用于选举。</p>
</li>
<li>
<p><strong>附加条目RPC</strong>：领导人发起，复制日志和提供心跳机制。</p>
</li>
<li>
<p><strong>安装快照PRC</strong>：领导人发起，安装快照。为了提高性能，服务器在未及时收到响应时会重试 RPC，并且能够并行发起 RPC。</p>
</li>
</ul>
<h3 id="领导人选举" class="heading-element"><span>5.2 领导人选举</span>
  <a href="#%e9%a2%86%e5%af%bc%e4%ba%ba%e9%80%89%e4%b8%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Raft 算法采用心跳机制来触发领导人选举过程。服务器启动时，<strong>默认处于跟随者状态</strong>，仅当接收到来自领导人或候选人的有效 RPC 时才保持这一状态。领导人定期向所有跟随者发送心跳包，即不含日志项的附加条目RPC，以此维护其领导地位。若跟随者<font color="red">在设定的选举超时时间内未收到任何消息</font>，它将假定无有效领导人并发起选举，以选出新的领导人。</p>
<p>选举流程开始时，跟随者增加自己的当前任期号并转换为候选人状态，然后向集群中其他服务器节点发送请求投票RPC来给自己投票。候选人保持该状态，直至出现以下三种情况之一：</p>
<ul>
<li>
<p>赢得选举。</p>
</li>
<li>
<p>其他服务器成为领导人。</p>
</li>
<li>
<p>在一定时间内无明确获胜者。</p>
</li>
</ul>
<p>赢得选举的条件是获得集群大多数服务器节点的选票，<font color="red">每台服务器对同一任期号的投票遵循先来先服务原则</font>，并有额外限制（5.4）以确保选举安全性，避免了脑裂（同一人气，集群出现两个领导人）。一旦当选，候选人即刻转变为领导人，通过发送心跳消息确立领导地位并阻止发起新选举。</p>
<p>在等待投票的过程中，候选人可能接收到领导人发送的附加条目RPC，如果该领导人任期号不低于候选人的任期号，候选人将认可其合法性，回归跟随者状态；反之，候选人将拒绝RPC，继续竞选。<font color="red">若多个候选人同时发起选举，选票分散可能导致无人胜出，所有候选人均会因超时而重新开始选举，但任期号会递增。</font></p>
<p>为防止选票分散，Raft算法引入了<font color="red">随机化选举超时时间策略</font>。各服务器在固定时间范围内（例如$[150,200]$）随机选取超时值，使得通常情况下仅有一台服务器超时，进而顺利赢得选举并在其他服务器超时前发送心跳。即使发生选票分散，随机化的超时机制也降低了下一轮选举中再次分散的可能性。</p>
<p>作者最初设计考虑过引入排名系统以决定优先级，但发现这可能导致高排名服务器故障时的可用性问题，且算法调整复杂，难以确保没有副作用。经过多次调整，最终确定随机重试方法更为直观易懂，且避免了排名系统带来的复杂性和潜在问题。</p>
<h3 id="日志复制" class="heading-element"><span>5.3 日志复制</span>
  <a href="#%e6%97%a5%e5%bf%97%e5%a4%8d%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一旦选举产生领导人，它便开始处理客户端请求，每个请求携带一条被复制状态机执行的指令。领导人将此指令作为新日志条目追加至日志中，并并行发起附加条目RPC给其他服务器复制，日志条目在被安全复制后，领导人将其应用到状态机并将执行结果返回给客户端，即使面对跟随者崩溃、延迟或网络丢包，领导人也会持续重试RPC（<font color="red">尽管已经回复了客户端</font>）直至所有跟随者存储所有日志条目。</p>
<p>日志结构如图6所示，条目按序编号，包含创建时的任期号及待执行指令。日志条目在满足一定条件时变为可提交状态，即安全地应用到状态机中。<font color="red">领导人决定何时提交日志条目，Raft算法保证所有提交条目持久化并最终被执行</font>。日志条目在被复制到多数服务器时即被提交，包括前任领导人创建的条目。领导人追踪最大已提交条目索引，并在附加条目RPC中包含该索引，使跟随者同步应用已提交条目。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>Raft的日志机制维持不同服务器日志之间的高层次一致性，简化系统行为并增强可预测性，是安全性的重要组成部分。关键特性是<font color="red">若两日志条目索引和任期号相同，则它们存储相同指令，并且前序条目也相同。</font>。这是因为日志匹配特性，领导人最多在一个任期内特定索引创建日志条目，且日志条目位置固定不变。<font color="red">附加条目RPC包含前一条目的索引和任期号，若跟随者找不到匹配条目则拒绝，确保日志匹配特性</font>。</p>
<p>正常运行时，领导人与跟随者日志一致，但在领导人崩溃后可能出现不一致，如图7所示。领导人通过强制跟随者复制自己的日志解决不一致，覆盖冲突条目。领导人维护<code>nextIndex</code>记录每个跟随者下一个待发送条目索引，初始化为自身最后条目索引+1。<font color="red">当一致性检查失败，领导人就会减小<code>nextIndex</code>直至找到共同点，删除跟随者冲突条目并发送自身条目</font>。成功后，跟随者日志与领导人保持一直。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<p>算法可优化减少拒绝次数，跟随者可返回冲突条目任期号及对应最小索引，领导人据此一次性跳过冲突任期所有条目。但实践中，这种优化可能非必需，因不一致性罕见且涉及条目不多。</p>
</blockquote>
<p>通过日志复制机制，领导人无需特殊操作即可恢复一致性，只需执行常规流程，日志在响应一致性检查失败时自动对齐。领导人从不覆盖或删除自身日志，确保一致性。日志复制机制体现了高可用性、快速复制及对慢跟随者的容忍度。</p>
<h3 id="安全性" class="heading-element"><span>5.4 安全性</span>
  <a href="#%e5%ae%89%e5%85%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 Raft 算法中，尽管已经描述了领导人的选举和日志的复制过程，但这些机制本身并不足以保证所有状态机按照相同的顺序执行相同的指令。存在一种情况，即一个跟随者在领导人提交了若干日志条目后变得不可用，之后这个跟随者可能被选举为新的领导人，并可能覆盖这些已提交的日志条目，导致不同状态机可能执行不同的指令序列。</p>
<p>为了解决这个问题，Raft 算法在领导选举时增加了限制，确保任何给定任期的领导人都拥有之前任期的所有已提交的日志条目（即<strong>领导人完整特性</strong>）。这一限制简化了提交规则，并为复制状态机的正确行为提供了证明。</p>
<h4 id="选举限制" class="heading-element"><span>5.4.1 选举限制</span>
  <a href="#%e9%80%89%e4%b8%be%e9%99%90%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在基于领导人的一致性算法中，领导人都必须存储所有已提交的日志条目。Raft 算法通过简单的方法确保新选举的领导人拥有之前任期中所有已提交的日志条目，避免了额外的日志传输机制和复杂性。</p>
<p>Raft 使用投票机制来阻止未包含所有已提交日志条目的候选人赢得选举。<font color="red">候选人必须获得集群中大多数节点的同意，这确保了所有已提交的日志条目至少存在于一个节点上</font>。如果候选人的日志至少和大多数的服务器节点一样新，那么他一定持有了所有已经提交的日志条目。请求投票RPC 实现了这样的限制：<font color="red">RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求</font>。</p>
<p>Raft通过比较日志中最后一条条目的任期号和索引来判断哪个日志更“新”。</p>
<ul>
<li>如果任期号不同，任期号更大的日志更“新”。</li>
<li>如果任期号相同，则条目更多（索引值更大）的日志更“新”。</li>
</ul>
<h4 id="提交之前任期内的日志条目" class="heading-element"><span>5.4.2 提交之前任期内的日志条目</span>
  <a href="#%e6%8f%90%e4%ba%a4%e4%b9%8b%e5%89%8d%e4%bb%bb%e6%9c%9f%e5%86%85%e7%9a%84%e6%97%a5%e5%bf%97%e6%9d%a1%e7%9b%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>领导人在当前任期内创建的日志条目，当被复制到大多数服务器上时，则可认为是可提交的。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，<font color="red">对于之前任期中的日志条目，即使它们已经被复制到大多数服务器上，也不能简单地通过副本数量来确定它们是否已提交</font>，如图8所示。这是因为在领导人崩溃和重新选举的过程中，可能会出现新的领导人并不包含所有之前任期的日志条目，这可能导致已复制的日志被覆盖。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了避免这种情况，<font color="red">Raft不会通过副本数目去提交一个之前任期内的日志条目，只有当前任期的日志条目才能通过复制到大多数服务器来提交</font>。一旦当前任期的日志条目被提交，根据日志匹配特性，之前任期的日志条目也会被间接的提交。</p>
<p><font color="red">Raft 在处理日志时保留了原始的任期号</font>，这虽然增加了提交规则的复杂性，但简化了日志的识别和管理。与其它算法不同，Raft 在复制之前任期日志不需要使用新的任期号，在提交前不用发送冗余的日志条目来重新编号，</p>
<h4 id="安全性论证" class="heading-element"><span>5.4.3 安全性论证</span>
  <a href="#%e5%ae%89%e5%85%a8%e6%80%a7%e8%ae%ba%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在 Raft 算法中，领导人完整性特性是确保一致性的关键。这一特性保证了在任期 T 的领导人提交的日志条目，必须被存储在未来任期的领导人日志中。</p>
<p>设任期U（&gt;T）的领导人U缺失该条目，如下图所示，在U的选举中，至少存在一个节点（如S3）同时持有T任期的日志并投票给U。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ul>
<li><strong>关键点</strong>：此节点在投票前接受T任期已提交日志，且在投票时仍保存该条目。</li>
<li><strong>矛盾一</strong>：此节点把自己选票投给领导人 U 时，<strong>说明领导人 U 的日志必须和投票者自己一样新</strong>。但假设U不包含T任期提交的日志。</li>
<li><strong>矛盾二</strong>：若U最后日志任期大于此节点，<strong>则前领导人必含提交日志，由日志匹配特性知U亦应含该日志</strong>，产生矛盾。</li>
</ul>
<p>故所有大于T任期的领导人必定包含T任期中所有已提交日志条目。<strong>日志匹配原则</strong>确保未来领导人同样包含间接提交的条目。<font color="red">领导人完整性特性支撑状态机安全特性，防止不同日志在相同索引值上被应用</font>。</p>
<h3 id="追随者和候选人崩溃" class="heading-element"><span>5.5 追随者和候选人崩溃</span>
  <a href="#%e8%bf%bd%e9%9a%8f%e8%80%85%e5%92%8c%e5%80%99%e9%80%89%e4%ba%ba%e5%b4%a9%e6%ba%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>崩溃影响</strong>：崩溃导致后续RPC失败，影响通信和一致性。</li>
<li><strong>处理机制</strong>：
<ul>
<li><strong>无限重试</strong>：系统通过持续重试RPC来处理这类失败。</li>
<li><strong>重启恢复</strong>：当崩溃服务器重启，未完成的RPC能够继续执行至成功。</li>
</ul>
</li>
<li><strong>RPC幂等性保障</strong>：<font color="red">指多次执行相同操作产生的效果等同于一次执行</font>，故重复执行RPC也不会引起不一致或错误状态。</li>
</ul>
<h3 id="时间和可用性" class="heading-element"><span>5.6 时间和可用性</span>
  <a href="#%e6%97%b6%e9%97%b4%e5%92%8c%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Raft 算法的一个核心要求是安全性不应依赖于时间，即系统不应因为事件的快慢而产生错误的结果。然而，系统的可用性，即及时响应客户端的能力，不可避免地依赖于时间因素。特别是在领导人选举过程中，时间要求尤为关键。</p>
<p>关键的时间因素有：</p>
<ul>
<li><strong>广播时间 (Broadcast Time)</strong>：服务器向集群成员并行发送RPC并接收响应的平均时间。</li>
<li><strong>选举超时时间 (Election Timeout)</strong>：跟随者等待领导人心跳的最长时限，过期则发起选举。</li>
<li><strong>平均故障间隔时间 (Mean Time Between Failures, MTBF)</strong>：服务器两次故障之间的平均时间。</li>
</ul>
<p>Raft 要求满足以下时间不等式以保证系统正常运行：</p>
<p>$\text{Broadcast Time}\ll\text{Election Timeout}\ll\text{MTBF}$</p>
<p><font color="red">广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的</font>。广播时间受存储技术影响，范围约为$[0.5,20]\text{ ms}$，选举超时时间基于广播时间设置，要比广播时间大几个数量级，一般在$[10,500]\text{ ms}$，而MTBF通常数月以上，远大于选举超时时间，满足系统稳定运行需求。</p>
<h2 id="集群成员变化" class="heading-element"><span>6 集群成员变化</span>
  <a href="#%e9%9b%86%e7%be%a4%e6%88%90%e5%91%98%e5%8f%98%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 算法在设计时假设集群配置是固定的，但在实际应用中，集群配置需要动态调整，如替换宕机的机器或改变复制级别。直接更改集群配置存在风险，可能导致同一任期内两个领导人同时存在，因此需要一种安全的配置变更机制。为了确保配置变更的安全性，必须采用两阶段方法。在Raft中，集群切换到一个过渡配置，称为联合共识，结合了新旧配置：</p>
<ul>
<li>日志条目被复制给新旧配置的所有服务器。</li>
<li>新旧配置的服务器都可以成为领导人。</li>
<li>达成一致（选举和提交）需要分别在新旧配置上获得大多数支持。</li>
</ul>
<p><font color="red">联合共识允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程</font>。此外，联合共识可以让集群在配置转换的过程中依然响应客户端的请求。配置变更过程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li><strong>请求接收</strong>：领导人接收到从 $C_\text{old}$ 到 $C_\text{new}$ 的配置变更请求。</li>
<li><strong>联合共识日志条目</strong>：领导人创建 $C_\text{old,new}$ 配置条目并将其作为日志条目存储和复制。</li>
<li><strong>提交联合共识</strong>：一旦 $C_\text{old,new}$ 被提交，<font color="red">新旧配置都不能单方面做出决定</font>，只有拥有 $C_\text{old,new}$ 日志条目的服务器才能成为领导人。</li>
<li><strong>新配置日志条目</strong>：这个时候，领导人创建 $C_\text{new}$ 配置条目并复制给集群，最终在 $C_\text{new}$ 规则下提交，旧的配置变得无关紧要。</li>
</ol>
<h2 id="日志压缩" class="heading-element"><span>7 日志压缩</span>
  <a href="#%e6%97%a5%e5%bf%97%e5%8e%8b%e7%bc%a9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 算法通过复制日志来维护一致性，但随着时间的推移，日志会不断增长，占用大量空间并影响性能。为了解决这个问题，Raft 使用<strong>快照技术</strong>压缩日志，通过存储系统状态至持久化存储，随后丢弃先前日志。</p>
<p>下图展示了快照的基本思想，<strong>每个服务器独立创建快照，只包含已提交的日志条目，主要的工作包括将状态机的状态写入快照中</strong>。Raft也包含一些少量元数据到快照中：最后索引和任期号。保留这些数据是为了支持一致性检查，允许服务器清除过期日志。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>领导人偶尔也需要通过安装快照RPC将快照分块发送给一些落后的追随者，追随者收到快照后，他必须自己决定对于已经存在的日志该如何处理，一般来说是覆盖冲突日志，保留后续未冲突日志。</p>
<p>在快照时，有两个性能相关的因素需要考虑：</p>
<ul>
<li><strong>创建时机</strong>：服务器需要决定何时创建快照，以避免频繁写入或存储空间耗尽。Raft 的策略是当日志大小达到一个阈值之后，就开始快照。</li>
<li><strong>写入时间</strong>：写入快照可能需要显著时间，为了不影响正常的操作，应通过写时复制技术避免影响正常操作。</li>
</ul>
<h2 id="客户端交互" class="heading-element"><span>8 客户端交互</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%ba%a4%e4%ba%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft中的客户端发送所有请求给领导人。客户端初始化时随机选择服务器，非领导人服务器会拒绝客户端请求并提供最近接收到的领导人信息。如果领导人崩溃后，客户端请求超时，重启随机选择过程直至找到新领导人。</p>
<p>Raft目标是要实现线性化语义，由于Raft是可能同时执行同一条命令多次的，为了解决这个问题，<strong>客户端为每条指令分配唯一序列号，状态机跟踪每个客户端的最新序列号和相应响应。如果接收到的指令序列号已经被执行，状态机直接返回结果而不重新执行</strong>。</p>
<p>只读操作可以不写入日志直接处理。但不记录日志可能导致返回脏数据，即领导人在不知情的情况下被新领导人取代。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。</p>
<ol>
<li>
<p><strong>最新提交日志信息</strong>：<font color="red">领导人需要知道任期内所有被提交的日志条目</font>。Raft 通过让领导人在任期开始时提交一个空白日志条目来实现。</p>
</li>
<li>
<p><strong>领导人状态检查</strong>：在处理只读请求前，领导人必须检查自己是否已被废黜。Raft 通过让领导人在响应只读请求前与集群大多数节点交换心跳信息来处理这个问题。</p>
</li>
</ol>
<h2 id="总结" class="heading-element"><span>9 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 是一种用于管理复制日志的一致性算法，旨在解决分布式系统中的一致性问题。它通过领导人选举、日志复制和安全性保证来实现系统的高可用性和一致性。</p>
<p><strong>Raft 的五大保证</strong>：</p>
<ol>
<li>
<p><strong>选举安全性</strong>：在任一给定任期内，最多只能有一个领导人被选举出来。</p>
</li>
<li>
<p><strong>领导人只追加</strong>：领导人不会覆盖或删除其日志中的条目；它只追加新的条目。</p>
</li>
<li>
<p><strong>日志匹配</strong>：如果两个日志在相同索引和任期号处含有相同的条目，则在该索引之前的所有条目都是相同的。</p>
</li>
<li>
<p><strong>领导人完整性</strong>：如果一个日志条目在给定任期被提交，那么该条目将出现在所有更高编号任期的领导人的日志中。</p>
</li>
<li>
<p><strong>状态机安全性</strong>：如果一个服务器将某个索引的日志条目应用到其状态机中，其他服务器不会对该索引应用不同的日志条目。</p>
</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】GFS</title><link>https://hezephyr.github.io/posts/04.gfs/</link><pubDate>Tue, 28 May 2024 16:24:28 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.gfs/</guid><description><![CDATA[<h2 id="分布式存储系统难点" class="heading-element"><span>1 分布式存储系统难点</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f%e9%9a%be%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在设计大型分布式系统或存储系统时，初衷通常是为了获得显著的性能提升，通过数百台计算机的资源来并行完成大量工作。因此，性能问题成为最初的关注点。一个自然的想法是将数据分片（Sharding），分布到大量服务器上，从而并行读取数据。</p>
<p>当你在成百上千台服务器上进行分片时，服务器故障将成为常态。如果你有数千台服务器，每天甚至每小时都可能有服务器宕机。因此，需要自动化的方法来修复错误，而不是依赖人工介入。为此，自动容错系统至关重要，这引出了容错（fault tolerance）的概念。</p>
<p>实现容错最有效的方法之一是使用数据复制，只需维护2-3个数据副本，当其中一个故障时，可以使用另一个。因此，要实现容错，必须进行数据复制（replication）。</p>
<p>然而，数据复制带来了不一致性（inconsistency）问题。拥有多个数据副本，如果管理不当，副本之间可能不一致。理想情况下，可以任意使用任一副本进行容错，但如果副本不一致，应用程序将面临麻烦。因此，数据复制不可避免地会引发不一致性问题。</p>
<p>通过精巧的设计，可以减少甚至避免不一致性，使数据表现得符合预期。但要实现这一点，服务器之间需要进行额外的网络交互，这会降低性能。因此，如果追求一致性（consistency），必须付出性能的代价，这与最初的高性能目标相悖。</p>
<p>尽管可以构建高性能系统，但不可避免地会陷入性能与一致性的权衡之中。在实际应用中，为了获得良好的一致性，必须付出相应的代价。如果不愿付出代价，就需要忍受一定程度的不确定性。很多系统中都存在这种权衡，人们往往不愿为高一致性牺牲性能。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=small" data-sub-html="<h2>image-20240528101751499</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png" alt="image-20240528101751499" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=large 2x" data-title="image-20240528101751499" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="错误的设计" class="heading-element"><span>2 错误的设计</span>
  <a href="#%e9%94%99%e8%af%af%e7%9a%84%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于强一致性系统，应用程序或客户端感受到的就像在与一台服务器通信。尽管系统由数百台计算机组成，但理想的强一致模型让它看起来像只有一台服务器，一份数据，并且一次只处理一个请求。这种设计确保了每个请求能看到之前所有请求按顺序执行的结果。</p>
<p>对于存储服务器来说，它通常包含一块磁盘。执行写请求可能意味着向磁盘写入数据或对数据进行自增操作。如果是一次修改操作，并且我们有一个以 key-value 为索引的数据表单，那么我们会更新这个表单。如果是读取操作，只需从表单中取出之前写入的数据即可。为了保证这个简单服务的行为可预期，需要遵循一个规则：每次只执行一个请求。这样，每个请求都能看到之前所有请求按顺序执行后的结果。如果服务器按某种顺序依次处理写请求，当你读取数据时，你就能看到预期的数据。</p>
<p>举例来说，客户端 C1 发起写请求将 X 设置为 1，同时客户端 C2 发起写请求将 X 设置为 2。待 C1 和 C2 的写请求都执行完毕后，客户端 C3 发送读取 X 的请求，得到一个结果；客户端 C4 也发送读取 X 的请求，得到另一个结果。此时，问题是这两个客户端看到的结果会是什么。</p>
<p>即使在一个非常简单的系统中，仍会出现一些模糊场景，使你无法确定系统的执行过程及其输出结果。你只能根据结果判断系统是否保持了一致性。</p>
<p>如果 C3 读取 X 得到 2，那么 C4 也应该读取到 2，因为这表明写 X 为 2 的请求是第二个执行的写请求。当 C4 读取 X 时，写 X 为 2 应该仍然是第二个写请求。</p>
<p>然而，单服务器设计存在容错能力差的问题。如果服务器故障或磁盘损坏，系统将无法使用。因此，现实中我们会构建多副本的分布式系统，这引发了一系列新的问题。</p>
<p>假设我们有两台服务器，每台服务器都有数据的一份完整拷贝，并在磁盘上存储一个 key-value 表单。我们希望这两个表单完全一致，这样当一台服务器故障时，可以切换到另一台服务器继续读写操作。</p>
<p>两个表单完全一致意味着，<font color="red">每一个写请求都必须在两台服务器上执行，而读请求只需要在一台服务器上执行</font>，否则就没有容错性了。因为如果读请求也需要从两台服务器读数据，那么一台服务器故障我们就没法提供服务了。现在问题来了，假设客户端C1和C2都想执行写请求，其中一个要写X为1，另一个写X为2。C1会将写X为1的请求发送个两个服务器，因为我们想要更新两台服务器上的数据。C2也会将写X为2的请求发送给两个服务器。</p>
<p>这里会出现什么错误呢？是的，我们没有做任何事情来保障两台服务器以相同的顺序处理这2个请求。如果服务器1（S1）先处理C1的请求，那么在它的表单里面，X先是1，之后S1看到了来自C2的请求，会将自己表单中的X覆盖成2。但是，如果S2恰好以不同的顺序收到客户端请求，那么S2会先执行C2的请求，将X设置为2，之后收到C1的请求，将X设置为1。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=small" data-sub-html="<h2>image-20240528104959963</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png" alt="image-20240528104959963" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=large 2x" data-title="image-20240528104959963" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>之后，如果另外一些客户端，假设C3从S1读数据，C4从S2读数据，我们就会面临一个可怕的场景：这两个客户端读取的数据不一样。但是从前一个例子中的简单模型可以看出，相连的读请求应该读出相同的数据。</p>
<p>这里的问题可以以另一种方式暴露出来。假设我们尝试修复上面的问题，我们让客户端在S1还在线的时候，只从S1读取数据，S1不在线了再从S2读取数据。这样最开始所有的客户端读X都能得到2。但是突然，如果S1故障了，尽管没有写请求将X改成1，客户端读X得到的数据将会从2变成1。因为S1故障之后，所有的客户端都会切换到S2去读数据。这种数据的神奇变化与任何写操作都没有关联，并且也不可能在前一个例子的简单模型中发生。</p>
<p>当然，这里的问题是可以修复的，修复需要服务器之间更多的通信，并且复杂度也会提升。由于获取强一致会带来不可避免的复杂性的提升，有大量的方法可以在好的一致性和一些小瑕疵行为之间追求一个平衡。</p>
<h2 id="gfs设计目标" class="heading-element"><span>3 GFS设计目标</span>
  <a href="#gfs%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Google的目标是构建一个大型且快速的文件系统（GFS），以便各种应用程序都能全局访问数据。传统的方法是为每个应用程序构建特定的存储系统，但这会导致重复建设。GFS 作为一个全局通用的存储系统，允许不同应用程序共享和访问数据。例如，存储了大量互联网抓取数据后，其他用户可以通过申请权限查看这些数据，因为大家使用的是同一个存储系统。这样，Google 内部的人员可以根据名字读取 GFS 中可共享的内容。</p>
<p>为了实现大容量和高速性能，GFS 将数据文件自动分割并存储在多台服务器上，这样可以并行读取同一个文件，从而获得更高的聚合吞吐量。文件分割存储还允许存储比单个磁盘更大的文件。由于存储系统分布在数百台服务器上，GFS 具备自动故障修复功能，不需要人工干预来修复服务器或迁移数据。</p>
<p>GFS 的一些特征并非设计目标。例如，GFS 只在一个数据中心内运行，多个副本并未分布在全球各地。理论上，数据副本应该地理分散，但实现起来很难，所以 GFS 局限于单个数据中心内。</p>
<p>此外，GFS 面向 Google 内部使用，供工程师开发应用程序，并不直接面向普通用户。虽然 Google 可能会出售基于 GFS 的服务，但 GFS 本身并不对外提供。</p>
<p>最后，GFS 专注于对大型顺序文件的读写优化。例如，银行账户系统需要能够读写小数据块的数据库，而 GFS 针对 TB 级别的文件进行优化，只支持顺序处理而非随机访问。某种程度上，它更像批处理系统，注重巨大的吞吐量而非低延迟，每次操作都涉及 MB 级别的数据。</p>
<h2 id="master节点" class="heading-element"><span>4 Master节点</span>
  <a href="#master%e8%8a%82%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>假设我们有上百个客户端和一个Master节点。虽然实际中可以有多台机器作为Master节点，但GFS中Master采用Active-Standby模式（系统包含两个或多个实例，其中一个实例（Active）正在运行并处理所有的请求，而其他实例（Standby）则处于待命状态，准备在Active实例发生故障时立即接管工作。），所以只有一个Master节点在工作。Master节点保存了文件名和存储位置的对应关系。除此之外，还有大量的Chunk服务器，每个Chunk服务器上都有1-2块磁盘。</p>
<p>Master节点管理文件和Chunk的信息，而Chunk服务器存储实际数据。这种设计将管理和存储分开处理，提高了系统效率。在GFS中，Master节点知道每个文件对应的所有Chunk handle，这些Chunk每个是64MB大小，共同构成一个文件。例如，一个1GB的文件会分成多个Chunk，Master节点知道每个Chunk存储在哪。读取文件时，需要先向Master节点查询Chunk位置，然后从对应的Chunk服务器读取数据。</p>
<p>我们需要了解Master节点内保存的数据内容，这里我们关心的主要是两个表单：</p>
<ol>
<li><strong>文件名到Chunk handle的对应关系</strong>：Master节点有一个表单记录了文件名到Chunk handle数组的对应关系。</li>
<li><strong>Chunk handle到Chunk数据的对应关系</strong>：另一个表单记录了Chunk handle和它们的数据的对应关系，包括每个Chunk的服务器列表、当前版本号、主Chunk（Primary Chunk）和租约过期时间。</li>
</ol>
<p>这些数据都存储在内存中，但为了防止数据丢失，Master节点也将部分数据存储在磁盘上。Master节点的写操作会记录到磁盘的日志（log）中，并定期生成检查点（CheckPoint）。</p>
<p>有些数据需要存在磁盘上，而有些不用。它们分别是：</p>
<ul>
<li><strong>Chunk Handle数组</strong>（非易失性，NV）：保存到磁盘上。</li>
<li><strong>Chunk服务器列表</strong>（易失性，V）：不用写入磁盘，重启后可重新获取。</li>
<li><strong>版本号</strong>（非易失性，NV）：写入磁盘，确保数据一致性。</li>
<li><strong>主Chunk的handle</strong>（易失性，V）：不写入磁盘，重启后可重新分配。</li>
<li><strong>租约过期时间</strong>（易失性，V）：不写入磁盘。</li>
</ul>
<p>当文件扩展到新的64MB或主Chunk变更时，Master节点会向磁盘日志中追加记录。这种日志追加方式比数据库高效，因为它只需顺序写入，不涉及磁盘的随机访问。</p>
<p>Master节点故障重启时，会从最近的检查点开始恢复状态，然后通过执行日志中的记录恢复到最新状态。这种方式避免了从日志最开始重建状态的低效问题。</p>
<h2 id="读文件" class="heading-element"><span>5 读文件</span>
  <a href="#%e8%af%bb%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于读请求来说，应用程序或GFS客户端会提供一个文件名和读取的偏移量（offset）。首先，客户端将这些信息发送给Master节点。Master节点从自己的文件表单中查找文件名，获取对应的Chunk handle数组。每个Chunk大小为64MB，因此可以通过偏移量除以64MB来确定对应的Chunk handle。接着，Master节点从Chunk表单中找到包含该Chunk的服务器列表，并将这个列表返回给客户端。</p>
<p>具体步骤如下：</p>
<ol>
<li>客户端（或应用程序）将文件名和偏移量发送给Master节点。</li>
<li>Master节点将Chunk Handle（即Chunk ID）和服务器列表发送给客户端。</li>
</ol>
<p>客户端接下来可以从服务器列表中选择一个服务器来读取数据。根据GFS论文的描述，客户端会选择一个在网络上最近的服务器（在Google的数据中心中，通过IP地址的差异可以判断网络位置的远近），然后将读请求发送到这个服务器。由于客户端每次可能只读取1MB或64KB的数据，它可能会多次读取同一个Chunk的不同部分。为此，客户端会缓存Chunk和服务器的对应关系，这样在后续读取相同Chunk数据时，不需要每次都向Master请求相同的信息。</p>
<p>接下来，客户端会与选定的Chunk服务器通信，将Chunk Handle和偏移量发送给该服务器。Chunk服务器在本地硬盘上将每个Chunk存储为独立的Linux文件，并通过普通的Linux文件系统进行管理。可以推测，Chunk文件会按照Handle（即ID）命名。因此，Chunk服务器需要做的就是根据文件名找到对应的Chunk文件，从文件中读取相应的数据段，并将数据返回给客户端。</p>
<h2 id="写文件" class="heading-element"><span>6 写文件</span>
  <a href="#%e5%86%99%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于应用程序来说，写文件的过程与读文件的接口非常类似，都是通过调用GFS的库函数进行操作。在写文件时，应用程序会告诉库函数，要将缓冲区中的数据追加到指定文件中。为了简化讨论，我们只考虑GFS论文中的记录追加（Record Append）的情况。</p>
<p>所以再次描述一下，对于写文件，客户端会向Master节点发送请求说：我想向这个文件名对应的文件追加数据，请告诉我文件中最后一个Chunk的位置。</p>
<p>当有多个客户端同时写同一个文件时，一个客户端并不能知道文件究竟有多长。因为如果只有一个客户端在写文件，客户端自己可以记录文件长度，而多个客户端时，一个客户端没法知道其他客户端写了多少。例如，不同客户端写同一份日志文件，没有一个客户端会知道文件究竟有多长，因此也就不知道该往什么样的偏移量，或者说向哪个Chunk去追加数据。这个时候，客户端可以向Master节点查询哪个Chunk服务器保存了文件的最后一个Chunk。</p>
<p>对于读操作，可以从任何最新的Chunk副本读取数据，但写操作必须通过Chunk的主副本（Primary Chunk）进行。Master节点需要确保Chunk的主副本存在。如果不存在，Master节点会查找所有存有该Chunk最新副本的Chunk服务器。Master节点确定哪些副本是最新的（副本中保存的版本号与Master中记录的Chunk的版本号一致），并从中选择一个作为Primary，其余作为Secondary。</p>
<p>之后，Master节点增加Chunk的版本号，并将新的版本号写入磁盘。Master节点通知Primary和Secondary服务器新的Chunk版本号，并指定它们的角色。Primary和Secondary服务器将新版本号存储在本地磁盘中，以便在重启时报告给Master。</p>
<p>所以客户端将要追加的数据发送给Primary和Secondary服务器，这些服务器将数据写入临时位置。所以最开始，这些数据不会追加到文件中。当所有服务器确认数据已写入临时位置后，客户端向Primary发送消息，要求将数据追加到文件中。Primary按照顺序处理来自多个客户端的并发请求，确保每次只执行一个请求。Primary将数据写入Chunk的末尾，并通知所有Secondary服务器也将数据写入它们的Chunk末尾。</p>
<p>Secondary服务器将数据写入本地磁盘后，向Primary发送确认消息。如果所有Secondary服务器成功写入数据并回复“yes”，Primary向客户端返回写入成功。如果任何Secondary服务器写入失败，Primary向客户端返回写入失败。</p>
<p>如果客户端接到写入失败的消息，应重新发起整个追加过程。首先，客户端再次与Master节点交互，找到文件末尾的Chunk，然后重新向Primary和Secondary发起追加操作。</p>
<h2 id="gfs的一致性" class="heading-element"><span>7 GFS的一致性</span>
  <a href="#gfs%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在GFS中，追加数据的过程相对复杂。我们通过一个例子来解释这一过程。</p>
<ol>
<li>
<p>**数据追加请求：**客户端发送一个追加数据的请求，例如数据A，要将数据A追加到文件末尾。Chunk的三个副本（一个Primary和两个Secondary）都成功将数据A追加到了Chunk中，因此Chunk中的第一个记录是A。</p>
</li>
<li>
<p>**网络问题导致的部分写入：**第二个客户端加入，想要追加数据B。但由于网络问题，消息只被Primary和一个Secondary收到并处理。因此，两个副本追加了数据B，而另一个副本没有。</p>
</li>
<li>
<p>**后续写入：**第三个客户端想要追加数据C，并且Primary选择了偏移量并通知Secondary。三个副本都成功追加了数据C。</p>
</li>
<li>
<p>**处理写入失败：**由于网络问题，第二个客户端会收到写入失败的回复，并重新发起追加数据B的请求。假设这次数据B没有丢包，三个副本都成功追加了数据B。现在，三个副本都在线，并且都有最新的版本号。</p>
</li>
<li>
<p>**读取数据的影响：**客户端读取文件时，读取的内容取决于读取的是哪个副本。例如：</p>
<ul>
<li>读取第一个副本时，可能会看到数据A、B、C，然后是重复的B。</li>
<li>读取第三个副本时，可能会看到数据A、一个空白数据、然后是C、B。</li>
</ul>
<p>所以不同的读请求可能得到不同的结果，具体取决于读取的是哪个副本。</p>
</li>
<li>
<p>**处理写入失败的复杂情况：**在最坏情况下，某个Secondary未能成功执行数据追加操作，客户端从Primary收到写入失败的回复。在客户端重新发送写文件请求之前，客户端可能故障，导致数据D只存在于某些副本中，而其他副本完全没有。</p>
</li>
</ol>
<p>在GFS的这种工作方式下，如果Primary返回写入成功，一切正常。如果Primary返回写入失败，不同副本的数据可能不同。GFS的设计简单，但可能会暴露一些奇怪的数据顺序问题。应用程序需要容忍数据乱序，或通过在文件中写入序列号来识别顺序。如果应用程序对数据顺序敏感，可以避免并发写入，例如，电影文件的写入应使用一个客户端顺序追加数据。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=small" data-sub-html="<h2>4f013eecba1d5a096fdac0325605e35f</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png" alt="4f013eecba1d5a096fdac0325605e35f" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=large 2x" data-title="4f013eecba1d5a096fdac0325605e35f" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果要将GFS升级为强一致系统，需要考虑以下几点：</p>
<ol>
<li>**检测重复请求：**Primary需要能够检测重复的请求，确保数据不会重复写入。</li>
<li>**Secondary的强制执行：**Secondary必须执行Primary的请求，而不能简单地返回错误。对于永久性故障的Secondary，需要有机制将其移除。</li>
<li>**两阶段提交：**写请求需要两个阶段：首先Primary向Secondary发出请求并等待确认；如果所有Secondary都确认，Primary再指示实际执行操作。</li>
<li>**处理Primary崩溃：**当Primary崩溃时，新Primary需要与Secondary同步，确保操作历史一致。</li>
<li>**Secondary的租约系统：**Secondary需要一个类似Primary的租约系统，确保在合法时间内响应客户端请求。</li>
</ol>
<p>总体而言，GFS取得了巨大的成功，许多Google的应用都依赖于它。例如，BigTable和MapReduce等关键基础架构都是构建在GFS之上的，因此GFS在Google内部得到了广泛应用。然而，GFS也有其局限性，最严重的问题在于它只有一个Master节点，这带来了以下几个问题：</p>
<ol>
<li>
<p>**内存限制：**Master节点必须为每个文件和每个Chunk维护表单。随着使用量的增加，文件数量不断上升，最终Master节点会耗尽内存来存储这些表单。虽然可以增加内存，但单台计算机的内存总有上限，这成为了早期遇到的一个显著问题。</p>
</li>
<li>
<p>**处理能力：**单个Master节点需要处理数千个客户端的请求，而其CPU每秒只能处理数百个请求。尤其当Master节点还需要将部分数据写入磁盘时，这个问题变得更加严重，导致客户端数量很快超过了单个Master的处理能力。</p>
</li>
<li>
<p>**复杂的语义：**应用程序发现很难处理GFS复杂的语义，特别是副本数据同步问题（或不同步问题），这在一定程度上增加了开发难度。</p>
</li>
<li>
<p>**故障切换：**从GFS论文中可以了解到，Master节点的故障切换不是自动的。当Master节点永久故障时，需要人工干预来更换新的服务器，这可能需要几十分钟甚至更长时间来处理。对于某些应用程序来说，这样的停机时间是不可接受的。</p>
</li>
</ol>
<h2 id="faq" class="heading-element"><span>8 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li>应用程序如何知道Chunk的哪些部分由填充和重复记录组成？</li>
</ol>
<p>为了检测填充，应用程序可以在有效记录的开头放置一个可预测的幻数，或者包含一个校验和，该校验和可能仅在记录有效时才有效。应用程序可以通过在记录中包含唯一 ID 来检测重复项。然后，如果它读取的记录与之前的记录具有相同的 ID，它就知道它们是彼此的重复项。 GFS 为处理这些情况的应用程序提供了一个库。 GFS 设计的这一方面有效地将复杂性从 GFS 转移到了应用程序，但这可能并不理想。</p>
<ol start="2">
<li>怎样知道一个文件存储在哪台机器上？</li>
</ol>
<p>根据master中文件到chunk再到chunk位置的映射来定位具体的chunkserver。</p>
<ol start="3">
<li>论文提到了引用计数——它们是什么？</li>
</ol>
<p>它们是快照写时复制实现的一部分。当GFS创建快照时，它不会复制块，而是增加每个块的引用计数器。这使得创建快照的成本很低。如果客户端写入一个chunk并且主服务器注意到引用计数大于 1，则主服务器首先创建一个副本，以便客户端可以更新该副本（而不是属于快照一部分的块）。您可以将此视为延迟复制，直到绝对必要为止。希望并非所有块都会被修改，并且可以避免制作一些副本。</p>
<ol start="4">
<li>什么是租约？</li>
</ol>
<p>对于 GFS，租约是master授予 chunkserver 充当特定 chunk 的主chunkserver的能力的一段时间。master保证在租约期间不会分配不同的主chunkserver，并且主服务器同意在租约到期之前停止充当主chunkserver（除非主chunkserver要求master延长租约）。租约是避免主chunkserver必须反复询问master是否仍然是主chunkserver的一种方法—它知道它可以在下一分钟（或无论租约间隔是多少）充当主chunkserver，而无需再次与master通信。</p>
<ol start="5">
<li>什么是内部碎片？为什么惰性分配有帮助？</li>
</ol>
<p>内部碎片是当系统使用大于所请求分配所需的分配单元时浪费的空间。如果 GFS 以 64MB 为单位分配磁盘空间，那么一个 1 字节的文件将浪费近 64MB 的磁盘空间。 GFS 通过延迟分配磁盘空间来避免这个问题。每个块都是一个Linux文件，Linux文件系统使用的块大小为几十KB；<font color="red">因此，当应用程序创建一字节 GFS 文件时，该文件的块仅消耗 1 个 Linux 磁盘块，而不是 64 MB</font>。</p>
<ol start="6">
<li>Google 还在使用 GFS 吗？</li>
</ol>
<p>有传言称 GFS 已被 Colossus 所取代，总体目标相同，但在主性能和容错性方面有所改进。此外，Google内部的许多应用程序已经转向更多类似数据库的存储系统，例如BigTable和Spanner。然而，GFS 的大部分设计仍然存在于 HDFS（Hadoop 开源 MapReduce 的存储系统）中。</p>
</blockquote>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】 测试分布式系统的线性一致性</title><link>https://hezephyr.github.io/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Wed, 22 May 2024 09:33:17 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description><![CDATA[<p><a href="https://anishathalye.com/testing-distributed-systems-for-linearizability/"target="_blank" rel="external nofollow noopener noreferrer">Testing Distributed Systems for Linearizability 原文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正确实现一个分布式系统是非常有挑战的一件事情，因为需要很好的处理并发和失败这些问题。网络包可能被延迟，重复，乱序或者丢弃，机器可能在任何时候宕机。即使一些计被论文证明是正确的，也仍然很难再实现中避免 bug。</p>
<p>除非我们使用形式方法，不然，即使我们假设实现是正确的，我们也需要去测试系统。测试分布式系统也是一件非常有挑战的事情。并发和不确定性使得我们在测试的时候非常难抓住 bug，尤其是在一些极端情况下面才会出现的 bug，譬如同时机器宕机或者极端网络延迟。</p>
<h2 id="正确性" class="heading-element"><span>2 正确性</span>
  <a href="#%e6%ad%a3%e7%a1%ae%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在讨论测试分布式系统的正确性之前，我们首先定义下什么是 “正确性”。即使对于一些简单的系统，要完全的确定系统符合预期也是一件相当复杂的事情。</p>
<p>考虑一个简单的 key-value store，譬如 etcd，支持两个操作：<code>Put(key, value)</code> 和 <code>Get(key)</code>，首先，我们需要考虑它在顺序情况下面的行为。</p>
<h3 id="顺序规范" class="heading-element"><span>2.1 顺序规范</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e8%a7%84%e8%8c%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通常对于一个 key-value store，我们对于它在顺序操作下面的行为都能有一个直观的认识：<code>Get</code> 操作如果在 <code>Put</code> 的后面，那么一定能得到 <code>Put</code> 的结果。譬如，如果 <code>Put(&quot;x&quot;, &quot;y&quot;)</code> ，那么后面的 <code>Get(&quot;x&quot;)</code> 就能得到 &ldquo;y&rdquo;，如果得到了 &ldquo;z&rdquo;，那么这就是不对的。</p>
<p>我们使用 Python 定义一个简单的 key-value store：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>上面的代码比较简单，但包含了足够的信息，包括初始状态是怎样的，内部状态是如何被操作的结果改变的，从 key-value存储里面操作返回的结果是怎样的。这里需要留意下 <code>Get()</code> 对于不存在的 key 的处理，通常会返回一个空字符串。</p>
<h2 id="线性一致性" class="heading-element"><span>3 线性一致性</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>接下来，我们来考虑我们的 key-value store在并发下面会有怎样的行为。需要注意顺序规范并没有指明在并发操作下面会发生什么。譬如，顺序规范并没有说 key-value store 在下面这个场景下可以允许的操作。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们并不能立刻知道 <code>Get(&quot;x&quot;)</code> 这个操作会允许返回怎样的结果。直觉上，我们可以说<code>Get(&quot;x&quot;)</code> 是跟 <code>Put(&quot;x&quot;, &quot;y&quot;)</code> 和 <code>Put(&quot;x&quot;, &quot;z&quot;)</code> 一起执行的，所以它能可能返回一个值，甚至也可能返回 <code>&quot;&quot;</code>。 如果有另一个 <code>Get(&quot;x&quot;)</code> 的操作在更后面执行，我们可以说这个一定能返回 <code>&quot;z&quot;</code>，因为它是最后一次写入的值，而且那个时候并没有其他的并发写入。</p>
<p>对于一个基于顺序规范的并发操作来说，我们会用一个一致性模型，也就是线性一致性来说明它的正确性。在一个线性一致性的系统里面，任何操作都可能在调用或者返回之间原子和瞬间执行。除了线性一致性，还有一些其他一致性的模型，但多数分布式系统都提供了线性一致性的操作：线性一致性是一个强的一致性模型，并且基于线性一致性系统，很容易去构建其他的系统。考虑到如下对 key-value store 操作的历史例子：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这个历史是一个线性的。在下面图片的蓝色地方，我们现实的标明了线性一致的点。这个顺序历史 <code>Put(&quot;x&quot;, &quot;0&quot;)</code>, <code>Get(&quot;x&quot;) -&gt; &quot;0&quot;</code>, <code>Put(&quot;x&quot;, &quot;1&quot;)</code>, <code>Get(&quot;x&quot;) -&gt; &quot;1&quot;</code>，对于顺序规范来说就是一个正确的历史。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>对应的，下面的历史就不是线性一致的。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>对于顺序规范来说，这个历史并不是线性一致的：我们并不能在这个历史的操作里面指定出线性一致的点。我们可以画出 client 1，2 和 3 的，但我们并不能画出 client 4 的，因为这明显是一个过期的值。类似的，我们可以画出 client 1，2 和 4 的，那么 client 2 的操作一定会在 4 的操作开始的后面，但这样我们就不能处理 client 3，它只可能合法的返回 <code>&quot;&quot;</code>或者 <code>&quot;0&quot;</code>。</p>
<h2 id="测试" class="heading-element"><span>4 测试</span>
  <a href="#%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了一个正确性的定义，我们就可以考虑如何去测试分布式系统了。通常的做法就是对于正确的操作，不停的进行随机的错误注入，类似机器宕机，网络隔离等。我们甚至能模拟整个网络，这样我们就能做长时间的网络延迟等。因为测试时随机的，我们需要跑很多次从而确定一个系统的实现是正确的。</p>
<h3 id="临时测试" class="heading-element"><span>4.1 临时测试</span>
  <a href="#%e4%b8%b4%e6%97%b6%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们实际如何做正确操作的测试呢？在最简单的软件里面，我们可以使用输入输出测试，譬如 <code>assert(expected_output == f(input))</code>，我们也可以在分布式系统上面使用一个类似的方法，譬如，对于 key-value store，当多个 client 开始执行操作的时候，我们可以有如下的测试：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果测试挂掉了，那么这个系统一定不是线性一致性的，当然，这个测试并不是很完备，因为有可能不是线性一致的系统也可能通过这个测试。</p>
<h3 id="线性一致性-1" class="heading-element"><span>4.2 线性一致性</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个更好的办法就是并发的客户端完全跑随机的操作。譬如，循环的去调用 <code>kvstore.put(rand(), rand())</code> 和 <code>kvstore.get(rand())</code>，有可能会只用很少的 key 去增大冲突的概率。但在这种情况下，我们如何定义什么是正确的操作呢？在上面的简单的测试里面，因为每个 client 都操作的是一个独立的 key，所以我们可以非常明确的知道输出结果。</p>
<p>但是 clients 并发的操作同一堆 keys，事情就变得复杂了。我们并不能预知每个操作的返回值因为这并没样一个唯一的答案。但我们可以用另一个办法：我们可以记录整个操作的历史，然后去验证这个操作历史是线性一致的。</p>
<h4 id="线性一致性验证" class="heading-element"><span>4.2.1 线性一致性验证</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7%e9%aa%8c%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">一个线性一致性验证器会使用一个顺序规范和一个并发操作的历史，然后执行一个判定程序去检查这个历史在规范下面是否线性一致。</font></p>
<h4 id="np-完备" class="heading-element"><span>4.2.2 NP 完备</span>
  <a href="#np-%e5%ae%8c%e5%a4%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>但不幸的是，线性一致性验证是 NP 完备的。这个证明非常简单：我们能说明线性一致性验证是 NP 问题，并且也能展示一个 NP 困难问题能被简化成线性一致性验证。明显的，线性一致性验证是 NP 问题，譬如，所有操作的线性一致性点，根据相关的顺序规范，我们可以在多项式时间里验证。</p>
<p>为了说明线性一致性验证是 NP 困难的，我们可以将子集合问题简化成线性一致性验证。对于子集合问题，我们给出非负数的集合 $S={s_1,s_2,…,s_n}$ 和目标结果 $t$，然后我们必须确定是否存在一个子集 $S$ 的和等于 $t$。我们可以将这个问题简化成如下的线性一致性验证。考虑顺序规范：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>以及历史：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当且仅当子集和问题的答案为“是”时，该历史才可线性化。如果历史是可线性化的，那么我们可以采用在 <code>Get()</code> 操作之前具有线性化点的所有操作 <code>Add(s_i)</code> ，并且这些操作对应于中的元素 $s_i$总和为 $t$ 的子集。如果该集合确实有一个总和为$t$的子集，那么我们可以通过与子集中的元素$s_i$对应的操作 <code>Add(s_i)</code> 来构造线性化放置在 <code>Get()</code> 操作之前，并使其余操作发生在 <code>Get()</code> 操作之后。</p>
<h4 id="实现" class="heading-element"><span>4.2.3 实现</span>
  <a href="#%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>即使线性一致性验证是 NP 完全的，在实际中，它仍然能在一些小的历史上面很好的工作。线性一致性验证器的实现会用一个可执行的规范，加上一个历史，执行一个搜索过程去构造一个线性化，并使用一些技巧来限制减少搜索的空间。</p>
<p>现有的线性化检查器如 Knossos，用于 Jepsen 测试系统。但不幸的是，在测试一些分布式 key-value store 的时候，Knossos 并不能很好的工作，它可能只能适用于一些少的并发 clients，以及只有几百的事件的历史。但在一些测试里面，有很多的 clients，以及会生成更多的历史事件。</p>
<p>为了解决 Knossos 的问题，作者开发了 Procupine，一个用 Go 写的更快的线性一致性验证工具。Porcupine 使用一个用 Go 开发的执行规范去验证历史是否是线性的。根据实际测试的情况，Porcupine 比 Knossos 快很多倍。</p>
<p><a href="https://github.com/anishathalye/porcupine"target="_blank" rel="external nofollow noopener noreferrer">Procupine Github<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h4 id="效果" class="heading-element"><span>4.2.4 效果</span>
  <a href="#%e6%95%88%e6%9e%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>使用故障注入和线性化检查来测试可线性化分布式系统是一种有效的方法。</p>
<p>作为对比，在使用专门的测试用 Porcupine 测试 key-value store 的时候，作者使用了这两种方式。作者在实现它自己的 key-value store 的时候引入不同的设计错误，譬如在修改之后会出现过期读，来看这些测试是否会挂掉。专门测试会捕捉到很多 bugs，但并没有能力去捕捉到更多的狡猾的 bugs。相对而言，作者现在还没找到一个正确性的 bug 是线性一致性测试不能抓住的。</p>
<ol>
<li>形式方法能够保证一个分布式系统的正确性。例如，UM PLSE 研究小组最近使用 Coq proof assistnt 来验证了 Raft 一致性协议。但不幸的的是，验证需要特定的知识，另外验证实际的系统需要做大量的工作。没准有一天，验证能被用在实际系统上面，但现在，主要还是测试，而不是验证。</li>
<li>理论上，所有的生产系统都会有一个形式规范，而且一些系统也已经有了，譬如 Raft 就有一个用 TLA+ 写的形式规范。但不幸的是，大部分的系统是没有的。</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程</title><link>https://hezephyr.github.io/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 15 May 2024 09:55:12 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/</guid><description><![CDATA[<h2 id="为什么选择go" class="heading-element"><span>1 为什么选择Go</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9go" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在实现分布式系统时，选择合适的编程语言非常重要。Go有以下特点：</p>
<ul>
<li>优秀的线程支持；</li>
<li>便捷的RPC机制、类型；</li>
<li>内存安全以及垃圾回收机制。</li>
</ul>
<p>这使Go成为了一个理想的选择。Go不仅相对简单，而且其垃圾回收机制使线程管理更加容易，避免了使用后释放问题。由于这些优势，Go在分布式系统中被广泛应用。</p>
<p><a href="https://golang.org/doc/effective_go.html"target="_blank" rel="external nofollow noopener noreferrer">Go Tutorial<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="线程与go中的goroutine" class="heading-element"><span>2 线程与Go中的Goroutine</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e4%b8%8ego%e4%b8%ad%e7%9a%84goroutine" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>线程是一种有用的结构工具，允许一个程序同时执行多项任务，每个线程串行执行，就像非线程程序一样。Go中称线程为Goroutine，每个Goroutine在执行时包含自己的程序计数器、寄存器和栈，但共享内存。使用线程可以提高I/O并发性和多核性能，同时也方便后台任务的处理。</p>
<h3 id="为什么使用线程" class="heading-element"><span>2.1 为什么使用线程？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>I/O并发性</strong>：客户端可以并行向多个服务器发送请求并等待回复，服务器可以同时处理多个客户端请求。</li>
<li><strong>多核性能</strong>：在多核处理器上并行执行代码，提高计算效率。</li>
<li><strong>便捷性</strong>：后台线程可以定期检查各个<code>worker</code>线程是否仍然活跃。</li>
</ol>
<h3 id="线程的替代方案" class="heading-element"><span>2.2 线程的替代方案</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>事件驱动编程（Event-driven programming）是一种替代传统多线程编程的方式，通过在单线程中显式交错处理活动来实现I/O并发性。这种编程模型常用于处理大量I/O操作的场景，例如网络服务器和图形用户界面（GUI）应用。</p>
<p>在事件驱动编程中，系统维护一个事件循环（event loop），不断检查并处理事件队列中的事件。每个事件通常对应某种外部输入或状态变化，如网络请求到达、用户点击按钮或定时器到期。事件处理程序（event handler）被注册到特定事件上，当相应事件发生时，处理程序被调用来执行预定义的操作。</p>
<h3 id="线程编程挑战" class="heading-element"><span>2.3 线程编程挑战</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e7%bc%96%e7%a8%8b%e6%8c%91%e6%88%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>安全共享数据</strong>：多个线程同时访问共享数据时可能导致竞争条件，常用的解决方案是使用锁（如Go的<code>sync.Mutex</code>）或者避免共享可变数据。</li>
<li><strong>线程间协调</strong>：一个线程生产数据，另一个线程消费数据，需要使用Go的通道（<code>channel</code>）或条件变量（<code>sync.Cond</code>）或等待组（<code>sync.WaitGroup</code>）进行协调。</li>
<li><strong>死锁</strong>：线程之间通过锁或<code>channel</code>或RPC相互等待资源时可能导致死锁，需要小心避免。</li>
</ol>
<h2 id="以网络爬虫为例的线程应用" class="heading-element"><span>3 以网络爬虫为例的线程应用</span>
  <a href="#%e4%bb%a5%e7%bd%91%e7%bb%9c%e7%88%ac%e8%99%ab%e4%b8%ba%e4%be%8b%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>网络爬虫的目标是抓取所有网页内容，常见的实现方式有串行和并发两种。并发爬虫利用线程提高抓取效率，但也需要解决避免重复抓取和循环依赖的问题。</p>
<p>在本例中，我们使用一个填充的<code>Fetcher</code>来模拟抓取。<code>fetcher</code>结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">fakeResult</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">body</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">fakeFetcher</span><span class="p">)</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">url</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found:   %s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">urls</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;missing: %s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not found: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fetcher is a populated fakeFetcher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">fetcher</span> <span class="p">=</span> <span class="nx">fakeFetcher</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;The Go Programming Language&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/cmd/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Packages&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/cmd/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/fmt/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/os/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/fmt/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Package fmt&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/os/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Package os&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="串行爬虫" class="heading-element"><span>3.1 串行爬虫</span>
  <a href="#%e4%b8%b2%e8%a1%8c%e7%88%ac%e8%99%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>串行爬虫通过递归调用实现深度优先搜索，使用一个共享的map记录已抓取的URL，防止重复抓取。然而，这种方式只能一次抓取一个页面，速度较慢。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Serial</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">fetched</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Use a map to keep track of fetched URLs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Recursively fetch URLs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Serial</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">,</span> <span class="nx">fetched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>我们是否可以在<code>Serial()</code>调用前面放一个<code>go</code>呢</p>
</blockquote>
<p>在 <code>Serial()</code> 调用前添加 <code>go</code> 关键字会导致并发执行多个爬虫任务，从而可能导致重复抓取相同的页面。这是因为每个爬虫任务都会尝试从未抓取过的页面开始递归抓取，而并发执行可能导致多个爬虫同时选择相同的页面作为起始点，进而重复抓取。</p>
<h3 id="并发爬虫" class="heading-element"><span>3.2 并发爬虫</span>
  <a href="#%e5%b9%b6%e5%8f%91%e7%88%ac%e8%99%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="使用锁" class="heading-element"><span>3.3 使用锁</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个页面的抓取在独立的线程中进行，为了确保抓取过程的正确性，我们使用了互斥锁来保护共享的 <code>fetchState</code> 结构体，避免了重复抓取和并发冲突的问题。在抓取过程中，我们使用了递归调用 <code>ConcurrentMutex</code> 函数来处理当前页面的所有子链接。每当发现一个新的子链接时，我们启动一个新的 Goroutine 来并发地抓取该链接，从而实现了多个页面的并行抓取。使用 <code>sync.WaitGroup</code> 来等待所有的子链接抓取任务完成，确保主线程在所有任务完成后才返回，以避免提前结束抓取过程。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">fetchState</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>      <span class="c1">// protect concurrent crawls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fetched</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span> <span class="c1">// Used to store crawled URLs. The key is URL and the value is whether it has been crawled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">fs</span> <span class="o">*</span><span class="nx">fetchState</span><span class="p">)</span> <span class="nf">testAndSet</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span><span class="p">.</span><span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">r</span> <span class="c1">// Return to previous crawling status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ConcurrentMutex</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">fs</span> <span class="o">*</span><span class="nx">fetchState</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">fs</span><span class="p">.</span><span class="nf">testAndSet</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">done</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// Create a wait group that waits for all subtasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">done</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1">// Increase the counter of the waiting group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">u</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Start a Go coroutine to concurrently crawl sub-links
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">defer</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nf">ConcurrentMutex</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">,</span> <span class="nx">fs</span><span class="p">)</span> <span class="c1">// Recursive call ConcurrentMutex, fetching sub-links.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}(</span><span class="nx">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// Wait for all subtasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用通道" class="heading-element"><span>3.4 使用通道</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%80%9a%e9%81%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个<code>worker</code>线程将抓取到的URL发送到一个通道，<code>coordinator</code>从通道中读取URL并启动新的<code>worker</code>线程。这种方式避免了锁的使用，但需要小心避免通道阻塞导致的死锁。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">urls</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">coordinator</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">1</span>                           <span class="c1">// 记录正在处理的任务数量，初始值为 1，因为最开始只有一个初始 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fetched</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// 记录已经抓取的 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">urls</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>           <span class="c1">// 不断从通道中接收抓取到的链接列表，直到通道被关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span> <span class="c1">// 遍历接收到的链接列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">fetched</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fetched</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">				<span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">				<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">ch</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span> <span class="c1">// 启动一个新的 worker 协程抓取该链接的子链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 如果当前没有正在处理的任务，则退出循环，结束并发抓取过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ConcurrentChannel 函数是并发抓取的入口函数，利用通道协调并发抓取的过程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ConcurrentChannel</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 创建一个字符串切片类型的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>               <span class="c1">// 启动一个匿名函数的 Go 协程，用于向通道发送 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">url</span><span class="p">}</span> <span class="c1">// 向通道发送包含初始 URL 的字符串切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">coordinator</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span> <span class="c1">// 调用 coordinator 函数，开始并发抓取的协调过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>worker</code> 函数中，每个<code>worker</code>线程会尝试抓取指定的URL，并将抓取到的子链接发送到通道中。如果抓取失败，则发送一个空的字符串切片到通道，以便通知<code>coordinator</code>任务失败。</p>
<p>在 <code>coordinator</code> 函数中，<code>coordinator</code>不断从通道中读取抓取到的链接列表，然后遍历这些链接，如果发现之前未抓取过的新链接，则将其标记为已抓取并启动一个新的<code>worker</code>线程进行抓取。同时，<code>coordinator</code>会维护一个计数器 <code>n</code> 来记录当前正在处理的任务数量，当所有任务都处理完成后，<code>coordinator</code>结束并发抓取的过程。</p>
<p>在 <code>ConcurrentChannel</code> 函数中，我们首先创建了一个字符串切片类型的通道，并启动了一个匿名的 Goroutine 来向通道发送初始的 URL。然后，调用 <code>coordinator</code> 函数开始并发抓取的协调过程。</p>
<blockquote>
<ol>
<li><code>coordinator</code>如何知道它已经完成？</li>
</ol>
<p><code>coordinator</code>知道它已完成的条件是 <code>n</code> 计数器的值归零。<code>coordinator</code>通过维护 <code>n</code> 计数器来跟踪当前正在处理的任务数量，每个<code>worker</code>线程处理完成后会将 <code>n</code> 减一。当 <code>n</code> 计数器的值为零时，表示所有的任务都已经完成，<code>coordinator</code>就知道自己的工作已经完成。</p>
<ol start="2">
<li>通道在这里有两个作用：</li>
</ol>
<p>- 通信值：<code>worker</code>线程将抓取到的链接列表发送到通道中，以便<code>coordinator</code>可以读取并处理。
- 事件通知：通道的关闭可作为事件通知，当通道关闭时，<code>coordinator</code>会知道所有的<code>worker</code>线程都已完成，并且没有新的任务需要处理。</p>
</blockquote>
<h2 id="远程过程调用rpc" class="heading-element"><span>4 远程过程调用（RPC）</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="介绍" class="heading-element"><span>4.1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="远程过程调用rpc-1" class="heading-element"><span>4.2 远程过程调用（RPC）</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>远程过程调用（RPC）是分布式系统中的关键技术之一，它使得客户端和服务器之间的通信变得简单而直观。在分布式系统中，不同的节点可能分布在不同的物理机器上，RPC允许这些节点之间进行远程通信，就像调用本地函数一样，无需了解底层的网络协议细节。</p>
<p>RPC的目标是实现易于编程的客户端/服务器通信，它隐藏了底层网络通信的复杂性，为开发人员提供了简单的接口。通过RPC，开发人员可以专注于业务逻辑的实现，而无需担心网络通信的细节。</p>
<p>在RPC中，数据在客户端和服务器之间通过网络传输，因此需要将数据转换为“有线格式”（wire format）。RPC库负责处理数据的序列化和反序列化，以确保数据可以在网络上传输并在另一端正确解析。</p>
<p>RPC消息的基本结构是请求-响应模式。<font color="red">客户端发送请求给服务器，服务器处理请求并发送响应给客户端。</font>这种简单的请求-响应模式使得RPC成为了一种非常有效的通信方式。</p>
<p>在RPC的软件结构中，通常会有以下几个组件：</p>
<ul>
<li>客户端应用程序：负责发起RPC请求的应用程序。</li>
<li>存根函数（Stub functions）：客户端应用程序调用的接口函数，实际上是一个本地代理，负责将RPC调用转发给远程服务器。</li>
<li>服务器处理函数（Handler functions）：服务器端实际执行业务逻辑的函数。</li>
<li>调度器（Dispatcher）：负责将RPC请求分发给正确的处理函数。</li>
<li>RPC库：提供了RPC通信所需的基本功能，例如序列化、网络通信等。</li>
</ul>
<p>通过RPC，不同语言编写的客户端和服务器可以进行通信，实现了跨语言的可移植性和互操作性。</p>
<h3 id="go的rpc实现" class="heading-element"><span>4.3 Go的RPC实现</span>
  <a href="#go%e7%9a%84rpc%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Go中，实现RPC需要定义请求和回复的结构体，并使用Go的RPC库来处理通信。下面是一个示例，展示了如何在Go中实现一个简单的键值存储服务器（key/value storage server），并使用RPC进行通信。</p>
<ul>
<li>
<p>请求回复结构体</p>
<p>在键值存储服务器的示例中，我们定义了用于Put和Get操作的请求和回复结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PutArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PutReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GetArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GetReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>服务器端（Server）</p>
<p>在服务器端，首先需要定义一个对象，并在该对象上注册处理函数作为RPC处理程序。这些处理函数将处理客户端发送的RPC请求。服务器接受TCP连接并将其传递给RPC库。RPC库负责读取每个请求，并为每个请求创建一个新的Goroutine进行处理。处理函数会读取请求参数，并根据请求调用相应的方法。处理完请求后，服务器将回复信息进行序列化，并通过TCP连接发送回客户端。<font color="red">服务器端的处理函数必须使用锁进行同步，因为RPC库为每个请求创建了一个新的Goroutine。</font>处理函数需要读取请求参数并修改回复信息，因此需要确保并发访问的安全性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KV</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// 互斥锁，保护数据并发访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">KV</span><span class="p">{</span><span class="nx">data</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}}</span> <span class="c1">// 创建键值存储服务器实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcs</span> <span class="o">:=</span> <span class="nx">rpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>              <span class="c1">// 创建一个 RPC 服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcs</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">kv</span><span class="p">)</span>                    <span class="c1">// 注册 kv 为 RPC 服务器的服务对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1234&#34;</span><span class="p">)</span>   <span class="c1">// 监听 TCP 端口 1234
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 启动一个协程来处理客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span> <span class="c1">// 接受客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">go</span> <span class="nx">rpcs</span><span class="p">.</span><span class="nf">ServeConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// 启动一个协程来为客户端提供服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// 关闭监听器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get 方法用于处理客户端发送的 Get 请求，获取指定键的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Put 方法用于处理客户端发送的 Put 请求，存储键值对。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>客户端（Client）</p>
<p>在客户端，首先需要使用Dial函数建立与服务器的TCP连接。然后，客户端需要定义RPC请求的参数结构体和回复结构体，并实现对应的处理函数。客户端通过调用Call函数发起RPC调用，指定连接、函数名称、参数以及存放回复的位置。RPC库负责对参数进行序列化，并将请求发送给服务器。然后，客户端等待并接收服务器的回复，并将回复反序列化为指定的回复结构体。Call函数的返回值指示是否成功接收到了回复，通常还包括服务级别的错误信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// connect 函数用于与键值存储服务器建立连接，并返回一个 RPC 客户端对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">connect</span><span class="p">()</span> <span class="o">*</span><span class="nx">rpc</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1234&#34;</span><span class="p">)</span> <span class="c1">// 使用 TCP 协议连接服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;dialing:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// 如果连接失败，则记录错误并终止程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">connect</span><span class="p">()</span>                         <span class="c1">// 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">GetArgs</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span>                        <span class="c1">// 构造 Get 请求的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">GetReply</span><span class="p">{}</span>                         <span class="c1">// 准备接收服务器的响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KV.Get&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span> <span class="c1">// 调用远程方法 Get，并传递参数 args，将响应写入 reply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>     <span class="c1">// 关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// 返回服务器返回的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// put 函数用于向键值存储服务器发送 Put 请求，存储键值对。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">connect</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">PutArgs</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">PutReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KV.Put&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>其他细节：</p>
<ul>
<li>
<p>绑定（Binding）：客户端如何知道要与哪台服务器通信？</p>
<p>在Go的RPC中，服务器的名称和端口是Dial函数的参数。在大型系统中，通常会有一种名称或配置服务器来管理这些信息。</p>
</li>
<li>
<p>序列化（Marshalling）：数据格式化为数据包。Go的RPC库可以传递字符串、数组、对象、映射等类型的数据。Go通过复制指向的数据来传递指针，但不能传递通道或函数。RPC库只序列化导出字段（即大写字母开头的字段）。</p>
</li>
</ul>
<h3 id="处理rpc中的失败" class="heading-element"><span>4.4 处理RPC中的失败</span>
  <a href="#%e5%a4%84%e7%90%86rpc%e4%b8%ad%e7%9a%84%e5%a4%b1%e8%b4%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在分布式系统中，网络故障和服务器故障是不可避免的。简单的解决方案是“尽力而为”的RPC，即在超时后重试请求，但这可能导致重复操作。</p>
<p>这种方法的缺点是，重试请求可能导致操作被重复执行。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果第二个<code>Put</code>请求因网络故障重试多次，可能会导致不一致的结果：</p>
<p>更好的解决方案是“至多一次”的RPC，“至多一次”的RPC通过以下机制实现更可靠的行为：</p>
<ul>
<li>客户端在未收到响应时重新发送请求。</li>
<li>服务器检测重复请求，并返回之前的响应，而不是重新执行处理函数。</li>
</ul>
<p>为了检测重复请求，客户端在每个请求中包含一个唯一的ID（XID）。每个请求使用相同的 XID 重新发送服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if seen[xid] {
</span></span><span class="line"><span class="cl">  reply = old[xid]
</span></span><span class="line"><span class="cl">} else {
</span></span><span class="line"><span class="cl">  reply = handler()
</span></span><span class="line"><span class="cl">  old[xid] = reply
</span></span><span class="line"><span class="cl">  seen[xid] = true
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一些“至多一次”复杂性问题：</strong></p>
<ul>
<li>
<p>如果两个客户端使用相同的XID？</p>
<ul>
<li>解决方案：使用大随机数生成唯一ID。</li>
</ul>
</li>
<li>
<p>如何避免seen[xid]表过大？</p>
<ul>
<li>每个客户端有一个唯一ID，使用序列号。</li>
<li>客户端在每次RPC中包含“已见到的最大回复”信息，类似于TCP序列号和确认号。</li>
</ul>
</li>
<li>
<p><strong>服务器崩溃和重启：</strong></p>
<ul>
<li>
<p>如果“至多一次”信息保存在内存中，服务器重启后将忘记这些信息，可能会接受重复请求。</p>
<p>解决方案：将重复检测信息写入磁盘，或使用复制服务器同步这些信息。</p>
</li>
</ul>
</li>
</ul>
<p>Go的RPC库是“至多一次”策略的简单实现：</p>
<ul>
<li>打开TCP连接。</li>
<li>将请求写入TCP连接。</li>
<li>Go RPC从不重发请求，因此服务器不会看到重复请求。</li>
<li>如果未收到回复，Go RPC代码返回错误（可能是由于TCP超时）。</li>
</ul>
<blockquote>
<p>关于“恰好一次”的RPC</p>
<p>“恰好一次”的RPC包括无限重试、重复检测和容错服务，这种方法更复杂，在实际系统中需要实现容错机制。</p>
<p>例如，lab 4中将探讨“恰好一次”RPC的实现。</p>
</blockquote>
<h2 id="faq" class="heading-element"><span>5 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li>Go通道是如何工作的？Go如何确保它们在多个goroutines之间同步？</li>
</ol>
<p>可以在<a href="https://go.dev/src/runtime/chan.go"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>查看源码，尽管不易理解。高层次上，<font color="red">通道是一个包含缓冲区和锁的结构体</font>。发送到通道涉及获取锁，等待（可能释放CPU）直到某个线程接收，并交付消息。接收涉及获取锁并等待发送者。可以使用Go的sync.Mutex和sync.Cond自己实现通道。</p>
<ol start="2">
<li>我使用通道唤醒另一个goroutine，通过在通道上发送一个虚拟的bool值。但如果另一个goroutine已经在运行（因此没有在通道上接收），发送goroutine会阻塞。我应该怎么做？</li>
</ol>
<p>尝试使用条件变量（Go的sync.Cond）而不是通道。条件变量非常适合通知可能（或可能不）等待某事的goroutines。由于通道是同步的，如果不确定通道另一端是否有goroutine在等待，使用通道会显得很尴尬。</p>
<ol start="3">
<li>如何让一个goroutine等待来自多个不同通道的输入？如果没有任何内容可读取，则尝试在任何一个通道上接收都会阻塞，从而阻止 goroutine 检查其他通道。</li>
</ol>
<p>尝试为每个通道创建一个单独的goroutine，每个goroutine阻塞在其通道上。这不是总能实现，但在可行时通常是最简单的方法。否则，尝试使用Go的select。</p>
<ol start="4">
<li>什么时候应该使用sync.WaitGroup而不是通道？反之亦然？</li>
</ol>
<p>WaitGroup用途较为特殊；它仅在等待一堆活动完成时有用。通道用途更广泛；例如，可以通过通道传递值。尽管比WaitGroup需要多写几行代码，但也可以使用通道等待多个goroutines。</p>
<ol start="5">
<li>如何创建一个通过互联网连接的Go通道？如何指定用于发送消息的协议？</li>
</ol>
<p>Go通道仅在单个程序内工作；通道不能用于与其他程序或计算机通信。可以查看Go的RPC包，它允许你通过互联网与其他Go程序通信：
<a href="https://golang.org/pkg/net/rpc/"target="_blank" rel="external nofollow noopener noreferrer">https://golang.org/pkg/net/rpc/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol start="6">
<li>一些重要/有用的Go特定并发模式有哪些？</li>
</ol>
<p>这是一个关于该主题的幻灯片，由Go专家编写：
<a href="https://talks.golang.org/2012/concurrency.slide"target="_blank" rel="external nofollow noopener noreferrer">https://talks.golang.org/2012/concurrency.slide<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol start="7">
<li>切片是如何实现的？</li>
</ol>
<p>切片是一个对象，包含指向数组的指针以及该数组的开始和结束索引。这种安排允许多个切片共享一个底层数组，每个切片可能暴露数组元素的不同范围。这里有一个更详细的讨论：
<a href="https://blog.golang.org/go-slices-usage-and-internals"target="_blank" rel="external nofollow noopener noreferrer">https://blog.golang.org/go-slices-usage-and-internals<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
Go切片比Go数组更灵活，因为数组的大小是其类型的一部分，而以切片作为参数的函数可以接受任何长度的切片。</p>
<ol start="8">
<li>什么时候使用同步RPC调用，什么时候使用异步RPC调用？</li>
</ol>
<p>大多数代码需要在继续执行前获得RPC回复；在这种情况下，使用同步RPC是合理的。但有时客户端希望启动许多并发RPC；在这种情况下，异步可能更好。或者客户端希望在等待RPC完成时做其他工作，可能是因为服务器很远（所以光速时间很高）或因为服务器可能不可达，从而RPC经历长时间的超时。我(Robert)从未在Go中使用异步RPC。当我想发送RPC但不必等待结果时，我创建一个goroutine，并让这个goroutine进行同步Call()。</p>
<ol start="9">
<li>开发人员在开始使用Go时常见的问题有哪些？</li>
</ol>
<p>以下是一些常见问题：</p>
<p>- 未在并发访问时使用锁保护映射。使用Go的竞态检测器！
- 使用通道时的死锁。
- 在创建goroutine时未捕获变量。
- 泄漏的goroutines。</p>
<ol start="10">
<li>Go是否支持继承？（像Java/C++那样的“扩展”方式？）</li>
</ol>
<p>Go不支持C++风格的继承，但有接口和嵌入结构体，可以完成在C++中使用继承的许多事情。这是Go设计中备受争议的部分；可以搜索“golang generics”。</p>
<ol start="11">
<li>我对选择值接收器或指针接收器仍有些困惑。能否提供一些具体的实际例子说明我们应该选择哪一个？</li>
</ol>
<p>当你想修改接收器的状态时，必须使用指针接收器。如果结构体非常大，你可能想使用指针接收器，因为值接收器操作的是一个副本。如果两者都不适用，可以使用值接收器。然而，要小心使用值接收器；例如，如果结构体中有一个互斥锁，你不能将其作为值接收器，因为互斥锁会被复制，从而失去其作用。</p>
</blockquote>
]]></description></item><item><title>【MIT 6.5840(6.824) 】Lab2:Key/Value Server 设计实现</title><link>https://hezephyr.github.io/posts/06.mit-6.58406.824-lab2-kv-server/</link><pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/06.mit-6.58406.824-lab2-kv-server/</guid><description><![CDATA[<h2 id="实验要求" class="heading-element"><span>1 实验要求</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在本次 Lab 中，你将在单机上构建一个键/值服务器，以确保即使网络出现故障，每个操作也只能执行一次，并且操作是可线性化的。</p>
<p>客户端可以向键/值服务器发送三个不同的 RPC： <code>Put(key, value)</code> 、 <code>Append(key, arg)</code> 和 <code>Get(key)</code> 。服务器在内存中维护键/值对的<code>map</code>。键和值是字符串。 <code>Put(key, value)</code> 设置或替换<code>map</code>中给定键的值， <code>Append(key, arg)</code> 将 arg 附加到键的值并返回旧值， <code>Get(key)</code> 获取键的当前值。不存在的键的 <code>Get</code>请求应返回空字符串；对于不存在的键的 <code>Append</code> 请求应该表现为现有值是零长度字符串。每个客户端都通过<code>Clerk</code>的 <code>Put/Append/Get</code> 方法与服务器进行通信。 <code>Clerk</code> 管理与服务器的 RPC 交互。</p>
<p>你的服务器必须保证应用程序对<code>Clerk Get/Put/Append</code> 方法的调用是线性一致的。 如果客户端请求不是并发的，每个客户端 Get/Put/Append 调用时能够看到之前调用序列导致的状态变更。 对于并发的请求来说，返回的结果和最终状态都必须和这些操作顺序执行的结果一致。如果一些请求在时间上重叠，则它们是并发的：例如，如果客户端 X 调用 <code>Clerk.Put()</code> ，并且客户端 Y 调用 <code>Clerk.Append()</code> ，然后客户端 X 的调用 返回。 一个请求必须能够看到已完成的所有调用导致的状态变更。</p>
<p>一个应用实现线性一致性就像一台单机服务器一次处理一个请求的行为一样简单。 例如，如果一个客户端发起一个更新请求并从服务器获取了响应，随后从其他客户端发起的读操作可以保证能看到改更新的结果。在单台服务器上提供线性一致性是相对比较容易的。</p>
<p>Lab 在 <code>src/kvsrv</code> 中提供了框架代码和单元测试。你需要更改 <code>kvsrv/client.go</code>、<code>kvsrv/server.go</code> 和 <code>kvsrv/common.go</code> 文件。</p>
<h2 id="无网络故障的kv-server" class="heading-element"><span>2 无网络故障的KV Server</span>
  <a href="#%e6%97%a0%e7%bd%91%e7%bb%9c%e6%95%85%e9%9a%9c%e7%9a%84kv-server" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="任务要求" class="heading-element"><span>2.1 任务要求</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>此任务需要实现一个在没有丢失消息的情况下有效的解决方案。你需要在 <code>client.go</code> 中，在 Clerk 的 Put/Append/Get 方法中添加 RPC 的发送代码；并且实现 <code>server.go</code> 中 Put、Append、Get 三个 RPC handler。</p>
<p>当你通过了前两个测试 case：one client、many clients 时表示完成该任务。</p>
<h3 id="设计实现" class="heading-element"><span>2.2 设计实现</span>
  <a href="#%e8%ae%be%e8%ae%a1%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这个任务比较简单，我们只需要根据实验要求的逻辑进行实现即可。</p>
<ul>
<li>
<p><code>server.go</code></p>
<p>使用<code>map</code>保存键值信息，三种操作都需要通过锁来保证互斥访问共享<code>map</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldValue</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">oldValue</span> <span class="o">+</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">oldValue</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>client.go</code></p>
<p>只需要添加RPC的发送代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.Get&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">PutAppend</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">op</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span>   <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Value</span><span class="p">:</span> <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.&#34;</span><span class="o">+</span><span class="nx">op</span><span class="p">,</span> <span class="nx">arg</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nf">PutAppend</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="s">&#34;Put&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="可能丢弃消息的kv-server" class="heading-element"><span>3 可能丢弃消息的KV Server</span>
  <a href="#%e5%8f%af%e8%83%bd%e4%b8%a2%e5%bc%83%e6%b6%88%e6%81%af%e7%9a%84kv-server" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="任务要求-1" class="heading-element"><span>3.1 任务要求</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e8%a6%81%e6%b1%82-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在，您应该修改您的解决方案，以便在遇到丢失的消息（例如 RPC 请求和 RPC 回复）时继续工作。如果消息丢失，则客户端的 <code>ck.server.Call()</code> 将返回 <code>false</code> （更准确地说， <code>Call()</code> 等待响应直至超市，如果在此时间内没有响应就返回<code>false</code>）。您将面临的一个问题是 <code>Clerk</code> 可能需要多次发送 RPC，直到成功为止。但是，每次调用 <code>Clerk.Put()</code> 或 <code>Clerk.Append()</code> 应该只会导致一次执行，因此您必须确保重新发送不会导致服务器执行请求两次。</p>
<p>你的任务是在 <code>Clerk</code> 中添加重试逻辑，并且在 <code>server.go</code> 中来过滤重复请求。</p>
<blockquote>
<center>Hint
</center>
<ol>
<li>您需要唯一地标识<code>client</code>操作，以确保KV Server仅执行每个操作一次。</li>
<li>您必须仔细考虑<code>server</code>必须维持什么状态来处理重复的 <code>Get()</code> 、 <code>Put()</code> 和 <code>Append()</code> 请求（如果有的话）。</li>
<li>您的重复检测方案应该快速释放服务器内存，例如让每个 RPC 暗示<code>client</code>已看到其前一个 RPC 的回复。可以假设<code>client</code>一次只向<code>Clerk</code>发起一次调用。</li>
</ol>
</blockquote>
<h3 id="方案设计" class="heading-element"><span>3.2 方案设计</span>
  <a href="#%e6%96%b9%e6%a1%88%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>根据提示，我们可以为<code>Put</code>和<code>Append</code>消息添加标识ID（<code>Get</code>消息只需不断重试，不会有影响），这里我们还需要用到<code>sync.Map</code>用于在键/值服务器中跟踪处理过的请求ID，以防止重复处理请求。每当服务器接收到一个新的RPC请求时，它会检查请求ID是否已存在于<code>sync.Map</code>中。如果存在，则表明该请求已经处理过，服务器可以跳过重复的处理，直接返回之前处理过的值。否则，服务器会记录该请求ID处理请求，并将回复结果记录。这种机制确保了操作的幂等性，避免了由于网络故障或重试机制导致的重复执行。</p>
<p>当然，还需要考虑一个问题，就是服务器会不断积压处理过的请求ID信息，所以我们需要快速释放服务器内存，即让<code>Client</code>通知<code>Server</code>这个任务操作已经完成，删除相关的记录信息。故我们还需要给消息结构添加一个<code>Type</code>字段标识为<code>Modify</code>还是<code>Report</code>。</p>
<p>整个流程图如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=small" data-sub-html="<h2>image-20240515111905159</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png" alt="image-20240515111905159" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=large 2x" data-title="image-20240515111905159" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="代码实现" class="heading-element"><span>3.3 代码实现</span>
  <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>实验代码实现仓库：https://github.com/unique-pure/MIT6.5840/tree/main/src/kvsrv，实验代码已通过实验测试。</p>
<ul>
<li>
<p><code>common.go</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MessageType</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Modify</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Report</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Put or Append
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PutAppendArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MessageType</span> <span class="nx">MessageType</span> <span class="c1">// Modify or Report
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MessageID</span>   <span class="kt">int64</span>       <span class="c1">// Unique ID for each message
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>server.go</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KVServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">data</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">record</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">MessageType</span> <span class="o">==</span> <span class="nx">Report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">res</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 重复请求，返回之前的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">,</span> <span class="nx">old</span><span class="p">)</span> <span class="c1">// 记录请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">MessageType</span> <span class="o">==</span> <span class="nx">Report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">res</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 重复请求，返回之前的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">old</span> <span class="o">+</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">,</span> <span class="nx">old</span><span class="p">)</span> <span class="c1">// 记录请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>client.go</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.Get&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="c1">// keep trying forever
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">PutAppend</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">op</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MessageID</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span>         <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Value</span><span class="p">:</span>       <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageID</span><span class="p">:</span>   <span class="nx">MessageID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageType</span><span class="p">:</span> <span class="nx">Modify</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.&#34;</span><span class="o">+</span><span class="nx">op</span><span class="p">,</span> <span class="nx">arg</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">PutAppendArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageType</span><span class="p">:</span> <span class="nx">Report</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageID</span><span class="p">:</span>   <span class="nx">MessageID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.&#34;</span><span class="o">+</span><span class="nx">op</span><span class="p">,</span> <span class="nx">arg</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ go <span class="nb">test</span>
</span></span><span class="line"><span class="cl">Test: one client
</span></span><span class="line"><span class="cl">  ... Passed -- t  3.3 nrpc <span class="m">20037</span> ops <span class="m">13359</span>
</span></span><span class="line"><span class="cl">Test: many clients ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  3.7 nrpc <span class="m">85009</span> ops <span class="m">56718</span>
</span></span><span class="line"><span class="cl">Test: unreliable net, many clients ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  3.3 nrpc  <span class="m">1161</span> ops  <span class="m">632</span>
</span></span><span class="line"><span class="cl">Test: concurrent append to same key, unreliable ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.4 nrpc   <span class="m">131</span> ops   <span class="m">52</span>
</span></span><span class="line"><span class="cl">Test: memory use get ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.6 nrpc     <span class="m">8</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use put ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.3 nrpc     <span class="m">4</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use append ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.5 nrpc     <span class="m">4</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use many put clients ...
</span></span><span class="line"><span class="cl">  ... Passed -- t 36.7 nrpc <span class="m">200000</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use many get client ...
</span></span><span class="line"><span class="cl">  ... Passed -- t 22.6 nrpc <span class="m">100002</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use many appends ...
</span></span><span class="line"><span class="cl">2024/05/15 12:48:26 m0 <span class="m">411000</span> m1 <span class="m">1550088</span>
</span></span><span class="line"><span class="cl">  ... Passed -- t  2.6 nrpc  <span class="m">2000</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">PASS
</span></span><span class="line"><span class="cl">ok      6.5840/kvsrv    75.329s</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>【MIT 6.5840(6.824)】Lab1:MapReduce 设计实现</title><link>https://hezephyr.github.io/posts/05.mit-6.58406.824-lab1mapreduce-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 14 May 2024 19:56:28 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/05.mit-6.58406.824-lab1mapreduce-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</guid><description><![CDATA[<h2 id="介绍" class="heading-element"><span>1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>本次实验是实现一个简易版本的<code>MapReduce</code>，你需要实现一个工作程序（worker process）和一个调度程序（coordinator process）。工作程序用来调用Map和Reduce函数，并处理文件的读取和写入。调度程序用来协调工作任务并处理失败的任务。你将构建出跟 <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf"target="_blank" rel="external nofollow noopener noreferrer">MapReduce论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 里描述的类似的东西。（注意：本实验中用&quot;coordinator&quot;替代里论文中的&quot;master&quot;。）</p>
<p>实验先决条件：</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/hzf0701/article/details/138770454?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">阅读MapReduce论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p><a href="http://nil.csail.mit.edu/6.5840/2024/labs/lab-mr.html"target="_blank" rel="external nofollow noopener noreferrer">阅读lab文档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p>理解MapReduce框架</p>
</li>
<li>
<p>理解原框架代码，理清所需完成任务</p>
</li>
</ul>
<p>实验代码实现仓库：https://github.com/unique-pure/MIT6.5840/tree/main/src/mr，实验代码已通过实验测试，并在以下清单中列出了实现的功能及待办事项。</p>
<ul>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> Complete the basic requirements for MapReduce</li>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> Handling worker failures</li>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> No data competition, a big lock ensures safety</li>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> Pass lab test</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> Communicate over TCP/IP and read/write files using a shared file system</li>
</ul>
<h2 id="原框架解析" class="heading-element"><span>2 原框架解析</span>
  <a href="#%e5%8e%9f%e6%a1%86%e6%9e%b6%e8%a7%a3%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><code>src/mrapps/wc.go</code></p>
<p>这是一个用于 MapReduce 的字数统计（Word Count）插件。该插件包含 Map 和 Reduce 函数，用于统计输入文本中的单词频率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Map</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">contents</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">mr</span><span class="p">.</span><span class="nx">KeyValue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// function to detect word separators.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ff</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsLetter</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// split contents into an array of words.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">FieldsFunc</span><span class="p">(</span><span class="nx">contents</span><span class="p">,</span> <span class="nx">ff</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kva</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">mr</span><span class="p">.</span><span class="nx">KeyValue</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">words</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span> <span class="o">:=</span> <span class="nx">mr</span><span class="p">.</span><span class="nx">KeyValue</span><span class="p">{</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kva</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">kva</span><span class="p">,</span> <span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">kva</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Reduce</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">values</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// return the number of occurrences of this word.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>src/main/mrcoordinator.go</code></p>
<p><code>mrcoordinator.go</code> 定义了调度器（Coordinator）的主要逻辑。调度器通过 <code>MakeCoordinator</code> 启动一个 <code>Coordinator</code> 实例 <code>c</code>，并在 <code>c.server()</code> 中通过协程 <code>go http.Serve(l, nil)</code> 启动一个 HTTP 服务器来接收和处理 RPC 调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rpc</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rpc</span><span class="p">.</span><span class="nf">HandleHTTP</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//l, e := net.Listen(&#34;tcp&#34;, &#34;:1234&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sockname</span> <span class="o">:=</span> <span class="nf">coordinatorSock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sockname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">l</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="nx">sockname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeCoordinator</span><span class="p">(</span><span class="nx">files</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">nReduce</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Coordinator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">Coordinator</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">server</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意：在 Go 的 <code>net/http</code> 包中，使用 <code>http.Serve(l, nil)</code> 启动 HTTP 服务器时，服务器会为每个传入的请求自动启动一个新的协程。这意味着每个 RPC 调用都是在独立的协程中处理的，从而允许并发处理多个请求。因此，在设计时可能需要使用锁等同步原语来保护共享资源。此外，Coordinator 不会主动与 Worker 通信（除非额外实现），只能通过 Worker 的 RPC 通信来完成任务。同时，当所有任务完成时，<code>Done</code> 方法将返回 <code>false</code>，从而关闭 Coordinator。</p>
</li>
<li>
<p><code>src/main/mrworker.go</code></p>
<p><code>mrworker.go</code> 通过 <code>Worker</code> 函数运行。因此，<code>Worker</code> 函数需要完成请求任务、执行任务、报告任务状态等多个任务。可以推测，<code>Worker</code> 需要在这个函数中不断地轮询 Coordinator，并根据 Coordinator 的不同回复来驱动当前 Worker 完成各种任务。</p>
</li>
<li>
<p><code>src/main/mrsequential.go</code></p>
<p><code>mrsequential.go</code> 实现了一个简单的顺序 MapReduce 应用程序。该程序读取输入文件，执行 Map 和 Reduce 操作，并将结果写入输出文件。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ul>
<h2 id="设计实现" class="heading-element"><span>3 设计实现</span>
  <a href="#%e8%ae%be%e8%ae%a1%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="任务分析" class="heading-element"><span>3.1 任务分析</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>总体而言，<code>Worker</code>通过RPC轮询<code>Coordinator</code>请求任务，例如Map或者Reduce任务，<code>Coordinator</code>将剩余任务分配给<code>Worker</code>处理（先处理完Map任务才能处理Reduce任务）。</p>
<blockquote>
<p>其中，在此实验中Map任务数量就是输入文件数量，每个<code>Map Task</code>的任务就是处理一个<code>.txt</code>文件；Reduce任务的数量是<code>nReduce</code>。</p>
<p>由于Map任务会将文件的内容分割为指定的<code>nReduce</code>份，每一份应当由序号标明，拥有这样的序号的多个Map任务的输出汇总起来就是对应的Reduce任务的输入。</p>
</blockquote>
<p>请求完任务后，<code>Worker</code>需要根据任务类型进行处理，这段处理过程跟<code>mrsequential.go</code>基本一致，但需要注意的就是论文中提到的，如果同一个任务被多个<code>Worker</code>执行，针对同一个最终的输出文件将有多个重命名操作执行。我们这就依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个任务产生的数据。即通过<code>os.Rename()</code>。</p>
<p>处理完任务后，<code>Worker</code>通过RPC告知<code>Coordinator</code>任务结果。</p>
<p><font color="red">所以，我们可以知道<code>Coordinator</code>管理着任务状态和任务分配，而无需记录<code>Worker</code>的信息，<code>Worker</code>实现任务处理。</font></p>
<p>整个任务流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=small" data-sub-html="<h2>image-20240514154125349</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png" alt="image-20240514154125349" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=large 2x" data-title="image-20240514154125349" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>MapReduce处理WordCount程序的流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="rpc" class="heading-element"><span>3.2 RPC</span>
  <a href="#rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通信时首先需要确定这个消息是什么类型, 通过前述分析可知：</p>
<ul>
<li>
<p>对于<code>Worker</code>发送消息，<code>Worker</code>需要跟<code>Coordinator</code>报告<code>Map</code>或<code>Reduce</code>任务的执行情况(成功或失败)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskCompletedStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MapTaskCompleted</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MapTaskFailed</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ReduceTaskCompleted</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ReduceTaskFailed</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<ul>
<li>
<p>对于<code>Coordinator</code>回复消息，<code>Coordinator</code>需要分配<code>Reduce</code>或<code>Map</code>任务，告知任务的类型，或者告知<code>Worker</code>休眠（暂时没有任务需要执行）、<code>Worker</code>退出（所有任务执行成功）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskType</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MapTask</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ReduceTask</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Wait</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Exit</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>同时，消息还需要附带额外的信息，我这里的设计是发送消息包含任务ID，以便<code>Coordinator</code>更新任务状态，结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MessageSend</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TaskID</span>              <span class="kt">int</span>                 <span class="c1">// task id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskCompletedStatus</span> <span class="nx">TaskCompletedStatus</span> <span class="c1">// task completed status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>回复消息结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MessageReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TaskID</span>   <span class="kt">int</span>      <span class="c1">// task id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskType</span> <span class="nx">TaskType</span> <span class="c1">// task type, map or reduce or wait or exit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskFile</span> <span class="kt">string</span>   <span class="c1">// task file name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NReduce</span>  <span class="kt">int</span>      <span class="c1">// reduce number, indicate the number of reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NMap</span>     <span class="kt">int</span>      <span class="c1">// map number, indicate the number of map tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些字段都是为了辅助<code>Worker</code>进行任务处理，如<code>NMap</code>是为了提供Map任务的数量，以便生成中间文件名，<code>TaskFile</code>是保存Map任务需要处理的输入文件。</p>
<p>对于通信，原框架已提供Unix套接字通信，如果有想法，我们可以将 RPC 设置为通过 TCP/IP 而不是 Unix 套接字进行通信（请参阅 <code>Coordinator.server()</code> 中注释掉的行），并使用共享文件系统读/写文件。</p>
<h3 id="coordinator" class="heading-element"><span>3.3 Coordinator</span>
  <a href="#coordinator" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="结构" class="heading-element"><span>3.3.1 结构</span>
  <a href="#%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>如前所述，<code>Coordinator</code>需要管理任务的状态信息，对于一个任务而言，我们这里定义它的状态为：未分配、已分配、完成、失败。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Unassigned</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Assigned</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Completed</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Failed</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么，任务结构应该包括任务状态，同时，如论文中提到的，可能有<code>Worker</code>成为落伍者，所以我们还需要考虑一个任务是否执行了很长时间还没结束，故这里需要记录任务分配时的时间戳，以便计算运行时间。另外，我们还需要一个字段来存储需要处理的任务文件名。故任务信息结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskInfo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TaskStatus</span> <span class="nx">TaskStatus</span> <span class="c1">// task status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskFile</span>   <span class="kt">string</span>     <span class="c1">// task file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TimeStamp</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>  <span class="c1">// time stamp, indicating the running time of the task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于<code>Coordinator</code>结构，首先肯定是需要两个数据结构来存储所有的Map任务状态和Reduce任务状态，我这里使用的列表；然后由于是并发执行，更新共享任务状态数据，需要一把大锁保平安；最后需要一些额外变量存储任务数量（也可以直接<code>len(list)</code>）以及标志某阶段任务是否完成（如在Reduce任务进行之前Map任务是否已经完成）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Coordinator</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NMap</span>                   <span class="kt">int</span>        <span class="c1">// number of map tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NReduce</span>                <span class="kt">int</span>        <span class="c1">// number of reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MapTasks</span>               <span class="p">[]</span><span class="nx">TaskInfo</span> <span class="c1">// map task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ReduceTasks</span>            <span class="p">[]</span><span class="nx">TaskInfo</span> <span class="c1">// reduce task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">AllMapTaskCompleted</span>    <span class="kt">bool</span>       <span class="c1">// whether all map tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">AllReduceTaskCompleted</span> <span class="kt">bool</span>       <span class="c1">// whether all reduce tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Mutex</span>                  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// mutex, used to protect the shared data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="初始化" class="heading-element"><span>3.3.2 初始化</span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们需要对<code>Coordinator</code>初始化，其中最重要的是更新任务初始状态，一开始都是未分配，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">InitTask</span><span class="p">(</span><span class="nx">file</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">idx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="p">=</span> <span class="nx">TaskInfo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TaskFile</span><span class="p">:</span>   <span class="nx">file</span><span class="p">[</span><span class="nx">idx</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TaskStatus</span><span class="p">:</span> <span class="nx">Unassigned</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TimeStamp</span><span class="p">:</span>  <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">idx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="p">=</span> <span class="nx">TaskInfo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TaskStatus</span><span class="p">:</span> <span class="nx">Unassigned</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeCoordinator</span><span class="p">(</span><span class="nx">files</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">nReduce</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Coordinator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">Coordinator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">NReduce</span><span class="p">:</span>                <span class="nx">nReduce</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">NMap</span><span class="p">:</span>                   <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MapTasks</span><span class="p">:</span>               <span class="nb">make</span><span class="p">([]</span><span class="nx">TaskInfo</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ReduceTasks</span><span class="p">:</span>            <span class="nb">make</span><span class="p">([]</span><span class="nx">TaskInfo</span><span class="p">,</span> <span class="nx">nReduce</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">AllMapTaskCompleted</span><span class="p">:</span>    <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">AllReduceTaskCompleted</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Mutex</span><span class="p">:</span>                  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">InitTask</span><span class="p">(</span><span class="nx">files</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">server</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="requesttask函数" class="heading-element"><span>3.3.3 RequestTask函数</span>
  <a href="#requesttask%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这部分比较复杂，根据我们之前的分析，处理逻辑如下：</p>
<ol>
<li>如果有未分配的任务、之前执行失败、已分配但已经超时（10s）的<code>Map</code>任务，则选择这个任务进行分配；</li>
<li>如果以上的<code>Map</code>任务均不存在，但<code>Map</code>又没有全部执行完成，告知<code>Worker</code>先等待；</li>
<li><code>Map</code>任务全部执行完成的情况下，按照<code>1</code>和<code>2</code>相同的逻辑进行<code>Reduce</code>任务的分配；</li>
<li>所有的任务都执行完成了, 告知<code>Worker</code>退出。</li>
</ol>
<p>因此，处理代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">RequestTask</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">MessageSend</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// assign map task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">AllMapTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// count the number of completed map tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">NMapTaskCompleted</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">idx</span><span class="p">,</span> <span class="nx">taskInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Unassigned</span> <span class="o">||</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Failed</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Assigned</span> <span class="o">&amp;&amp;</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TimeStamp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span> <span class="p">=</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskFile</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span> <span class="p">=</span> <span class="nx">idx</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">MapTask</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NReduce</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NMap</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NMap</span>
</span></span><span class="line"><span class="cl">				<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Assigned</span>  <span class="c1">// mark the task as assigned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TimeStamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="c1">// update the time stamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Completed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">NMapTaskCompleted</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// check if all map tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">NMapTaskCompleted</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">AllMapTaskCompleted</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">Wait</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// assign reduce task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">AllReduceTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// count the number of completed reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">NReduceTaskCompleted</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">idx</span><span class="p">,</span> <span class="nx">taskInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Unassigned</span> <span class="o">||</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Failed</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Assigned</span> <span class="o">&amp;&amp;</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TimeStamp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span> <span class="p">=</span> <span class="nx">idx</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">ReduceTask</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NReduce</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NMap</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NMap</span>
</span></span><span class="line"><span class="cl">				<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Assigned</span>  <span class="c1">// mark the task as assigned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TimeStamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="c1">// update the time stamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Completed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">NReduceTaskCompleted</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// check if all reduce tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">NReduceTaskCompleted</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">AllReduceTaskCompleted</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">Wait</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// all tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">Exit</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="reporttask函数" class="heading-element"><span>3.3.4 ReportTask函数</span>
  <a href="#reporttask%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这个函数则是根据<code>Worker</code>发送的消息任务完成状态来更新任务状态信息即可，<font color="red">记住，一把大锁保平安</font>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">ReportTask</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">MessageSend</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">MapTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Completed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">MapTaskFailed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Failed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">ReduceTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Completed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">ReduceTaskFailed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Failed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="worker" class="heading-element"><span>3.4 Worker</span>
  <a href="#worker" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="worker轮询" class="heading-element"><span>3.4.1 Worker轮询</span>
  <a href="#worker%e8%bd%ae%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>Worker</code>需要通过RPC轮询<code>Coordinator</code>请求任务，然后根据返回的任务类型进行处理（即调用相应函数）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Worker</span><span class="p">(</span><span class="nx">mapf</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reducef</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">args</span> <span class="o">:=</span> <span class="nx">MessageSend</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">MessageReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.RequestTask&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">MapTask</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nf">HandleMapTask</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">reply</span><span class="p">,</span> <span class="nx">mapf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">ReduceTask</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nf">HandleReduceTask</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">reply</span><span class="p">,</span> <span class="nx">reducef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">Wait</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">Exit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="处理map任务" class="heading-element"><span>3.4.2 处理Map任务</span>
  <a href="#%e5%a4%84%e7%90%86map%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>跟<code>mrsequential.go</code>处理基本一致，处理完成后需要通过RPC告知<code>Coordinator</code>结果。但需要注意的是，我们需要通过<code>os.Rename()</code>原子重命名来保证最终的文件系统状态仅仅包含一个任务产生的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">HandleMapTask</span><span class="p">(</span><span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">,</span> <span class="nx">mapf</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// open the file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot open %v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// read the file, get the content
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot read %v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// call the map function to get the key-value pairs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">kva</span> <span class="o">:=</span> <span class="nf">mapf</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">content</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// create intermediate files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">intermediate</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="nx">KeyValue</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">kv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">kva</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span> <span class="o">:=</span> <span class="nf">ihash</span><span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="o">%</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span>
</span></span><span class="line"><span class="cl">		<span class="nx">intermediate</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">[</span><span class="nx">r</span><span class="p">],</span> <span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// write the intermediate files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">kva</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intermediate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">oname</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-%v-%v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ofile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">CreateTemp</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot create tempfile %v&#34;</span><span class="p">,</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">enc</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">ofile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">kv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">kva</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// write the key-value pairs to the intermediate file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">enc</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ofile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Atomic file renaming：rename the tempfile to the final intermediate file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">ofile</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// send the task completion message to the coordinator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">MessageSend</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskID</span><span class="p">:</span>              <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskCompletedStatus</span><span class="p">:</span> <span class="nx">MapTaskCompleted</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.ReportTask&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">MessageReply</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="处理reduce任务" class="heading-element"><span>3.4.3 处理Reduce任务</span>
  <a href="#%e5%a4%84%e7%90%86reduce%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这里利用我们生成的中间文件名特点，对于每个<code>Reduce</code>任务，它的输入文件（中间文件）名为<code>mr-MapID-ReduceID</code>，所以我们构造出输入文件数组，将其解码得到键值对，再进行处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// generate the intermediate files for reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">generateFileName</span><span class="p">(</span><span class="nx">r</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">NMap</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fileName</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">TaskID</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">TaskID</span> <span class="p">&lt;</span> <span class="nx">NMap</span><span class="p">;</span> <span class="nx">TaskID</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fileName</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-%d-%d&#34;</span><span class="p">,</span> <span class="nx">TaskID</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">fileName</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">HandleReduceTask</span><span class="p">(</span><span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">,</span> <span class="nx">reducef</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// load the intermediate files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">intermediate</span> <span class="p">[]</span><span class="nx">KeyValue</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// get the intermediate file names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">intermediateFiles</span> <span class="o">:=</span> <span class="nf">generateFileName</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">NMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// fmt.Println(intermediateFiles)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intermediateFiles</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot open %v&#34;</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// decode the intermediate file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">dec</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">kv</span> <span class="o">:=</span> <span class="nx">KeyValue</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">kv</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">intermediate</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">,</span> <span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// sort the intermediate key-value pairs by key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span> <span class="p">&lt;</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Key</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// write the key-value pairs to the output file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">oname</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-out-%v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ofile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot create %v&#34;</span><span class="p">,</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">);</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">values</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">values</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// call the reduce function to get the output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">output</span> <span class="o">:=</span> <span class="nf">reducef</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// write the key-value pairs to the output file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">ofile</span><span class="p">,</span> <span class="s">&#34;%v %v\n&#34;</span><span class="p">,</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ofile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// rename the output file to the final output file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">ofile</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// send the task completion message to the coordinator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">MessageSend</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskID</span><span class="p">:</span>              <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskCompletedStatus</span><span class="p">:</span> <span class="nx">ReduceTaskCompleted</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.ReportTask&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">MessageReply</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="测试和常见问题" class="heading-element"><span>4 测试和常见问题</span>
  <a href="#%e6%b5%8b%e8%af%95%e5%92%8c%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><code>test-mr.sh</code>为测试脚本，也可以通过运行<code>sh test-mr-many.sh n</code>来运行$n$次测试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">❯ bash test-mr.sh
</span></span><span class="line"><span class="cl">*** Starting wc <span class="nb">test</span>
</span></span><span class="line"><span class="cl">--- wc test: PASS
</span></span><span class="line"><span class="cl">*** Starting indexer test.
</span></span><span class="line"><span class="cl">--- indexer test: PASS
</span></span><span class="line"><span class="cl">*** Starting map parallelism test.
</span></span><span class="line"><span class="cl">--- map parallelism test: PASS
</span></span><span class="line"><span class="cl">*** Starting reduce parallelism test.
</span></span><span class="line"><span class="cl">--- reduce parallelism test: PASS
</span></span><span class="line"><span class="cl">*** Starting job count test.
</span></span><span class="line"><span class="cl">--- job count test: PASS
</span></span><span class="line"><span class="cl">*** Starting early <span class="nb">exit</span> test.
</span></span><span class="line"><span class="cl">--- early <span class="nb">exit</span> test: PASS
</span></span><span class="line"><span class="cl">*** Starting crash test.
</span></span><span class="line"><span class="cl">--- crash test: PASS
</span></span><span class="line"><span class="cl">*** PASSED ALL TESTS</span></span></code></pre></td></tr></table>
</div>
</div><p>常见的问题如下：</p>
<ol>
<li>
<p>不能通过<code>job-count</code>测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="o">***</span> <span class="nx">Starting</span> <span class="nx">job</span> <span class="nx">count</span> <span class="nx">test</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="o">---</span> <span class="kd">map</span> <span class="nx">jobs</span> <span class="nx">ran</span> <span class="nx">incorrect</span> <span class="nx">number</span> <span class="nx">of</span> <span class="nf">times</span> <span class="p">(</span><span class="mi">10</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">---</span> <span class="nx">job</span> <span class="nx">count</span> <span class="nx">test</span><span class="p">:</span> <span class="nx">FAIL</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为多次处理同一个任务，且任务没有异常。这是因为在分配任务后没有更新任务的状态，例如标记为已分配和记录当前时间戳。</p>
</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】 分布式系统介绍</title><link>https://hezephyr.github.io/posts/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 14 May 2024 14:12:32 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</guid><description><![CDATA[<h2 id="概念" class="heading-element"><span>1 概念</span>
  <a href="#%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当我们谈论分布式系统时，我们指的是一组通过网络连接的计算机，它们协同工作以完成某种共同的任务或目标。</p>
<p>在分布式系统中，通信是通过消息传递进行的。<font color="red">这意味着各个计算节点之间通过发送和接收消息来进行通信，而不是通过共享内存。</font>这种消息传递模型使得分布式系统的设计和实现更为灵活，因为每个节点可以独立地运行，并通过消息传递来进行协作。</p>
<p>尽管消息传递模型具有很多优点，但也需要注意到它引入了一些复杂性。例如，需要考虑消息的传递延迟、顺序和可靠性等问题。因此，在设计分布式系统时，需要仔细考虑如何有效地管理消息传递，以确保系统的正确性和性能。</p>
<blockquote>
<p>TIP：在设计系统或解决问题时，应该始终优先考虑在单台计算机上解决。只有在问题规模超出单台计算机的处理能力，或者需要满足高可用性、容错性等需求时，才需要考虑采用分布式系统。因此，深入了解问题的性质和需求，以及权衡利弊，是设计分布式系统的关键。</p>
</blockquote>
<h2 id="驱动力和挑战" class="heading-element"><span>2 驱动力和挑战</span>
  <a href="#%e9%a9%b1%e5%8a%a8%e5%8a%9b%e5%92%8c%e6%8c%91%e6%88%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当人们构建分布式系统时，驱动力主要包括以下几个方面：</p>
<ol>
<li><strong>追求更高的计算性能</strong>：分布式系统能够利用大量的计算资源，实现并行运算，充分利用多个CPU、大容量内存和磁盘资源。</li>
<li><strong>实现容错性</strong>：即使在其中一台计算机发生故障时，系统仍然能够保持正常运行。</li>
<li><strong>解决空间分布性问题</strong>：某些问题天然具有空间分布性，需要跨越不同地理位置的计算资源和数据进行协同处理。例如，银行跨地域的资金转移需要协调不同地点的数据和操作，这就需要分布式系统来实现数据的同步和协调，以确保交易的准确性和可靠性。</li>
<li><strong>提高安全性</strong>：分布式系统可以通过将系统分散在多个计算机上来提高安全性。不信任的代码或系统可能存在潜在的安全风险，通过在分布式环境中运行代码并采用加密通信等安全措施，可以有效降低风险，并限制错误和攻击的影响范围。</li>
</ol>
<p>分布式系统的挑战源自其驱动力：</p>
<ol>
<li><strong>并发执行和复杂交互</strong>：分布式系统中存在大量并发执行的部分，以及复杂的交互关系。这导致了在并发编程中遇到各种问题，例如同步、异步操作的管理以及处理时间依赖性。</li>
<li><strong>意外故障</strong>：分布式系统由多个组成部分和计算机网络组成，因此容易受到意外故障的影响。与单个计算机不同，这些组件可能在工作或停止状态之间切换，同时还受到网络中断或不稳定性的影响。</li>
<li><strong>性能预期</strong>：分布式系统的设计旨在实现更高的性能，例如利用大量计算资源实现并行处理。但实际评估多台计算机或磁盘臂的性能存在一定挑战，需要仔细的设计和调整以实现预期的性能水平。</li>
</ol>
<h2 id="抽象和实现工具" class="heading-element"><span>3 抽象和实现工具</span>
  <a href="#%e6%8a%bd%e8%b1%a1%e5%92%8c%e5%ae%9e%e7%8e%b0%e5%b7%a5%e5%85%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式系统基础架构主要包括<font color="red">存储、通信（网络）和计算</font>这三种类型。我们的目标是设计简单的接口，使第三方应用程序能够轻松使用这些分布式存储和计算功能，这样才能简单的在这些基础架构之上，构建第三方应用程序。</p>
<p>通过这种抽象接口，我们可以将分布式系统的复杂性隐藏在系统内部，使用户专注于应用程序的开发。举例来说，在存储方面，用户可以将整个系统视为非分布式系统，类似于一个文件系统或者常规的编程模型，而不必担心分布式系统的细节。我们的目标是构建一个接口，使其看起来像一个非分布式存储和计算系统，但实际上却具备了分布式系统的高性能和容错性。</p>
<p>但实际上，很难能找到一个抽象来描述分布式的存储或者计算，使得它们能够像非分布式系统一样有简单易懂的接口。</p>
<p>抽象的实际实现是我们首先要考虑的问题。在构建分布式系统时，人们使用了许多工具：</p>
<ul>
<li><strong>RPC（Remote Procedure Call）</strong>：RPC旨在掩盖在不可靠网络上通信的复杂性，使得远程调用过程更为简单直接。</li>
<li><strong>线程</strong>：线程是一种重要的编程技术，可用于充分利用多核心计算机。它不仅仅是为了提高计算机的利用率，更重要的是提供了结构化的并发操作方式，简化了程序员对并发操作的处理。</li>
<li><strong>分布式文件系统</strong>：分布式文件系统是分布式系统中常用的存储工具之一，它提供了分布式的数据存储和访问接口。通过分布式文件系统，可以实现数据的分布式存储和管理，从而支持大规模数据处理和分布式计算任务的执行。</li>
</ul>
<h2 id="分布式系统特性" class="heading-element"><span>4 分布式系统特性</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%89%b9%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="可扩展性" class="heading-element"><span>4.1 可扩展性</span>
  <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>分布式系统的主要特性是可扩展性（Scalability）。可扩展性指的是，增加计算资源后系统能够以相应的方式提高性能或吞吐量。举例来说，如果一台计算机能够解决一定量的问题，那么增加第二台计算机后，系统能够以更快的速度解决相同数量的问题，或者在相同时间内处理更多的问题。如果由两台计算机组成的系统能够实现两倍的性能或吞吐量，那就达到了可扩展性的标准。</p>
<p>这是一个极为强大的特性，因为只需花钱就可以购买计算机。如果构建的系统能够通过增加计算机数量来提高性能或吞吐量，那将是一个巨大的成就。相比之下，通过雇佣程序员来优化系统或应用更优的算法通常是一种昂贵的方法。我们希望通过增加计算机数量，从十台提升到一千台，来应对一百倍的流量。</p>
<p>例如在构建一个常规网站时，通常会有一个HTTP服务器、一些用户和浏览器以及基于Python或PHP的Web服务器，它们与数据库进行交互。</p>
<p>在初始阶段，一台计算机可以运行Web服务器和数据库，或者将Web服务器和数据库分别部署在两台计算机上。但是，当网站突然迎来数以亿计的用户登录请求时，单一服务器显然无法满足需求。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=small" data-sub-html="<h2>image-20240513103410005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web" alt="image-20240513103410005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=large 2x" data-title="image-20240513103410005" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了应对高流量，第一步是购买更多的Web服务器，并将用户分配到不同的服务器上。这样，不同的用户可以访问不同的Web服务器，但它们需要访问相同的数据，因此所有的Web服务器都需要与后端数据库通信。在这个阶段，通过添加更多的Web服务器来提高代码效率是一个有效的方法，前提是单个服务器不会给数据库带来过大的压力。</p>
<p>然而，可扩展性并非无限的。随着Web服务器数量的增加，数据库很可能成为性能的瓶颈。即使增加更多的Web服务器也无法解决问题。在某个临界点，系统中添加更多计算机将不再有效，而瓶颈将转移到其他地方，比如从Web服务器转移到数据库。</p>
<p>在这种情况下，必须进行一些重构工作。然而，重构一个单一的数据库是困难的，尽管可以将数据库拆分为多个来提高性能，但这需要大量的工作。</p>
<h3 id="可用性" class="heading-element"><span>4.2 可用性</span>
  <a href="#%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在构建系统时，使用单台计算机往往具有较高的可靠性。单台计算机通常可以长时间稳定运行，这是因为计算机和操作系统都很可靠，而且电源也很稳定。然而，如果系统由数千台计算机构成，即使每台计算机都能稳定运行一年，每天也会有多台计算机发生故障。</p>
<p>因此，大型分布式系统面临的一个主要问题是放大一些罕见问题的影响。在这样的系统中，总会有一些机器故障、运行错误、执行缓慢或执行错误任务的情况发生。网络问题也是一个常见的挑战，比如网线踩断或交换机故障。这些小问题在大规模系统中会变成持续不断的问题。</p>
<p>因此，在设计系统时必须考虑系统的容错性，即使发生错误也要能够继续运行。同时，为了简化应用开发人员的工作，需要构建一个基础架构，能够尽可能屏蔽和掩盖错误。</p>
<p>容错有多种概念和表述方式，其中一个重要思想是可用性（Availability）。通过精心设计，系统可以在特定类型的错误发生时继续提供服务，就像没有错误一样。某些系统通过多副本的方式实现可用性。比如，构建一个有两个拷贝的多副本系统，其中一个故障了，另一个仍然可以正常运行。可用性意味着在特定的故障范围内，系统仍能提供服务。</p>
<p>另一种容错特性是自我可恢复性（Recoverability），即在出现问题后系统停止工作，不再响应请求，等待修复，然后恢复正常运行。</p>
<p>可恢复性是一个重要的需求，尽管它比可用性更弱。在故障发生到修复期间，系统将完全停止工作。但修复后，系统应能正确运行，因此可恢复性至关重要。对于可恢复的系统，通常需要采取一些措施，如将最新数据存储在磁盘中，以便在供电恢复后检索。甚至对于具备可用性的系统，在实际应用中，也需要具备可恢复性。</p>
<p>为了实现这些特性，有两个关键工具。</p>
<ul>
<li>一个是非易失存储（Non-volatile storage），如硬盘或闪存，用于存储系统状态的checkpoint或日志。这样，即使出现电源故障，系统也能从存储中读取最新状态，并继续运行。</li>
<li>另一个重要工具是复制（Replication），即通过多副本系统实现容错。管理复制的多副本系统可能会面临同步偏移等问题，这在容错系统中是一个挑战。</li>
</ul>
<h3 id="一致性" class="heading-element"><span>4.3 一致性</span>
  <a href="#%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最后一个很重要的特性是一致性（Consistency）。一致性定义了操作的行为，特别是在分布式系统中。在分布式存储系统中，例如键值（KV）服务，put操作将一个值存储到一个键中，而get操作从键中获取值。在分布式系统中，多个副本可能存在不同版本的数据，因此一致性变得至关重要。</p>
<p>强一致性（Strong Consistency）要求get请求总是返回最近一次完成的put请求写入的值，这确保了数据的完全一致。然而，实现强一致性需要大量的通信和延迟。弱一致性（Weak Consistency）不保证get请求获取到最新的数据，但通常可以提供更高的性能。</p>
<p>因此，为了尽可能减少通信，特别是当副本相距很远时，人们会构建弱一致性系统，只需要更新最近的数据副本，并且只需要从最近的副本获取数据，并允许读取旧数据。当然，为了使弱一致性更具实际意义，人们会定义更多的规则。</p>
<h2 id="mapreduce论文阅读笔记" class="heading-element"><span>5 MapReduce论文阅读笔记</span>
  <a href="#mapreduce%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a href="https://blog.csdn.net/hzf0701/article/details/138770454?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">MapReduce论文阅读笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>【论文阅读笔记】MapReduce: Simplified Data Processing on Large Clusters</title><link>https://hezephyr.github.io/posts/01.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0mapreduce/</link><pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0mapreduce/</guid><description><![CDATA[<h2 id="概念" class="heading-element"><span>1 概念</span>
  <a href="#%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><code>MapReduce</code> 是一种用于在大型集群上进行简化数据处理的编程模型和计算框架。它最初由 Google 公司设计用于解决大规模数据处理问题，后来被广泛应用于各种大数据处理场景。</p>
<p><code>MapReduce</code> 模型的核心思想是将大规模的数据集分解成多个小的数据块，然后分配给集群中的多个计算节点进行并行处理，最终将结果合并成最终的输出。</p>
<h2 id="编程模型" class="heading-element"><span>2 编程模型</span>
  <a href="#%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>MapReduce 编程模型由两个主要阶段组成：map 阶段和 reduce 阶段。</p>
<ul>
<li><strong>map 阶段</strong>：在 map 阶段，输入数据被分割成若干个数据块，并由不同的计算节点进行并行处理。每个计算节点都会执行用户定义的 map 函数，将输入数据转换为键值对的形式，并发出中间结果。</li>
<li><strong>reduce 阶段</strong>：在 reduce 阶段，会将中间结果按照键进行分组，并由不同的计算节点进行并行处理。每个计算节点都会执行用户定义的 reduce 函数，对相同键的数据进行合并和处理，最终生成最终的输出结果。</li>
</ul>
<p>对于用户(MapReduce的使用者)而言：MapReduce是一种抽象化的编程模型，它隐藏了分布式数据处理的细节，仅对外暴露<code>map</code>和<code>reduce</code>的抽象，用户来实现具体的<code>map</code>和<code>reduce</code>功能。MapReduce自身关注的是并行计算、容错、分布式数据、负载均衡等一系列问题，并且保证分布计算的结果和无错误的串形计算的结果一致。</p>
<p>形式化地说，由用户提供的 <code>map</code> 函数和 <code>reduce</code> 函数应有如下类型：
$$
\begin{align*}
\text{map} &amp;\quad (k_1, v_1)\quad\quad\quad\rightarrow\quad\text{list}(k_2, v_2)\
\text{reduce} &amp;\quad (k_2,\text{list}(v_2))\quad\rightarrow\quad\text{list}(v_2)
\end{align*}
$$
其中，输入的 <code>key</code> 和 <code>value</code> 值与输出的 <code>key</code> 和 <code>value</code> 值在类型上推导的域不同。此外，中间结果 <code>key</code> 和 <code>value</code> 值与输出 <code>key</code> 和 <code>value</code> 值在类型上推导的域相同。</p>
<p>例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">map(String key, String value):
</span></span><span class="line"><span class="cl">    // key: document name
</span></span><span class="line"><span class="cl">    // value: document contents
</span></span><span class="line"><span class="cl">    for each word w in value:
</span></span><span class="line"><span class="cl">        EmitIntermediate(w, “1″);
</span></span><span class="line"><span class="cl">reduce(String key, Iterator values):
</span></span><span class="line"><span class="cl">    // key: a word
</span></span><span class="line"><span class="cl">    // values: a list of counts
</span></span><span class="line"><span class="cl">    int result = 0;
</span></span><span class="line"><span class="cl">    for each v in values:
</span></span><span class="line"><span class="cl">        result += ParseInt(v);
</span></span><span class="line"><span class="cl">    Emit(AsString(result));</span></span></code></pre></td></tr></table>
</div>
</div><p><code>map</code> 函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是 1)。<code>reduce</code> 函数把 <code>map</code> 函数产生的每一个特定的词的计数累加起来。</p>
<p>值得注意的是，在实际的实现中 <code>MapReduce</code> 框架使用 <code>Iterator</code> 来代表作为输入的集合，主要是为了避免集合过大，无法被完整地放入到内存中。</p>
<h2 id="实现" class="heading-element"><span>3 实现</span>
  <a href="#%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="mapreduce执行流程" class="heading-element"><span>3.1 MapReduce执行流程</span>
  <a href="#mapreduce%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>下图展示了<code>MapReduce</code>操作的全部流程。当用户调用 <code>MapReduce</code> 函数时，将发生下面的一 系列动作（下面的序号和图中的序号一一对应）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=small" data-sub-html="<h2>image-20240512144947298</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png" alt="image-20240512144947298" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=large 2x" data-title="image-20240512144947298" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li>用户程序首先调用的 <code>MapReduce</code> 库将输入文件分成 $M$ 个数据片度，每个数据片段的大小一般从 $16\text{ MB}$ 到$64\text{ MB}$(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。</li>
<li>这些程序副本中的有一个特殊的程序—<code>master</code>。副本中其它的程序都是 <code>worker</code> 程序，由 <code>master</code> 分配 任务。有 $M$ 个 <code>map</code> 任务和 $R$ 个 <code>reduce</code> 任务将被分配，<code>master</code> 将一个 <code>map</code> 任务或 <code>reduce</code> 任务分配给一个空闲的 <code>worker</code>。</li>
<li>被分配了 <code>map</code> 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出键值对，然后把键值对传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间结果键值对，并缓存在内存中。</li>
<li>缓存中的键值对通过分区函数（可由用户指定，默认为<code>hasy(key) mod R</code>）分成 $R$ 个区域，之后周期性的写入到本地磁盘上。缓存的键值对在本地磁盘上的存储位置将被回传给 <code>master</code>，由 <code>master</code> 负责把这些存储位置再传送给 <code>reduce worker</code>。</li>
<li>当 <code>reduce worker</code> 程序接收到 <code>master</code> 程序发来的数据存储位置信息后，使用 <code>RPC</code> 从 <code>Map worker</code> 所在主机的磁盘上读取这些缓存数据。当 <code>reduce worker</code> 读取了所有的中间数据后，通过对 <code>key</code> 进行排序后使得具有相同 <code>key</code> 值的数据聚合在一起。由于许多不同的 <code>key</code> 值会映射到相同的 <code>reduce</code> 任务上， 因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li>
<li><code>reduce worker</code> 程序遍历排序后的中间数据，对于每一个唯一的中间 <code>key</code> 值，<code>reduce worker</code> 程序将这 个 <code>key</code> 值和它相关的中间结果<code>value</code> 值的集合传递给用户自定义的 <code>reduce</code> 函数。<code>reduce</code> 函数的输出被追加到所属分区的输出文件。</li>
<li>当所有的 <code>map</code> 和 <code>reduce</code> 任务都完成之后，<code>master</code> 唤醒用户程序。在这个时候，在用户程序里的对 <code>MapReduce</code> 调用才返回。</li>
</ol>
<p>在成功完成任务之后，<code>MapReduce</code> 的输出存放在 $R$ 个输出文件中（对应每个 <code>reduce</code> 任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这 $R$ 个输出文件合并成一个文件—他们经常把这些文件作为另外一个 <code>MapReduce</code> 的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。</p>
<h3 id="master数据结构" class="heading-element"><span>3.2 master数据结构</span>
  <a href="#master%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>master</code> 持有一些数据结构，它存储每一个 <code>map</code> 和 <code>reduce</code> 任务的状态（空闲、工作中或完成)，以及 <code>worker</code> 机器(非空闲任务的机器)的标识。</p>
<p><code>master</code> 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从 <code>map</code> 传递到 <code>reduce</code>。因此， 对于每个已经完成的 <code>map</code> 任务，<code>master</code> 存储了 <code>map</code> 任务产生的 $R$ 个中间文件存储区域的大小和位置。当 <code>map</code> 任务完成时，<code>master</code> 接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的 <code>reduce</code> 任务。</p>
<h3 id="容错机制" class="heading-element"><span>3.3 容错机制</span>
  <a href="#%e5%ae%b9%e9%94%99%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="worker故障" class="heading-element"><span>3.3.1 worker故障</span>
  <a href="#worker%e6%95%85%e9%9a%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li>
<p>故障判定</p>
<p><code>master</code> 周期性的 <code>ping</code> 每个 <code>worker</code>。如果在一个约定的时间范围内没有收到 <code>worker</code> 返回的信息，<code>master</code> 将 把这个 <code>worker</code> 标记为失效。</p>
</li>
<li>
<p>故障处理</p>
<ul>
<li>正在运行：正在运行的 <code>map</code> 或 <code>reduce</code> 任务将被重新置为空闲状态，等待重新调度。</li>
<li>已完成：所有由这个故障的<code>worker</code> 完成的 <code>map</code> 任务也会被重设为初始的空闲状态，等待重新调度，因为该 <code>worker</code> 不可用也意味着存储在该 <code>worker</code> 本地磁盘上的中间结果也不可用了；已经完成的 <code>reduce</code> 任务的输出存储在全局文件系统（eg. Google File System）上，因此不需要重新执行。</li>
</ul>
</li>
</ul>
<p>当一个 <code>map</code> 任务首先被 <code>worker A</code> 执行，之后由于 <code>worker A</code> 故障了又被调度到 <code>worker B</code> 执行，这个“重新执行”的动作会被通知给所有执行 <code>reduce</code> 任务的 <code>worker</code>。任何还没有从 <code>worker A</code> 读取数据的 <code>reduce</code> 任务 将从 <code>worker B</code>读取数据。</p>
<h4 id="master故障" class="heading-element"><span>3.3.2 master故障</span>
  <a href="#master%e6%95%85%e9%9a%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>一个简单的解决办法是让 <code>master</code> 周期性的将上面描述的master数据结构的写入磁盘，<font color="red">即检查点（checkpoint）</font>。如果这个 master 任务失败了，可以从最后一个检查点（checkpoint）开始启动另一个 <code>master</code> 进程。</p>
<p>然而，由于只有一个 <code>master</code> 进程，<code>master</code> 失效后再恢复是比较麻烦的，因此现在的实现是如果 <code>master</code> 故障，就中止<code>MapReduce</code> 运算。用户可以检查到这个状态，并且可以根据需要重新执行 <code>MapReduce</code> 操作。</p>
<h4 id="出现故障时的语义" class="heading-element"><span>3.3.3 出现故障时的语义</span>
  <a href="#%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e6%97%b6%e7%9a%84%e8%af%ad%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当用户提供的 <code>map</code> 和 <code>reduce</code> 操作是输入确定性函数（即相同的输入产生相同的输出）时，MapReduce保证任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 这依赖对 <code>map</code> 和 <code>reduce</code> 任务的输出是原子提交的来完成这个特性。</p>
<ul>
<li>每个工作中的任务把它的输出写到私有的临时文件中。</li>
<li>每个 <code>reduce</code> 任务生成一个这样的文件，而每个 <code>map</code> 任务则生成 $R$ 个这样的文件（一 个 <code>reduce</code> 任务对应一个文件）。</li>
<li>当一个 <code>map</code> 任务完成的时，<code>worker</code> 发送一个包含 <code>R</code> 个临时文件名的完成消息给<code>master</code>。如果 <code>master</code> 从一个已经完成的 <code>map</code> 任务再次接收到到一个完成消息，<code>master</code> 将忽略这个消息；否 则，<code>master</code> 将这 $R$ 个文件的名字记录在数据结构里。</li>
<li>当 <code>reduce</code> 任务完成时，<code>reduce worker</code> 进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个 <code>reduce</code> 任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。这就依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 <code>reduce</code>任务产生的数据。</li>
</ul>
<p>使用 MapReduce 模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的 <code>map</code> 和 <code>reduce</code> 操作是确定性的，而且存在这样的一个事实：我们的语义（也可以理解为处理机制）等价于一个顺序的执行的操作。</p>
<p>当 <code>map</code> and/or <code>reduce</code> 操作是不确定性的时候，MapReduce提供虽然较弱但是依然合理的语义。当使用非确定操作的时候， 一个 <code>reduce</code> 任务 $R_1$ 的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个 <code>reduce</code> 任务 $R_2$的输出也许符合一个不同的非确定程序顺序执行产生的 $R_2$ 的输出。</p>
<p>考虑 <code>map</code> 任务 $M$ 和 <code>reduce</code> 任务 $R_1$、$R_2$ 的情况。我们设定 $e(R_i)$是 $R_i$ 已经提交的执行过程（有且仅有一个这样的执行过程）。出现较弱语义是因为 $e(R_1)$可能读取了$M$ 一次执行产生的输出，而 $e(R_2)$可能读取了 $M$ 的另一次执行产生的输出。</p>
<h3 id="存储位置" class="heading-element"><span>3.4 存储位置</span>
  <a href="#%e5%ad%98%e5%82%a8%e4%bd%8d%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">核心思想：尽量把输入数据(由 GFS 管理)存储在集群中机器的本地磁盘上来节省网络带宽。</font></p>
<p>GFS 把每个文件按 64MB 一个 Block 分隔，每个 Block 保存 在多台机器上，环境中就存放了多份拷贝(一般是 3 个拷贝)。MapReduce 的 <code>master</code> 在调度 <code>map</code> 任务时会考虑输入文件的位置信息，尽量将一个 <code>map</code> 任务调度在包含相关输入数据拷贝的机器上执行；</p>
<p>如果上述努力失败 了，<code>master</code> 将尝试在保存有输入数据拷贝的机器附近的机器上执行 <code>map</code> 任务(例如，分配到一个和包含输入数据的机器在一个 switch 里的 worker 机器上执行)。当在一个足够大的 cluster 集群上运行大型 MapReduce 操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。</p>
<h3 id="任务粒度" class="heading-element"><span>3.5 任务粒度</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e7%b2%92%e5%ba%a6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>理想情况下，$M$ 和 $R$ 应当比集群中 <code>worker</code> 的机器数量要多得多。在每台 <code>worker</code> 机器都执行大量的不同任务能够<strong>提高集群的动态的负载均衡能力</strong>，并且能够加快故障恢复的速度：失效机器上执行的大量 <code>map</code> 任务都可以分布到所有其他的 <code>worker</code> 机器上去执行。</p>
<p>但是实际上，在具体实现中对 $M$ 和 $R$ 的取值都有一定的客观限制，因为 <code>master</code> 必须执行 $O(M+R) $次调度，并且在内存中保存 $O(M\times R)$个状态（对影响内存使用的因素还是比较小的：$O(M\times R)$块状态，大概每对 <code>map</code> 任务/<code>reduce</code> 任务 1 个字节就可以了）。</p>
<p>更进一步，$R$ 值通常是由用户指定的，因为每个 <code>reduce</code> 任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的 $M$ 值，<font color="red">以使得每一个独立任务都是处理大约 16M 到 64M 的输入数据</font>（这样， 上面描写的输入数据本地存储优化策略才最有效），另外，我们把 $R$ 值设置为我们想使用的 <code>worker</code> 机器数量的小的倍数。</p>
<p>所以我们通常会用这样的比例来执行 MapReduce：$M=200000$，$R=5000$，使用 $2000$ 台 <code>worker</code> 机器。</p>
<h3 id="备用任务" class="heading-element"><span>3.6 备用任务</span>
  <a href="#%e5%a4%87%e7%94%a8%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>如果集群中有某个 <code>worker</code> 花了特别长的时间来完成最后的几个 <code>map</code> 或 <code>reduce</code> 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 <code>worker</code> 也就成了落后者（Straggler）。</p>
<p>因此，论文提出一个通用的机制来减少“落伍者”出现的情况。当一个 MapReduce 操作接近完成的时候，<code>master</code> 会调度备用（backup）任务进程来执行剩下的、处于处理中状态（in-progress）的任务。<font color="red">无论是最初的执行、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。</font></p>
<h2 id="扩展技巧" class="heading-element"><span>4 扩展技巧</span>
  <a href="#%e6%89%a9%e5%b1%95%e6%8a%80%e5%b7%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="分区函数" class="heading-element"><span>4.1 分区函数</span>
  <a href="#%e5%88%86%e5%8c%ba%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>MapReduce 的使用者通常会指定 <code>reduce</code> 任务和 <code>reduce</code> 任务输出文件的数量（$R$）。我们在中间结果<code>key</code> 上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。</p>
<p>一个缺省的分区函数是使用 <code>hash</code> 方法(比如， <code>hash(key) mod R</code>)进行分区。<code>hash</code> 方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 <code>key</code> 值进行的分区将非常有用。</p>
<p>比如，输出的 <code>key</code> 值是 URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用<code>hash(Hostname(urlkey)) mod R</code>作为分区函数就可以把所有来自同一个主机的 URLs 保存在同一个输出文件中。</p>
<h3 id="顺序保证" class="heading-element"><span>4.2 顺序保证</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e4%bf%9d%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在给定的分区$R$中，MapReduce保证所有中间键值对数据的处理顺序是按照 <code>key</code> 值增量顺序处理的。</p>
<h3 id="combiner函数" class="heading-element"><span>4.3 Combiner函数</span>
  <a href="#combiner%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在某些情况下，<code>map</code> 函数产生的中间 <code>key</code> 值的重复数据会占很大的比重，并且，用户自定义的 <code>reduce</code> 函数满足结合律和交换律。词数统计程序是个很好的例子。由于词频率倾向于一个 zipf 分布，每个 <code>map</code> 任务将产生成千上万个这样的记录。所有的这些记录将通过网络被发送到一个单独的 <code>reduce</code> 任务，然后由这个<code>reduce</code> 任务把所有这些记录累加起来产生一个数字。</p>
<p>MapReduce允许用户指定一个可选的 <code>combiner</code> 函数，<code>combiner</code> 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出 去。 <code>combiner</code> 函数在每台执行 Map 任务的机器上都会被执行一次。一般情况下，<code>combiner</code> 和 <code>reduce</code> 函数是 一样的。<code>combiner</code> 函数和 Reduce 函数之间唯一的区别是 MapReduce 库怎样控制函数的输出。</p>
<p><code>reduce</code> 函数的输出被保存在最终的输出文件里，而 <code>combiner</code> 函数的输出被写到中间文件里，然后被发送给 <code>reduce</code> 任务。 部分的合并中间结果可以显著的提高一些 MapReduce 操作的速度。</p>
<h3 id="输入和输出的类型" class="heading-element"><span>4.4 输入和输出的类型</span>
  <a href="#%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba%e7%9a%84%e7%b1%bb%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>MapReduce库支持几种不同的格式的输入数据。比如文本模式中，<code>key</code>是文件的偏移量，<code>value</code>是该行内容。</p>
<p>程序员可以定义<code>Reader</code>接口来适应不同的输入类型，程序员需要保证必须能把输入数据切分成数据片段，且这些数据片段能够由单独的Map任务来处理就行了。<code>Reader</code>的数据源可能是数据库，可能是文本文件，甚至是内存等。</p>
<p>同样，用户采用类似添加新的输入数据类型的方式增加新的输出类型（定义<code>Writer</code>接口）。</p>
<h3 id="副作用" class="heading-element"><span>4.5 副作用</span>
  <a href="#%e5%89%af%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>程序员在写<code>map</code>和/或<code>reduce</code>操作的时候，可能会因为方便，定义很多额外功能，比如增加辅助的输出文件等。但应当时刻记住，<code>map</code>和<code>reduce</code>操作应当保证原子性和幂等性。</p>
<p>比如，一个任务生成了多个输出文件，但是我们没有原子化多段commit的操作。这就需要程序员自己保证生成多个输出的任务是确定性任务。</p>
<h3 id="跳过损坏的记录" class="heading-element"><span>4.6 跳过损坏的记录</span>
  <a href="#%e8%b7%b3%e8%bf%87%e6%8d%9f%e5%9d%8f%e7%9a%84%e8%ae%b0%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>有时候，用户程序中的 bug 导致 <code>map</code> 或者 <code>reduce</code> 函数在处理某些记录的时候 crash 掉，MapReduce 操作 无法顺利完成。相较于修复无法执行的 Bug，跳过引发 Bug 的记录可能更为明智。因此，我们希望 MapReduce 检测哪些记录导致确定性的crash， 并且跳过这些记录不处理。</p>
<p>MapReduce 如何自动检测这种情况呢？首先，每个<code>worker</code>进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。 在执行 <code>map</code> 或者 <code>reduce</code> 操作之前，MapReduce 库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，信号处理函数将用“最后一口气”通过 UDP 包向 <code>master</code> 发送处理的最后一条记录的序号。当 <code>master</code> 看到在处理某条特定记录不止失败一次时，<code>master</code> 就标志这条记录需要被跳过，并且在下次重新执行相关的<code>map</code> 或者 <code>reduce</code> 任务的时候跳过这条记录。</p>
<h3 id="本地执行" class="heading-element"><span>4.7 本地执行</span>
  <a href="#%e6%9c%ac%e5%9c%b0%e6%89%a7%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>调试 <code>map</code> 和 <code>reduce</code> 函数的 bug 非常困难，因为它们在分布式系统中执行，并且通常跨多台计算机执行，由 <code>master</code> 动态调度。为了简化调试、性能分析和小规模测试，Google开发了本地版本的 MapReduce 库。这个本地版本可以让 MapReduce 操作在单台计算机上顺序执行。用户可以控制操作的执行，并且可以将其限制在特定的 <code>map</code> 任务上。通过设置特殊标志，用户可以在本地执行他们的程序，并且轻松使用本地调试和测试工具（如 <code>gdb</code>）。</p>
<h3 id="状态信息" class="heading-element"><span>4.8 状态信息</span>
  <a href="#%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 <code>master</code> 内部，设有一个内置的 HTTP 服务器，用于展示一系列状态信息页面。这些页面会显示计算进度，例如已完成的任务数量、正在执行的任务数量、输入、中间数据和输出的字节数，以及处理速率等。</p>
<p>这些页面还包含了指向每个任务的<code>stderr</code>和<code>stdout</code>文件的链接。用户可以利用这些数据来预测计算完成所需的时间，以及是否需要增加更多资源。当计算花费的时间超过预期时，这些页面还可以帮助用户找出执行速度缓慢的原因。</p>
<p>另外，顶层状态页面还会显示出现故障的<code>worker</code>及其故障时正在执行的 <code>map</code> 和 <code>reduce</code> 任务。这些信息对于调试用户代码中的 bug 非常有帮助。</p>
<p><strong>很多分布式系统架构都会提供可视化监控界面，这是提升分布式系统的可维护性的重要手段</strong>。</p>
<h3 id="计数器" class="heading-element"><span>4.9 计数器</span>
  <a href="#%e8%ae%a1%e6%95%b0%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>MapReduce 库提供计数器机制，用来统计不同操作发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇 German 文档等等。</p>
<p>要想使用这个特性，用户需要创建Counter对象，然后在<code>map</code>和<code>reduce</code>函数中以正确的方式增加<code>counter</code>。这些计数器的值周期性的从各个单独的<code>worker</code>机器上传递给<code>master</code>（附加在ping的应答包中传递）。<code>master</code> 把执行成功的 <code>map</code> 和 <code>reduce</code> 任务的计数器值进行累计，当 MapReduce 操作完成之后，返回给用户代码。 计数器当前的值也会显示在 <code>master</code> 的状态页面上，这样用户就可以看到当前计算的进度。</p>
<p>当累加这些<code>counter</code>的值时，<code>master</code>会去掉那些重复执行的相同<code>map</code>或者<code>reduce</code>操作的次数，以此避免重复计数（之前提到的备用任务和故障后重新执行任务，这两种情况会导致相同的任务被多次执行）。</p>
<p>有些<code>counter</code>值是由MapReduce库自动维护的，例如已经处理过的输入键值对的数量以及生成的输出键值对的数量等等。</p>
<h2 id="应用场景" class="heading-element"><span>5 应用场景</span>
  <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="论文中提出的应用场景" class="heading-element"><span>5.1 论文中提出的应用场景</span>
  <a href="#%e8%ae%ba%e6%96%87%e4%b8%ad%e6%8f%90%e5%87%ba%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>分布式的 Grep：<code>map</code> 函数输出匹配某个模式的一行，<code>reduce</code> 函数是一个恒等函数，即把中间数据复制到输出。</li>
<li>计算 URL 访问频率：<code>map</code> 函数处理日志中 web 页面请求的记录，然后输出 (URL,1)。<code>reduce</code> 函数把相同 URL 的 value 值都累加起来，产生 (URL, 记录总数）结果。</li>
<li>倒转网络链接图：<code>map</code> 函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。 <code>reduce</code> 函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</li>
<li>每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。<code>map</code> 函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的 URL。<code>reduce</code> 函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。</li>
<li>倒排索引：<code>map</code> 函数分析每个文档输出一个(词,文档号)的列表，<code>reduce</code> 函数的输入是一个给定词的所有 （词，文档号），排序所有的文档号，输出(词,list(文档号))。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</li>
<li>分布式排序：<code>map</code> 函数从每个记录提取 <code>key</code>，输出(key,record)。<code>reduce</code> 函数不改变任何的值。这个运算依赖<strong>分区机制和排序属性</strong>。</li>
<li>重建索引系统：重写了 Google 网络搜索服务所使用的索引系统。这个索引系统的输入数据是网络爬虫抓取回来的大量文档，这些文档数据保存在 GFS 文件系统中，其原始内容超过了 20TB。通过一系列的 MapReduce 操作（大约 5 到 10 次），来建立索引。使用 MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：
<ul>
<li>简化的代码：索引部分的代码变得简单、小巧、易于理解；</li>
<li>灵活性：MapReduce 库的性能已经足够好，因此可以将概念上不相关的计算步骤分开处理，减少数据传递的额外开销；</li>
<li>操作管理的简化：因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由 MapReduce 库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</li>
</ul>
</li>
</ul>
<h3 id="其他应用场景" class="heading-element"><span>5.2 其他应用场景</span>
  <a href="#%e5%85%b6%e4%bb%96%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>数据清洗和预处理：MapReduce 可以用于处理大规模数据集的清洗和预处理，包括数据去重、数据过滤、数据格式转换等操作；</li>
<li>日志分析和异常检测：MapReduce 可以用于分析大规模日志数据，检测异常行为、故障事件和系统性能问题；</li>
<li>图算法和社交网络分析：MapReduce 可以应用于图算法和社交网络分析，包括图的遍历、最短路径计算、社区发现等操作；</li>
<li>文本挖掘和信息抽取：MapReduce 可以用于处理文本数据，进行信息抽取、实体识别、主题建模等自然语言处理任务。</li>
</ul>
<h2 id="faq" class="heading-element"><span>6 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>当你调用emit时，数据会发生什么变化？emit函数在哪运行？</p>
<p>首先看，这些函数在哪运行。这里可以看MapReduce论文的图1。现实中，MapReduce运行在大量的服务器之上，我们称之为worker服务器或者worker。同时，也会有一个Master节点来组织整个计算过程。这里实际发生的是，Master服务器知道有多少输入文件，例如5000个输入文件，之后它将Map函数分发到不同的worker。所以，它会向worker服务器发送一条消息说，请对这个输入文件执行Map函数吧。之后，MapReduce框架中的worker进程会读取文件的内容，调用Map函数并将文件名和文件内容作为参数传给Map函数。worker进程还需要实现emit，这样，每次Map函数调用emit，worker进程就会将数据写入到本地磁盘的文件中。所以，Map函数中调用emit的效果是在worker的本地磁盘上创建文件，这些文件包含了当前worker的Map函数生成的所有的key和value。</p>
<p>所以，Map阶段结束时，我们看到的就是Map函数在worker上生成的一些文件。之后，MapReduce的worker会将这些数据移动到Reduce所需要的位置。对于一个典型的大型运算，Reduce的入参包含了所有Map函数对于特定key的输出。通常来说，每个Map函数都可能生成大量key。所以通常来说，在运行Reduce函数之前。运行在MapReduce的worker服务器上的进程需要与集群中每一个其他服务器交互来询问说，看，我需要对key=a运行Reduce，请看一下你本地磁盘中存储的Map函数的中间输出，找出所有key=a，并通过网络将它们发给我。所以，Reduce worker需要从每一个worker获取特定key的实例。这是通过由Master通知到Reduce worker的一条指令来触发。一旦worker收集完所有的数据，它会调用Reduce函数，Reduce函数运算完了会调用自己的emit，这个emit与Map函数中的emit不一样，它会将输出写入到一个Google使用的共享文件服务中。</p>
<p>有关输入和输出文件的存放位置，这是我之前没有提到的，它们都存放在文件中，但是因为我们想要灵活的在任意的worker上读取任意的数据，这意味着我们需要某种网络文件系统（network file system）来存放输入数据。所以实际上，MapReduce论文谈到了GFS（Google File System）。GFS是一个共享文件服务，并且它也运行在MapReduce的worker集群的物理服务器上。GFS会自动拆分你存储的任何大文件，并且以64MB的块存储在多个服务器之上。所以，如果你有了10TB的网页数据，你只需要将它们写入到GFS，甚至你写入的时候是作为一个大文件写入的，GFS会自动将这个大文件拆分成64MB的块，并将这些块平均的分布在所有的GFS服务器之上，而这是极好的，这正是我们所需要的。如果我们接下来想要对刚刚那10TB的网页数据运行MapReduce Job，数据已经均匀的分割存储在所有的服务器上了。如果我们有1000台服务器，我们会启动1000个Map worker，每个Map worker会读取1/1000输入数据。这些Map worker可以并行的从1000个GFS文件服务器读取数据，并获取巨大的读取吞吐量，也就是1000台服务器能提供的吞吐量。</p>
</blockquote>
<h2 id="参考" class="heading-element"><span>7 参考</span>
  <a href="#%e5%8f%82%e8%80%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf"target="_blank" rel="external nofollow noopener noreferrer">paper:MapReduce<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pdos.csail.mit.edu/6.824/schedule.html"target="_blank" rel="external nofollow noopener noreferrer">MIT 6.824<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/525032069"target="_blank" rel="external nofollow noopener noreferrer">知乎 【分布式】MapReduce论文笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34849261"target="_blank" rel="external nofollow noopener noreferrer">知乎 Google MapReduce 论文详解<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>【论文阅读笔记】The Google File System</title><link>https://hezephyr.github.io/posts/02.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0gfs/</link><pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0gfs/</guid><description><![CDATA[<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Google File System (GFS) 是一个可扩展的分布式文件系统，专为快速增长的Google数据处理需求而设计。这篇论文发表于2003年，此前已在Google内部大规模应用。</p>
<p>GFS不仅追求性能、可伸缩性、可靠性和可用性等传统分布式文件系统的设计目标，还基于对自身应用负载情况和技术环境的深入观察，提出了独特的设计思路，与早期文件系统的假设明显不同。</p>
<h2 id="设计概述" class="heading-element"><span>2 设计概述</span>
  <a href="#%e8%ae%be%e8%ae%a1%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="设计目标" class="heading-element"><span>2.1 设计目标</span>
  <a href="#%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 在设计的时候有一些假想，即预期要实现的目标。</p>
<ol>
<li>系统由许多廉价的普通组件组成，因此<font color="red">组件失效是一种常态</font>。GFS必须能够持续监控自身的状态，将组件失效作为一种常态事件，并能够迅速侦测、冗余和恢复失效的组件。</li>
<li>系统能存储一定数量的大文件。Google预期会存储几百万个文件，这些文件通常大小在100MB以上，数GB大小的文件也是普遍存在的。系统必须能够高效管理这些大文件，同时，系统也必须支持小文件，但不需要针对小文件进行专门优化。</li>
<li>工作负载主要包括两类读操作：
<ul>
<li><strong>大规模流式读取</strong>：单个读操作一般读几百 KB，更常见的是读 1MB 甚至更多。来自同一个客户端的连续操作通常是读取同一个文件中连续的一个区域。</li>
<li><strong>小规模随机读取</strong>：一般是在文件的某个随机位置读几个 KB 数据。注重性能的应用程序通常会将小规模随机读取操作合并并排序，之后按顺序批量读取，避免在文件中前后移动读取位置。</li>
</ul>
</li>
<li>系统的工作负载也会有很多大规模的、顺序的、数据追加方式的写操作。一般这种操作的大小和大规模读类似。一旦写入操作完成，这个文件很少会被修改。小规模的随机写也支持，但是不太高效。</li>
<li><font color="red">系统必须高效的、行为定义明确的实现多客户端并行追加数据到同一个文件里的语意</font>。GFS 中的文件通常用作“生产者—消费者”队列或其他多路文件合并操作。系统中通常有数百个生产者，每个机器上运行一个，这些生产者并发地追加修改一个文件，<font color="red">因此以最小的同步开销来实现原子性是必不可少的</font>。这些文件可能随后被读取，也可能是消费者在追加的操作的同时读取文件。</li>
<li><font color="red">高性能的稳定网络带宽远比低延迟重要</font>。GFS 的大多数目标应用程序都重视以高速率的、大批量的处理数据，而很少有应用程序对单个读或写有严格的响应时间要求。</li>
</ol>
<h3 id="接口" class="heading-element"><span>2.2 接口</span>
  <a href="#%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 提供了一套类似传统文件系统的 API 接口函数，虽然并不是严格按照 POSIX 等标准 API 的形式实现的。<font color="red">文件以分层目录的形式组织，用路径名来标识</font>。GFS 支持常用操作以创建(create)、删除(delete)、打开(open)、关闭(close)、读(read)和写(write)文件。</p>
<p>另外，GFS 提供了快照和记录追加操作。</p>
<ul>
<li><font color="red">快照以很低的成本创建一个文件或者目录树的拷贝</font>。</li>
<li><font color="red">记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的</font>。这对于实现多路结果合并、“生产者-消费者”队列非常有用，多个客户端可以同时追加写入，而不需要额外的同步锁。Google 发现在构建大型分布式应用时，这些类型的文件是非常有用的。</li>
</ul>
<h3 id="架构" class="heading-element"><span>2.3 架构</span>
  <a href="#%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 GFS 集群包含一个单独的master节点和多个chunk服务器，允许多个客户端访问，如下图所示。</p>
<p>所有这些机器通常是普通的 Linux 机器，运行用户级别的服务进程。可以将 chunkserver和客户端部署在同一台机器上，前提是机器资源允许，并能接受稳定性降低的风险。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=small" data-sub-html="<h2>image-20240522203712282</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS" alt="image-20240522203712282" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=large 2x" data-title="image-20240522203712282" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>其中GFS存储的文件都被分割成固定大小的chunk。在chunk 创建的时候，master会给每个 chunk 分 配一个不变的、全局唯一的 64 位的 chunk 句柄来标识。chunkserver把 chunk 以 Linux 文件的形式保存在本地硬盘上，并且根据指定的 chunk 句柄和字节范围来读写块数据。出于可靠性的考虑，每个chunk都会复制到多个chunk服务器上。默认使用3 个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>
<p>master节点管理所有的文件系统元数据。这些元数据包括命名空间、访问控制信息、文件和chunk 的映射信息、以及chunk当前的位置信息。Master 节点还管理着系统范围内的活动，比如，chunk 租用管理、孤儿 chunk的回收、以及 chunk 在 chunkserver之间的迁移。master 节点使用心跳信息周期地和每个 chunkserver通讯，发送指令到各个 chunkserver并接收 chunkserver的状态信息。</p>
<p>链接到每个应用程序的 GFS 客户端代码中实现了文件系统 API，这个 GFS 客户端代表应用程序与 master 和 chunk服务器通信以读写数据。<font color="red">客户端与 master 交互只进行元数据操作，所有的数据操作都是由客户端直接和 chunkserver进行交互的</font>。GFS 没有提供 POSIX标准的API，因此不需要深入到 Linux 的 vnode 层。</p>
<p>客户端和 chunk服务器都不缓存文件数据。</p>
<ul>
<li>客户端缓存文件数据几乎没什么好处，因为大多数应用程序通过巨大的文件进行流式传输，或者工作集太大而无法缓存。不缓存文件数据使得客户端代码和总体系统的代码得以简化，因为无需编写代码解决缓存一致性的问题（不过客户端是缓存元数据的）。</li>
<li>chunk服务器不需要缓存文件数据是因为 chunk 以本地文件的方式保存，Linux 操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</li>
</ul>
<h3 id="单个master" class="heading-element"><span>2.4 单个Master</span>
  <a href="#%e5%8d%95%e4%b8%aamaster" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>单一的 Master 节点策略大大简化了系统设计。单一的 Master 节点能够通过全局信息精确定位 chunk 的位置，并做出复制决策。<font color="red">不过必须最小化在读写中 master 的调用次数，防止 master 成为 GFS 系统的性能瓶颈</font>。客户端永远不通过 Master 节点直接读写文件数据，而是向 master 节点请求应联系的 chunkserver，并将这些元数据缓存一段时间，后续操作直接与 chunkserver进行。</p>
<p>以上图GFS架构为例，在一次简单读取操作中：</p>
<ol>
<li>客户端将文件名和字节偏移量转换成文件的 chunk索引（<code>chunk_index = offset / chunk_size</code>），并将文件名和 chunk 索引发送给 master 节点。</li>
<li>master 节点返回相应的 chunk 句柄和副本的位置信息，客户端将这些信息缓存。</li>
<li>客户端将请求发送给一个副本，通常选择最近的副本，请求包含 chunk 句柄和字节范围。在后续对该 chunk 的读取操作中，客户端无需再次与 master 节点通讯，除非缓存的元数据信息过期或文件被重新打开。</li>
</ol>
<p>客户端通常会在一次请求中查询多个 chunk 信息，master 节点的回复可能包含后续 chunk 的信息，<strong>这些额外信息在避免未来多次通讯的同时，不增加额外代价</strong>。这种设计保证了系统的高效性，减少了 master 节点的负担，提高了整体性能。</p>
<h3 id="chunk大小" class="heading-element"><span>2.5 chunk大小</span>
  <a href="#chunk%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>chunk 的大小是 GFS 的关键设计参数之一，GFS 选择了 64MB 的 chunk 大小，这远大于一般文件系统的 block 大小。<font color="red">每个 chunk 的副本都以普通 Linux 文件的形式保存在 chunkserver上，并且只有在需要时才扩大，采用惰性空间分配策略避免了内部碎片造成的空间浪费。</font></p>
<p>将 chunk 设置为 64MB 这么大，有以下几个有点：</p>
<ol>
<li>它减少了客户端和 master 节点之间的通信需求。因为一次与 master 节点通信即可获取 chunk 的位置信息，之后可以对同一个 chunk 进行多次读写操作。</li>
<li>较大的 chunk大小使客户端能够对同一个 chunk 进行多次操作，通过与 chunkserver保持较长时间的 TCP 连接来减少网络负载。</li>
<li>较大的 chunk大小减少了 master 节点需要保存的元数据数量，允许将所有元数据放在内存中，从而提高访问速度。</li>
</ol>
<p>然而，较大的 chunk 大小也有缺点。小文件包含的 chunk 较少，甚至只有一个 chunk。当多个客户端频繁访问同一个小文件时，存储这些 chunk 的服务器容易成为热点。在实际应用中，这种情况较少发生，因为程序通常是连续读取包含多个 chunk 的大文件。</p>
<p>但将GFS应用于批处理队列系统中，热点问题曾经出现过：一个可执行文件保存在一个单一 chunk 中，当数百台机器同时启动这个文件时，存储这个 chunk 的服务器因并发请求导致系统局部过载。为解决这个问题，<font color="red">GFS通过增加可执行文件的复制参数和错开程序启动时间来缓解。</font>此外，一个长效解决方案是<strong>允许客户端在这种情况下从其他客户端读取数据</strong>。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=small" data-sub-html="<h2>image-20240527103425005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png" alt="image-20240527103425005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=large 2x" data-title="image-20240527103425005" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="元数据" class="heading-element"><span>2.6 元数据</span>
  <a href="#%e5%85%83%e6%95%b0%e6%8d%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>master 中主要存储三种类型的元数据：</p>
<ol>
<li>文件和 chunk 的命名空间；</li>
<li>文件和 chunk 的映射；</li>
<li>每个 chunk 的副本的位置。</li>
</ol>
<p><font color="red">所有的元数据都存储在 master 的内存里</font>。前两种类型也会通过在操作日志(operation log)上记录修改来持久化，操作日志文件存储在 master 的本地磁盘上，同时日志会被复制到其它的远程master服务器上。使用日志使得我们能够简单可靠的更新 master 的状态，，而不用担心 master 崩溃导致的不一致性的风险。master 不会持久的存储 chunk 位置信息，<font color="red">而是会在 master 启动时或一个 chunkserver加入集群时向 chunkserver轮询其 chunk 信息</font>。</p>
<h4 id="内存中的数据结构" class="heading-element"><span>2.6.1 内存中的数据结构</span>
  <a href="#%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>GFS 的设计<font color="red">将所有元数据保存在内存中</font>，使 master 的操作速度非常快。这种设计允许 master 在后台简单而高效地周期性扫描所有状态信息，实现如 chunk 垃圾收集、在 chunkserver失效的时重新复制数据、通过 chunk 的迁移实现跨 chunkserver的负载均衡以及磁盘使用状况统计等功能。</p>
<p>虽然将元数据保存在内存中会使 chunk 的数量和系统的承载能力受限于 master 的内存大小，但在实际应用中，这并不是严重问题。具体而言，master 管理每个 64MB 的 chunk 只需不到 64字节的元数据。由于大多数文件包含多个 chunk，绝大多数chunk 都是满的，只有最后一个 chunk 可能部分填充。同样，每个文件在命名空间中的数据大小通常在 64 字节以下，因为文件名经过前缀压缩。</p>
<p>即便需要支持更大的文件系统，增加 master 的内存成本也相对较低。通过增加少量内存，可以使元数据全部保存在内存中，从而增强系统的简洁性、可靠性、高性能和灵活性。</p>
<h4 id="chunk位置信息" class="heading-element"><span>2.6.2 chunk位置信息</span>
  <a href="#chunk%e4%bd%8d%e7%bd%ae%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">master 不持久化存储哪个 chunkserver包含指定 chunk 副本的信息，master 只是在启动时会轮询 chunkserver以获取这些信息，并通过控制 chunk 位置分配和定期的心跳信息监控chunk服务器状态保持最新。</font></p>
<p>Google起初尝试将 chunk 位置信息持久化保存在 master 上，但发现启动时轮询 chunkserver并定期更新更为简便。这种设计简化了在 chunkserver加入、离开、更名、故障和重启时的数据同步问题，适应了大规模集群中频繁发生的事件。</p>
<p>这个设计的另一个理解思路：只有 chunkserver才能最终确定一个 chunk 是否在其硬盘上。在 master 上维护全局视图是不现实的，因为 chunkserver的错误可能导致 chunk 自动消失，或者操作人员可能重命名 chunkserver。这种方法确保了系统的简洁性和可靠性。</p>
<h4 id="操作日志" class="heading-element"><span>2.6.3 操作日志</span>
  <a href="#%e6%93%8d%e4%bd%9c%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">操作日志包含关键的元数据变更历史记录，是元数据唯一的持久化存储和判断同步操作顺序的逻辑时间基线。</font>每个文件和 chunk，还有它们的版本， 都由它们创建的逻辑时间唯一的、永久的标识。</p>
<p>日志文件必须确保完整性。<font color="red">只有在元数据变更被持久化后，日志才对客户端可见，以防止丢失文件系统或最近的客户端操作。</font>为此，日志会被复制到多台远程机器，只有在本地和远程机器都写入日志后，master 才响应客户端请求。master 会收集多个日志记录后批量处理，以减少写入和复制对系统性能的影响。</p>
<p>在灾难恢复时，master 通过重演操作日志恢复文件系统。为了缩短启动时间，日志必须足够小。当日志增长到一定量时，master 会进行 checkpoint，将所有状态数据写入 checkpoint 文件。<font color="red">恢复时，master读取 Checkpoint 文件并重演之后的日志文件即可</font>。Checkpoint 文件以压缩 B-树形式存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析，提高了恢复速度和系统可用性。</p>
<p>创建 Checkpoint 文件时，master 确保不会阻塞正在进行的操作，通过独立线程切换到新的日志文件和创建新的 Checkpoint 文件。生成一个 Checkpoint 文件大约需要一分钟，完成后Checkpoint会被写入本地和远程硬盘。</p>
<p><font color="red">master 恢复仅需最新的 Checkpoint 文件和后续日志文件</font>。虽然旧的 Checkpoint 文件和日志文件可以删除，但通常会保留一些历史文件以应对灾难性故障。Checkpoint 失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的 Checkpoint 文件（<font color="red">使用前一个完整的 Checkpoint 文件和之后的操作日志来恢复系统</font>）。</p>
<h3 id="一致性模型" class="heading-element"><span>2.7 一致性模型</span>
  <a href="#%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 有一个宽松的一致性模型，很好地支持我们的高度分布式应用程序，但是实现起来依然简单且高效。</p>
<p>我们现在讨论 GFS 如何保证一致性，以及这对应用程序来说有何意义。我们也会强调 GFS 如何维护这些保证，但是更详细的内容将在本文的其他部分来说。</p>
<h4 id="gfs一致性保障机制" class="heading-element"><span>2.7.1 GFS一致性保障机制</span>
  <a href="#gfs%e4%b8%80%e8%87%b4%e6%80%a7%e4%bf%9d%e9%9a%9c%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>文件命名空间的修改（例如，文件创建）是原子性的，且仅由 master 控制。命名空间锁保证了操作的原子性和正确性（详见4.1），而操作日志定义了这些操作的全局顺序（详见2.6.3）。</p>
<p>数据修改后的文件区域状态取决于操作类型、成功与否以及是否同步修改。下表总结了各种操作的结果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=small" data-sub-html="<h2>image-20240523094914274</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png" alt="image-20240523094914274" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=large 2x" data-title="image-20240523094914274" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ul>
<li>如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件区域是<em>consistent</em>；</li>
<li>如果对文件的数据修改之后，文件区域是一致的，并且客户端能够看到写入操作全部的内容，那么这个 region 是<em>defined</em>。</li>
</ul>
<p>其中，对于一个文件区域，只要所有客户端看到的数据都是一样的，那这个区域就是 <em>consistent</em> 的。在 <em>consistent</em> 的前提下，如果所有修改都已经被写入，就是 <em>defined</em> 的。<em>consistent</em> 是 <em>defined</em> 的子集。即 <em>defined</em> 的一定是 <em>consistent</em> 的，但 <em>consistent</em> 的不一定是 <em>defined</em> 的。</p>
<p>当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰（即串行修改），那么受影响的区域就是 <em>defined</em>（隐含了 <em>consistent</em> ）：所有的客户端都可以看到写入的内容。</p>
<p>当多个并行修改操作成功完成后，文件区域处于<em>consistent</em>但<em>undefined</em>的状态：即所有的客户端看到的数据是一样的，但这并不意味着每个修改都已经被写入。一般来说，写入的内容由多个修改的混合片段组成。</p>
<p>失败的修改操作导致文件区域<em>inconsistent</em> (因此也是 <em>undefined</em> )：不同客户端在不同时间看到的数据不同。后面我们将描述应用如何区分 <em>defined</em> 和 <em>undefined</em> 的区域。应用程序没有必要再去细分 <em>undefined</em> 区域的不同类型。</p>
<p>数据修改操作分为写入或者记录追加两种：</p>
<ul>
<li><strong>写入操作</strong>：数据写在应用程序指定的文件偏移位置上。</li>
<li><strong>记录追加操作</strong>：数据（记录）原子性追加到文件中至少一次（即使是并发修改），但偏移位置由 GFS 选择（3.3）。</li>
</ul>
<p>作为对比，一个普通的追加操作仅仅是一个在客户端认为是当前文件末尾的偏移处的写入操作。GFS 返回给客户端一个偏移量，表示包含写入记录的 <em>defined</em> 区域的起点。另外，GFS 可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件区域被认定是 <em>inconsistent</em>（即上表 中的 <em>defined</em> interspersed with <em>inconsistent</em>，即 <em>defined</em> 区域中穿插了 <em>inconsistent</em> 区域，但这些区域不会影响读取数据的结果，因为会被过滤掉）， 这些数据通常比用户数据小的多。</p>
<p>经过一系列成功的修改操作后，GFS 确保被修改的文件区域是<em>defined</em>的，并包含最后一次修改操作写入的数据。GFS 通过以下措施确保这一点：</p>
<ol>
<li><strong>对chunk的所有副本的修改操作顺序一致</strong>。</li>
<li><strong>使用 chunk 版本号检测副本</strong>是否因其所在的 chunkserver宕机而错过了修改操作导致失效。失效的副本不再进行修改操作，master 也不会返回该副本的位置信息给客户端，失效副本会被垃圾收集系统尽快回收。</li>
</ol>
<p>由于 chunk 位置信息会被客户端缓存，在信息刷新前，客户端可能从失效的副本读取数据。只有当缓存条目超时，或文件被重新打开时，这个问题才能解决，因为条目超时或重新打开文件会清除客户端缓存中的所有跟这个文件有关的 chunk 信息。此外，大多数文件只进行追加操作，因此失效副本通常返回一个提前结束的 chunk 而不是过期的数据（也就是说，数据还是有效的数据，只是返回的偏移位置不对）。当 Reader 程序 重新尝试联络 master 时，会立刻得到最新的 chunk 位置信息。</p>
<p>即使修改操作成功执行后很长时间，组件故障仍可能损坏或删除数据。GFS 通过 master 和所有 chunkserver的定期“握手”找到失效的 chunkserver，并使用<strong>校验和检测数据是否损坏</strong>。一旦发现问题，数据将尽快利用有效副本进行恢复。只有当一个 chunk 的所有副本在 GFS 检测到错误并采取应对措施之前全部丢失，chunk 才会不可逆转地丢失。通常，GFS 的反应时间（master 节点检测到错误并采取应对措施）为几分钟。即便如此，chunk 也只是不可用而非损坏，应用程序会收到明确的错误信息而非损坏的数据。</p>
<h4 id="对应用程序的影响" class="heading-element"><span>2.7.2 对应用程序的影响</span>
  <a href="#%e5%af%b9%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%bd%b1%e5%93%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>使用 GFS 的应用程序可以利用一些简单的技术来实现宽松的一致性模型，也可以实现其他目标功能，包括<font color="red">尽量采用追加写入而不是覆盖、Checkpoint、写入自验证和自识别的记录</font>。</p>
<p>在实际应用中，我们所有的应用程序对文件的写入操作都尽量采用追加方式而不是覆盖方式。例如，应用程序从头到尾写入数据生成一个文件，写入完成后自动将文件改名为一个永久文件名，或者定期进行 Checkpoint，记录成功写入的数据量。Checkpoint 文件可以包含程序级别的校验和。<font color="red">Readers 仅校验并处理上个 Checkpoint 之后的文件区域，这些区域的状态是<em>defined</em>的</font>。这种方法满足了我们的一致性和并发处理需求。追加写入比随机写入更加高效，对应用程序的失败处理更具弹性。Checkpoint 允许 Writer 以渐进方式重新开始，并防止 Reader 处理已成功写入但从应用程序的角度来看未完成的数据。</p>
<p>另一个典型的应用场景是，许多应用程序并行追加数据到同一个文件，例如进行结果合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”特性保证了 Writer 的输出。Readers 可以通过以下方法处理偶然性的填充数据和重复内容：Writers 在每条写入记录中包含额外信息，例如 Checksum，用来验证有效性。Reader 可以利用 Checksum 识别并丢弃额外的填充数据和记录片段。如果应用不能容忍偶尔的重复内容，可以使用记录的唯一标识符来过滤重复数据，这些唯一标识符通常用于命名程序中处理的实体对象，如 web 文档。这些记录 I/O 功能都包含在我们共享的程序库中，并适用于 Google 内部的其他文件接口实现。这样，相同序列的记录，加上偶尔出现的重复数据，都能正确分发给 Reader。</p>
<h2 id="系统交互" class="heading-element"><span>3 系统交互</span>
  <a href="#%e7%b3%bb%e7%bb%9f%e4%ba%a4%e4%ba%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">Google 设计 GFS 系统一个重要的原则是最小化所有操作和 master 的交互（因为 master 只有一个，必须减轻 master 的压力）</font>。在这个背景下，我们现在来说客户端、master 和 chunk服务器如何互动以实现数据修改、原子记录追加(append)，以及快照(snapshot)。</p>
<h3 id="租约lease和变更顺序" class="heading-element"><span>3.1 租约（lease）和变更顺序</span>
  <a href="#%e7%a7%9f%e7%ba%a6lease%e5%92%8c%e5%8f%98%e6%9b%b4%e9%a1%ba%e5%ba%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>变更是一个会改变 chunk 内容或者元数据的操作（如写入或记录追加），会在 chunk 的所有副本上执行。为了保持多个副本间变更顺序的一致性，GFS 采用了租约（lease）机制。master 节点为 chunk 的一个副本（主 chunk）建立租约，初始租期为 60 秒。主 chunk 对所有更改操作进行序列化，所有副本遵从这个序列进行修改。因此，修改操作全局的顺序首先由 master 选择的租约的顺序决定，然后由租约中主 chunk 分配的序列号决定。</p>
<p>只要 chunk 被修改了，主 chunk 就可以申请更长的租期，通常会得到 master 的确认并收到租约延长的时间。 这些租约延长请求和批准的信息通常都是附加在 master 和 chunkserver之间的心跳消息中来传递。有时 master 会试图提前取消租约（例如，master 想取消在一个已经被改名的文件上的修改操作）。<font color="red">即使 master 和主chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个chunk副本签订新的租约</font>。</p>
<p>在下图中，我们通过列出 写入操作的控制流描述了这个过程，并且用数字标记了步骤顺序。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=small" data-sub-html="<h2>image-20240525151330305</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png" alt="image-20240525151330305" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=large 2x" data-title="image-20240525151330305" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li>客户端向master询问哪个chunk服务器持有当前的租约，以及其他副本的位置。如果没有一个chunk服务器持有租约，master则会选择其中一个副本建立一个租约（图中没有显示此步骤）；</li>
<li>master将主chunk的标识符以及其他副本（又称二级副本）的位置返回给客户端。客户端缓存这些数据以便后续的操作。<font color="red">只有在主 chunk 不可用，或者主 chunk 回复信息表明它已不再持有租约的时候，客户端才需要重新跟 master 联系</font>。</li>
<li>客户端把数据 push 给所有的副本，客户端可以以任意的顺序 push。chunkserver接收到数据并保存在它的内部 LRU 缓存中，一直到数据被使用或者过期交换出去。通过将数据流与控制流解耦，我们可以基于网络拓扑情况调度昂贵的数据流来提高性能，而不管哪个 chunk服务器是主 chunk。</li>
<li>当所有的副本都确认接收到了数据，客户端发送写请求到主chunk服务器。这个请求标识了之前推送到所有副本的数据。主 chunk 为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户端，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中。</li>
<li>主chunk把写请求传递到所有的二级副本。每个二级副本依照主chunk分配的序列号以相同的顺序执行这些操作。</li>
<li>所有完成了操作的二级副本向主chunk 回复，表明它们已经完成了操作。</li>
<li>主 chunk 回复客户端。任何副本产生的任何错误都会返回给客户端。在出现错误的情况下，写入操作可能在主chunk和一些二级副本执行成功（因为是主chunk 先成功完成修改后，才会让二级副本开始应用修改，如果主 chunk 失败了，二级副本就不会收到序列号以及应用更改的命令）。客户端的请求被确认为失败，被修改的区域处于<em>inconsistent</em>的状态。我们的客户端代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户端会先从步骤（3）到步骤（7） 做几次尝试。（Q：已经完成操作或部分完成操作的副本，接收到重试的数据后，如何处理？A：直接在文件末尾（最后一个 chunk 末尾）继续写入，之前成功的二级副本会重复写入，去重任务由读取数据的客户端来完成。）</li>
</ol>
<p>如果应用程序一次写入的数据量很大，或者数据跨越了多个 chunk，GFS 客户端代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户端上同时进行的操作打断或者覆盖。 因此，共享的文件区域的尾部可能包含来自不同客户端的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，chunk 的所有副本都是一致的。这使文件 region 处于 2.7 节描述 的<em>consistent</em>但是<em>undefined</em>的状态。</p>
<h3 id="数据流" class="heading-element"><span>3.2 数据流</span>
  <a href="#%e6%95%b0%e6%8d%ae%e6%b5%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了提高网络效率，GFS采取了将数据流和控制流分开的措施。在控制流从客户端到主 chunk再到所有二级副本的同时，数据以管道方式顺序沿着精心选择的 chunkserver链推送，充分利用每台机器的带宽，避免网络瓶颈和高延时连接，最小化数据推送延时。</p>
<p>数据顺序沿着一个 chunkserver链推送，而不是分散推送（如树型拓扑结构），以充分利用每台机器的出口带宽，实现最快速度的传输，而不分散带宽。为避免网络瓶颈和高延迟连接，<font color="red">每台机器尽量选择网络拓扑中离自己最近且尚未接收到数据的机器作为目标推送数据</font>。例如，客户端将数据推送到最近的 chunkserver S1，S1 推送到 S2，以此类推，<strong>基于 IP 地址计算节点距离</strong>。</p>
<p>利用基于 TCP 连接的管道式数据推送方式最小化延迟。chunkserver接收到数据后立即向前推送，利用全双工交换网络的优势，传输不会减慢接收速度。在无网络拥塞情况下，传送 $B$ 字节的数据到 $R$ 个副本的理想时间为 $\frac{B}{T} + RL$（$T$ 是网络吞吐量，$L$ 是传输延迟）。通常，我们的网络连接速度是 100Mbps，传输 1MB 数据的理想时间约为 80ms。</p>
<h3 id="原子的记录追加" class="heading-element"><span>3.3 原子的记录追加</span>
  <a href="#%e5%8e%9f%e5%ad%90%e7%9a%84%e8%ae%b0%e5%bd%95%e8%bf%bd%e5%8a%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 提供了一种原子的记录追加操作，客户端只需指定要写入的数据，GFS 保证至少一次原子写入成功执行（即写入一个顺序的byte流），写入数据追加到 GFS 指定的偏移位置，并返回该偏移量给客户端。类似于 Unix 的 <code>O_APPEND</code> 模式，多个并发写操作无竞态条件。</p>
<p>记录追加在分布式应用中频繁使用，特别是在多个客户端并行追加数据的情况下。<font color="red">传统写入需要复杂的同步机制，如分布式锁管理器，而记录追加简化了这种需求，常用于生产者/消费者队列系统或数据合并文件</font>。</p>
<p>记录追加遵循 3.1 节描述的控制流程，主 chunk 有额外控制逻辑。客户端将数据推送到最后一个 chunk 的所有副本，然后发送请求给主 chunk。主 chunk 检查是否超出最大大小（64MB），如果超出，则填充到最大大小并通知二级副本做同样的操作，然后回复客户端要求其对下一个chunk重新进行记录追加。通常情况下，主 chunk 追加数据并通知二级副本写入相同位置，最后回复客户端操作成功。</p>
<p>如果记录追加在任何副本上失败，客户端需要重新操作，可能导致同一个chunk的不同副本包含不同数据。GFS 只保证数据整体原子性写入至少一次，而不保证字节级别一致。成功执行操作的数据区域是<em>defined</em>的（且<em>consistent</em>的），否则是<em>inconsistent</em>的（且<em>undefined</em>义的）。程序可以处理这些<em>inconsistent</em>区域。</p>
<h3 id="快照" class="heading-element"><span>3.4 快照</span>
  <a href="#%e5%bf%ab%e7%85%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>快照操作在 GFS 中几乎瞬间完成，且不干扰其他操作。用户可以用快照快速创建数据集的分支拷贝或在实验前备份当前状态，方便之后提交或回滚。</p>
<p>就像AFS（Andrew File System，一种分布式文件系统），GFS 使用标准的“写时复制”（copy-on-write）技术实现快照。当 master 收到快照请求时，它会取消作快照的文件的所有 chunk 的租约，确保后续写操作必须与 master 交互，使 master 有机会先创建 chunk 的新拷贝。</p>
<p>租约取消或过期后，master 将操作记录到硬盘日志，并通过复制源文件或目录的元数据将变化反映到内存中。新创建的快照文件与源文件共享相同的 chunk 地址。</p>
<p>快照操作后，当客户端首次写入 chunk <code>C</code> 时，会先请求 master 查询当前租约持有者。master 发现 chunk C 的引用计数超过 1（<font color="red">写时复制方法创建快照时是给这个chunk加一个引用计数，没有立刻真的拷贝，一个 chunk 的引用计数大于 1 的话就代表这个 chunk 是某个快照的一部分，要保留原样数据的。当这个 chunk 上有新的写入的时候，这个 chunk 才会真的被复制，客户端在新复制的 chunk 上写入，而原来的旧 chunk 被快照继续引用</font>），不立即回复客户端，而是选择新的 chunk 句柄 <code>C'</code>，<strong>并要求所有持有 chunk C 副本的服务器创建 <code>C'</code></strong>。通过在本地创建新的 chunk 避免了网络复制，提高了效率。master 确保新 chunk <code>C'</code>的一个副本拥有租约后回复客户机，客户机即可正常写入该 chunk。</p>
<h2 id="master操作" class="heading-element"><span>4 Master操作</span>
  <a href="#master%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>master 执行所有的命名空间操作。此外，它还管理着整个系统里所有 Chunk 的副本：</p>
<ol>
<li>master 决定 chunk 副本的存储位置；</li>
<li>创建新的 chunk 和它的副本；</li>
<li>协调各种各样的系统范围内的活动以保证 chunk 被完全拷贝；</li>
<li>在所有的 chunkserver上做负载均衡；</li>
<li>回收不再使用的存储空间。</li>
</ol>
<p>下面我们深入讨论下上述的几点。</p>
<h3 id="命名空间管理和锁" class="heading-element"><span>4.1 命名空间管理和锁</span>
  <a href="#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86%e5%92%8c%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 GFS 中，master 节点的操作可能耗时较长，例如快照操作需取消所有相关 chunk 的租约。为避免延缓其他操作，GFS 允许多个操作同时进行，并通过命名空间的区域锁保证顺序正确。</p>
<p><font color="red">GFS 命名空间是一个全路径与元数据映射的查找表，采用前缀压缩高效存储在内存中</font>。不同于传统文件系统，GFS 不支持列出目录下所有文件的结构，也不支持文件或目录的链接。<font color="red">每个节点（绝对路径的文件名或目录名）有一个关联的读写锁</font>。</p>
<p>每个 master 操作开始前都要获得相关锁。通常，涉及路径<code>/d1/d2/.../dn/leaf</code> 的操作需要获得<code>/d1</code>，<code>/d1/d2</code>，&hellip;，<code>/d1/d2/.../dn</code> 的读锁，以及<code>/d1/d2/.../dn/leaf</code> 的读写锁。根据操作不同，<code>leaf</code> 可以是文件或目录。例如，在<code>/home/user</code> 快照到<code>/save/user</code> 时，锁机制防止创建文件<code>/home/user/foo</code>。快照操作获得<code>/home</code> 和<code>/save</code> 的读锁及<code>/home/user</code> 和<code>/save/user</code> 的写锁；文件创建操作获得<code>/home</code> 和<code>/home/user</code> 的读锁及<code>/home/user/foo</code> 的写锁。由于<code>/home/user</code> 锁冲突，这两个操作顺序执行。文件创建操作不需要获取父目录的写入锁，因为这里没有“目录”，或者类似 inode 等用来 禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p>
<p><font color="red">这种锁方案支持对同一目录的并行操作</font>。例如，可在同一目录下同时创建多个文件：每个操作获取目录名的读锁和文件名的写锁。<font color="red">目录名的读锁防止目录被删除、改名或快照；文件名的写锁序列化文件创建操作，确保不会多次创建同名文件。</font></p>
<p>由于命名空间节点众多，读写锁采用惰性分配策略，不再使用时立刻删除。锁的获取依据全局一致的顺序避免死锁：首先按命名空间层次排序，在同一层次内按字典顺序排序。</p>
<h3 id="副本放置" class="heading-element"><span>4.2 副本放置</span>
  <a href="#%e5%89%af%e6%9c%ac%e6%94%be%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 集群采用高度分布的多层布局结构，典型拓扑包括数百个 chunkserver分布在多个机架上，由来自同一或不同机架的数百个客户机访问。<font color="red">通信可能跨越一个或多个网络交换机，且机架出入带宽可能较小</font>。多层分布架构带来数据灵活性、可靠性和可用性挑战。</p>
<p>chunk 副本位置选择旨在最大化数据可靠性和可用性，以及网络带宽利用率。仅在多台机器上存储副本不足以达到目标，需在多个机架间分布储存 chunk 的副本。这保证即使整个机架故障或掉线，某些副本仍可用，且网络流量尤其读操作可利用多个机架的带宽。尽管写操作需与多个机架设备通信，但这是值得的。</p>
<h3 id="创建重新复制重新平衡" class="heading-element"><span>4.3 创建、重新复制、重新平衡</span>
  <a href="#%e5%88%9b%e5%bb%ba%e9%87%8d%e6%96%b0%e5%a4%8d%e5%88%b6%e9%87%8d%e6%96%b0%e5%b9%b3%e8%a1%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>chunk 副本在 GFS 中有三个主要用途：chunk 创建、重新复制和重新平衡。</p>
<ol>
<li>
<p>Master 节点在创建 chunk 时选择存放初始空副本的位置，考虑以下因素：</p>
<ul>
<li>优先选择硬盘使用率低于平均值的 chunkserver，以平衡硬盘使用率。</li>
<li>限制每个 chunkserver上最近 chunk 创建操作的次数，以减少写入操作的集中度。</li>
<li>分布在多个机架之间，以提高可靠性。</li>
</ul>
</li>
<li>
<p>当有效副本数量低于指定复制因数时，master 节点会重新复制 chunk，可能原因包括：</p>
<ul>
<li>
<p>chunkserver不可用或报告副本损坏。</p>
</li>
<li>
<p>磁盘错误或复制因数增加。</p>
</li>
<li>
<p>重新复制优先级基于现有副本数量与复制因数的差异、chunk 活跃状态及其对客户端的影响。</p>
</li>
</ul>
<p>master 选择优先级最高的chunk，命令 chunkserver克隆副本，选择新副本的位置的策略类似于 chunk 创建。为防止克隆操作超载网络，master会限制克隆操作数量及其读请求频率。</p>
</li>
<li>
<p>master 周期性检查副本分布，移动副本以优化硬盘空间利用和平衡。在这个过程中，master 渐进式填充新 chunkserver，避免短期内填充过载。副本位置选择策略同上，并优先移走剩余空间低于平均值的服务器上的副本，以平衡整体硬盘使用率。</p>
</li>
</ol>
<h3 id="垃圾回收" class="heading-element"><span>4.4 垃圾回收</span>
  <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 在文件删除后不会立即回收物理空间，而是采用惰性垃圾回收策略，仅在文件和 chunk 级的常规垃圾收集中进行。这样简化了系统设计，提高了可靠性。</p>
<h4 id="机制" class="heading-element"><span>4.4.1 机制</span>
  <a href="#%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当一个文件被应用程序删除时，master立刻把删除操作以日志的方式记录下来。但是，<font color="red">master 并不马上回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字</font>。当 master 对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件（这个时间间隔是可以设置的）。在文件被真正删除之前，它们仍旧可以用新的特殊的名字（即被重命名后的带有删除时间戳的名字）读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“取消删除”。当隐藏文件被从命名空间中删除，master 内存中保存的这个文件的相关元数据才会被删除。这也有效的切断了文件和它包含的所有 chunk 的连接。</p>
<p><font color="red">在对 chunk 命名空间做类似的常规扫描时，master 找到孤儿 chunk（不被任何文件包含的 Chunk） 并删除它们的元数据</font>。chunkserver在和 master 交互的心跳信息中，报告它拥有的 chunk 子集的信息， master 回复 chunkserver哪些 chunk 在 master 保存的元数据中已经不存在了。chunkserver可以任意删除这些 chunk 的副本。</p>
<h4 id="讨论" class="heading-element"><span>4.4.2 讨论</span>
  <a href="#%e8%ae%a8%e8%ae%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>GFS 的垃圾回收方案简单可靠。可以轻易得到chunk 的引用：存储在 master 的文件到chunk的映射表中；也可以轻松得到chunk所有副本：以Linux文件的形式存储在 chunkserver指定目录下。所有master 不能识别的副本即为“垃圾”。</p>
<p>垃圾回收在空间回收方面相比直接删除有几个优势。</p>
<ol>
<li>在大规模分布式系统中，组件失效是常态。chunk 可能在某些服务器上创建成功，但在其他服务器上失败，失败的副本处于无法被 master 识别的状态。副本删除消息可能丢失，master 必须重新发送失败的删除消息， 包括自身的（元数据）和 chunkserver的。垃圾回收提供了一致的、可靠的清除无用副本的方法。</li>
<li>垃圾回收将存储空间回收操作合并到 master 的规律性后台活动中，如例行扫描和与 chunkserver的握手。因此操作被批量执行，减少开销。回收在 master 相对空闲时进行，提高了响应速度。</li>
<li>延迟回收为意外、不可逆转的删除操作提供了安全保障，防止误删。</li>
</ol>
<p>虽然延迟回收可能阻碍存储优化，尤其在空间紧缺时。但可以通过显式再次删除文件可以加速回收。用户可以为不同命名空间设置不同的复制和回收策略，以优化存储使用。</p>
<h3 id="过期副本检测" class="heading-element"><span>4.5 过期副本检测</span>
  <a href="#%e8%bf%87%e6%9c%9f%e5%89%af%e6%9c%ac%e6%a3%80%e6%b5%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">当 chunkserver失效时，chunk 的副本可能因错失一些修改操作而过期。master 通过保存每个 Chunk 的版本号来区分当前副本和过期副本。</font>每次与 chunk 签订新租约时，master 都会增加 chunk 的版本号，并通知最新的副本，且这些副本会将新的版本号记录在其持久化存储中。这个过程在任何客户端得到通知前完成，因此也是在对这个 chunk 开始写之前完成的。如果某个副本所在的 chunkserver正好失效，那么其版本号就不会被更新。待该 chunkserver重新启动并向 master 报告其持有的 chunk 及相应版本号时，master 会检测出其包含过期的 chunk。若 master 发现一个比其记录的版本号更高的版本号，会认为之前签订租约的操作失败，并选择更高的版本号作为当前版本号。</p>
<p>master 在例行垃圾回收过程中移除所有过期副本。在此之前，master 在回复客户端的 chunk 信息请求时，master 实际上会认为根本不存在一个过期的副本（也就是说，给客户端返回的 chunk 列表中可能包含过期的 chunk，客户端有可能去读过期的 chunk。GFS 是弱一致性的）。另外一重保障措施是，master 在通知客户端哪个 chunkserver持有租约或指示 chunkserver从哪个 chunkserver进行克隆时，消息中都会附带 chunk 的版本号。客户端或 chunkserver在执行操作时会验证版本号，以确保总是访问当前版本的数据。</p>
<h2 id="容错和诊断" class="heading-element"><span>5 容错和诊断</span>
  <a href="#%e5%ae%b9%e9%94%99%e5%92%8c%e8%af%8a%e6%96%ad" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="高可用性" class="heading-element"><span>5.1 高可用性</span>
  <a href="#%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 GFS 集群中，高可用性的策略主要包括快速恢复和复制。</p>
<ul>
<li>首先，对于快速恢复，无论是 master 还是 chunkserver，它们都能在数秒内恢复状态并重新启动。系统不区分正常关闭和异常关闭，通常通过直接终止进程来关闭服务器。</li>
<li>其次，对于 chunk 复制，每个 chunk 都被复制到不同机架上的不同 chunkserver上，并可以根据需要设定不同的复制级别。当有 chunkserver 离线或发现数据损坏时，master 通过克隆已有的副本来确保每个 chunk 都被完整复制。</li>
<li>最后，master 的状态也需要复制以保证其可靠性。master 的所有操作日志和 checkpoint 文件都被复制到多台机器上，确保操作日志写入备用节点和本机磁盘，以支持失败后的快速重新启动。此外，还存在“影子”master，用于提供文件系统的只读访问。这些“影子”服务器能够保持状态最新，并通过与主 master 相同的方式处理数据结构的更改。它们定期从 chunkserver拉取数据，并与其握手以确定状态，从而确保系统的高可用性。</li>
</ul>
<h3 id="数据完整性" class="heading-element"><span>5.2 数据完整性</span>
  <a href="#%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个 Chunkserver使用 checksum 来检查保存的数据是否损坏。由于 GFS 集群通常包含数百台机器和数千块硬盘，磁盘损坏导致的数据丢失或损坏在读写过程中是常见的。虽然可以通过其他副本恢复数据，但跨服务器比较副本以检查数据完整性并不实际。此外，由于 GFS 允许存在有歧义的副本，特别是在原子记录追加操作中，副本并不总是完全一致的（副本不是 byte-wise 完全一致的）。因此，每个 chunkserver必须独立维护 checksum 来校验自己的副本完整性。</p>
<p>每个 chunk 被分为 64KB 的块，每个块对应一个 32 位的 checksum，存储在内存和硬盘上，并记录在操作日志中。在读取数据之前，chunkserver会校验与读取范围重叠的数据块的checksum。如果 checksum 不匹配，服务器返回错误信息并通知 master，之后从其他副本读取数据并进行克隆恢复。一旦新的副本就绪，master 通知 chunkserver删除错误的副本。</p>
<p>checksum 对读操作性能影响很小，因为大部分读操作涉及多个块，而只需读取少量额外数据进行校验。通过对齐读操作到 checksum块的边界，可以进一步减少额外读取操作的影响。此外，checksum 的查找和比较不需要额外的 I/O 操作，计算可以与 I/O 操作并行进行。</p>
<p>针对追加写入操作，checksum 的计算进行了优化，因为这种操作在 GFS 工作中占很大比例。只需增量更新最后一个不完整块的 checksum，并使用新写入的数据计算新的 checksum。如果最后一个checksum块损坏，问题会在下次读取时被发现。</p>
<p>相比之下，覆盖写操作需要读取和校验被覆盖范围内的第一个和最后一个块，操作完成后重新计算和写入新的 checksum。如果不校验第一个和最后一个被写的块，新的 checksum 可能会隐藏未覆盖区域内的数据错误。</p>
<p><font color="red">当 chunkserver空闲时，会扫描和校验每个不活动 chunk 的内容，以发现很少被读取的 chunk 是否完整</font>。一旦发现数据损坏，master 可以创建新的正确副本并删除损坏的副本，避免非活动的损坏 chunk 误导 master，使其认为副本数量足够。</p>
<h3 id="诊断工具" class="heading-element"><span>5.3 诊断工具</span>
  <a href="#%e8%af%8a%e6%96%ad%e5%b7%a5%e5%85%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>详尽的、深入细节的诊断日志在问题隔离、调试和性能分析等方面提供了极大的帮助，而所需开销却很小。没有日志，我们很难理解短暂的、不重复的机器间消息交互。GFS 服务器会生成大量日志，记录关键事件（如 chunkserver 的启动和关闭）以及所有 RPC 请求和回复。这些日志可以随时删除，不影响系统的正确运行，但我们在存储空间允许的情况下尽量保留这些日志。</p>
<p>RPC 日志详细记录了网络上的所有请求和响应，但不包括读写的文件数据。通过匹配请求与回应，并收集不同机器上的 RPC 日志，我们可以重现所有消息交互来诊断问题。这些日志还用于跟踪负载测试和进行性能分析。</p>
<p>日志对性能的影响很小，因为日志写入是顺序且异步的。最近的事件日志保存在内存中，用于持续的在线监控。</p>
<h2 id="经验" class="heading-element"><span>6 经验</span>
  <a href="#%e7%bb%8f%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在构建和部署 GFS 的过程中，Google 遇到了许多问题，包括操作和技术方面的挑战。最初，GFS 主要作为生产系统的后端文件系统，后来逐渐支持研究和开发任务，增加了权限和配额等功能。</p>
<p>最大的难题是磁盘和 Linux 相关问题。许多磁盘声称支持 Linux IDE 驱动，但实际应用中情况不一，导致协议不匹配，数据可能因内核问题而被破坏。为此，Google 使用校验和来验证数据，并修改内核处理这些问题。</p>
<p>早期使用 Linux 2.2 内核时，fsync() 效率与文件大小相关而非修改部分大小相关，导致操作日志文件过大时出现问题，尤其是在尚未实现checkpoint 的时候。Google费了很大的力气用同步写来解决这个问题，但是最后还是移植到了 Linux2.4 内核上。</p>
<p>另一个问题是单个读写锁，导致系统偶尔超时。Google 通过用 pread() 替代 mmap() 并增加额外复制操作解决了这个问题。</p>
<p>在任意地址空间的线程在磁盘读入（读锁）时或 <code>mmap()</code> 调用（写锁）时必须持有锁。即使系统负载很轻，也会偶尔超时。Google花费大量精力查找资源瓶颈或硬件问题，最终发现磁盘线程在交换数据到磁盘时，锁住了当前网络线程，阻止其将新数据映射到内存。由于性能主要受限于网络接口而非内存复制带宽，Google用 <code>pread()</code> 替代 <code>mmap()</code>，通过额外复制操作解决了问题。</p>
]]></description></item><item><title>【MIT 6.5840(6.824)】 Lab 5:Sharded Key/Value Service 设计实现</title><link>https://hezephyr.github.io/posts/11.mit6.5840-lab5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/11.mit6.5840-lab5/</guid><description><![CDATA[<h2 id="实验要求" class="heading-element"><span>1 实验要求</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="介绍" class="heading-element"><span>1.1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>本实验要求构建一个键 / 值存储系统，该系统能够将键 “分片” 或分区到一组副本组上。分片是键 / 值对的子集，例如所有以“a”开头的键可能是一个分片等，通过分片可提高系统性能，因为每个副本组仅处理几个分片的放置和获取，并且这些组并行操作。</p>
<p>系统有两个主要组件：一组副本组和分片控制器。每个副本组使用 Raft 复制负责部分分片的操作，分片控制器决定每个分片应由哪个副本组服务，其配置会随时间变化。客户端和副本组都需咨询分片控制器来找到对应关系。系统必须能在副本组间转移分片，以平衡负载或应对副本组的加入和离开。</p>
<p>主要挑战在于处理重新配置，即分片到组的分配变化，<font color="red">且要确保任何时候每个分片只有一个副本组在处理请求，同时重新配置还需要副本组间的交互（分片移动）</font>。本实验只允许通过 RPC 进行客户端和服务器间的交互。实验架构与许多其他系统类似，但相对简单。实验需使用相同的 Raft 实现，完成后需通过相关测试。</p>
<h3 id="lab5a控制器和静态分片" class="heading-element"><span>1.2 lab5A：控制器和静态分片</span>
  <a href="#lab5a%e6%8e%a7%e5%88%b6%e5%99%a8%e5%92%8c%e9%9d%99%e6%80%81%e5%88%86%e7%89%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p>实现分片控制器</p>
<ul>
<li>在<code>shardctrler/server.go</code>和<code>client.go</code>中实现。需支持<code>Join</code>、<code>Leave</code>、<code>Move</code>和<code>Query</code>四种 RPC 接口。</li>
<li><code>Join</code> RPC：管理员用于添加新副本组，参数是从唯一、非零副本组标识符（GIDs）到服务器名称列表的映射集。分片控制器创建新配置，尽可能均匀地分配分片并尽量少移动分片。若 GID 不在当前配置中可重复使用。</li>
<li><code>Leave</code> RPC：参数是已加入组的 GIDs 列表，分片控制器创建新配置，排除这些组并将其分片分配给剩余组，且尽可能均匀分配并少移动分片。</li>
<li><code>Move</code> RPC：参数是分片编号和 GID，分片控制器创建新配置将分片分配给指定组，主要用于测试。</li>
<li><code>Query</code> RPC：参数是配置编号，分片控制器回复对应编号的配置，若编号为 - 1 或大于最大已知配置编号，则回复最新配置。第一个配置编号为 0，无组且所有分片分配给无效 GID 0，后续配置编号依次递增。通常，分片的数量明显多于组（即，每一组将服务多个分片），以便可以以相当细的粒度转移负载。</li>
</ul>
<blockquote>
<ul>
<li>从</li>
<li>实现时要注意去重客户端请求，代码需具有确定性，注意 Go 中 map 的特性，可使用 <code>Go test --race</code> 查找漏洞。</li>
</ul>
</blockquote>
</li>
<li>
<p>实现分片键 / 值服务器（处理静态配置）</p>
<ul>
<li>在<code>shardkv/</code>目录下实现，可从现有的<code>kvraft</code>服务器复制代码。</li>
<li>对于第一个测试，无需特别处理分片即可通过。</li>
<li>对于第二个测试，键 / 值副本组必须拒绝处理不属于其负责分片的键请求，服务器需定期向控制器获取最新配置，并在每次收到客户端<code>Get/Put/Append</code> RPC 时检查配置，对不负责分片的键请求返回<code>ErrWrongGroup</code>错误，且服务器不应调用分片控制器的<code>Join()</code>处理程序，由测试程序在适当时候调用。</li>
</ul>
</li>
</ol>
<blockquote>
<p>Hint</p>
<ul>
<li>从 kvraft 服务器的精简副本开始。</li>
<li>实现时要注意去重客户端请求。</li>
<li>状态机中执行分片重新平衡的代码必须是确定性的。在Go中，map的迭代顺序是不确定的</li>
<li>Go map是引用。如果将map类型的一个变量分配给另一个变量，则这两个变量都引用同一个map。因此，如果你想创建一个新的 <code>Config</code> 基于前一个，您需要创建一个新的地图对象（使用 <code>make()</code> ）并单独复制键和值。</li>
<li>Go竞争detector（<code>go test --race</code>）可以帮助您发现错误。</li>
</ul>
</blockquote>
<h3 id="lab5b碎片移动" class="heading-element"><span>1.3 lab5B：碎片移动</span>
  <a href="#lab5b%e7%a2%8e%e7%89%87%e7%a7%bb%e5%8a%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>当控制器改变分片时在副本组间移动分片，并确保键 / 值客户端操作的线性化。每个分片仅在其 Raft 副本组中多数服务器存活且能相互通信，以及能与多数分片控制器服务器通信时才能进行操作。系统在某些副本组中的少数服务器出现故障、暂时不可用或速度慢的情况下仍需运行。</p>
<p><font color="red">一个<code>shardkv</code>服务器只属于一个副本组，且组内服务器集合不会改变</font>。</p>
<p>服务器需监测配置变化，检测到变化时启动分片迁移过程。若副本组丢失分片，需立即停止处理该分片的请求并迁移数据给接管的副本组；若副本组获得分片，需等待前所有者发送旧分片数据后再接受请求。实现配置更改期间的分片迁移，确保副本组中的所有服务器在操作执行顺序中的同一点进行迁移，以统一处理并发客户端请求。</p>
<blockquote>
<p>Hint</p>
<ul>
<li>服务器需周期性（约每 100 毫秒）轮询分片控制器获取新配置，配置更改时服务器间需通过 RPC 传输分片，使用<code>make_end()</code>函数将服务器名称转换为<code>labrpc.ClientEnd</code>来发送 RPC。</li>
<li>按顺序处理重新配置，处理跨分片移动的客户端请求时需提供最多一次语义（去重检测）。</li>
<li>考虑<code>shardkv</code>客户端和服务器如何处理<code>ErrWrongGroup</code>错误，包括客户端是否更改序列号，服务器执行<code>Get/Put</code>请求返回该错误时是否更新客户端状态等。</li>
<li>服务器迁移到新配置后可继续存储不再拥有的分片，但在实际系统中应避免。</li>
<li>考虑在配置更改过程中，一个组从另一个组获取分片时，发送分片的时间点是否重要。</li>
<li>可在 RPC 请求或回复中发送整个map来简化分片转移代码，但要注意可能导致的竞态问题，处理方法是在 RPC 处理程序的回复中包含map的副本，以及在将映射 / 切片放入 Raft 日志条目并保存到键 / 值服务器状态时也要复制以避免竞态。</li>
<li>配置更改时，两组之间可能需要双向移动分片，注意避免死锁。</li>
</ul>
</blockquote>
<h3 id="挑战任务" class="heading-element"><span>1.4 挑战任务</span>
  <a href="#%e6%8c%91%e6%88%98%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>状态垃圾回收
<ul>
<li>当副本组失去一个分片的所有权时，应从其数据库中删除该分片的键，避免浪费空间，但这给迁移带来问题。</li>
<li>解决方法是让副本组在必要时保留旧分片，且在副本组崩溃后重新启动时仍能正常工作，通过<code>TestChallenge1Delete</code>测试即完成此挑战。</li>
</ul>
</li>
<li>配置更改期间的客户端请求处理
<ul>
<li><strong>基本优化</strong>：修改解决方案，使在配置更改期间，不受影响分片的客户端操作能够继续执行，通过<code>TestChallenge2Unaffected</code>测试即完成此部分挑战。</li>
<li><strong>进一步优化</strong>：修改解决方案，使副本组在能够处理分片时立即开始服务，即使配置更改仍在进行中，通过<code>TestChallenge2Partial</code>测试即完成此挑战。</li>
</ul>
</li>
</ol>
<h2 id="实验设计" class="heading-element"><span>2 实验设计</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="整体架构" class="heading-element"><span>2.1 整体架构</span>
  <a href="#%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Shardedkv服务整体架构如下图所示，主要由<strong>shardctrler</strong>（分片控制器）和<strong>shardkv</strong>（分片键值存储）两个核心组件构成，基于Raft一致性协议。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020102540500.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020102540500.png?size=small" data-sub-html="<h2>image-20241020102540500</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020102540500.png" alt="image-20241020102540500" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020102540500.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020102540500.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020102540500.png?size=large 2x" data-title="image-20241020102540500" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li>客户端层
<ul>
<li>shardctrler客户端：主要用于与shardctrler集群进行交互，执行分片配置的管理操作。通过4个主要的RPC接口，客户端可以请求<code>Join</code>（加入新分片组）、<code>Leave</code>（离开分片组）、<code>Move</code>（迁移分片）和<code>Query</code>（查询分片配置）。</li>
<li>shardkv客户端：负责向shardkv集群发送具体的键值操作请求。客户端通过分片ID（<code>shardID</code>）查找目标分片所在的集群组（通过本地配置中的映射关系），并将请求发送到正确的shardkv服务器。如果该shardkv服务器无法提供服务（如分片迁移导致服务不可用），客户端会向shardctrler请求最新的配置，并重新定向请求。</li>
</ul>
</li>
<li>服务器层：分为两个主要的集群：<strong>shardctrler集群</strong>和<strong>shardkv集群</strong>，它们分别处理配置管理和数据存储。
<ul>
<li><strong>Shardctrler集群</strong>：Shardctrler是负责管理分片配置的服务器集群。该集群的每个节点保存一个<code>configs[]</code>数组，记录系统中每个分片的最新及历史配置，包括<code>configNum,map:shard-&gt;gid,map:gid-&gt;servers</code>。该集群通过RPC接口处理客户端发起的配置变更请求，包括<code>Join</code>、<code>Leave</code>、<code>Move</code>和<code>Query</code>。每当shardctrler接收到配置变更请求时，它会生成一个新的配置，将分片重新分配给不同的shardkv集群组。</li>
<li><strong>Shardkv集群</strong>：Shardkv集群是处理实际键值存储和数据操作的核心部分。整个Shardkv系统被划分为多个分片组（Group），每个组负责管理一部分分片。一个组通常包含多个shardkv服务器，每个服务器保存其负责的分片数据。客户端的<code>Get</code>、<code>Put</code>和<code>Append</code>请求会根据分片ID路由到对应的服务器，服务器根据当前配置中的分片分配情况进行操作。如果服务器收到的请求涉及的分片已经迁移或重新分配，它会通过向shardctrler请求最新配置来处理这一变化。具体来说，当分片被重新分配时，shardkv集群会将原先分配给某个组的分片数据传输到新的分片组。<font color="red">每个分片在迁移过程中，需要通过状态追踪保证只有新的分片组接管该分片的数据写入与查询</font>。当分片完成迁移后，原先拥有该分片的shardkv服务器需要清理掉旧的分片数据，以释放存储资源。</li>
</ul>
</li>
<li>Raft层：Shardctrler集群和Shardkv集群都依赖于Raft一致性协议来实现分布式日志的一致性复制。</li>
<li>持久化存储层：Raft协议的实现要求系统能够将Raft状态和日志数据持久化，以便在节点宕机或重启时恢复状态。其中由于shardctrler的配置数据比较小，所以不太需要快照功能。</li>
</ol>
<h3 id="shardctrler" class="heading-element"><span>2.2 shardctrler</span>
  <a href="#shardctrler" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>shardctrler本质上跟kvraft没什么区别，只是存储的是配置项信息，包含每个分片由哪个副本组负责以及副本组ID到对应服务器的endPoint这两个映射。所以在代码实现上完全可以按照kvraft的实现，并且由于配置项数据一般比较少，所以不需要实现日志快照功能。</p>
<p>具体在于四个RPC请求：<code>Join</code>、<code>Leave</code>、<code>Move</code>、<code>Query</code>的实现。</p>
<ul>
<li>
<p>我们根据 <code>Join</code> 请求的副本组 ID 和服务器列表，更新最新配置中的副本组列表，将新副本组添加进去。<font color="red">并且根据新的副本组数量，重新分配分片（使用简单的负载均衡算法：尽量让所有副本组处理的分片数量相等）</font>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Join adds new groups to the configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">MemoryConfigStateMachine</span><span class="p">)</span> <span class="nf">Join</span><span class="p">(</span><span class="nx">groups</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Err</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastConfig</span> <span class="o">:=</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// create a new configuration based on the last configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">newConfig</span> <span class="o">:=</span> <span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastConfig</span><span class="p">.</span><span class="nx">Shards</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nf">deepCopy</span><span class="p">(</span><span class="nx">lastConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">gid</span><span class="p">,</span> <span class="nx">servers</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">groups</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// if the group does not exist in the new configuration, add it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">newConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">[</span><span class="nx">gid</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">newServers</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">servers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nb">copy</span><span class="p">(</span><span class="nx">newServers</span><span class="p">,</span> <span class="nx">servers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">newConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">[</span><span class="nx">gid</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newServers</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">group2Shards</span> <span class="o">:=</span> <span class="nf">Group2Shards</span><span class="p">(</span><span class="nx">newConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// load balance the shards among the groups
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">source</span><span class="p">,</span> <span class="nx">target</span> <span class="o">:=</span> <span class="nf">GetGIDWithMaximumShards</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">),</span> <span class="nf">GetGIDWithMinimumShards</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">source</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">[</span><span class="nx">source</span><span class="p">])</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">[</span><span class="nx">target</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">group2Shards</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">[</span><span class="nx">target</span><span class="p">],</span> <span class="nx">group2Shards</span><span class="p">[</span><span class="nx">source</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="nx">group2Shards</span><span class="p">[</span><span class="nx">source</span><span class="p">]</span> <span class="p">=</span> <span class="nx">group2Shards</span><span class="p">[</span><span class="nx">source</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// update the shard assignment in the new configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">newShards</span> <span class="p">[</span><span class="nx">NShards</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">gid</span><span class="p">,</span> <span class="nx">shards</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">group2Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">newShards</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gid</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newConfig</span><span class="p">.</span><span class="nx">Shards</span> <span class="p">=</span> <span class="nx">newShards</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">,</span> <span class="nx">newConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">OK</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>Leave</code>：根据需要移除的副本组ID，从配置中删除这些组的信息。将它们负责的分片重新分配给现存的副本组，保证分片的平衡。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Leave removes specified groups from the configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">MemoryConfigStateMachine</span><span class="p">)</span> <span class="nf">Leave</span><span class="p">(</span><span class="nx">gids</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="nx">Err</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastConifg</span> <span class="o">:=</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// create a new configuration based on the last configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">newConfig</span> <span class="o">:=</span> <span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastConifg</span><span class="p">.</span><span class="nx">Shards</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nf">deepCopy</span><span class="p">(</span><span class="nx">lastConifg</span><span class="p">.</span><span class="nx">Groups</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">group2Shards</span> <span class="o">:=</span> <span class="nf">Group2Shards</span><span class="p">(</span><span class="nx">newConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// used to store the orphan shards (i.e., shards owned by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">orphanShards</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">gid</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gids</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// if the group exists in the new configuration, remove it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">newConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">[</span><span class="nx">gid</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">delete</span><span class="p">(</span><span class="nx">newConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">,</span> <span class="nx">gid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// if the group owns any shards, remove them and add them to the orphan shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">shards</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">group2Shards</span><span class="p">[</span><span class="nx">gid</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">delete</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">,</span> <span class="nx">gid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">orphanShards</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">orphanShards</span><span class="p">,</span> <span class="nx">shards</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">newShards</span> <span class="p">[</span><span class="nx">NShards</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// re-allocate orphan shards to the remaining groups
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">orphanShards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gid</span> <span class="o">:=</span> <span class="nf">GetGIDWithMinimumShards</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">newShards</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gid</span>
</span></span><span class="line"><span class="cl">			<span class="nx">group2Shards</span><span class="p">[</span><span class="nx">gid</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">[</span><span class="nx">gid</span><span class="p">],</span> <span class="nx">shard</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// update the shard assignment in the new configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">gid</span><span class="p">,</span> <span class="nx">shards</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">group2Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">newShards</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gid</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newConfig</span><span class="p">.</span><span class="nx">Shards</span> <span class="p">=</span> <span class="nx">newShards</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">,</span> <span class="nx">newConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">OK</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>Move</code>：更新当前的配置，将该分片从旧的副本组重新分配到指定的新副本组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Move moves a specified shard to a specified group.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">MemoryConfigStateMachine</span><span class="p">)</span> <span class="nf">Move</span><span class="p">(</span><span class="nx">shard</span><span class="p">,</span> <span class="nx">gid</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Err</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastConfig</span> <span class="o">:=</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// create a new configuration based on the last configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">newConfig</span> <span class="o">:=</span> <span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastConfig</span><span class="p">.</span><span class="nx">Shards</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nf">deepCopy</span><span class="p">(</span><span class="nx">lastConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// update the shard assignment in the new configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">newConfig</span><span class="p">.</span><span class="nx">Shards</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nx">gid</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">,</span> <span class="nx">newConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">OK</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>Query</code>：根据 <code>Query</code> 请求中的参数（版本号），返回对应版本的配置。如果请求的版本号为 -1，则返回最新的配置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Query queries a specified configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">MemoryConfigStateMachine</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">Config</span><span class="p">,</span> <span class="nx">Err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// if the configuration number is not valid, return the latest configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">num</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">num</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">OK</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">Configs</span><span class="p">[</span><span class="nx">num</span><span class="p">],</span> <span class="nx">OK</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Group2Shards assigns each shard to the corresponding group.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Group2Shards</span><span class="p">(</span><span class="nx">config</span> <span class="nx">Config</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">group2Shards</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">gid</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">config</span><span class="p">.</span><span class="nx">Groups</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">group2Shards</span><span class="p">[</span><span class="nx">gid</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">shard</span><span class="p">,</span> <span class="nx">gid</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">config</span><span class="p">.</span><span class="nx">Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">group2Shards</span><span class="p">[</span><span class="nx">gid</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">group2Shards</span><span class="p">[</span><span class="nx">gid</span><span class="p">],</span> <span class="nx">shard</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">group2Shards</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="shardkv-server" class="heading-element"><span>2.3 shardkv server</span>
  <a href="#shardkv-server" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="结构" class="heading-element"><span>2.3.1 结构</span>
  <a href="#%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>ShardKV的结构体代码如下，其中</p>
<ul>
<li><code>stateMachine</code>用于存储实际的键值数据。它是一个分片映射，键为分片 ID，值为存储该分片数据的 <code>Shard</code> 结构体，每个 <code>Shard</code> 结构体由哈希表和状态变量构成，有以下四种状态：
<ul>
<li><code>Serving</code>：表示该分片正在正常地为客户端提供读写服务。这意味着客户端对该分片内键值对的<code>Get</code>、<code>Put</code>、<code>Append</code>等操作都可以得到及时处理。</li>
<li><code>Pulling</code>：表明该分片正在从其他服务器拉取数据。这种情况通常发生在配置变更后，分片需要从原来所属的服务器迁移到当前服务器时，当前服务器会将该分片标记为<code>Pulling</code>状态。</li>
<li><code>BePulling</code>：<code>BePulling</code>状态意味着该分片的数据正在被其他服务器拉取。与<code>Pulling</code>状态不同，<code>BePulling</code>状态是从数据提供方的角度来看的，即本服务器上的该分片数据正在被其他服务器获取。</li>
<li><code>GCing</code>：<code>GCing</code>即垃圾回收（Garbage Collection）状态。当一个分片服务器已经完成了迁移操作，会将进入<code>GCing</code>状态，以便清理拉取服务器上的分片数据（即<code>BePulling</code>状态）。</li>
</ul>
</li>
<li>根据不同状态和当前<code>raft</code>组的配置，决定是否提供读写服务以及进行相应的数据迁移和清理操作。</li>
<li><code>notifyChans</code>: 用于通知客户端操作的完成情况。每次当 Raft 提交某个操作时，通过<code>notifyChans</code>唤醒等待的客户端。</li>
<li><code>lastOperations</code>：用于去重记录，保存每个客户端最后一次请求的 <code>commandId</code> 和操作结果，避免重复操作。</li>
</ul>
<p>此外，<code>ShardKV</code> 还通过 <code>applyCh</code> 接收 Raft 提交的日志条目，并通过定时任务监控配置更新、分片迁移、垃圾回收以及空日志检测。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ShardKV</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>       <span class="c1">// mutex for synchronizing access to shared resources
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dead</span>    <span class="kt">int32</span>              <span class="c1">// set by Kill(), indicates if the server is killed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rf</span>      <span class="o">*</span><span class="nx">raft</span><span class="p">.</span><span class="nx">Raft</span>         <span class="c1">// raft instance for consensus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">applyCh</span> <span class="kd">chan</span> <span class="nx">raft</span><span class="p">.</span><span class="nx">ApplyMsg</span> <span class="c1">// channel for applying raft messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">makeEnd</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span> <span class="c1">// function to create a client end to communicate with other groups
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gid</span>     <span class="kt">int</span>                            <span class="c1">// group id of the server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sc</span>      <span class="o">*</span><span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Clerk</span>             <span class="c1">// client to communicate with the shardctrler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxRaftState</span> <span class="kt">int</span> <span class="c1">// snapshot if log grows this big
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lastApplied</span>  <span class="kt">int</span> <span class="c1">// index of the last applied log entry to prevent stateMachine from rolling back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastConfig</span>    <span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span> <span class="c1">// the last configuration received from the shardctrler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">currentConfig</span> <span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span> <span class="c1">// the current configuration of the cluster
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">stateMachine</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">Shard</span>             <span class="c1">// KV State Machines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lastOperations</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="nx">OperationContext</span> <span class="c1">// determine whether log is duplicated by (clientId, commandId)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">notifyChans</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">CommandReply</span> <span class="c1">// notify the client when the command is applied
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">StartServer</span><span class="p">(</span><span class="nx">servers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span><span class="p">,</span> <span class="nx">me</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">persister</span> <span class="o">*</span><span class="nx">raft</span><span class="p">.</span><span class="nx">Persister</span><span class="p">,</span> <span class="nx">maxraftstate</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">gid</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ctrlers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span><span class="p">,</span> <span class="nx">makeEnd</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span><span class="p">)</span> <span class="o">*</span><span class="nx">ShardKV</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// call labgob.Register on structures you want
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Go&#39;s RPC library to marshall/unmarshall.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">labgob</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">Command</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">labgob</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">CommandArgs</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">labgob</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">labgob</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">ShardOperationArgs</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">labgob</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">ShardOperationReply</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create a channel to receive messages applied by Raft.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">applyCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">raft</span><span class="p">.</span><span class="nx">ApplyMsg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ShardKV</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dead</span><span class="p">:</span>           <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rf</span><span class="p">:</span>             <span class="nx">raft</span><span class="p">.</span><span class="nf">Make</span><span class="p">(</span><span class="nx">servers</span><span class="p">,</span> <span class="nx">me</span><span class="p">,</span> <span class="nx">persister</span><span class="p">,</span> <span class="nx">applyCh</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">applyCh</span><span class="p">:</span>        <span class="nx">applyCh</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">makeEnd</span><span class="p">:</span>        <span class="nx">makeEnd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gid</span><span class="p">:</span>            <span class="nx">gid</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sc</span><span class="p">:</span>             <span class="nx">shardctrler</span><span class="p">.</span><span class="nf">MakeClerk</span><span class="p">(</span><span class="nx">ctrlers</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">maxRaftState</span><span class="p">:</span>   <span class="nx">maxraftstate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastApplied</span><span class="p">:</span>    <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastConfig</span><span class="p">:</span>     <span class="nx">shardctrler</span><span class="p">.</span><span class="nf">DefaultConfig</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">currentConfig</span><span class="p">:</span>  <span class="nx">shardctrler</span><span class="p">.</span><span class="nf">DefaultConfig</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stateMachine</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">Shard</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastOperations</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="nx">OperationContext</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">notifyChans</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">CommandReply</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Restore any snapshot data stored in persister to recover the state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">kv</span><span class="p">.</span><span class="nf">restoreSnapshot</span><span class="p">(</span><span class="nx">persister</span><span class="p">.</span><span class="nf">ReadSnapshot</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applier</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Start several monitoring routines that periodically perform specific actions:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">Monitor</span><span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">configurationAction</span><span class="p">,</span> <span class="nx">ConfigurationMonitorTimeout</span><span class="p">)</span>         <span class="c1">// Monitor configuration changes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">Monitor</span><span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">migrationAction</span><span class="p">,</span> <span class="nx">MigrationMonitorTimeout</span><span class="p">)</span>                 <span class="c1">// Monitor shard migration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">Monitor</span><span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">gcAction</span><span class="p">,</span> <span class="nx">GCMonitorTimeout</span><span class="p">)</span>                               <span class="c1">// Monitor garbage collection of old shard data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">Monitor</span><span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">checkEntryInCurrentTermAction</span><span class="p">,</span> <span class="nx">EmptyEntryDetectorTimeout</span><span class="p">)</span> <span class="c1">// Monitor Raft log entries in the current term.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">kv</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Execute</code>函数用于处理命令并返回结果，非领导者返回<code>ErrWrongLeader</code>，领导者获取通知通道等待结果或超时处理，最后异步释放通道；<code>applier</code>协程从<code>Raft</code>日志获取消息应用到状态机，对有效命令消息检查是否应用并按类型处理，可能通知客户端和进行快照，对有效快照消息安装快照恢复状态机，对无效消息抛异常。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Execute processes a command and returns the result via the reply parameter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">Execute</span><span class="p">(</span><span class="nx">command</span> <span class="nx">Command</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">CommandReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// do not hold lock to improve throughput
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// when KVServer holds the lock to take snapshot, underlying raft can still commit raft logs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">isLeader</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">isLeader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrWrongLeader</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">notifyChan</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getNotifyChan</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// wait for the result or timeout.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">result</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">notifyChan</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Err</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">ExecuteTimeout</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrTimeout</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// release notifyChan to reduce memory footprint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// why asynchronously? to improve throughput, here is no need to block client request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nf">removeOutdatedNotifyChan</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// applier continuously applies commands from the Raft log to the state machine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">applier</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">kv</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// wait for a new message in the apply channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">case</span> <span class="nx">message</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">kv</span><span class="p">.</span><span class="nx">applyCh</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandValid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// check if the command has already been applied.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span> <span class="o">&lt;=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="k">continue</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// update the last applied index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// type assert the command from the message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">command</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">Command</span><span class="p">.(</span><span class="nx">Command</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">switch</span> <span class="nx">command</span><span class="p">.</span><span class="nx">CommandType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">Operation</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// extract the operation data and apply the operation to the state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">operation</span> <span class="o">:=</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">CommandArgs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyOperation</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">operation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">Configuration</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// extract the configuration data and apply the configuration to the state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">nextConfig</span> <span class="o">:=</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyConfiguration</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nextConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">InsertShards</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// extract the shard insertion data and apply the insertion to the state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">shardsInfo</span> <span class="o">:=</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">ShardOperationReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyInsertShards</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">shardsInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">DeleteShards</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// extract the shard deletion data and apply the deletion to the state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">shardsInfo</span> <span class="o">:=</span> <span class="nx">command</span><span class="p">.</span><span class="nx">Data</span><span class="p">.(</span><span class="nx">ShardOperationArgs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyDeleteShards</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">shardsInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">EmptyShards</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// apply empty shards to the state machine, to prevent the state machine from rolling back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyEmptyShards</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="c1">// only notify the related channel for currentTerm&#39;s log when node is Leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">currentTerm</span><span class="p">,</span> <span class="nx">isLeader</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetState</span><span class="p">();</span> <span class="nx">isLeader</span> <span class="o">&amp;&amp;</span> <span class="nx">message</span><span class="p">.</span><span class="nx">CommandTerm</span> <span class="o">==</span> <span class="nx">currentTerm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">notifyChan</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getNotifyChan</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">notifyChan</span> <span class="o">&lt;-</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="c1">// take snapshot if needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">needSnapshot</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nf">takeSnapshot</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CommandIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotValid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// restore the state machine from the snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">CondInstallSnapshot</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotTerm</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotIndex</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nf">restoreSnapshot</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nx">lastApplied</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">SnapshotIndex</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;{Node %v}{Group %v} invalid apply message %v&#34;</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">GetId</span><span class="p">(),</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">gid</span><span class="p">,</span> <span class="nx">message</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="日志类型" class="heading-element"><span>2.3.2 日志类型</span>
  <a href="#%e6%97%a5%e5%bf%97%e7%b1%bb%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在 <code>ShardKV</code> 系统中，Raft 日志包含了以下几种不同类型的操作：</p>
<ol>
<li><strong>客户端命令 (<code>Command</code>)</strong>: 包含对键值存储的<code>Put</code>、<code>Append</code>、<code>Get</code>等操作，这些操作会通过 Raft 日志提交来保证多副本的一致性。</li>
<li><strong>配置变更 (<code>Config</code>)</strong>: 当从 <code>shardctrler</code> 获取到新的分片配置时，会通过 Raft 日志来记录配置的变化。所有副本组通过 Raft 日志共享同一配置，确保分片的一致分配。</li>
<li><strong>分片操作 (<code>ShardOperation</code>)</strong>: 当进行分片迁移时，涉及到的操作也会记录在 Raft 日志中，保证分片迁移过程的顺序和一致性。</li>
<li><strong>空日志条目</strong>: Raft 有时会生成空日志条目以保持领导者的状态和活动性，避免在某些情况下集群处于无操作状态。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Operation</span>     <span class="nx">CommandType</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// Generic operation command
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Configuration</span>                    <span class="c1">// Configuration change command
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">InsertShards</span>                     <span class="c1">// Command to insert shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">DeleteShards</span>                     <span class="c1">// Command to delete shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">EmptyShards</span>                      <span class="c1">// Command to empty shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Command</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CommandType</span> <span class="nx">CommandType</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span>        <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ShardOperationArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ConfigNum</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ShardIDs</span>  <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ShardOperationReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Err</span>            <span class="nx">Err</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ConfigNum</span>      <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Shards</span>         <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">LastOperations</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="nx">OperationContext</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// NewOperationCommand creates a new operation command from CommandArgs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewOperationCommand</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">CommandArgs</span><span class="p">)</span> <span class="nx">Command</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Command</span><span class="p">{</span><span class="nx">Operation</span><span class="p">,</span> <span class="o">*</span><span class="nx">args</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NewConfigurationCommand creates a new configuration command
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewConfigurationCommand</span><span class="p">(</span><span class="nx">config</span> <span class="o">*</span><span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span><span class="p">)</span> <span class="nx">Command</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Command</span><span class="p">{</span><span class="nx">Configuration</span><span class="p">,</span> <span class="o">*</span><span class="nx">config</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NewInsertShardsCommand creates a new command to insert shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewInsertShardsCommand</span><span class="p">(</span><span class="nx">reply</span> <span class="o">*</span><span class="nx">ShardOperationReply</span><span class="p">)</span> <span class="nx">Command</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Command</span><span class="p">{</span><span class="nx">InsertShards</span><span class="p">,</span> <span class="o">*</span><span class="nx">reply</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NewDeleteShardsCommand creates a new command to delete shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewDeleteShardsCommand</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">ShardOperationArgs</span><span class="p">)</span> <span class="nx">Command</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Command</span><span class="p">{</span><span class="nx">DeleteShards</span><span class="p">,</span> <span class="o">*</span><span class="nx">args</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NewEmptyShardsCommand creates a new command indicating no shards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewEmptyShardsCommand</span><span class="p">()</span> <span class="nx">Command</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">Command</span><span class="p">{</span><span class="nx">EmptyShards</span><span class="p">,</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="读写服务" class="heading-element"><span>2.3.3 读写服务</span>
  <a href="#%e8%af%bb%e5%86%99%e6%9c%8d%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这段代码主要实现了与<code>shardkv</code>服务相关的操作逻辑。其中<code>canServe</code>函数用于判断服务器是否能服务指定分片，依据是当前配置下分片所属组与服务器组 ID 是否一致以及分片状态。<code>Command</code>函数先检查是否为重复请求，若是非<code>Get</code>操作的重复请求则直接返回结果，同时也检查服务器能否服务对应分片，不能则返回<code>ErrWrongGroup</code>，否则调用<code>Execute</code>。<code>applyOperation</code>函数在处理操作时，先检查服务器能否服务分片，对于非<code>Get</code>操作的重复请求返回上次结果，否则将操作应用到状态机，并在非<code>Get</code>操作时更新客户端操作相关信息，通过在多处进行相关判断和检查来保障操作的正确性和线性化语义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// canServe checks if the server can serve the shard.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">canServe</span><span class="p">(</span><span class="nx">shardID</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Shards</span><span class="p">[</span><span class="nx">shardID</span><span class="p">]</span> <span class="o">==</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">gid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">stateMachine</span><span class="p">[</span><span class="nx">shardID</span><span class="p">].</span><span class="nx">Status</span> <span class="o">==</span> <span class="nx">Serving</span> <span class="o">||</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">stateMachine</span><span class="p">[</span><span class="nx">shardID</span><span class="p">].</span><span class="nx">Status</span> <span class="o">==</span> <span class="nx">GCing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">Command</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">CommandArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">CommandReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// if the command is the duplicated, return result directly without raft layer&#39;s participation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">Get</span> <span class="o">&amp;&amp;</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">isDuplicateRequest</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastReply</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">].</span><span class="nx">LastReply</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">lastReply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">lastReply</span><span class="p">.</span><span class="nx">Err</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// check if the server can serve the requested shard.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">kv</span><span class="p">.</span><span class="nf">canServe</span><span class="p">(</span><span class="nf">key2shard</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrWrongGroup</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nf">NewOperationCommand</span><span class="p">(</span><span class="nx">args</span><span class="p">),</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// applyOperation applies a given operation to the KV state machine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">applyOperation</span><span class="p">(</span><span class="nx">operation</span> <span class="o">*</span><span class="nx">CommandArgs</span><span class="p">)</span> <span class="o">*</span><span class="nx">CommandReply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">shardID</span> <span class="o">:=</span> <span class="nf">key2shard</span><span class="p">(</span><span class="nx">operation</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// check if the server can serve the requested shard.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">kv</span><span class="p">.</span><span class="nf">canServe</span><span class="p">(</span><span class="nx">shardID</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrWrongGroup</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// check if the operation is duplicated(only for non-Get operations)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">operation</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">Get</span> <span class="o">&amp;&amp;</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">isDuplicateRequest</span><span class="p">(</span><span class="nx">operation</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">operation</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">lastReply</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">operation</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">].</span><span class="nx">LastReply</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">lastReply</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">lastReply</span><span class="p">.</span><span class="nx">Err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// apply the operation to the state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">reply</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">applyLogToStateMachine</span><span class="p">(</span><span class="nx">operation</span><span class="p">,</span> <span class="nx">shardID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// update the last operation context for the client if the operation is not a Get operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">operation</span><span class="p">.</span><span class="nx">Op</span> <span class="o">!=</span> <span class="nx">Get</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">operation</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">]</span> <span class="p">=</span> <span class="nx">OperationContext</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">operation</span><span class="p">.</span><span class="nx">CommandId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">					<span class="nx">reply</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="配置更新检测" class="heading-element"><span>2.3.4 配置更新检测</span>
  <a href="#%e9%85%8d%e7%bd%ae%e6%9b%b4%e6%96%b0%e6%a3%80%e6%b5%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>首先，配置更新协程负责定时监测配置是否更新，即<code>configNum</code>是否增加（<code>currentConfigNum+1==nextConfig.Num</code>）。但检测前提是需要检查分片的状态是否都为Serving，如果不是，则意味着其他协程仍然没有完成任务，故需要阻塞新配置的拉取和提取。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Checks if the next configuration can be performed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If all shards are in Serving status, it queries and applies the next configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">configurationAction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">canPerformNextConfig</span> <span class="o">:=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If any shard is not in the Serving status, the next configuration cannot be applied
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">stateMachine</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">Status</span> <span class="o">!=</span> <span class="nx">Serving</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">canPerformNextConfig</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">currentConfigNum</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Num</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Query and apply the next configuration if allowed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">canPerformNextConfig</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nextConfig</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">currentConfigNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Ensure the queried configuration is the next one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">nextConfig</span><span class="p">.</span><span class="nx">Num</span> <span class="o">==</span> <span class="nx">currentConfigNum</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">kv</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nf">NewConfigurationCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">nextConfig</span><span class="p">),</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// applyConfiguration applies a new configuration to the shard.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">applyConfiguration</span><span class="p">(</span><span class="nx">nextConfig</span> <span class="o">*</span><span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span><span class="p">)</span> <span class="o">*</span><span class="nx">CommandReply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// check if the new configuration is the next in line.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">nextConfig</span><span class="p">.</span><span class="nx">Num</span> <span class="o">==</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Num</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// update the shard status based on the new configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">kv</span><span class="p">.</span><span class="nf">updateShardStatus</span><span class="p">(</span><span class="nx">nextConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// save the last configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">kv</span><span class="p">.</span><span class="nx">lastConfig</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// update the current configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span> <span class="p">=</span> <span class="o">*</span><span class="nx">nextConfig</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">OK</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrOutDated</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="分片迁移" class="heading-element"><span>2.3.5 分片迁移</span>
  <a href="#%e5%88%86%e7%89%87%e8%bf%81%e7%a7%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>分片迁移协程会定时检测分片的 <code>Pulling</code> 状态。它依据 lastConfig 算出对应 raft 组的 gid 和待拉取的分片，随后并行拉取数据。这里采用 <code>waitGroup</code> 确保所有独立任务完成后再开始下一轮任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Executes the migration task to pull shard data from other groups.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">migrationAction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gid2Shards</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getShardIDsByStatus</span><span class="p">(</span><span class="nx">Pulling</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create pull tasks for each group (GID)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">gid</span><span class="p">,</span> <span class="nx">shardIDs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gid2Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">servers</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">configNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">shardIDs</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pullTaskArgs</span> <span class="o">:=</span> <span class="nx">ShardOperationArgs</span><span class="p">{</span><span class="nx">configNum</span><span class="p">,</span> <span class="nx">shardIDs</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Try to pull shard data from each server in the group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">server</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">servers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">pullTaskReply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">ShardOperationReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">srv</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">makeEnd</span><span class="p">(</span><span class="nx">server</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;ShardKV.GetShardsData&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pullTaskArgs</span><span class="p">,</span> <span class="nx">pullTaskReply</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">pullTaskReply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">OK</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">//Pulling data from these servers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">kv</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nf">NewInsertShardsCommand</span><span class="p">(</span><span class="nx">pullTaskReply</span><span class="p">),</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">lastConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">[</span><span class="nx">gid</span><span class="p">],</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Num</span><span class="p">,</span> <span class="nx">shardIDs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// Wait for all pull tasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// applyInsertShards applies the insertion of shard data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">applyInsertShards</span><span class="p">(</span><span class="nx">shardsInfo</span> <span class="o">*</span><span class="nx">ShardOperationReply</span><span class="p">)</span> <span class="o">*</span><span class="nx">CommandReply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// check if the configuration number matches the current one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">shardsInfo</span><span class="p">.</span><span class="nx">ConfigNum</span> <span class="o">==</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Num</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">shardID</span><span class="p">,</span> <span class="nx">shardData</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shardsInfo</span><span class="p">.</span><span class="nx">Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">stateMachine</span><span class="p">[</span><span class="nx">shardID</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// only pull if the shard is in the Pulling state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">Status</span> <span class="o">==</span> <span class="nx">Pulling</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shardData</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">shard</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// update the shard status to Garbage Collecting.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">shard</span><span class="p">.</span><span class="nx">Status</span> <span class="p">=</span> <span class="nx">GCing</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// update last operations with the provided contexts.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">clientId</span><span class="p">,</span> <span class="nx">operationContext</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shardsInfo</span><span class="p">.</span><span class="nx">LastOperations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">lastOperation</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">clientId</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">lastOperation</span><span class="p">.</span><span class="nx">MaxAppliedCommandId</span> <span class="p">&lt;</span> <span class="nx">operationContext</span><span class="p">.</span><span class="nx">MaxAppliedCommandId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">clientId</span><span class="p">]</span> <span class="p">=</span> <span class="nx">operationContext</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrOutDated</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="垃圾回收" class="heading-element"><span>2.3.6 垃圾回收</span>
  <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>分片清理协程负责定时检测分片的 <code>GCing</code> 状态，利用<code>lastConfig</code> 计算出对应 raft 组的 gid 和要拉取的分片，然后并行地去删除分片。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Executes garbage collection (GC) tasks to delete shard data from other groups.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">gcAction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Get the group that was previously responsible for these shards and clean up the shards that are no longer responsible.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gid2Shards</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">getShardIDsByStatus</span><span class="p">(</span><span class="nx">GCing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create GC tasks for each group (GID)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">gid</span><span class="p">,</span> <span class="nx">shardIDs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gid2Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">servers</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">configNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">shardIDs</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gcTaskArgs</span> <span class="o">:=</span> <span class="nx">ShardOperationArgs</span><span class="p">{</span><span class="nx">configNum</span><span class="p">,</span> <span class="nx">shardIDs</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Try to delete shard data from each server in the group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">server</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">servers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">gcTaskReply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">ShardOperationReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">srv</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nf">makeEnd</span><span class="p">(</span><span class="nx">server</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;ShardKV.DeleteShardsData&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">gcTaskArgs</span><span class="p">,</span> <span class="nx">gcTaskReply</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gcTaskReply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">OK</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">kv</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nf">NewDeleteShardsCommand</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcTaskArgs</span><span class="p">),</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">lastConfig</span><span class="p">.</span><span class="nx">Groups</span><span class="p">[</span><span class="nx">gid</span><span class="p">],</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Num</span><span class="p">,</span> <span class="nx">shardIDs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// Wait for all GC tasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// applyInsertShards applies the insertion of shard data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">applyInsertShards</span><span class="p">(</span><span class="nx">shardsInfo</span> <span class="o">*</span><span class="nx">ShardOperationReply</span><span class="p">)</span> <span class="o">*</span><span class="nx">CommandReply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// check if the configuration number matches the current one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">shardsInfo</span><span class="p">.</span><span class="nx">ConfigNum</span> <span class="o">==</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Num</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">shardID</span><span class="p">,</span> <span class="nx">shardData</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shardsInfo</span><span class="p">.</span><span class="nx">Shards</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">stateMachine</span><span class="p">[</span><span class="nx">shardID</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// only pull if the shard is in the Pulling state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">Status</span> <span class="o">==</span> <span class="nx">Pulling</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shardData</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">shard</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// update the shard status to Garbage Collecting.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">shard</span><span class="p">.</span><span class="nx">Status</span> <span class="p">=</span> <span class="nx">GCing</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// update last operations with the provided contexts.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">clientId</span><span class="p">,</span> <span class="nx">operationContext</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shardsInfo</span><span class="p">.</span><span class="nx">LastOperations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">lastOperation</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">clientId</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">lastOperation</span><span class="p">.</span><span class="nx">MaxAppliedCommandId</span> <span class="p">&lt;</span> <span class="nx">operationContext</span><span class="p">.</span><span class="nx">MaxAppliedCommandId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">kv</span><span class="p">.</span><span class="nx">lastOperations</span><span class="p">[</span><span class="nx">clientId</span><span class="p">]</span> <span class="p">=</span> <span class="nx">operationContext</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="p">=</span> <span class="nx">ErrOutDated</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="空日志检测" class="heading-element"><span>2.3.7 空日志检测</span>
  <a href="#%e7%a9%ba%e6%97%a5%e5%bf%97%e6%a3%80%e6%b5%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>根据 raft 论文 5.4.2 节，新 leader 提交之前 term 的日志存在风险。若要提交这类日志，需等新 leader 在自身任期产生新日志，新日志提交时，之前 term 的日志才能随之提交。这意味着若当前 term 迟迟无日志生成并提交，之前 term 的部分日志将一直无法提交，进而可能导致活锁，使日志无法推进。</p>
<p>所以空日志检测协程会定时检测 raft 层的 leader 是否拥有当前 term 的日志，如果没有则提交一条空日志，这使得新 leader 的状态机能够迅速达到最新状态，从而避免多 raft 组间的活锁状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Ensures that a log entry is present in the current term to keep the log active.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">checkEntryInCurrentTermAction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If no log entry exists in the current term, execute an empty command
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">kv</span><span class="p">.</span><span class="nx">rf</span><span class="p">.</span><span class="nf">HasLogInCurrentTerm</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nf">NewEmptyShardsCommand</span><span class="p">(),</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// applyEmptyShards handles the case for empty shards. This is to prevent the state machine from rolling back.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">ShardKV</span><span class="p">)</span> <span class="nf">applyEmptyShards</span><span class="p">()</span> <span class="o">*</span><span class="nx">CommandReply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">CommandReply</span><span class="p">{</span><span class="nx">Err</span><span class="p">:</span> <span class="nx">OK</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="shardkv-clerk" class="heading-element"><span>2.4 shardkv clerk</span>
  <a href="#shardkv-clerk" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>clerk结构体：</p>
<ul>
<li><code>sm</code>：用于和<code>shardctrler</code>交互获取集群最新配置（分片 - 组映射）。</li>
<li><code>config</code>：当前集群配置，决定请求发送的依据。</li>
<li><code>makeEnd</code>：创建与服务器的 RPC 连接。</li>
<li><code>leaderIds</code>：记录组 ID 对应的领导服务器 ID，便于请求发送。</li>
<li><code>clientId</code>和<code>commandId</code>：用于唯一确定客户端操作，保证操作的可识别性和顺序性。</li>
</ul>
<p>这里将四种命令封装成一个<code>command</code>函数，其具体逻辑如下：</p>
<ol>
<li>先将操作参数<code>args</code>中的<code>ClientId</code>和<code>CommandId</code>设置为<code>Clerk</code>结构体中的对应值。</li>
<li>根据操作键确定分片所属组 ID。</li>
<li>组内leader查找与请求发送：
<ul>
<li>若组存在，获取组内服务器列表，确定领导 ID（若未记录则默认为 0）。</li>
<li>尝试向领导服务器发送请求，若请求成功且回复正常（<code>Err</code>为<code>OK</code>或<code>ErrNoKey</code>），则更新<code>commandId</code>并返回结果；若回复<code>ErrWrongGroup</code>，则跳出当前组内循环重新获取配置；若请求失败或回复错误码不符，尝试下一个服务器，若遍历完组内服务器都不行，则跳出组内循环。</li>
</ul>
</li>
<li>配置更新：
<ul>
<li>若不存在对应组或组内无合适服务器处理请求，等待 100 毫秒后从<code>shardctrler</code>获取最新配置，重新开始循环处理请求。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Clerk</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sm</span>      <span class="o">*</span><span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Clerk</span>             <span class="c1">// Client that communicates with the shardctrler to get the latest configuration data (mapping of shards to groups)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">config</span>  <span class="nx">shardctrler</span><span class="p">.</span><span class="nx">Config</span>             <span class="c1">// The current cluster configuration, including the shard-to-group mapping, based on which Clerk sends requests.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">makeEnd</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span> <span class="c1">// Generates an RPC connection to a server, each of which is identified by a unique address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// You will have to modify this struct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">leaderIds</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span> <span class="c1">// gid -&gt; leaderId, gid is the group id, leaderId is the leader server id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">clientId</span>  <span class="kt">int64</span>       <span class="c1">// generated by nrand(), it would be better to use some distributed ID generation algorithm that guarantees no conflicts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">commandId</span> <span class="kt">int64</span>       <span class="c1">// (clientId, commandId) defines a operation uniquely
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Command</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">CommandArgs</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span><span class="p">.</span><span class="nx">ClientId</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">CommandId</span> <span class="p">=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">clientId</span><span class="p">,</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">commandId</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">shard</span> <span class="o">:=</span> <span class="nf">key2shard</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gid</span> <span class="o">:=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Shards</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">servers</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">Groups</span><span class="p">[</span><span class="nx">gid</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// if not set, set the default leader id to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">leaderIds</span><span class="p">[</span><span class="nx">gid</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ck</span><span class="p">.</span><span class="nx">leaderIds</span><span class="p">[</span><span class="nx">gid</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">oldLeaderId</span> <span class="o">:=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">leaderIds</span><span class="p">[</span><span class="nx">gid</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="nx">newLeader</span> <span class="o">:=</span> <span class="nx">oldLeaderId</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">CommandReply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// send the request to the leader server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ck</span><span class="p">.</span><span class="nf">makeEnd</span><span class="p">(</span><span class="nx">servers</span><span class="p">[</span><span class="nx">newLeader</span><span class="p">]).</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;ShardKV.Command&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">OK</span> <span class="o">||</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">ErrNoKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ck</span><span class="p">.</span><span class="nx">commandId</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">ErrWrongGroup</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// try the next server
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">newLeader</span> <span class="p">=</span> <span class="p">(</span><span class="nx">newLeader</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">servers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// check if all servers have been tried
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="k">if</span> <span class="nx">newLeader</span> <span class="o">==</span> <span class="nx">oldLeaderId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="k">break</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Query the latest configuration from the shardctrler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">ck</span><span class="p">.</span><span class="nx">config</span> <span class="p">=</span> <span class="nx">ck</span><span class="p">.</span><span class="nx">sm</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结" class="heading-element"><span>3 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>这个实验难度还是非常大的，基本上不是自己独立完成，借鉴了<a href="https://github.com/OneSizeFitsQuorum"target="_blank" rel="external nofollow noopener noreferrer">Github OneSizeFitsQuorum<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>的很多代码，其讲解也非常详细。最后也是成功通过了实验测试。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125349042.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125349042.png?size=small" data-sub-html="<h2>image-20241020125349042</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125349042.png" alt="image-20241020125349042" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125349042.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125349042.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125349042.png?size=large 2x" data-title="image-20241020125349042" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125315201.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125315201.png?size=small" data-sub-html="<h2>image-20241020125315201</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125315201.png" alt="image-20241020125315201" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125315201.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125315201.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241020125315201.png?size=large 2x" data-title="image-20241020125315201" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从这个实验中也学到了很多：</p>
<ol>
<li>可以将多个操作封装成一个操作接口去处理，能让代码变得更简洁且易于理解，从kvraft-&gt;shardkv，这种设计理想还是非常不错的。</li>
<li>要注意在分片迁移和垃圾回收中，并不是由被拉取的服务器来主动拉取和回收的，而都是由拉取服务器进行RPC操作通知。这样的好处是能够使这两个操作同步，因为被拉取服务器不知道该什么时候回收数据的。</li>
<li>leader不能先更新分片状态，它只能先进行检测，更新还是需要通过raft共识协议，等日志落地后通过apply协程来进行更新，且总是需要去判断leader的身份。</li>
<li>可以通过读写锁来优化并发性能，但需要注意的是何时采用读锁很关键。如果不确定，可以一把大锁保平安。</li>
</ol>
<h2 id="参考" class="heading-element"><span>4 参考</span>
  <a href="#%e5%8f%82%e8%80%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><a href="https://blog.csdn.net/qq_43460956/article/details/134885751"target="_blank" rel="external nofollow noopener noreferrer">MIT 6.824 Lab 4 ShardKV详细实现思路及过程<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md#%E7%BB%93%E6%9E%84"target="_blank" rel="external nofollow noopener noreferrer">Github OneSizeFitsQuorum/MIT6.824-2021<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/464097239"target="_blank" rel="external nofollow noopener noreferrer">知乎mit-6.824 分布式系统2021<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
]]></description></item></channel></rss>