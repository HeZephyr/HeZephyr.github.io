<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>ZephyrHe</title><link>https://hezephyr.github.io/</link><description>HeZephyr's Note Zephyr He的博客：日拱一卒无有尽，功不唐捐终入海</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Sun, 09 Jun 2024 09:39:47 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Shell 23道例题实战</title><link>https://hezephyr.github.io/posts/07.shell%E5%AE%9E%E6%88%98/</link><pubDate>Sun, 09 Jun 2024 09:39:47 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/07.shell%E5%AE%9E%E6%88%98/</guid><description><![CDATA[<h2 id="统计文件的行数" class="heading-element"><span>1 统计文件的行数</span>
  <a href="#%e7%bb%9f%e8%ae%a1%e6%96%87%e4%bb%b6%e7%9a%84%e8%a1%8c%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中的行数</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 方法1：使用 wc -l 和 awk</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 统计行数并使用 awk 提取第一个字段，即行数</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>wc -l nowcoder.txt <span class="p">|</span> awk <span class="s1">&#39;{print $1}&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;使用 wc -l 和 awk：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法2：通过输入流传递文件内容给 wc -l</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 &lt; 操作符</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>wc -l &lt; nowcoder.txt<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;通过输入流：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法3：使用 cat 和管道传递给 wc -l</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 cat 命令和管道</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>cat nowcoder.txt <span class="p">|</span> wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;通过管道：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法4：使用 sed 统计行数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed 的 -n &#39;$=&#39; 选项</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>sed -n <span class="s1">&#39;$=&#39;</span> nowcoder.txt<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;使用 sed：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印文件的最后5行" class="heading-element"><span>2 打印文件的最后5行</span>
  <a href="#%e6%89%93%e5%8d%b0%e6%96%87%e4%bb%b6%e7%9a%84%e6%9c%80%e5%90%8e5%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>查看日志的时候，经常会从文件的末尾往前查看，请你写一个<code>bash shell</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中的最后5行。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 查看文件的前5行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;前5行：&#34;</span>
</span></span><span class="line"><span class="cl">head -5 nowcoder.txt
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看文件的后5行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;后5行：&#34;</span>
</span></span><span class="line"><span class="cl">tail -5 nowcoder.txt
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看文件的第5行到第20行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;第5行到第20行：&#34;</span>
</span></span><span class="line"><span class="cl">sed -n <span class="s1">&#39;5,20p&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="输出-0-到-500-中-7-的倍数" class="heading-element"><span>3 输出 0 到 500 中 7 的倍数</span>
  <a href="#%e8%be%93%e5%87%ba-0-%e5%88%b0-500-%e4%b8%ad-7-%e7%9a%84%e5%80%8d%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个 <code>bash</code>脚本以输出数字 $0$ 到 $500$ 中 $7$ 的倍数$(0 7 14 21&hellip;)$的命令</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 方法1：使用 Bash 的扩展语法的 for 循环</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;方法1：使用 Bash 的扩展语法的 for 循环&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> item in <span class="o">{</span>0..500..7<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> 
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$item</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span> <span class="c1"># 分隔行</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法2：使用 seq 命令 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># seq [选项]... 首部 增量 尾部</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;方法2：使用 seq 命令&#34;</span>
</span></span><span class="line"><span class="cl">seq <span class="m">0</span> <span class="m">7</span> <span class="m">500</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span> <span class="c1"># 分隔行</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法3：使用 while 循环</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;方法3：使用 while 循环&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 初始化变量</span>
</span></span><span class="line"><span class="cl"><span class="nv">i</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 while 循环</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">500</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 输出当前的 7 的倍数</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$i</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 增加 7</span>
</span></span><span class="line"><span class="cl">    <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i <span class="o">+</span> <span class="m">7</span><span class="k">))</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="输出第5行的内容" class="heading-element"><span>4 输出第5行的内容</span>
  <a href="#%e8%be%93%e5%87%ba%e7%ac%ac5%e8%a1%8c%e7%9a%84%e5%86%85%e5%ae%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>bash</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中第$5$行的内容。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># head 命令拿到前五行，再通过通道，通过tail取出来最后一行，即第五行</span>
</span></span><span class="line"><span class="cl">head -n <span class="m">5</span> nowcoder.txt <span class="p">|</span> tail -n <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用sed 命令中的 p选项，打印第五行</span>
</span></span><span class="line"><span class="cl">sed -n 5p nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印空行的行号" class="heading-element"><span>5 打印空行的行号</span>
  <a href="#%e6%89%93%e5%8d%b0%e7%a9%ba%e8%a1%8c%e7%9a%84%e8%a1%8c%e5%8f%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中空行的行号（空行可能连续，从1开始输出）</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep 命令匹配所有空行，并且输出匹配的行号。-n 选项表示输出匹配行的行号，&#39;^$&#39; 匹配空行。使用 cut 命令以 : 作为分隔符，提取每行的第一个字段，即行号。</span>
</span></span><span class="line"><span class="cl">grep -n <span class="s1">&#39;^$&#39;</span> nowcoder.txt <span class="p">|</span> cut -d<span class="s1">&#39;:&#39;</span> -f1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令，NF 表示当前行的字段数，NR 表示当前行号。当字段数为0时，即当前行为空行，{ print NR } 输出当前行的行号。</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;NF == 0 { print NR }&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed 命令匹配所有空行，并输出匹配行的行号。-n 选项表示只输出指定的行，/^$/ 匹配空行，=表示输出匹配行的行号。</span>
</span></span><span class="line"><span class="cl">sed -n <span class="s1">&#39;/^$/=&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="去掉空行" class="heading-element"><span>6 去掉空行</span>
  <a href="#%e5%8e%bb%e6%8e%89%e7%a9%ba%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个 <code>bash</code>脚本以去掉一个文本文件<code>nowcoder.txt</code>中的空行</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep 命令匹配所有非空行。-v 选项表示反转匹配，&#39;^$&#39; 匹配空行。</span>
</span></span><span class="line"><span class="cl">grep -v <span class="s1">&#39;^$&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed 命令删除匹配空行的行。/^$/ 匹配空行，d 命令删除匹配的行</span>
</span></span><span class="line"><span class="cl">sed <span class="s1">&#39;/^$/d&#39;</span> nowcoder.txt &gt; nowcoder_no_empty_lines.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令，NF 表示字段数，NF 为真时表示非空行。</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;NF&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印字母数小于8的单词" class="heading-element"><span>7 打印字母数小于8的单词</span>
  <a href="#%e6%89%93%e5%8d%b0%e5%ad%97%e6%af%8d%e6%95%b0%e5%b0%8f%e4%ba%8e8%e7%9a%84%e5%8d%95%e8%af%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以统计一个文本文件<code>nowcoder.txt</code>中字母数小于8的单词。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令遍历每个单词，NF 表示当前行的单词数，length($i) 表示当前单词的字母数，如果字母数小于8，则打印当前单词。</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ for (i=1; i&lt;=NF; i++) if (length($i)&lt;8) print $i }&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep 命令匹配字母数小于8的单词。-o 选项表示只输出匹配的内容，\b 表示单词边界，\w\{1,7\} 匹配字母数在1到7之间的单词。</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s1">&#39;\b\w\{1,7\}\b&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="统计所有进程占用内存百分比的和" class="heading-element"><span>8 统计所有进程占用内存百分比的和</span>
  <a href="#%e7%bb%9f%e8%ae%a1%e6%89%80%e6%9c%89%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8%e5%86%85%e5%ad%98%e7%99%be%e5%88%86%e6%af%94%e7%9a%84%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设 <code>nowcoder.txt</code> 内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">USER</span>       <span class="n">PID</span> <span class="o">%</span><span class="n">CPU</span> <span class="o">%</span><span class="n">MEM</span>    <span class="n">VSZ</span>   <span class="n">RSS</span> <span class="n">TTY</span>      <span class="n">STAT</span> <span class="n">START</span>   <span class="n">TIME</span> <span class="n">COMMAND</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>         <span class="mi">1</span>  <span class="mf">0.0</span>  <span class="mf">0.4</span>  <span class="mi">77744</span>  <span class="mi">8332</span> <span class="o">?</span>        <span class="n">Ss</span>    <span class="mi">2021</span>   <span class="mi">1</span><span class="o">:</span><span class="mi">15</span> <span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">init</span> <span class="n">noibrs</span> <span class="n">splash</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>         <span class="mi">2</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>      <span class="mi">0</span>     <span class="mi">0</span> <span class="o">?</span>        <span class="n">S</span>     <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="p">[</span><span class="n">kthreadd</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>         <span class="mi">4</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>      <span class="mi">0</span>     <span class="mi">0</span> <span class="o">?</span>        <span class="n">I</span><span class="o">&lt;</span>    <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="p">[</span><span class="n">kworker</span><span class="o">/</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="n">H</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">daemon</span>     <span class="mi">486</span>  <span class="mf">0.0</span>  <span class="mf">0.1</span>  <span class="mi">28340</span>  <span class="mi">2372</span> <span class="o">?</span>        <span class="n">Ss</span>    <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">atd</span> <span class="o">-</span><span class="n">f</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>       <span class="mi">586</span>  <span class="mf">0.0</span>  <span class="mf">0.3</span>  <span class="mi">72308</span>  <span class="mi">6244</span> <span class="o">?</span>        <span class="n">Ss</span>    <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">01</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sshd</span> <span class="o">-</span><span class="n">D</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">12847</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>   <span class="mi">4528</span>    <span class="mi">68</span> <span class="o">?</span>        <span class="n">S</span><span class="o">&lt;</span>   <span class="n">Jan03</span>   <span class="mi">0</span><span class="o">:</span><span class="mi">13</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">atopacctd</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">16306</span>  <span class="mf">1.7</span>  <span class="mf">1.2</span> <span class="mi">151964</span> <span class="mi">26132</span> <span class="o">?</span>        <span class="n">S</span><span class="o">&lt;</span><span class="n">sl</span> <span class="n">Apr15</span> <span class="mi">512</span><span class="o">:</span><span class="mo">03</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">aegis</span><span class="o">/</span><span class="n">aegis_client</span><span class="o">/</span><span class="n">aegis_11_25</span><span class="o">/</span><span class="n">AliYunDun</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24143</span>  <span class="mf">0.0</span>  <span class="mf">0.4</span>  <span class="mi">25608</span>  <span class="mi">8652</span> <span class="o">?</span>        <span class="n">S</span><span class="o">&lt;</span><span class="n">Ls</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">03</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">atop</span> <span class="o">-</span><span class="n">R</span> <span class="o">-</span><span class="n">w</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">log</span><span class="o">/</span><span class="n">atop</span><span class="o">/</span><span class="n">atop_20220505</span> <span class="mi">600</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24901</span>  <span class="mf">0.0</span>  <span class="mf">0.3</span> <span class="mi">107792</span>  <span class="mi">7008</span> <span class="o">?</span>        <span class="n">Ss</span>   <span class="mi">15</span><span class="o">:</span><span class="mi">37</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="nl">sshd</span><span class="p">:</span> <span class="n">root</span><span class="err">@</span><span class="n">pts</span><span class="o">/</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24903</span>  <span class="mf">0.0</span>  <span class="mf">0.3</span>  <span class="mi">76532</span>  <span class="mi">7580</span> <span class="o">?</span>        <span class="n">Ss</span>   <span class="mi">15</span><span class="o">:</span><span class="mi">37</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">systemd</span><span class="o">/</span><span class="n">systemd</span> <span class="o">--</span><span class="n">user</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24904</span>  <span class="mf">0.0</span>  <span class="mf">0.1</span> <span class="mi">111520</span>  <span class="mi">2392</span> <span class="o">?</span>        <span class="n">S</span>    <span class="mi">15</span><span class="o">:</span><span class="mi">37</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="p">(</span><span class="n">sd</span><span class="o">-</span><span class="n">pam</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上内容是通过<code>ps aux</code>命令输出到<code>nowcoder.txt</code>文件中的，请你写一个脚本计算一下所有进程占用内存大小的和。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用awk命令过滤到第一行并累加$4</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;BEGIN { sum=0 } NR &gt; 1 { sum+=$4 } END { print sum }&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用while循环读取，并用if跳过第一行，使用bc进行浮点数加法运算</span>
</span></span><span class="line"><span class="cl"><span class="nv">sum</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="nv">cnt</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nb">read</span> -r line<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="nv">$cnt</span> -gt <span class="m">1</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nv">mem</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $4 }&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">sum</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$sum</span><span class="s2">+</span><span class="nv">$mem</span><span class="s2">&#34;</span> <span class="p">|</span> bc<span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cnt</span><span class="o">=</span><span class="k">$((</span>cnt+1<span class="k">))</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$sum</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nv">sum</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">tail -n +2 nowcoder.txt <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> -r line<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="nv">mem</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $4 }&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">sum</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$sum</span><span class="s2">+</span><span class="nv">$mem</span><span class="s2">&#34;</span> <span class="p">|</span> bc<span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$sum</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$sum</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>Bash</code> 中，<font color="red">管道中的命令会在子 shell 中执行，因此变量修改不会影响主 shell 中的变量</font>。这就是为什么看到 <code>sum</code> 在循环内部被正确更新，但在循环外部仍然是初始值 <code>0</code>。</p>
</blockquote>
<h2 id="统计每个单词出现的个数" class="heading-element"><span>9 统计每个单词出现的个数</span>
  <a href="#%e7%bb%9f%e8%ae%a1%e6%af%8f%e4%b8%aa%e5%8d%95%e8%af%8d%e5%87%ba%e7%8e%b0%e7%9a%84%e4%b8%aa%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以统计一个文本文件<code>nowcoder.txt</code> 中每个单词出现的个数。</p>
<p>为了简单起见，你可以假设：
<code>nowcoder.txt</code>只包括小写字母和空格，每个单词只由小写字母组成，单词间由一个或多个空格字符分隔。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将空格转换为换行符，以便每个单词占一行</span>
</span></span><span class="line"><span class="cl">tr -s <span class="s1">&#39; &#39;</span> <span class="s1">&#39;\n&#39;</span> &lt;nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 对单词进行排序</span>
</span></span><span class="line"><span class="cl">	sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 统计每个单词的出现次数</span>
</span></span><span class="line"><span class="cl">	uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 调整输出格式为&#34;单词 词频&#34;</span>
</span></span><span class="line"><span class="cl">	awk <span class="s1">&#39;{ print $2, $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 按词频升序排序，-k2,2 意味着只使用第二列进行排序，表示按数值进行排序（默认情况按字典序排序）</span>
</span></span><span class="line"><span class="cl">	sort -k2,2n 
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 统计每个单词的出现次数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># NF 表示当前行的字段数，即单词数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用一个关联数组 cnt 存储每个单词出现的次数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i=1; i&lt;=NF; i++)  # 遍历当前行的每个单词
</span></span></span><span class="line"><span class="cl"><span class="s1">        cnt[$i] += 1        # 将单词加入关联数组 cnt，统计出现次数
</span></span></span><span class="line"><span class="cl"><span class="s1">}
</span></span></span><span class="line"><span class="cl"><span class="s1">END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (x in cnt)           # 遍历关联数组 cnt
</span></span></span><span class="line"><span class="cl"><span class="s1">        print x, cnt[x]       # 输出单词和对应的出现次数
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt <span class="p">|</span> sort -k2,2n</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第二列是否有重复" class="heading-element"><span>10 第二列是否有重复</span>
  <a href="#%e7%ac%ac%e4%ba%8c%e5%88%97%e6%98%af%e5%90%a6%e6%9c%89%e9%87%8d%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>给定一个<code>nowcoder.txt</code>文件，其中有3列信息，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">20201001 python 99
</span></span><span class="line"><span class="cl">20201002 go 80
</span></span><span class="line"><span class="cl">20201002 c++ 88
</span></span><span class="line"><span class="cl">20201003 php 77
</span></span><span class="line"><span class="cl">20201001 go 88
</span></span><span class="line"><span class="cl">20201005 shell 89
</span></span><span class="line"><span class="cl">20201006 java 70
</span></span><span class="line"><span class="cl">20201008 c 100
</span></span><span class="line"><span class="cl">20201007 java 88
</span></span><span class="line"><span class="cl">20201006 go 97</span></span></code></pre></td></tr></table>
</div>
</div><p>编写一个<code>shell</code>脚本来检查文件第二列是否有重复，且有几个重复，并提取出重复的行的第二列信息（先按次数排序，如果次数相同，按照单词字母顺序排序），输入如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">2 java
</span></span><span class="line"><span class="cl">3 go</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">cat nowcoder.txt <span class="p">|</span> 
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $2 }&#39;</span> <span class="p">|</span> 
</span></span><span class="line"><span class="cl">sort <span class="p">|</span> uniq -c <span class="p">|</span> 
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span> <span class="p">|</span> <span class="c1"># 重新格式化输出</span>
</span></span><span class="line"><span class="cl">sort -k1,1n -k2,2 <span class="p">|</span> <span class="c1"># 按照出现次数和字母顺序排序</span>
</span></span><span class="line"><span class="cl">grep -v <span class="s1">&#39;1&#39;</span>	<span class="c1"># 过滤出现次数不为 1 的行</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="转置文件的内容" class="heading-element"><span>11 转置文件的内容</span>
  <a href="#%e8%bd%ac%e7%bd%ae%e6%96%87%e4%bb%b6%e7%9a%84%e5%86%85%e5%ae%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本来转置文本文件<code>nowcoder.txt</code>中的文件内容。
文件中每行列数相同，并且每个字段由空格分隔</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 读取文件并使用 awk 转置文件内容</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">{
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 遍历当前行的每一个字段
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        a[NR, i] = $i  # 将每个字段存储在一个二维数组中，a[行号, 列号] = 值
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}
</span></span></span><span class="line"><span class="cl"><span class="s1">NF &gt; p { p = NF }  # 如果当前行的字段数大于 p，则更新 p 为当前行的字段数
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 遍历每一列（由最大字段数 p 确定）
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= p; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        # 遍历每一行（由总行数 NR 确定）
</span></span></span><span class="line"><span class="cl"><span class="s1">        for (j = 1; j &lt;= NR; j++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">            printf(&#34;%s%s&#34;, a[j,i], (j==NR ? &#34;&#34; : &#34; &#34;))  # 输出数组中对应的字段值，并在每个字段后添加空格，除非是最后一个字段
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf(&#34;\n&#34;)  # 每一列输出完之后换行
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印每一行出现的数字个数" class="heading-element"><span>12 打印每一行出现的数字个数</span>
  <a href="#%e6%89%93%e5%8d%b0%e6%af%8f%e4%b8%80%e8%a1%8c%e5%87%ba%e7%8e%b0%e7%9a%84%e6%95%b0%e5%ad%97%e4%b8%aa%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本，统计一个文本文件<code>nowcoder.txt</code>中每一行出现的<code>1~5</code>数字的个数，并且计算一下整个文档中一共出现了几个<code>1~5</code>数字的总数。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 读取文件并统计每行中包含的特定数字（1, 2, 3, 4, 5）的数量</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;[1,2,3,4,5]&#34;</span> <span class="s1">&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">BEGIN { 
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum = 0  # 初始化 sum 变量，用于存储总和
</span></span></span><span class="line"><span class="cl"><span class="s1">} {
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 打印当前行号 NR 以及当前行中包含的特定数字的数量 (NF - 1)
</span></span></span><span class="line"><span class="cl"><span class="s1">    print(&#34;line&#34; NR &#34; number: &#34; (NF - 1))
</span></span></span><span class="line"><span class="cl"><span class="s1">    
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 将当前行中包含的特定数字的数量累加到 sum
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum += (NF - 1)
</span></span></span><span class="line"><span class="cl"><span class="s1">} END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 打印总和
</span></span></span><span class="line"><span class="cl"><span class="s1">    print(&#34;sum is &#34; sum)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="去掉所有包含this的句子" class="heading-element"><span>13 去掉所有包含this的句子</span>
  <a href="#%e5%8e%bb%e6%8e%89%e6%89%80%e6%9c%89%e5%8c%85%e5%90%abthis%e7%9a%84%e5%8f%a5%e5%ad%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本以实现如下功能：去掉输入中含有<code>this</code>的语句，把不含<code>this</code>的语句输出</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># -v 反转匹配</span>
</span></span><span class="line"><span class="cl">grep -v <span class="s2">&#34;this&#34;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># sed 命令 -&gt; d 删除 -&gt; // 包含要搜索的字符串</span>
</span></span><span class="line"><span class="cl">sed <span class="s1">&#39;/this/d&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># awk 命令，$0为当前行的所有内容，!~ 是 awk 的模式匹配运算符，表示模式不匹配</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;$0!~/this/ {print $0}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="求平均值" class="heading-element"><span>14 求平均值</span>
  <a href="#%e6%b1%82%e5%b9%b3%e5%9d%87%e5%80%bc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以实现一个需求，求输入的一个数组的平均值</p>
<p>第<code>1</code>行为输入的数组长度<code>N</code></p>
<p>第<code>2~N</code>行为数组的元素，如以下为:
数组长度为<code>4</code>，数组元素为<code>1 2 9 8</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;BEGIN {
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum = 0
</span></span></span><span class="line"><span class="cl"><span class="s1">}{
</span></span></span><span class="line"><span class="cl"><span class="s1">    if (NR == 1) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        N = $1  # 将第一行的数字数量保存到变量 N 中
</span></span></span><span class="line"><span class="cl"><span class="s1">    } else {
</span></span></span><span class="line"><span class="cl"><span class="s1">        sum += $1  # 对随后的数字进行累加求和
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">} END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf(&#34;%.3f&#34;, sum / N)  # 输出平均值，保留三位小数
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="去掉不需要的单词" class="heading-element"><span>15 去掉不需要的单词</span>
  <a href="#%e5%8e%bb%e6%8e%89%e4%b8%8d%e9%9c%80%e8%a6%81%e7%9a%84%e5%8d%95%e8%af%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以实现一个需求，去掉输入中含有<code>B</code>和<code>b</code>的单词。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed -n 命令打印不包含 &#39;B&#39; 和 &#39;b&#39; 的行</span>
</span></span><span class="line"><span class="cl"><span class="c1"># /^[^bB]*$/ 表示匹配不包含 &#39;B&#39; 和 &#39;b&#39; 的行，^ 表示行开头，[^bB] 表示不包含 &#39;B&#39; 和 &#39;b&#39; 的任何字符，* 表示零次或多次重复，$ 表示行结尾</span>
</span></span><span class="line"><span class="cl">sed -n <span class="s1">&#39;/^[^bB]*$/p&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep -E -v 命令排除包含 &#39;B&#39; 和 &#39;b&#39; 的行</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -E 选项启用扩展的正则表达式，-v 选项表示反转匹配</span>
</span></span><span class="line"><span class="cl">grep -E -v <span class="s2">&#34;[bB]&#34;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令，遍历每个单词，如果不包含 &#39;B&#39; 和 &#39;b&#39;，则输出该单词</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1;i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        if ($i !~ /b|B/) {  # 使用正则表达式匹配单词中不包含 &#39;</span>B<span class="s1">&#39; 和 &#39;</span>b<span class="s1">&#39; 的部分
</span></span></span><span class="line"><span class="cl"><span class="s1">            printf(&#34;%s &#34;, $i)  # 输出不包含 &#39;</span>B<span class="s1">&#39; 和 &#39;</span>b<span class="s1">&#39; 的单词
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="判断输入的是否为ip地址" class="heading-element"><span>16 判断输入的是否为IP地址</span>
  <a href="#%e5%88%a4%e6%96%ad%e8%be%93%e5%85%a5%e7%9a%84%e6%98%af%e5%90%a6%e4%b8%baip%e5%9c%b0%e5%9d%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个脚本统计文件<code>nowcoder.txt</code>中的每一行是否是正确的<code>IP</code>地址。</p>
<p>如果是正确的<code>IP</code>地址输出：<code>yes</code></p>
<p>如果是错误的<code>IP</code>地址，且是四段号码的话输出：<code>no</code>，否则的话输出：<code>error</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;.&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    flag = &#34;error&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">    if (NF == 4) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        flag = &#34;yes&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">        for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">            if ($i &gt; 255) {
</span></span></span><span class="line"><span class="cl"><span class="s1">                flag = &#34;no&#34;;
</span></span></span><span class="line"><span class="cl"><span class="s1">                break;
</span></span></span><span class="line"><span class="cl"><span class="s1">            }
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf(flag&#34;\n&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="将字段逆序输出文件的每行" class="heading-element"><span>17 将字段逆序输出文件的每行</span>
  <a href="#%e5%b0%86%e5%ad%97%e6%ae%b5%e9%80%86%e5%ba%8f%e8%be%93%e5%87%ba%e6%96%87%e4%bb%b6%e7%9a%84%e6%af%8f%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本，将文件<code>nowcoder.txt</code>中每一行的字段逆序输出，其中字段之间使用英文冒号<code>:</code>相分隔。</p>
<p>假设<code>nowcoder.txt</code>内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
</span></span><span class="line"><span class="cl">root:*:0:0:System Administrator:/var/root:/bin/sh</span></span></code></pre></td></tr></table>
</div>
</div><p>你的脚本应当输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">/usr/bin/false:/var/empty:Unprivileged User:-2:-2:*:nobody
</span></span><span class="line"><span class="cl">/bin/sh:/var/root:System Administrator:0:0:*:root</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        temp[i] = $i
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = NF; i &gt;= 1; i--) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf(&#34;%s%s&#34;, temp[i], (i == 1 ? &#34;\n&#34; : &#34;:&#34;))
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="域名进行计数排序处理" class="heading-element"><span>18 域名进行计数排序处理</span>
  <a href="#%e5%9f%9f%e5%90%8d%e8%bf%9b%e8%a1%8c%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f%e5%a4%84%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设有一些域名，存储在<code>nowcoder.txt</code>里，现在需要写一个<code>shell</code>脚本，将域名取出并根据域名进行计数排序处理（降序）。</p>
<p>假设<code>nowcoder.txt</code>内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">http://www.nowcoder.com/index.html
</span></span><span class="line"><span class="cl">http://www.nowcoder.com/1.html
</span></span><span class="line"><span class="cl">http://m.nowcoder.com/index.html</span></span></code></pre></td></tr></table>
</div>
</div><p>你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">2 www.nowcoder.com
</span></span><span class="line"><span class="cl">1 m.nowcoder.com</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s1">&#39;/&#39;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    print($3)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    print($1&#34; &#34;$2)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印等腰三角形" class="heading-element"><span>19 打印等腰三角形</span>
  <a href="#%e6%89%93%e5%8d%b0%e7%ad%89%e8%85%b0%e4%b8%89%e8%a7%92%e5%bd%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本，输入正整数<code>n</code>，打印边长为<code>n</code>的等腰三角形。</p>
<p>示例：</p>
<p>输入：<code>5</code></p>
<p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">    *
</span></span><span class="line"><span class="cl">   * *
</span></span><span class="line"><span class="cl">  * * *
</span></span><span class="line"><span class="cl"> * * * *
</span></span><span class="line"><span class="cl">* * * * *</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nb">read</span> n
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 1<span class="p">;</span> i &lt;<span class="o">=</span> n<span class="p">;</span> i++<span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">((</span><span class="nv">j</span> <span class="o">=</span> 1<span class="p">;</span> j &lt;<span class="o">=</span> n - i<span class="p">;</span> j++<span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span>
</span></span><span class="line"><span class="cl">        <span class="nb">printf</span> <span class="s2">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">done</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">((</span><span class="nv">j</span> <span class="o">=</span> 1<span class="p">;</span> j &lt;<span class="o">=</span> i<span class="p">;</span> j++<span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$j</span> -eq <span class="nv">$i</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="nb">printf</span> <span class="s2">&#34;*&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="nb">printf</span> <span class="s2">&#34;* &#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="k">done</span>
</span></span><span class="line"><span class="cl">    <span class="nb">printf</span> <span class="s2">&#34;\n&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印只有一个数字的行" class="heading-element"><span>20 打印只有一个数字的行</span>
  <a href="#%e6%89%93%e5%8d%b0%e5%8f%aa%e6%9c%89%e4%b8%80%e4%b8%aa%e6%95%b0%e5%ad%97%e7%9a%84%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设有一个<code>nowcoder.txt</code>，编写脚本，打印只有一个数字的行。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;[0-9]&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    if (NF == 2) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        print($0)
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="格式化输出" class="heading-element"><span>21 格式化输出</span>
  <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>有一个文件<code>nowcoder.txt</code>，里面的每一行都是一个数字串，编写一个<code>shell</code>脚本对文件中每一行的数字串进行格式化：每$3$个数字加入一个逗号（,）。</p>
<p>例如：数字串为“123456789”，那么需要格式化为123,456,789。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用-F分割数字串</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf($i)
</span></span></span><span class="line"><span class="cl"><span class="s1">        if ((NF - i) % 3 == 0 &amp;&amp; i != NF) {
</span></span></span><span class="line"><span class="cl"><span class="s1">            printf(&#34;,&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf(&#34;\n&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="处理文本" class="heading-element"><span>22 处理文本</span>
  <a href="#%e5%a4%84%e7%90%86%e6%96%87%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>有一个文本文件<code>nowcoder.txt</code>，假设内容格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">111:13443
</span></span><span class="line"><span class="cl">222:13211
</span></span><span class="line"><span class="cl">111:13643
</span></span><span class="line"><span class="cl">333:12341
</span></span><span class="line"><span class="cl">222:12123</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写一个<code>shell</code>脚本，按照以下的格式输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">[111]
</span></span><span class="line"><span class="cl">13443
</span></span><span class="line"><span class="cl">13643
</span></span><span class="line"><span class="cl">[222]
</span></span><span class="line"><span class="cl">13211
</span></span><span class="line"><span class="cl">12123
</span></span><span class="line"><span class="cl">[333]
</span></span><span class="line"><span class="cl">12341</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    cnt[$1] = cnt[$1] $2 &#34;\n&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">} END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i in cnt) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf(&#34;[%s]\n%s&#34;, i, cnt[i])
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析1-ip访问次数统计" class="heading-element"><span>23 Nginx日志分析1-IP访问次数统计</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%901-ip%e8%ae%bf%e9%97%ae%e6%ac%a1%e6%95%b0%e7%bb%9f%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设 <code>Nginx</code> 的日志存储在 <code>nowcoder.txt</code> 里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.23</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">22</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.24</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">22</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.25</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">22</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">26</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">08</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.25</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">16</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.24</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.25</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写 Shell 脚本统计出 2020 年 4 月 23 号访问 IP 的对应次数，并且按照次数降序排序。你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">5</span> <span class="mf">192.168.1.22</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mf">192.168.1.21</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="mf">192.168.1.20</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mf">192.168.1.25</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mf">192.168.1.24</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 通过grep过滤，再统计排序</span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;23/Apr/2020&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析2-统计某个时间段的ip访问量" class="heading-element"><span>24 Nginx日志分析2-统计某个时间段的IP访问量</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%902-%e7%bb%9f%e8%ae%a1%e6%9f%90%e4%b8%aa%e6%97%b6%e9%97%b4%e6%ae%b5%e7%9a%84ip%e8%ae%bf%e9%97%ae%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设 <code>Nginx</code> 的日志存储在 <code>nowcoder.txt</code> 里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写 <code>Shell</code> 脚本统计 2020年04月23日20点至23点去重后的 IP 访问量，你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">5</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出说明：2020年04月23日20点至23点，共有 192.168.1.24、192.168.1.25、192.168.1.20、192.168.1.21、192.168.1.22 共 5 个 IP 访问了。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;23/Apr/2020:2[0-3]&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq <span class="p">|</span>
</span></span><span class="line"><span class="cl">wc -l</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析3-统计访问3次以上的ip" class="heading-element"><span>25 nginx日志分析3-统计访问3次以上的IP</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%903-%e7%bb%9f%e8%ae%a1%e8%ae%bf%e9%97%ae3%e6%ac%a1%e4%bb%a5%e4%b8%8a%e7%9a%84ip" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>nginx</code>的日志我们存储在nowcoder.txt里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>shell</code>脚本统计访问3次以上的IP，你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">6 192.168.1.22
</span></span><span class="line"><span class="cl">5 192.168.1.21
</span></span><span class="line"><span class="cl">4 192.168.1.20</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1 }&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    if ($1 &gt; 3) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        print $1, $2
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析4-查询某个ip的详细访问情况" class="heading-element"><span>26 Nginx日志分析4-查询某个IP的详细访问情况</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%904-%e6%9f%a5%e8%af%a2%e6%9f%90%e4%b8%aaip%e7%9a%84%e8%af%a6%e7%bb%86%e8%ae%bf%e9%97%ae%e6%83%85%e5%86%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>Nginx</code>的日志存储在<code>nowcoder.txt</code>里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>shell</code>脚本查询192.168.1.22的详细访问次数情况，按访问频率降序排序。你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">/</span><span class="mi">1</span><span class="o">/</span><span class="n">index</span><span class="p">.</span><span class="n">php</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">/</span><span class="mi">3</span><span class="o">/</span><span class="n">index</span><span class="p">.</span><span class="n">php</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;192.168.1.22&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $7 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析5-统计爬虫抓取404的次数" class="heading-element"><span>27 nginx日志分析5-统计爬虫抓取404的次数</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%905-%e7%bb%9f%e8%ae%a1%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96404%e7%9a%84%e6%ac%a1%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>nginx</code>的日志存储在<code>nowcoder.txt</code>里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 301 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 500 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:21:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:05:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 300 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 500 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:59:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>shell</code>脚本统计百度爬虫抓取404的次数，你的脚本应该输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">2</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;404&#34;</span> <span class="p">|</span> grep <span class="s2">&#34;www.baidu.com&#34;</span> <span class="p">|</span> wc -l</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析6-统计每分钟的请求数" class="heading-element"><span>28 Nginx日志分析6-统计每分钟的请求数</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%906-%e7%bb%9f%e8%ae%a1%e6%af%8f%e5%88%86%e9%92%9f%e7%9a%84%e8%af%b7%e6%b1%82%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>Nginx</code>的日志存储在nowcoder.txt里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:21:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:05:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Baiduspider&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Baiduspider&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:15:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:59:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>Shell</code>脚本统计每分钟的请求数，并且按照请求数降序排序。你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">5</span> <span class="mi">20</span><span class="o">:</span><span class="mi">27</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">15</span><span class="o">:</span><span class="mo">00</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">22</span><span class="o">:</span><span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">14</span><span class="o">:</span><span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">10</span><span class="o">:</span><span class="mi">27</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">23</span><span class="o">:</span><span class="mi">59</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">21</span><span class="o">:</span><span class="mi">21</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">16</span><span class="o">:</span><span class="mi">15</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">15</span><span class="o">:</span><span class="mi">26</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">09</span><span class="o">:</span><span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">08</span><span class="o">:</span><span class="mo">05</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{ print $2&#34;:&#34;$3 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习1-查看各个状态的连接数" class="heading-element"><span>29 netstat练习1-查看各个状态的连接数</span>
  <a href="#netstat%e7%bb%83%e4%b9%a01-%e6%9f%a5%e7%9c%8b%e5%90%84%e4%b8%aa%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9e%e6%8e%a5%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设netstat命令运行的结果我们存储在nowcoder.txt里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写shell脚本查看系统tcp连接中各个状态的连接数，并且按照连接数降序输出。你的脚本应该输出如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">ESTABLISHED 22
</span></span><span class="line"><span class="cl">TIME_WAIT 9
</span></span><span class="line"><span class="cl">LISTEN 3</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;tcp&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $6 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -nr <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $2, $1 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习2-查看和3306端口建立的连接" class="heading-element"><span>30 netstat练习2-查看和3306端口建立的连接</span>
  <a href="#netstat%e7%bb%83%e4%b9%a02-%e6%9f%a5%e7%9c%8b%e5%92%8c3306%e7%ab%af%e5%8f%a3%e5%bb%ba%e7%ab%8b%e7%9a%84%e8%bf%9e%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设netstat命令运行的结果我们存储在nowcoder.txt里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.143:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你查看和本机3306端口建立连接并且状态是<code>established</code>的所有IP，按照连接数降序排序。你的脚本应该输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">10 172.16.0.24
</span></span><span class="line"><span class="cl">9 172.16.34.144
</span></span><span class="line"><span class="cl">1 172.16.34.143</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;tcp.*ESTABLISHED&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $5 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;$2 == 3306 { print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -nr <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习3-输出每个ip的连接数" class="heading-element"><span>31 netstat练习3-输出每个IP的连接数</span>
  <a href="#netstat%e7%bb%83%e4%b9%a03-%e8%be%93%e5%87%ba%e6%af%8f%e4%b8%aaip%e7%9a%84%e8%bf%9e%e6%8e%a5%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>netstat</code>命令运行的结果我们存储在<code>nowcoder.txt</code>里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.143:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你输出每个IP的连接数，按照连接数降序排序。你的脚本应该输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">172.16.0.24 10
</span></span><span class="line"><span class="cl">172.16.34.144 9
</span></span><span class="line"><span class="cl">100.100.142.4 3
</span></span><span class="line"><span class="cl">0.0.0.0 3
</span></span><span class="line"><span class="cl">172.16.34.143 1
</span></span><span class="line"><span class="cl">172.16.240.74 1
</span></span><span class="line"><span class="cl">120.55.222.235 1
</span></span><span class="line"><span class="cl">100.100.54.133 1
</span></span><span class="line"><span class="cl">100.100.45.106 1
</span></span><span class="line"><span class="cl">100.100.32.118 1
</span></span><span class="line"><span class="cl">100.100.30.25 1
</span></span><span class="line"><span class="cl">100.100.142.5 1
</span></span><span class="line"><span class="cl">100.100.142.1 1</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;tcp&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $5 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -nr <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $2, $1 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习4-输出和3306端口建立连接总的各个状态的数目" class="heading-element"><span>32 netstat练习4-输出和3306端口建立连接总的各个状态的数目</span>
  <a href="#netstat%e7%bb%83%e4%b9%a04-%e8%be%93%e5%87%ba%e5%92%8c3306%e7%ab%af%e5%8f%a3%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e6%80%bb%e7%9a%84%e5%90%84%e4%b8%aa%e7%8a%b6%e6%80%81%e7%9a%84%e6%95%b0%e7%9b%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>netstat</code>命令运行的结果我们存储在<code>nowcoder.txt</code>里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.143:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你输出和本机3306端口建立连接的各个状态的数目，按照以下格式输出
<code>TOTAL_IP</code>表示建立连接的ip数目</p>
<p><code>TOTAL_LINK</code>表示建立连接的总数目</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">TOTAL_IP 3
</span></span><span class="line"><span class="cl">ESTABLISHED 20
</span></span><span class="line"><span class="cl">TOTAL_LINK 20</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 统计包含3306且协议为tcp的总IP数量</span>
</span></span><span class="line"><span class="cl"><span class="nv">TOTAL_IP</span><span class="o">=</span><span class="k">$(</span>grep <span class="s2">&#34;tcp&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk <span class="s1">&#39;{ print $5 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F: <span class="s1">&#39;$2 == 3306 {print $1, $2 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">	sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">	uniq <span class="p">|</span>
</span></span><span class="line"><span class="cl">	wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;TOTAL_IP </span><span class="nv">$TOTAL_IP</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 统计包含3306且状态为ESTABLISHED且协议为tcp的数量</span>
</span></span><span class="line"><span class="cl"><span class="nv">ESTABLISHED</span><span class="o">=</span><span class="k">$(</span>awk <span class="s1">&#39;/3306/ { if ($6 == &#34;ESTABLISHED&#34; &amp;&amp; $1 == &#34;tcp&#34;) print $5 }&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;ESTABLISHED </span><span class="nv">$ESTABLISHED</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 统计包含3306且协议为tcp的连接数量</span>
</span></span><span class="line"><span class="cl"><span class="nv">TOTAL_LINK</span><span class="o">=</span><span class="k">$(</span>awk <span class="s1">&#39;/3306/ { if ($1 == &#34;tcp&#34;) print $5 }&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;TOTAL_LINK </span><span class="nv">$TOTAL_LINK</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="业务分析-提取值" class="heading-element"><span>33 业务分析-提取值</span>
  <a href="#%e4%b8%9a%e5%8a%a1%e5%88%86%e6%9e%90-%e6%8f%90%e5%8f%96%e5%80%bc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设我们的日志<code>nowcoder.txt</code>里，内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">12-May-2017 10:02:22.789 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server version:Apache Tomcat/8.5.15
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.813 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:May 5 2017 11:03:04 UTC
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.813 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server number:8.5.15.0
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.814 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:Windows, OS Version:10
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.814 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:x86_64</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你提取出对应的值，输出内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">serverVersion:Apache Tomcat/8.5.15
</span></span><span class="line"><span class="cl">serverName:8.5.15.0
</span></span><span class="line"><span class="cl">osName:Windows
</span></span><span class="line"><span class="cl">osVersion:10</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;Server version:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print &#34;serverVersion:&#34; $2}&#39;</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;Server number:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print &#34;serverName:&#34; $2}&#39;</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;OS Name:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;[:,]&#34;</span> <span class="s1">&#39;{print &#34;osName:&#34; $2}&#39;</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;OS Version:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print &#34;osVersion:&#34; $2}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ps分析-统计vszrss各自总和" class="heading-element"><span>34 ps分析-统计VSZ,RSS各自总和</span>
  <a href="#ps%e5%88%86%e6%9e%90-%e7%bb%9f%e8%ae%a1vszrss%e5%90%84%e8%87%aa%e6%80%bb%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设命令运行的结果我们存储在<code>nowcoder.txt</code>里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span class="line"><span class="cl">root         1  0.0  0.1  37344  4604 ?        Ss    2020   2:13 /sbin/init
</span></span><span class="line"><span class="cl">root       231  0.0  1.5 166576 62740 ?        Ss    2020  15:15 /lib/systemd/systemd-journald
</span></span><span class="line"><span class="cl">root       237  0.0  0.0      0     0 ?        S&lt;    2020   2:06 [kworker/0:1H]
</span></span><span class="line"><span class="cl">root       259  0.0  0.0  45004  3416 ?        Ss    2020   0:25 /lib/systemd/systemd-udevd
</span></span><span class="line"><span class="cl">root       476  0.0  0.0      0     0 ?        S&lt;    2020   0:00 [edac-poller]
</span></span><span class="line"><span class="cl">root       588  0.0  0.0 276244  2072 ?        Ssl   2020   9:49 /usr/lib/accountsservice/accounts-daemon
</span></span><span class="line"><span class="cl">message+   592  0.0  0.0  42904  3032 ?        Ss    2020   0:01 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation
</span></span><span class="line"><span class="cl">root       636  0.0  0.0  65532  3200 ?        Ss    2020   1:51 /usr/sbin/sshd -D
</span></span><span class="line"><span class="cl">daemon     637  0.0  0.0  26044  2076 ?        Ss    2020   0:00 /usr/sbin/atd -f
</span></span><span class="line"><span class="cl">root       639  0.0  0.0  29476  2696 ?        Ss    2020   3:29 /usr/sbin/cron -f
</span></span><span class="line"><span class="cl">root       643  0.0  0.0  20748  1992 ?        Ss    2020   0:26 /lib/systemd/systemd-logind
</span></span><span class="line"><span class="cl">syslog     645  0.0  0.0 260636  3024 ?        Ssl   2020   3:17 /usr/sbin/rsyslogd -n
</span></span><span class="line"><span class="cl">root       686  0.0  0.0 773124  2836 ?        Ssl   2020  26:45 /usr/sbin/nscd
</span></span><span class="line"><span class="cl">root       690  0.0  0.0  19472   252 ?        Ss    2020  14:39 /usr/sbin/irqbalance --pid=/var/run/irqbalance.pid
</span></span><span class="line"><span class="cl">ntp        692  0.0  0.0  98204   776 ?        Ss    2020  25:18 /usr/sbin/ntpd -p /var/run/ntpd.pid -g -u 108:114
</span></span><span class="line"><span class="cl">uuidd      767  0.0  0.0  28624   192 ?        Ss    2020   0:00 /usr/sbin/uuidd --socket-activation
</span></span><span class="line"><span class="cl">root       793  0.0  0.0 128812  3148 ?        Ss    2020   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;
</span></span><span class="line"><span class="cl">www-data   794  0.0  0.2 133376  9120 ?        S     2020 630:57 nginx: worker process
</span></span><span class="line"><span class="cl">www-data   795  0.0  0.2 133208  8968 ?        S     2020 633:02 nginx: worker process
</span></span><span class="line"><span class="cl">www-data   796  0.0  0.2 133216  9120 ?        S     2020 634:24 nginx: worker process
</span></span><span class="line"><span class="cl">www-data   797  0.0  0.2 133228  9148 ?        S     2020 632:56 nginx: worker process
</span></span><span class="line"><span class="cl">web        955  0.0  0.0  36856  2112 ?        Ss    2020   0:00 /lib/systemd/systemd --user
</span></span><span class="line"><span class="cl">web        956  0.0  0.0  67456  1684 ?        S     2020   0:00 (sd-pam)
</span></span><span class="line"><span class="cl">root      1354  0.0  0.0   8172   440 tty1     Ss+   2020   0:00 /sbin/agetty --noclear tty1 linux
</span></span><span class="line"><span class="cl">root      1355  0.0  0.0   7988   344 ttyS0    Ss+   2020   0:00 /sbin/agetty --keep-baud 115200 38400 9600 ttyS0 vt220
</span></span><span class="line"><span class="cl">root      2513  0.0  0.0      0     0 ?        S    13:07   0:00 [kworker/u4:1]
</span></span><span class="line"><span class="cl">root      2587  0.0  0.0      0     0 ?        S    13:13   0:00 [kworker/u4:2]
</span></span><span class="line"><span class="cl">root      2642  0.0  0.0      0     0 ?        S    13:17   0:00 [kworker/1:0]
</span></span><span class="line"><span class="cl">root      2679  0.0  0.0      0     0 ?        S    13:19   0:00 [kworker/u4:0]
</span></span><span class="line"><span class="cl">root      2735  0.0  0.1 102256  7252 ?        Ss   13:24   0:00 sshd: web [priv]
</span></span><span class="line"><span class="cl">web       2752  0.0  0.0 102256  3452 ?        R    13:24   0:00 sshd: web@pts/0
</span></span><span class="line"><span class="cl">web       2753  0.5  0.1  14716  4708 pts/0    Ss   13:24   0:00 -bash
</span></span><span class="line"><span class="cl">web       2767  0.0  0.0  29596  1456 pts/0    R+   13:24   0:00 ps aux
</span></span><span class="line"><span class="cl">root     10634  0.0  0.0      0     0 ?        S    Nov16   0:00 [kworker/0:0]
</span></span><span class="line"><span class="cl">root     16585  0.0  0.0      0     0 ?        S&lt;    2020   0:00 [bioset]
</span></span><span class="line"><span class="cl">root     19526  0.0  0.0      0     0 ?        S    Nov16   0:00 [kworker/1:1]
</span></span><span class="line"><span class="cl">root     28460  0.0  0.0      0     0 ?        S    Nov15   0:03 [kworker/0:2]
</span></span><span class="line"><span class="cl">root     30685  0.0  0.0  36644  2760 ?        Ss    2020   0:00 /lib/systemd/systemd --user
</span></span><span class="line"><span class="cl">root     30692  0.0  0.0  67224  1664 ?        S     2020   0:00 (sd-pam)
</span></span><span class="line"><span class="cl">root     32689  0.0  0.0  47740  2100 ?        Ss    2020   0:00 /usr/local/ilogtail/ilogtail
</span></span><span class="line"><span class="cl">root     32691  0.2  0.5 256144 23708 ?        Sl    2020 1151:31 /usr/local/ilogtail/ilogtail</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你统计<code>VSZ</code>，<code>RSS</code>各自的总和（以M兆为统计），输出格式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">MEM TOTAL
</span></span><span class="line"><span class="cl">VSZ_SUM:3250.8M,RSS_SUM:179.777M</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum_vsz = sum_vsz + $5
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum_rss = sum_rss + $6
</span></span></span><span class="line"><span class="cl"><span class="s1">}END{
</span></span></span><span class="line"><span class="cl"><span class="s1">    print(&#34;MEM TOTAL \n&#34; &#34;VSZ_SUM:&#34; sum_vsz/1024 &#34;M,&#34; &#34;RSS_SUM:&#34; sum_rss/1024 &#34;M&#34;)}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>计算机网络 面试题目总结</title><link>https://hezephyr.github.io/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</link><pubDate>Sun, 02 Jun 2024 19:45:50 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="基础" class="heading-element"><span>1 基础</span>
  <a href="#%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="计算机网络体系结构" class="heading-element"><span>1.1 计算机网络体系结构</span>
  <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 OSI 七层模型、TCP/IP 四层模型和五层体系结构。<font color="red">OSI 是理论上的网络通信模型，TCP/IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。</font></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/计算机网络体系结构.png?size=small" data-sub-html="<h2>image-20240601203255272</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png" alt="image-20240601203255272" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=large 2x" data-title="image-20240601203255272" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="说说-osi-七层模型" class="heading-element"><span>1.2 说说 OSI 七层模型？</span>
  <a href="#%e8%af%b4%e8%af%b4-osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>OSI七层模型是一个用来描述计算机网络体系结构的标准模型。它将网络通信划分为七个抽象层，每一层都负责特定的功能，从物理连接到应用程序。这些层从下到上分别是：</p>
<ol>
<li>物理层（Physical Layer）：负责传输比特流，并管理物理介质。</li>
<li>数据链路层（Data Link Layer）：处理帧的传输，通过物理地址进行寻址。</li>
<li>网络层（Network Layer）：负责数据包的路由和转发，实现不同网络之间的通信。</li>
<li>传输层（Transport Layer）：提供端到端的可靠数据传输，包括错误检测、流量控制和分段重组。</li>
<li>会话层（Session Layer）：负责建立、管理和终止会话连接，以及数据的同步和恢复。</li>
<li>表示层（Presentation Layer）：处理数据的格式化和表示，确保不同系统的数据格式能够互相理解。</li>
<li>应用层（Application Layer）：提供用户与网络服务的接口，包括各种应用程序和协议，如HTTP、FTP和SMTP。</li>
</ol>
<h3 id="说说-tcpip-四层模型" class="heading-element"><span>1.3 说说 TCP/IP 四层模型？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcpip-%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP/IP 合并了 OSI 的部分层次，专注于高效的网络通信实践，更具实用性。</p>
<ol>
<li>网络接口层（Network Interface Layer）：对应于 OSI 模型的物理层和数据链路层。负责数据帧的物理传输，包括硬件地址寻址（MAC 地址），数据封装和解封装，错误检测和纠正等。</li>
<li>网际层（Internet Layer）对应于 OSI 模型的网络层。主要协议是 IP，负责数据包的寻址和路由。这一层还包括 ICMP 协议。</li>
<li>传输层（Transport Layer）：对应于 OSI 模型的传输层。负责提供端到端的数据传输服务，包括数据分割、流量控制、错误恢复等。主要的协议有 TCP 和 UDP</li>
<li>应用层（Application Layer）：对应于 OSI 模型的会话层、表示层和应用层。包括所有与网络有关的高级协议，如 HTTP、FTP、SMTP 等。</li>
</ol>
<h3 id="说说五层体系结构" class="heading-element"><span>1.4 说说五层体系结构？</span>
  <a href="#%e8%af%b4%e8%af%b4%e4%ba%94%e5%b1%82%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>是对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p>
<ul>
<li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li>
<li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li>
<li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li>
<li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li>
<li>物理层：电缆、光纤、无线电频谱、网络适配器等。</li>
</ul>
<h3 id="说一下每一层对应的网络协议有哪些" class="heading-element"><span>1.5 说一下每一层对应的网络协议有哪些？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e6%af%8f%e4%b8%80%e5%b1%82%e5%af%b9%e5%ba%94%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center">OSI七层网络模型</th>
<th style="text-align:center">TCP/IP四层模型</th>
<th style="text-align:center">对应的网络协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">HTTP、DNS、FTP、NFS、WAIS、SMIP、Telnet、SNMP</td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">TIFF、GIF、JPEG、PICT</td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">RPC、SQL、NFS、NetBIOS、names、AppleTalk</td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">传输层</td>
<td style="text-align:center">TCP、UDP</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center">IP、ICMP、ARP、RAPP、RIP、IPX</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">网络接口层</td>
<td style="text-align:center">FDDI、Frame Relay、HDLC、PPP</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">网络接口层</td>
<td style="text-align:center">EIA/TIA-232、EIA/TIA-499</td>
</tr>
</tbody>
</table>
<h3 id="数据在各层之间是怎么传输的呢" class="heading-element"><span>1.6 数据在各层之间是怎么传输的呢？</span>
  <a href="#%e6%95%b0%e6%8d%ae%e5%9c%a8%e5%90%84%e5%b1%82%e4%b9%8b%e9%97%b4%e6%98%af%e6%80%8e%e4%b9%88%e4%bc%a0%e8%be%93%e7%9a%84%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。</p>
<ul>
<li>发送方的应用进程向接收方的应用进程传送数据</li>
<li>AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li>
<li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li>
<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>
<li>最后的物理层，进行比特流的传输</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=small" data-sub-html="<h2>数据在各层之间的传输</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg" alt="数据在各层之间的传输" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=large 2x" data-title="数据在各层之间的传输" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</font></p>
<h2 id="网络综合" class="heading-element"><span>2 网络综合</span>
  <a href="#%e7%bd%91%e7%bb%9c%e7%bb%bc%e5%90%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="从浏览器地址栏输入-url-到显示主页的过程" class="heading-element"><span>2.1 从浏览器地址栏输入 URL 到显示主页的过程</span>
  <a href="#%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%9c%b0%e5%9d%80%e6%a0%8f%e8%be%93%e5%85%a5-url-%e5%88%b0%e6%98%be%e7%a4%ba%e4%b8%bb%e9%a1%b5%e7%9a%84%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>从在浏览器地址栏输入 URL 到显示主页的过程包括多个步骤，涵盖了 DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 响应、浏览器处理响应并渲染页面等多个环节。</p>
<ol>
<li><strong>DNS 解析</strong>：浏览器发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址。</li>
<li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接（通常是通过 443 端口进行 SSL 加密的 HTTPS 连接）。这一步涉及到 TCP 的三次握手过程，确保双方都准备好进行数据传输。</li>
<li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求消息，包括请求行（如 GET / HTTP/1.1）、请求头（包含用户代理、接受的内容类型等信息）和请求体（如果有）；将请求发送到服务器。</li>
<li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理（可能包括数据库查询等），生成 HTTP 响应消息；响应消息包括状态行（如 HTTP/1.1 200 OK）、响应头（内容类型、缓存控制等信息）和响应体（请求的资源内容）。</li>
<li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li>
<li><strong>断开连接</strong>：TCP 四次挥手，连接结束</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=small" data-sub-html="<h2>image-20240601205448054</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png" alt="image-20240601205448054" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=large 2x" data-title="image-20240601205448054" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="各个过程都使用了哪些协议" class="heading-element"><span>2.2 各个过程都使用了哪些协议？</span>
  <a href="#%e5%90%84%e4%b8%aa%e8%bf%87%e7%a8%8b%e9%83%bd%e4%bd%bf%e7%94%a8%e4%ba%86%e5%93%aa%e4%ba%9b%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>DNS:获取域名对应的IP</li>
<li>TCP:与服务器建立连接和断开连接</li>
<li>IP：使用TCP协议时，网络层需要使用IP协议。</li>
<li>OPSF：IP数据包在路由器之间，路由选择使用OPSF协议</li>
<li>ARP：路由器再与服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议</li>
<li>HTTP：TCP连接建立完成之后，使用HTTP协议传递HTTP报文</li>
</ul>
<h3 id="说说-dns-的解析过程" class="heading-element"><span>2.3 说说 DNS 的解析过程？</span>
  <a href="#%e8%af%b4%e8%af%b4-dns-%e7%9a%84%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DNS 的全称是 <strong>Domain Name System</strong>，也就是域名解析系统，它可以将域名映射到对应的 IP 地址上，比如说我们访问 <code>www.google.com</code>，实际上访问的是谷歌的一台服务器，它的 IP 地址是 <code>xxx.xxx.xxx.xxx</code>。可以通过 IP 地址直接访问服务器，但不方便记忆，所以就有了域名系统。域名到 IP 之间的映射，就需要 DNS 来完成。</p>
<p>假设我们在浏览器地址栏里键入了<code>www.google.com</code>：</p>
<ol>
<li>浏览器会首先检查自己的缓存中是否有这个域名对应的 IP 地址，如果有，直接返回；如果没有，进入下一步。</li>
<li>检查本地 DNS 缓存是否有该域名的记录。</li>
<li>如果没有，向<strong>根域名服务器</strong>发送请求，根域名服务器将请求指向更具体的服务，如 <code>com</code> 顶级域名服务器。</li>
<li>顶级域名服务器再将请求指向权限域名服务器，通常由域名注册机构直接管理，所以机构会提供对应的 DNS 解析服务，将域名和谷歌服务器绑定起来。</li>
<li>最终，浏览器使用获得的 IP 地址发起一个 HTTP 请求到目标服务器，然后该服务器返回所请求的网页内容。</li>
</ol>
<h3 id="说说-websocket-与-socket-的区别" class="heading-element"><span>2.4 说说 WebSocket 与 Socket 的区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-websocket-%e4%b8%8e-socket-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>
</li>
<li>
<p><strong>WebSocket</strong>: 是一种网络协议，属于应用层协议。它是在单个 TCP 连接上进行全双工通信的协议，设计用于浏览器和服务器之间的通信，用来解决 <strong>http 不支持持久化连接</strong>的问题。</p>
</li>
<li>
<p>Socket 一个是<strong>网络编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</p>
</li>
<li>
<p><strong>Socket</strong>工作在传输层，可以基于 TCP 或 UDP 协议。它需要开发者自己处理数据的发送和接收、连接的建立和断开等低层次的细节。</p>
</li>
<li>
<p><strong>WebSocket</strong>工作在应用层，<strong>依赖于 TCP 协议</strong>。<font color="red">WebSocket 在初次连接时通过 HTTP 请求进行握手，一旦连接建立，后续的数据传输都在 WebSocket 协议上进行</font>，浏览器和服务器都可以主动向对方发送数据，保持连接直到显式断开。</p>
</li>
<li>
<p><strong>Socket</strong>传输的是字节流，需要开发者自行定义数据的格式和协议。<strong>WebSocket</strong>传输的是文本帧或二进制帧，协议本身定义了消息的格式，能够直接发送 JSON 或二进制数据，方便开发者使用。</p>
</li>
</ul>
<h3 id="说一下你了解的端口及对应的服务" class="heading-element"><span>2.5 说一下你了解的端口及对应的服务？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e4%bd%a0%e4%ba%86%e8%a7%a3%e7%9a%84%e7%ab%af%e5%8f%a3%e5%8f%8a%e5%af%b9%e5%ba%94%e7%9a%84%e6%9c%8d%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th>端口</th>
<th style="text-align:center">服务</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td style="text-align:center">FTP(文件传输协议)</td>
<td style="text-align:center">用于在计算机之间传输文件</td>
</tr>
<tr>
<td>22</td>
<td style="text-align:center">SSH</td>
<td style="text-align:center">用于远程登录、文件传输和命令行界面交互</td>
</tr>
<tr>
<td>23</td>
<td style="text-align:center">Telnet(远程登录服务)</td>
<td style="text-align:center">允许用户从一台计算机登录到另一台计算机</td>
</tr>
<tr>
<td>53</td>
<td style="text-align:center">DNS域名解析服务</td>
<td style="text-align:center">将域名转换为IP地址以便访问网站</td>
</tr>
<tr>
<td>80</td>
<td style="text-align:center">HTTP超文本传输协议</td>
<td style="text-align:center">用于在万维网上交换信息</td>
</tr>
<tr>
<td>443</td>
<td style="text-align:center">HTTPS</td>
<td style="text-align:center">提供安全的HTTP通信</td>
</tr>
<tr>
<td>1080</td>
<td style="text-align:center">SOCKS</td>
<td style="text-align:center">用于在计算机之间安全地传输数据。它通过代理服务器来隐藏原始的IP地址和端口号，从而提供匿名性和安全性</td>
</tr>
<tr>
<td>3306</td>
<td style="text-align:center">MySQL默认端口号</td>
<td style="text-align:center">用于MySQL数据库服务器上的数据访问</td>
</tr>
</tbody>
</table>
<h2 id="http" class="heading-element"><span>3 HTTP</span>
  <a href="#http" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说-http-常用的状态码及其含义" class="heading-element"><span>3.1 说说 HTTP 常用的状态码及其含义？</span>
  <a href="#%e8%af%b4%e8%af%b4-http-%e5%b8%b8%e7%94%a8%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81%e5%8f%8a%e5%85%b6%e5%90%ab%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 响应状态码是由服务器返回给客户端，用于表示对请求的响应结果。</p>
<p>这些状态码分为五个不同的类别，每个类别用一个数字开头，共有三位数：</p>
<ul>
<li>1XX：<strong>信息性状态码</strong>，临时的响应，客户端应继续请求。</li>
<li>2XX：<strong>成功状态码</strong>，请求已成功被服务器接收。</li>
<li>3XX：<strong>重定向状态码</strong>，用来重定向。</li>
<li>4XX：<strong>客户端错误状态码</strong>，请求可能出错。</li>
<li>5XX：<strong>服务器错误状态码</strong>，服务器在尝试处理请求时发生了错误。</li>
</ul>
<p>常见HTTP状态码如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">101 <strong>Switching Protocols</strong></td>
<td style="text-align:center">切换请求协议</td>
</tr>
<tr>
<td style="text-align:center">200 <strong>OK</strong></td>
<td style="text-align:center">请求成功</td>
</tr>
<tr>
<td style="text-align:center">301 <strong>Moved Permanently</strong></td>
<td style="text-align:center">请求资源永久移动，返回新URI</td>
</tr>
<tr>
<td style="text-align:center">302 <strong>Found</strong></td>
<td style="text-align:center">请求资源临时移动，继续使用原有URI</td>
</tr>
<tr>
<td style="text-align:center">400 <strong>Bad Request</strong></td>
<td style="text-align:center">客户端请求的语法错误，服务端无法理解</td>
</tr>
<tr>
<td style="text-align:center">401 <strong>Unauthorized</strong></td>
<td style="text-align:center">当前请求需要认证</td>
</tr>
<tr>
<td style="text-align:center">403 <strong>Forbidden</strong></td>
<td style="text-align:center">服务器拒绝请求，客户端无权访问该资源</td>
</tr>
<tr>
<td style="text-align:center">404 <strong>Not Found</strong></td>
<td style="text-align:center">请求的资源在服务器上不存在</td>
</tr>
<tr>
<td style="text-align:center">500 <strong>Internal Server Error</strong></td>
<td style="text-align:center">服务器内部错误</td>
</tr>
</tbody>
</table>
<h3 id="http-有哪些请求方式" class="heading-element"><span>3.2 HTTP 有哪些请求方式？</span>
  <a href="#http-%e6%9c%89%e5%93%aa%e4%ba%9b%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 协议定义了多种请求方式，用以指示请求的目的。常见的请求方式有 GET、POST、DELETE、PUT。<font color="red">在正确实现的条件下，GET、HEAD、PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是</font>（每次发送 POST 请求，服务器可能会生成新的资源 ID 或处理生成的唯一值（如订单号、事务 ID）。因此，重复发送 POST 请求会导致创建多个不同的资源或多次执行某个操作）。</p>
<ul>
<li><strong>GET</strong>：请求检索指定的资源。应该只用于获取数据，并且是幂等的，即多次执行相同的 GET 请求应该返回相同的结果，并且不会改变资源的状态。</li>
<li><strong>POST</strong>：向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。可能会创建新的资源或修改现有资源。</li>
<li><strong>DELETE</strong>：删除指定的资源。</li>
<li><strong>PUT</strong>：用于替换指定的资源。如果指定的资源不存在，创建一个新资源。</li>
<li><strong>HEAD</strong>：类似于 GET 请求，但只请求响应头信息，不会返回响应体。常用于检查资源是否存在以及资源的元数据（如检查链接是否有效）。</li>
<li><strong>OPTIONS</strong>：请求服务器返回该资源所支持的所有 HTTP 方法。常用于检查服务器的功能或资源的通信选项。</li>
<li><strong>PATCH</strong>：用于对资源进行部分修改，而不是完全替代资源。</li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试和诊断。</li>
<li><strong>CONNECT</strong>：用于将请求连接转换为透明的 TCP/IP 隧道，通常用于 HTTPS 通过代理服务器的请求。</li>
</ul>
<h3 id="http-的-get-方法可以实现写操作吗" class="heading-element"><span>3.3 HTTP 的 GET 方法可以实现写操作吗?</span>
  <a href="#http-%e7%9a%84-get-%e6%96%b9%e6%b3%95%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e5%86%99%e6%93%8d%e4%bd%9c%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>严格来说，HTTP 的 GET 方法不应该用于实现写操作，因为它设计为一种安全的、幂等的读取操作。GET 请求的主要作用是从服务器获取资源，而不应对服务器上的数据进行任何修改。</p>
<p>但是，实际上，有些 Web 应用可能会滥用 GET 请求进行写操作，例如通过在 URL 中传递参数来修改服务器上的数据。这种做法是不推荐的，主要有以下几个原因：</p>
<ol>
<li><strong>安全性</strong>：GET 请求会将参数包含在 URL 中，这使得敏感数据容易暴露，且容易受到攻击（如 CSRF 攻击）。</li>
<li><strong>缓存问题</strong>：GET 请求通常会被缓存，而缓存的 GET 请求不应引发服务器状态的变化。如果 GET 请求用于写操作，可能会导致缓存的副作用。</li>
<li><strong>幂等性和安全性</strong>：HTTP 标准要求 GET 请求是幂等的（多次相同的请求应产生相同的结果）和安全的（不应对服务器状态产生副作用）。使用 GET 实现写操作违背了这些原则。</li>
</ol>
<h3 id="说一下-get-和-post-的区别" class="heading-element"><span>3.4 说一下 GET 和 POST 的区别？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b-get-%e5%92%8c-post-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p>从 HTTP 报文层面：</p>
<ul>
<li>
<p>GET 请求：将请求参数放在 URL 中，因此 URL 的长度有限制。数据在 URL 中传输，不安全，容易被窃取。</p>
</li>
<li>
<p>POST 请求：将请求参数放在请求体中，没有长度限制。数据在报文体中传输，相对更安全。</p>
</li>
</ul>
</li>
<li>
<p>从幂等性和安全性：</p>
<ul>
<li>
<p>GET 请求：</p>
<ul>
<li>幂等性：多次请求不会改变服务器状态，每次结果相同。</li>
<li>安全性：不会对服务器资源进行修改。</li>
</ul>
</li>
<li>
<p>POST 请求：</p>
<ul>
<li>
<p>不幂等：每次请求可能导致服务器状态变化（如创建资源）。</p>
</li>
<li>
<p>不安全：请求会对服务器资源进行修改。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>从其他层面：</p>
<ul>
<li>GET 请求：能够被缓存，减轻服务器负担。能够保存在浏览器的浏览记录里。URL 可以保存为浏览器书签。</li>
<li>POST 请求：<font color="red">不能被缓存，不保存在浏览器历史记录里</font>。URL 不便于保存为书签。</li>
</ul>
</li>
</ol>
<h3 id="get-的长度限制是多少" class="heading-element"><span>3.5 GET 的长度限制是多少？</span>
  <a href="#get-%e7%9a%84%e9%95%bf%e5%ba%a6%e9%99%90%e5%88%b6%e6%98%af%e5%a4%9a%e5%b0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 中的 GET 方法是通过 URL 传递数据的，<font color="red">但是 URL 本身其实并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器</font>。</p>
<p>例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。</p>
<p>这个长度限制也不是针对数据部分，而是针对整个 URL。</p>
<h3 id="http-请求的过程与原理" class="heading-element"><span>3.6 HTTP 请求的过程与原理？</span>
  <a href="#http-%e8%af%b7%e6%b1%82%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%8e%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 全称是超文本传输协议（HyperText Transfer Protocol），是一个基于请求与响应模式的应用层协议，基于 TCP/IP 协议传输数据。</p>
<p>HTTP 遵循标准的客户端-服务器模型，客户端打开连接以发出请求，然后等待它收到服务器端响应。</p>
<ul>
<li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li>
<li>服务器收到请求后，会根据请求的信息处理请求。</li>
<li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li>
<li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li>
</ul>
<p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。<font color="red">这个过程是同步的</font>，也就是说，客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</p>
<h3 id="说一下-http-的报文结构" class="heading-element"><span>3.7 说一下 HTTP 的报文结构？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b-http-%e7%9a%84%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 的报文结构可以分为两类：请求报文和响应报文。两者在结构上相似，都包含了<strong>起始行</strong>、<strong>头部</strong>和<strong>消息正文</strong>。</p>
<ul>
<li>
<p><strong>请求报文结构</strong></p>
<ol>
<li>
<p><strong>请求行 (Request Line)</strong></p>
<ul>
<li><strong>方法 (Method)</strong>：如 GET、POST、PUT、DELETE 等。</li>
<li><strong>请求目标 (Request-URI)</strong>：即请求的资源路径。</li>
<li><strong>HTTP 版本 (HTTP-Version)</strong>：如 HTTP/1.1。</li>
</ul>
</li>
<li>
<p><strong>请求头部 (Request Headers)</strong></p>
<ul>
<li>包含多个首部字段，每个字段由字段名和字段值组成。</li>
<li>用于提供客户端信息、请求的资源信息等。</li>
</ul>
<p><strong>常见请求头</strong>：</p>
<ul>
<li><code>Host</code>：请求的主机名和端口。</li>
<li><code>User-Agent</code>：发起请求的客户端信息。</li>
<li><code>Accept</code>：客户端可接受的响应内容类型。</li>
<li><code>Content-Type</code>：请求体的媒体类型。</li>
<li><code>Authorization</code>：认证信息。</li>
</ul>
</li>
<li>
<p><strong>空行</strong>：用于分隔请求头部和请求主体。</p>
</li>
<li>
<p><strong>请求主体 (Request Body)</strong>：包含实际要发送给服务器的数据，仅在 POST、PUT 等方法中存在。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="err">GET</span> <span class="err">/index.html</span> <span class="err">HTTP/1.1</span>
</span></span><span class="line"><span class="cl"><span class="nf">Host</span><span class="o">:</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
</span></span><span class="line"><span class="cl"><span class="nf">User-Agent</span><span class="o">:</span> <span class="n">Mozilla</span>/5.0
</span></span><span class="line"><span class="cl"><span class="nf">Accept</span><span class="o">:</span> <span class="n">text</span>/<span class="n">html</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>响应报文结构</strong></p>
<ol>
<li>
<p><strong>状态行 (Status Line)</strong></p>
<ul>
<li>
<p><strong>HTTP 版本 (HTTP-Version)</strong>：如 HTTP/1.1。</p>
</li>
<li>
<p><strong>状态码 (Status Code)</strong>：如 200、404、500 等。</p>
</li>
<li>
<p><strong>原因短语 (Reason-Phrase)</strong>：对状态码的简短描述。</p>
</li>
</ul>
</li>
<li>
<p><strong>响应头部 (Response Headers)</strong></p>
<ul>
<li>包含多个首部字段，每个字段由字段名和字段值组成。</li>
<li>用于提供服务器信息、响应的资源信息等。</li>
</ul>
<p><strong>常见响应头</strong>：</p>
<ul>
<li><code>Date</code>：响应生成的日期和时间。</li>
<li><code>Content-Type</code>：响应体的媒体类型。</li>
<li><code>Content-Length</code>：响应体的长度。</li>
<li><code>Set-Cookie</code>：设置 HTTP Cookie。</li>
</ul>
</li>
<li>
<p><strong>空行</strong>：用于分隔响应头部和响应主体。</p>
</li>
<li>
<p><strong>响应主体 (Response Body)</strong>：包含实际要返回给客户端的数据。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="err">HTTP/1.1</span> <span class="err">200</span> <span class="err">OK</span>
</span></span><span class="line"><span class="cl"><span class="nf">Date</span><span class="o">:</span> <span class="n">Mon</span><span class="p">,</span> 27 <span class="n">Jul</span> 2009 12:28:53 <span class="n">GMT</span>
</span></span><span class="line"><span class="cl"><span class="nf">Content-Type</span><span class="o">:</span> <span class="n">text</span>/<span class="n">html</span>
</span></span><span class="line"><span class="cl"><span class="nf">Content-Length</span><span class="o">:</span> 138
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">&lt;html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;body&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;h1&gt;Hello,</span> <span class="err">World!&lt;/h1&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;/body&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;/html&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="uri-和-url-有什么区别" class="heading-element"><span>3.8 URI 和 URL 有什么区别?</span>
  <a href="#uri-%e5%92%8c-url-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center"><strong>属性</strong></th>
<th style="text-align:center"><strong>URI</strong></th>
<th style="text-align:center"><strong>URL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>定义</strong></td>
<td style="text-align:center">统一资源标识符，用于标识一个资源</td>
<td style="text-align:center">统一资源定位符，提供资源的定位方法</td>
</tr>
<tr>
<td style="text-align:center"><strong>组成部分</strong></td>
<td style="text-align:center"><code>[scheme:][//authority][path][?query][#fragment]</code></td>
<td style="text-align:center"><code>scheme://authority/path[?query][#fragment]</code>（必须包含scheme（协议），authority（域名/IP），路径）</td>
</tr>
<tr>
<td style="text-align:center"><strong>例子</strong></td>
<td style="text-align:center"><code>urn:isbn:0451450523</code>（为URN，不是URL，但是URI）</td>
<td style="text-align:center"><code>https://www.example.com/index.html</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>子集</strong></td>
<td style="text-align:center">可以是 URL 或 URN</td>
<td style="text-align:center">是 URI 的子集</td>
</tr>
</tbody>
</table>
<h3 id="说下-http101120-的区别" class="heading-element"><span>3.9 说下 HTTP1.0，1.1，2.0 的区别？</span>
  <a href="#%e8%af%b4%e4%b8%8b-http101120-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><strong>HTTP1.0</strong> 默认短连接，HTTP 1.1 默认长连接，HTTP 2.0 采用<strong>多路复用</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>特性</strong></th>
<th style="text-align:center"><strong>HTTP/1.0</strong></th>
<th style="text-align:center"><strong>HTTP/1.1</strong></th>
<th style="text-align:center"><strong>HTTP/2.0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>连接管理</strong></td>
<td style="text-align:center">短连接（默认每个请求/响应对后都关闭连接）</td>
<td style="text-align:center">长连接（默认 keep-alive）</td>
<td style="text-align:center">多路复用（同一连接多请求）</td>
</tr>
<tr>
<td style="text-align:center"><strong>Host 头部</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>缓存控制</strong></td>
<td style="text-align:center">简单的 Expires 头部</td>
<td style="text-align:center">复杂的 Cache-Control 头部</td>
<td style="text-align:center">同 HTTP/1.1</td>
</tr>
<tr>
<td style="text-align:center"><strong>传输编码</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">支持分块传输编码</td>
<td style="text-align:center">二进制分帧</td>
</tr>
<tr>
<td style="text-align:center"><strong>请求方法</strong></td>
<td style="text-align:center">GET, POST</td>
<td style="text-align:center">GET, POST, PUT, DELETE, OPTIONS 等</td>
<td style="text-align:center">同 HTTP/1.1</td>
</tr>
<tr>
<td style="text-align:center"><strong>头部压缩</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">HPACK 压缩（减少了冗余头部信息的带宽消耗）</td>
</tr>
<tr>
<td style="text-align:center"><strong>服务器推送</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>流优先级</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">支持</td>
</tr>
</tbody>
</table>
<h3 id="http3-了解吗" class="heading-element"><span>3.10 HTTP/3 了解吗？</span>
  <a href="#http3-%e4%ba%86%e8%a7%a3%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP/2.0 基于 TCP 协议，而 HTTP/3.0 则基于 QUIC 协议，Quick UDP Connections，直译为快速 UDP 网络连接。</p>
<p>基于 TCP 的 HTTP/2.0，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输的过程中，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据。</p>
<p>而基于 UDP 的 QUIC 协议可以更彻底解决了 HTTP/2 中的队头阻塞问题，让不同的流之间真正的实现相互独立传输，互不干扰。同时，QUIC 协议在传输的过程中就完成了 TLS 加密握手，更直接了。</p>
<p>目前使用最广泛的是哪个HTTP版本还是是 HTTP/2，在 2022 年 1 月达到峰值，占所有网站的 46.9%。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=small" data-sub-html="<h2>w3techs：使用趋势</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png" alt="w3techs：使用趋势" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=large 2x" data-title="w3techs：使用趋势" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="http-如何实现长连接在什么时候会超时" class="heading-element"><span>3.11 HTTP 如何实现长连接？在什么时候会超时？</span>
  <a href="#http-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e8%b6%85%e6%97%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>什么是 HTTP 的长连接？</strong></p>
<ul>
<li>HTTP 分为长连接和短连接，<strong>本质上说的是 TCP 的长短连接</strong>。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法。</li>
<li>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</li>
</ul>
</blockquote>
<p>通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<code>keep-alive</code>，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p>
<p>在什么时候会超时呢？</p>
<ul>
<li>
<p>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，<strong>也可以在 HTTP 的 header 里面设置超时时间</strong></p>
</li>
<li>
<p>TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">tcp_keepalive_intvl = 15
</span></span><span class="line"><span class="cl">tcp_keepalive_probes = 5
</span></span><span class="line"><span class="cl">tcp_keepalive_time = 1800</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="说说-http-与-https-有哪些区别" class="heading-element"><span>3.12 说说 HTTP 与 HTTPS 有哪些区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-http-%e4%b8%8e-https-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>HTTPS 是 HTTP 的增强版，<font color="red">在 HTTP 的基础上加入了 SSL/TLS 协议，确保数据在传输过程中是加密的</font>。SSL/TLS 需要向 CA（证书权威机构）申请数字证书，用于验证服务器的身份。</li>
<li>HTTP 的默认端⼝号是 <strong>80</strong>，URL 以<code>http://</code>开头；HTTPS 的默认端⼝号是 <strong>443</strong>，URL 以<code>https://</code>开头。</li>
</ol>
<h3 id="为什么要用-https解决了哪些问题" class="heading-element"><span>3.13 为什么要用 HTTPS？解决了哪些问题？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-https%e8%a7%a3%e5%86%b3%e4%ba%86%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用 HTTPS 主要是为了解决 HTTP 传输过程中的一些安全问题，<font color="red">因为 HTTP 是明文传输，所以 HTTPS 在 HTTP 的基础上加入了 SSL/TLS 协议</font>。</p>
<p>HTTPS 主要解决了以下几个问题：</p>
<ul>
<li><strong>窃听风险</strong>：第三方可以截获传输的数据包，获取敏感信息。</li>
<li><strong>篡改风险</strong>：第三方可以在传输过程中篡改数据包，修改数据。</li>
<li><strong>冒充风险</strong>：第三方可以冒充服务器，与客户端通信。</li>
</ul>
<h3 id="https-工作流程是怎样的" class="heading-element"><span>3.14 HTTPS 工作流程是怎样的？</span>
  <a href="#https-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTPS 的连接建立在 SSL/TLS 握手之上，工作流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=small" data-sub-html="<h2>image-20240601233926542</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png" alt="image-20240601233926542" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=large 2x" data-title="image-20240601233926542" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。</p>
<p>HTTPS 在不同阶段会使用不同的加密方式：</p>
<ul>
<li>非对称加密：在握手阶段使用，特别是在密钥交换过程中。非对称加密使用公钥和私钥，其中公钥可以公开，私钥保密。客户端使用公钥加密信息，服务器使用私钥解密。</li>
<li>对称加密：在完成握手后，所有的数据传输都使用对称加密。对称加密使用相同的密钥进行加密和解密，这种加密方式比非对称加密更快。</li>
</ul>
<h3 id="https-会加密-url-吗" class="heading-element"><span>3.15 HTTPS 会加密 URL 吗？</span>
  <a href="#https-%e4%bc%9a%e5%8a%a0%e5%af%86-url-%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTPS 通过 SSL/TLS 协议确保了客户端与服务器之间交换的数据被加密，这包括 HTTP 头部和正文。而 URL 是 HTTP 头部的一部分，因此这部分信息也是加密的。但因为涉及到 SSL 握手的过程，所以域名信息会被暴露出来，需要注意。</p>
<h3 id="客户端怎么去校验证书的合法性" class="heading-element"><span>3.16 客户端怎么去校验证书的合法性？</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e6%80%8e%e4%b9%88%e5%8e%bb%e6%a0%a1%e9%aa%8c%e8%af%81%e4%b9%a6%e7%9a%84%e5%90%88%e6%b3%95%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>首先，所有的证书都是由 CA 机构签发的，CA 机构是一个受信任的第三方机构，它会对证书的申请者进行身份验证，然后签发证书，它具有极高的可信度。</p>
<p>客户端（通常是浏览器，通常会集成 CA 的公钥信息）在校验证书的合法性时，主要通过以下步骤来校验证书的合法性。</p>
<ul>
<li>浏览器会读取证书的所有者、有效期、颁发者等信息，先校验网站域名是否一致，然后校验证书的有效期是否过期；</li>
<li>浏览器开始查找内置的 CA，与服务器返回证书中的颁发者进行对比，确认是否为合法机构；</li>
<li>如果是，从内部植入的 CA 公钥解密 Certificate 的 Signature 内容，得到⼀个 Hash 值 H2；</li>
<li>使⽤同样的 Hash 算法获取证书的 Hash 值 H1，⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则告警。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=small" data-sub-html="<h2>三分恶面渣逆袭：证书签名和客户端校验-来源参考</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png" alt="三分恶面渣逆袭：证书签名和客户端校验-来源参考" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=large 2x" data-title="三分恶面渣逆袭：证书签名和客户端校验-来源参考" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="如何理解-http-协议是无状态的" class="heading-element"><span>3.17 如何理解 HTTP 协议是无状态的？</span>
  <a href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-http-%e5%8d%8f%e8%ae%ae%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这个<code>无状态</code>的的<code>状态</code>值的是什么？是客户端的状态，所以字面意思，就是 HTTP 协议中服务端不会保存客户端的任何信息。</p>
<p>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p>
<blockquote>
<p><strong>那有什么办法记录状态呢？</strong></p>
<p>主要有两个办法，Session 和 Cookie。</p>
</blockquote>
<h3 id="说说-session-和-cookie-有什么联系和区别" class="heading-element"><span>3.18 说说 Session 和 Cookie 有什么联系和区别?</span>
  <a href="#%e8%af%b4%e8%af%b4-session-%e5%92%8c-cookie-%e6%9c%89%e4%bb%80%e4%b9%88%e8%81%94%e7%b3%bb%e5%92%8c%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器（<font color="red">通过 HTTP 请求头的 <code>Cookie</code> 字段在客户端和服务器之间传递</font>）。服务端可以根据这个 Cookie 判断用户的身份和状态。Cookie可以设置过期时间。如果不设置过期时间，则 Cookie 在会话结束（浏览器关闭）时失效。可以通过设置 <code>Expires</code> 或 <code>Max-Age</code> 属性来定义 Cookie 的持久性。</li>
<li>Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。<font color="red">不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上（客户端只保存 Session ID）</font>。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。Session一般在用户会话结束时（例如关闭浏览器、超时）失效。服务器端可以配置 Session 的过期时间。</li>
</ul>
<p>Session 和 Cookie 联系：依赖于 Cookie 来传递 Session ID（通常是服务器在创建 Session 时设置一个 Cookie 来存储 Session ID）。</p>
<p>Session 和 Cookie 的使用场景也不同：</p>
<ul>
<li><strong>Cookie</strong>：适用于存储用户偏好、登录状态等较小的数据，可以跨页面持久化数据。<font color="red">常用于记录用户信息、跟踪用户行为等</font>。</li>
<li><strong>Session</strong>：适用于存储用户会话中的临时信息，如购物车、登录状态等。<font color="red">更适合需要较高安全性的场景，因为数据存储在服务器端</font>。</li>
</ul>
<blockquote>
<p><strong>分布式环境下 Session 怎么处理呢？</strong></p>
<p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。</p>
<p>可以使用 Redis 等分布式缓存来存储 Session，在多台服务器之间共享。</p>
</blockquote>
<blockquote>
<p><strong>客户端无法使用 Cookie 怎么办？</strong></p>
<p>有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。</p>
<p>这时候怎么办？SessionID 怎么存？怎么传给服务端呢？首先是 SessionID 的存储，可以使用客户端的本地存储，比如浏览器的 sessionStorage。</p>
<p>接下来怎么传呢？</p>
<ul>
<li>拼接到 URL 里：直接把 SessionID 作为 URL 的请求参数</li>
<li>放到请求头里：把 SessionID 放到请求的 Header 里，比较常用。</li>
</ul>
</blockquote>
<h2 id="tcp" class="heading-element"><span>4 TCP</span>
  <a href="#tcp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="详细说一下-tcp-的三次握手机制" class="heading-element"><span>4.1 详细说一下 TCP 的三次握手机制？</span>
  <a href="#%e8%af%a6%e7%bb%86%e8%af%b4%e4%b8%80%e4%b8%8b-tcp-%e7%9a%84%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP（Transmission Control Protocol）是一个<font color="red">面向连接的、可靠的、基于字节流的传输层协议</font>。TCP 通过三次握手机制来建立连接，确保双方准备就绪并能可靠地进行通信。以下是三次握手的详细过程：</p>
<ol start="11">
<li>
<p>第一次握手</p>
<ul>
<li><strong>客户端</strong>：发送一个带有 SYN 标志的 TCP 报文段（称为 SYN 报文段），并选择一个初始序列号 <code>seq = x</code>。</li>
<li><strong>服务器</strong>：收到这个 SYN 报文段后，服务器处于 “SYN_RCVD” 状态。</li>
<li><strong>目的</strong>：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。</li>
</ul>
<p><strong>报文内容</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">客户端 --&gt; 服务器: SYN, <span class="nv">seq</span> <span class="o">=</span> x</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第二次握手</p>
<ul>
<li><strong>服务器</strong>：服务器收到 SYN 报文段后，回复一个带有 SYN 和 ACK 标志的 TCP 报文段（称为 SYN-ACK 报文段）。该报文段中包含服务器选择的初始序列号 <code>seq = y</code>，以及对客户端序列号 <code>x</code> 的确认 <code>ack = x + 1</code>。</li>
<li><strong>客户端</strong>：收到这个 SYN-ACK 报文段后，客户端处于 “ESTABLISHED” 状态。</li>
<li><strong>目的</strong>：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。</li>
</ul>
<p>报文内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">服务器 --&gt; 客户端: SYN, ACK, <span class="nv">seq</span> <span class="o">=</span> y, <span class="nv">ack</span> <span class="o">=</span> x + <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第三次握手</p>
<ul>
<li><strong>客户端</strong>：客户端收到 SYN-ACK 报文段后，回复一个带有 ACK 标志的 TCP 报文段（称为 ACK 报文段）。该报文段中包含对服务器序列号 <code>y</code> 的确认 <code>ack = y + 1</code>。</li>
<li><strong>服务器</strong>：收到这个 ACK 报文段后，服务器处于 “ESTABLISHED” 状态，连接建立完成。</li>
<li><strong>目的</strong>：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。</li>
</ul>
<p><strong>报文内容</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">客户端 --&gt; 服务器: ACK, <span class="nv">seq</span> <span class="o">=</span> x + 1, <span class="nv">ack</span> <span class="o">=</span> y + <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP三次握手.png" alt="image-20240602101211701" style="zoom: 33%;" />
<h3 id="tcp-握手为什么是三次为什么不能是两次不能是四次" class="heading-element"><span>4.2 TCP 握手为什么是三次，为什么不能是两次？不能是四次？</span>
  <a href="#tcp-%e6%8f%a1%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e6%ac%a1%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e6%98%af%e4%b8%a4%e6%ac%a1%e4%b8%8d%e8%83%bd%e6%98%af%e5%9b%9b%e6%ac%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用三次握手可以建立一个可靠的连接。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。</p>
<p>两次握手无法确保连接的可靠性。具体原因如下：</p>
<ol>
<li><strong>旧的重复报文干扰</strong>：在两次握手情况下，旧的 SYN 报文可能会被错误地当作新的连接请求。如果服务器发送 SYN-ACK 报文后客户端没有响应，服务器会认为连接失败，但实际上客户端可能已经收到了 SYN-ACK 报文，这样就会导致服务器资源浪费和连接不一致。</li>
<li><strong>确认机制不完整</strong>：两次握手不能保证双方都能正确接收到对方的确认报文。服务器无法确认客户端是否收到了自己的 SYN-ACK 报文，而客户端也无法确认服务器是否收到了自己的 SYN 报文。</li>
</ol>
<p>四次握手在正常情况下是多余的，会增加连接建立的复杂性和开销。三次握手已经足够保证连接的可靠性和正确性：</p>
<ol>
<li><strong>增加复杂性和开销</strong>：四次握手会增加额外的一个报文传输，使得连接建立的过程变得复杂，不必要地增加了传输的延迟和开销。</li>
<li><strong>三次握手足够可靠</strong>：三次握手已经可以确保双方都能确认连接的建立，并且可以避免旧的重复报文的干扰，再增加一次握手并不会带来额外的安全性或可靠性提升。</li>
</ol>
<h3 id="三次握手中每一次没收到报文会发生什么情况" class="heading-element"><span>4.3 三次握手中每一次没收到报文会发生什么情况？</span>
  <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%ad%e6%af%8f%e4%b8%80%e6%ac%a1%e6%b2%a1%e6%94%b6%e5%88%b0%e6%8a%a5%e6%96%87%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在TCP三次握手的过程中，每一次没收到报文都会触发重传机制，并最终导致连接建立失败。具体情况如下：</p>
<ol>
<li>
<p>第一次握手：客户端发送 SYN 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果客户端发送的 SYN 报文没有收到服务器的 SYN-ACK 报文（比如报文丢失或服务器没有响应）。</p>
</li>
<li>
<p><strong>处理</strong>：客户端会进行超时重传。客户端在发送 SYN 报文后会启动一个定时器，如果在一定时间内没有收到服务器的响应（SYN-ACK 报文），客户端会重传 SYN 报文。</p>
</li>
<li>
<p><strong>结果</strong>：重传次数达到一定次数（通常是三次）后，客户端会放弃连接，报错并关闭连接请求。</p>
</li>
</ul>
</li>
<li>
<p>第二次握手：服务器发送 SYN-ACK 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果服务器发送的 SYN-ACK 报文没有收到客户端的 ACK 报文（比如报文丢失或客户端没有响应）。</p>
</li>
<li>
<p><strong>处理</strong>：服务器会进行超时重传。服务器在发送 SYN-ACK 报文后也会启动一个定时器，如果在一定时间内没有收到客户端的 ACK 报文，服务器会重传 SYN-ACK 报文。</p>
</li>
<li>
<p><strong>结果</strong>：重传次数达到一定次数后，服务器会放弃连接，报错并关闭连接请求。</p>
</li>
</ul>
</li>
<li>
<p>第三次握手：客户端发送 ACK 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果客户端发送的 ACK 报文没有收到服务器的确认（ACK 报文本身一般不会单独确认，但此处假设服务器未能进入 ESTABLISHED 状态）。</p>
</li>
<li>
<p><strong>处理</strong>：服务器会因为没有收到 ACK 报文而保持在 SYN-RECEIVED 状态，并可能最终超时并关闭连接。</p>
</li>
<li>
<p><strong>结果</strong>：客户端会认为连接已经建立，并进入 ESTABLISHED 状态，但如果服务器超时关闭连接，客户端在尝试发送数据时会发现连接无法使用，从而报错并关闭连接。</p>
</li>
</ul>
</li>
</ol>
<h3 id="第二次握手传回了-ack为什么还要传回-syn" class="heading-element"><span>4.4 第二次握手传回了 ACK，为什么还要传回 SYN？</span>
  <a href="#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bc%a0%e5%9b%9e%e4%ba%86-ack%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%a6%81%e4%bc%a0%e5%9b%9e-syn" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ACK 标志是为了告诉客户端，它发送的 SYN 报文已经被服务器正确接收。</p>
<p>而传回 SYN 是为了告诉客户端，服务器也希望建立连接，并且响应的确实是客户端发送的报文。</p>
<h3 id="第-3-次握手可以携带数据吗" class="heading-element"><span>4.5 第 3 次握手可以携带数据吗？</span>
  <a href="#%e7%ac%ac-3-%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%8f%af%e4%bb%a5%e6%90%ba%e5%b8%a6%e6%95%b0%e6%8d%ae%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>第 3 次握手是可以携带数据的。此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>
<p>但实际应用中通常不会携带数据，因为在第三次握手中发送数据可能会引发安全和可靠性问题。此时连接还未完全建立，发送数据可能导致数据丢失或安全漏洞。</p>
<p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p>
<h3 id="说说半连接队列和-syn-flood-攻击的关系" class="heading-element"><span>4.6 说说半连接队列和 SYN Flood 攻击的关系？</span>
  <a href="#%e8%af%b4%e8%af%b4%e5%8d%8a%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97%e5%92%8c-syn-flood-%e6%94%bb%e5%87%bb%e7%9a%84%e5%85%b3%e7%b3%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p>半连接队列（Half-Open Connection Queue）是指在 TCP 三次握手过程中，服务器在收到客户端的 SYN 报文后，返回 SYN-ACK 报文并等待客户端的 ACK 报文确认连接的这段时间内，服务器为每个未完成的连接分配的资源队列。</p>
<p><font color="red">SYN Flood 攻击是指攻击者发送大量的 SYN 报文请求与服务器建立连接，但在服务器返回 SYN-ACK 报文后，攻击者不发送最终的 ACK 报文完成握手</font>。这样，服务器的半连接队列会被大量未完成的连接占满，导致服务器资源耗尽，无法处理正常的连接请求，进而造成拒绝服务（Denial of Service，DoS）。</p>
<p>因此，SYN Flood 攻击的核心在于利用半连接队列的有限资源，通过大量伪造的连接请求使服务器无法处理合法用户的连接。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SYN_Flood_Example.png" alt="2fad1ef85054585e10ddeed7a3346a26" style="zoom:50%;" />
<blockquote>
<p><strong>那有什么应对方案呢？</strong></p>
<p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p>
<ul>
<li><strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li>
<li><strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li>
<li><strong>缩短 SYN-ACK 超时时间</strong>：调整系统的 SYN-ACK 超时时间，使未完成的连接请求能够更快地被清理出队列。</li>
<li><strong>分布式拒绝服务防护（DDoS Protection Services）</strong>：使用专业的 DDoS 防护服务，如 Cloudflare、Akamai 等，这些服务可以在网络边缘过滤恶意流量，减轻服务器的压力。</li>
</ul>
</blockquote>
<h3 id="说说-tcp-四次挥手的过程" class="heading-element"><span>4.7 说说 TCP 四次挥手的过程？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e7%9a%84%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 四次挥手是指 TCP 连接终止时所进行的四个步骤，数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起（通常是客户端），具体过程如下：</p>
<ol>
<li><strong>第一次挥手：FIN 报文</strong>：
<ul>
<li>客户端发送一个 FIN 报文段，表明它已经完成了数据发送，请求关闭连接。客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>报文段格式：<code>FIN=1, seq=x</code>。</li>
</ul>
</li>
<li><strong>第二次挥手：ACK 报文</strong>：
<ul>
<li>服务器接收到 FIN 报文后，返回一个 ACK 报文段，确认收到了关闭请求。发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li>报文段格式：<code>ACK=1, ack=x+1</code>。</li>
<li>此时，服务器可能还需要继续发送数据，因此连接处于半关闭状态。</li>
</ul>
</li>
<li><strong>第三次挥手：FIN 报文</strong>：
<ul>
<li>服务端在完成数据发送后，发送一个 FIN 报文段，表明它也已经完成了数据发送，请求关闭连接。发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li>
<li>报文段格式：<code>FIN=1, seq=y</code>。</li>
</ul>
</li>
<li><strong>第四次挥手：ACK 报文</strong>：
<ul>
<li>客户端接收到 FIN 报文后，返回一个 ACK 报文段，确认收到了关闭请求，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
<li>报文段格式：<code>ACK=1, ack=y+1</code>。</li>
<li>此时，连接正式关闭，双方都完成了连接的释放。</li>
</ul>
</li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP_Close_Example.png" alt="image-20240602130755941" style="zoom: 67%;" />
<h3 id="tcp-挥手为什么需要四次呢" class="heading-element"><span>4.8 TCP 挥手为什么需要四次呢？。</span>
  <a href="#tcp-%e6%8c%a5%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%9b%9b%e6%ac%a1%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h3 id="tcp-四次挥手过程中为什么需要等待-2msl-才进入-closed-关闭状态" class="heading-element"><span>4.9 TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</span>
  <a href="#tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%ad%89%e5%be%85-2msl-%e6%89%8d%e8%bf%9b%e5%85%a5-closed-%e5%85%b3%e9%97%ad%e7%8a%b6%e6%80%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN</strong> 报文段的确认。服务端会超时重传这个 <strong>FIN</strong> 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<blockquote>
<p><strong>为什么等待的时间是 2MSL？</strong></p>
<p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>
</blockquote>
<h3 id="保活计时器有什么用" class="heading-element"><span>4.10 保活计时器有什么用？</span>
  <a href="#%e4%bf%9d%e6%b4%bb%e8%ae%a1%e6%97%b6%e5%99%a8%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer），用于在长时间闲置的 TCP 连接中检测对端是否仍然存活，<strong>并防止连接因为长时间没有活动而被认为是不活跃的而被关闭</strong>。</p>
<p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="close-wait-和-time-wait-的状态和意义" class="heading-element"><span>4.11 <code>CLOSE-WAIT</code> 和 <code>TIME-WAIT</code> 的状态和意义？</span>
  <a href="#close-wait-%e5%92%8c-time-wait-%e7%9a%84%e7%8a%b6%e6%80%81%e5%92%8c%e6%84%8f%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>CLOSE-WAIT 状态有什么意义？</strong></p>
</blockquote>
<p>服务端收到客户端关闭连接的请求并确认之后，就会进入 CLOSE-WAIT 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而<font color="red"> CLOSE-WAIT 状态就是为了保证服务端在关闭连接之前将待发送的数据处理完</font>。</p>
<blockquote>
<p><strong>TIME-WAIT 有什么意义？</strong></p>
</blockquote>
<p>TIME-WAIT 状态发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入 TIME-WAIT 状态。</p>
<ul>
<li><strong>防⽌旧连接的数据包</strong></li>
<li><strong>保证连接正确关闭</strong></li>
</ul>
<h3 id="time_wait-状态过多会导致什么问题怎么解决" class="heading-element"><span>4.12 <code>TIME_WAIT</code> 状态过多会导致什么问题？怎么解决？</span>
  <a href="#time_wait-%e7%8a%b6%e6%80%81%e8%bf%87%e5%a4%9a%e4%bc%9a%e5%af%bc%e8%87%b4%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>TIME_WAIT 状态过多会导致什么问题?</strong></p>
</blockquote>
<p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p>
<blockquote>
<p><strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>HTTP 没有使用长连接</li>
<li>HTTP 长连接超时</li>
<li>HTTP 长连接的请求数量达到上限</li>
</ul>
</blockquote>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ol>
<li><strong>端口资源耗尽</strong>：每个处于 <code>TIME_WAIT</code> 状态的连接都会占用一个本地端口。如果 <code>TIME_WAIT</code> 状态的连接过多，可能会导致可用的本地端口资源耗尽，新的连接请求无法分配端口，从而导致服务不可用。</li>
<li><strong>内存和资源占用</strong>：<code>TIME_WAIT</code> 状态的连接会占用一定的系统内存和资源。如果连接过多，会导致系统资源被大量占用，影响服务器的性能和其他应用的运行。</li>
</ol>
<blockquote>
<p><strong>怎么解决 TIME_WAIT 状态过多？</strong></p>
</blockquote>
<ul>
<li>服务器可以设置 <code>SO_REUSEADDR</code> 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li>
<li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li>
</ul>
<h3 id="说说-tcp-报文头部的格式" class="heading-element"><span>4.13 说说 TCP 报文头部的格式？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e6%8a%a5%e6%96%87%e5%a4%b4%e9%83%a8%e7%9a%84%e6%a0%bc%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 TCP 报文段主要由报文段头部（Header）和数据两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mathematica" data-lang="mathematica"><span class="line"><span class="cl"><span class="w">  </span><span class="mi">0</span><span class="w">                   </span><span class="mi">1</span><span class="w">                   </span><span class="mi">2</span><span class="w">                   </span><span class="mi">3</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">          </span><span class="n">Source</span><span class="w"> </span><span class="n">Port</span><span class="w">          </span><span class="o">|</span><span class="w">       </span><span class="n">Destination</span><span class="w"> </span><span class="n">Port</span><span class="w">        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                        </span><span class="n">Sequence</span><span class="w"> </span><span class="n">Number</span><span class="w">                        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                    </span><span class="n">Acknowledgment</span><span class="w"> </span><span class="n">Number</span><span class="w">                      </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">Data</span><span class="w"> </span><span class="o">|</span><span class="n">Reser</span><span class="o">-|</span><span class="w">       </span><span class="n">Flags</span><span class="w">     </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Offset</span><span class="o">|</span><span class="n">ved</span><span class="w">   </span><span class="o">|</span><span class="w">       </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="o">|</span><span class="w">        </span><span class="n">Window</span><span class="w">                </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="p">(</span><span class="mi">4</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w">   </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">bits</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">       </span><span class="n">Checksum</span><span class="w">                </span><span class="o">|</span><span class="w">     </span><span class="n">Urgent</span><span class="w"> </span><span class="n">Pointer</span><span class="w">            </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                       </span><span class="n">Options</span><span class="w"> </span><span class="p">(</span><span class="n">if</span><span class="w"> </span><span class="n">any</span><span class="p">)</span><span class="w">                        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                                                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                        </span><span class="n">data</span><span class="w">                                   </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                                                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>源端口号</strong>（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。</li>
<li><strong>目标端口号</strong>（Destination Port）：也是 16 位，用于标识接收端的应用程序。</li>
<li><strong>序列号</strong>（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。</li>
<li><strong>确认号</strong>（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。</li>
<li><strong>数据偏移</strong>（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。</li>
<li><strong>保留</strong>（Reserved）：6 位，为将来使用预留，目前必须置为 0。</li>
<li><strong>控制位</strong>（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。</li>
<li><strong>窗口大小</strong>（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。</li>
<li><strong>校验和</strong>（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。</li>
<li><strong>紧急指针</strong>（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP_Data_Format_Example.png" alt="1f7ade5afa610376a72553a7d32f622c" style="zoom:50%;" />
<h3 id="tcp-是如何保证可靠性的" class="heading-element"><span>4.14 TCP 是如何保证可靠性的？</span>
  <a href="#tcp-%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e6%80%a7%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP（传输控制协议）通过多种机制来确保数据传输的可靠性。以下是TCP保证可靠性的主要方法：</p>
<ol>
<li><strong>连接管理（Connection Management）</strong>：TCP 使用三次握手（Three-Way Handshake）建立连接和四次挥手（Four-Way Handshake）关闭连接，确保连接的建立和释放过程可靠、无误。</li>
<li><strong>校验和（Checksum）</strong>：TCP 报文段包含一个校验和字段，用于验证报文段在传输过程中是否被损坏。发送方计算并填充校验和，接收方根据接收到的数据重新计算校验和并进行验证，确保数据的完整性。</li>
<li><strong>序列号（Sequence Numbers）</strong>：TCP 为每个字节分配一个序列号。发送方和接收方使用序列号来确保数据按照正确的顺序接收并重组，防止数据丢失或重复。</li>
<li><strong>确认应答（Acknowledgments, ACKs）</strong>：TCP 使用确认应答机制来确认数据的接收。接收方在收到数据后，会发送一个带有确认号的ACK报文段，告知发送方已成功接收到的数据。<strong>这种机制确保了数据的传递和确认</strong>。</li>
<li><strong>拥塞控制（Congestion Control）</strong>：TCP 通过慢启动、拥塞避免、快重传和快恢复等算法来防止网络拥塞，保证数据传输的稳定性和可靠性。</li>
<li><strong>流量控制（Flow Control）</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</li>
<li><strong>重传机制（Retransmission）</strong>：发送方在发送数据后会启动一个计时器。如果在指定时间内未收到对应的ACK报文段，发送方会认为该数据包丢失并进行重传。TCP还使用快速重传机制，当收到三个重复的ACK时，立即重传相应的数据包。</li>
<li><strong>最大消息长度（Maximum Message Length）</strong>：在建立 TCP 连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</li>
</ol>
<h3 id="说说-tcp-的流量控制" class="heading-element"><span>4.15 说说 TCP 的流量控制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，以确保接收方能够及时处理数据而不会因为数据过多而溢出缓冲区，这就是<strong>流量控制</strong>。</p>
<p>TCP 的流量控制主要通过滑动窗口（Sliding Window）机制来实现。示例如下：</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Flow_Control_Example_1.png" alt="97365f7a32a87ad913ceca13f1325e10_720" style="zoom:50%;" />
<h3 id="详细说说-tcp-的滑动窗口" class="heading-element"><span>4.16 详细说说 TCP 的滑动窗口？</span>
  <a href="#%e8%af%a6%e7%bb%86%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。而滑动窗口允许发送方在未接收到 ACK 确认之前可以发送多个数据段，以提高网络的利用率和传输效率，同时避免了发送方过度发送导致接收方缓冲区溢出。</p>
<p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>
<ul>
<li>已发送且已收到 ACK 确认</li>
<li>已发送但未收到 ACK 确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=small" data-sub-html="<h2>18481a6fdea7f130edac0e46840cc015_720</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png" alt="18481a6fdea7f130edac0e46840cc015_720" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=large 2x" data-title="18481a6fdea7f130edac0e46840cc015_720" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>蓝色框里就是发送窗口。SND.WND 表示发送窗口的大小，SND.NXT表示下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号；SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</p>
<p>接收方的滑动窗口包含三大部分，如下：</p>
<ul>
<li>已成功接收并确认</li>
<li>未收到数据但可以接收</li>
<li>未收到数据并不可以接收的数据</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=small" data-sub-html="<h2>154b2bfeb394bbae15f76d48be668ca6_720</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png" alt="154b2bfeb394bbae15f76d48be668ca6_720" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=large 2x" data-title="154b2bfeb394bbae15f76d48be668ca6_720" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>蓝色框内，就是接收窗口。REV.WND 表示接收窗口的大小；REV.NXT表示下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</p>
<p>发送方和接收方通过 ACK 确认报文段来协商窗口大小。发送方根据接收方的接收窗口大小来调整自己的发送窗口大小，以确保不会发送超出接收方能力的数据量。</p>
<h3 id="了解-nagle-算法和延迟确认吗" class="heading-element"><span>4.17 了解 Nagle 算法和延迟确认吗？</span>
  <a href="#%e4%ba%86%e8%a7%a3-nagle-%e7%ae%97%e6%b3%95%e5%92%8c%e5%bb%b6%e8%bf%9f%e7%a1%ae%e8%ae%a4%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>Nagle 算法和延迟确认是干什么的？</strong></p>
</blockquote>
<p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p>
<p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p>
<ul>
<li><strong>Nagle 算法</strong>：当应用程序发送数据时，Nagle 算法会先将数据放入缓冲区，并等待一定的时间（称为 Nagle 算法定时器），<strong>以便将多个小数据包合并成一个大数据包一起发送</strong>。只有当缓冲区中的数据量达到一定阈值（Nagle 算法的最小传输单元）或者定时器超时时，才会触发数据的发送。<font color="red">Nagle 算法主要用于避免发送大量小数据包的情况，从而减少网络的拥塞，提高网络的性能和效率</font>。</li>
<li><strong>延迟确认</strong>：当接收方收到数据时，不会立即发送 ACK 确认报文，而是等待一段时间（一般是等待 200 毫秒左右），以便将多个 ACK 合并成一个 ACK 一起发送。如果在延迟时间内收到新的数据包，则会立即发送 ACK 报文，以确认收到的数据。<font color="red">延迟确认主要用于减少确认报文的数量，避免网络中出现过多的 ACK 报文，从而减少网络的负载和提高网络的吞吐量</font>。</li>
</ul>
<p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p>
<h3 id="说说-tcp-的拥塞控制" class="heading-element"><span>4.18 说说 TCP 的拥塞控制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>什么是拥塞控制？不是有了流量控制吗？</strong></p>
</blockquote>
<p>前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。</p>
<p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤&hellip;.</p>
<p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p>
<p>于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p>
<p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，调节所要发送数据的量。</p>
<blockquote>
<p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong></p>
</blockquote>
<p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p>
<p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
<p>拥塞窗⼝ cwnd 变化的规则：</p>
<ul>
<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>但⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<blockquote>
<p><strong>拥塞控制有哪些常用算法？</strong></p>
</blockquote>
<p>拥塞控制主要有这几种常用算法：</p>
<ul>
<li><strong>慢启动</strong>：先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据）</li>
<li><strong>拥塞避免</strong>：在拥塞避免阶段，TCP的拥塞窗口以线性增长的方式增加，而不是指数级增长</li>
<li><strong>快重传</strong>：发送方不必等待超时计时器的到期，而是立即进行快速重传，重传丢失的数据包</li>
<li><strong>快恢复</strong>：快恢复算法用于在收到重复ACK时，迅速调整拥塞窗口大小以恢复传输速度</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Congestion_Control_Example_1.png" alt="f2bf90ccdfa385562fd6f475cc4f692f_720" style="zoom:50%;" />
<h3 id="说说-tcp-的重传机制" class="heading-element"><span>4.19 说说 TCP 的重传机制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 的重传机制是确保数据传输可靠性的重要部分之一。它通过在发送方定时器超时或者接收到连续的重复确认时触发，重新发送丢失或者未确认的数据段，以确保数据能够在网络中正确传输。以下是 TCP 的重传机制的主要原理：</p>
<ol>
<li><strong>超时重传</strong>：当发送方发送数据后，在等待一定时间内未收到确认 ACK 报文时，触发超时重传机制，重新发送未确认的数据段。超时时间通常根据网络往返时间（RTT）动态调整，以适应网络延迟的变化。</li>
<li><strong>快速重传</strong>：当发送方接收到连续的重复 ACK 报文时，表明接收方已经成功接收了一些数据，但有一个或多个数据段丢失。<font color="red">为了尽快重传丢失的数据段，发送方立即触发快速重传机制，重新发送丢失的数据段，而不必等待超时定时器的到期</font>。</li>
<li><strong>带选择确认的重传（SACK）</strong>：选择确认（SACK）为了解决应该重传多少个包的问题，允许接收方在确认报文中指示出连续的数据段中哪些已经成功接收，哪些丢失了。发送方可以根据 SACK 报文中指示的丢失数据段信息，选择性地进行重传，而不是重传整个窗口内的所有未确认数据段。</li>
<li><strong>重复 SACK</strong>：是在 SACK 的基础上做了一些扩展，在接收方收到连续的重复数据段时，会生成多个相同的 SACK 报文，用于指示哪些数据段已经成功接收。主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</li>
</ol>
<h3 id="说说-tcp-的粘包和拆包" class="heading-element"><span>4.20 说说 TCP 的粘包和拆包？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e7%b2%98%e5%8c%85%e5%92%8c%e6%8b%86%e5%8c%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分。</p>
<p><strong>粘包</strong>指的是在 TCP 连接中，发送方发送的多个数据包在接收方接收时被合并成一个数据包。这种情况通常发生在以下几种场景中：</p>
<ol>
<li>发送方发送数据过于频繁，发送的数据量较小，多个小数据包在发送时被合并成一个数据包。Nagle 算法的作用使得发送方在网络未确认前将小数据包合并发送。</li>
<li>接收方读取数据不及时，一次性读取多个数据包。</li>
</ol>
<p><strong>拆包</strong>指的是一个完整的数据包在接收方接收时被拆分成了多个数据包。这种情况通常发生在以下几种场景中：</p>
<ol>
<li>网络传输过程中，由于 MTU（最大传输单元）的限制，一个大的数据包被拆分成多个小的数据包进行传输。</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ol>
<blockquote>
<p><strong>那怎么解决呢？</strong></p>
</blockquote>
<ul>
<li>发送端将每个数据包封装为固定长度；</li>
<li>在数据尾部增加特殊字符进行分割；</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小；</li>
<li>设计特定的应用层协议，包含数据包头部（例如，标识符、长度字段、校验和等）和数据部分。接收方根据协议解析数据包。</li>
</ul>
<h3 id="如果已经建立了连接但是服务端的进程崩溃会发生什么服务器断电呢" class="heading-element"><span>4.21 如果已经建立了连接，但是服务端的进程崩溃会发生什么？服务器断电呢？</span>
  <a href="#%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%e4%bd%86%e6%98%af%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%b4%a9%e6%ba%83%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%96%ad%e7%94%b5%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<p>当服务器断电时，情况会有所不同：客户端在尝试与服务器通信时，会发现连接中断，通常会收到一个错误（如 <code>ECONNRESET</code> 或 <code>ETIMEDOUT</code>），客户端的应用程序需要处理这个错误，并可能尝试重新建立连接或采取其他应对措施。</p>
<h3 id="如果已经建立了连接但是客户端突然出现故障了怎么办" class="heading-element"><span>4.22 如果已经建立了连接，但是客户端突然出现故障了怎么办？</span>
  <a href="#%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%e4%bd%86%e6%98%af%e5%ae%a2%e6%88%b7%e7%ab%af%e7%aa%81%e7%84%b6%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h3 id="服务器出现大量-close_wait-状态的原因有哪些" class="heading-element"><span>4.23 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span>
  <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f-close_wait-%e7%8a%b6%e6%80%81%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%9c%89%e5%93%aa%e4%ba%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CLOSE_WAIT 状态是【被动关闭方】才会有的状态，而且如果【被动关闭方】没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因是：2，3，4，6步没有做</p>
<h2 id="udp" class="heading-element"><span>5 UDP</span>
  <a href="#udp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说-tcp-和-udp-的区别" class="heading-element"><span>5.1 说说 TCP 和 UDP 的区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e5%92%8c-udp-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">TCP</th>
<th style="text-align:center">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">连接</td>
<td style="text-align:center">面向连接，传输数据前需建立连接</td>
<td style="text-align:center">无需连接，立即传输数据</td>
</tr>
<tr>
<td style="text-align:center">服务对象</td>
<td style="text-align:center">一对一的两点服务</td>
<td style="text-align:center">支持一对一、一对多、多对多的交互通信</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">可靠交付，数据无差错、不丢失、不重复、按序到达</td>
<td style="text-align:center">尽最大努力交付，不保证可靠交付数据</td>
</tr>
<tr>
<td style="text-align:center">拥塞控制、流量控制</td>
<td style="text-align:center">有拥塞控制和流量控制机制</td>
<td style="text-align:center">无拥塞控制和流量控制机制，发送速率不受网络拥堵影响</td>
</tr>
<tr>
<td style="text-align:center">首部开销</td>
<td style="text-align:center">首部长度较长（20 字节—60字节）</td>
<td style="text-align:center">首部只有 8 字节，且固定不变，开销较小</td>
</tr>
<tr>
<td style="text-align:center">传输方式</td>
<td style="text-align:center">字节流式传输，无边界，保证顺序和可靠</td>
<td style="text-align:center">数据段报文传输，有边界，可能丢包和乱序</td>
</tr>
<tr>
<td style="text-align:center">分片</td>
<td style="text-align:center">在传输层进行分片，丢失分片时只重传丢失部分</td>
<td style="text-align:center">在 IP 层进行分片，接收后在 IP 层组装再传给传输层</td>
</tr>
<tr>
<td style="text-align:center">应用场景</td>
<td style="text-align:center">文件传输、邮件传输</td>
<td style="text-align:center">即时通讯、域名转换</td>
</tr>
</tbody>
</table>
<h3 id="为什么-qq-采用-udp-协议" class="heading-element"><span>5.2 为什么 QQ 采用 UDP 协议？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-qq-%e9%87%87%e7%94%a8-udp-%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>首先，QQ 并不是完全基于 UDP 实现。<font color="red">比如在使用 QQ 进行文件传输等活动的时候，就会使用 TCP 作为可靠传输的保证</font>。</li>
<li>使用 UDP 进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP 是一个全双工协议，需要建立连接，所以网络开销也会相对大。</li>
<li>如果使用 QQ 语音和 QQ 视频的话，UDP 的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li>
<li>由于 QQ 的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用 UDP 协议与客户端进行通讯才能保证这种超大规模的服务</li>
</ul>
<p>简单总结一下：UDP 协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。<strong>QQ 采用的通信协议以 UDP 为主，辅以 TCP 协议</strong>。</p>
<h3 id="udp-协议为什么不可靠" class="heading-element"><span>5.3 UDP 协议为什么不可靠？</span>
  <a href="#udp-%e5%8d%8f%e8%ae%ae%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e5%8f%af%e9%9d%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>UDP 在传输数据之前不需要先建立连接，远地主机的运输层在接收到 UDP 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="dns-为什么要用-udp" class="heading-element"><span>5.4 DNS 为什么要用 UDP?</span>
  <a href="#dns-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-udp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>更准确地说，DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。<font color="red">即在需要可靠传输或处理大数据包的特定场景下，DNS 也会使用 TCP 以确保传输的可靠性和完整性</font>。</p>
<p>当客户端想 DNS 服务器查询域名（域名解析）的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，用 UDP 传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="你会如何设计qq中的网络协议" class="heading-element"><span>5.5 你会如何设计QQ中的网络协议？</span>
  <a href="#%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1qq%e4%b8%ad%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>首先，我们要实现登录功能，这是使用 QQ 的第一步，为了保证账号和密码的安全性，我们可以选择 TCP + SSL/TLS 协议来进行登录。</p>
<p>因为 TCP 协议是一种可靠的传输协议，能够保证数据的完整性，而 SSL/TLS 能够对通信进行加密，保证数据的安全性。</p>
<p>接下来，我们需要考虑消息传递的实时性，如语音视频通话等，这时候我们可以选择 UDP 协议。UDP 的传输速度更快，对于实时性服务来说，速度是最重要的。</p>
<h3 id="udp如何尽量保证消息的不丢失" class="heading-element"><span>5.6 UDP如何尽量保证消息的不丢失</span>
  <a href="#udp%e5%a6%82%e4%bd%95%e5%b0%bd%e9%87%8f%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e7%9a%84%e4%b8%8d%e4%b8%a2%e5%a4%b1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于 TCP 协议来说，如果数据包在传输过程中丢失，TCP 协议会自动进行重传。</p>
<p>而对于 UDP 协议来说，我们可以通过应用层的重传机制来保证消息的不丢失。当接收方收到消息后，返回一个确认信息给发送方，如果发送方在一定时间内没有收到确认信息，就重新发送消息。</p>
<p>同时，每个消息都附带一个唯一的序列号，接收方根据序列号判断是否有消息丢失，如果发现序列号不连续，就可以要求发送方重新发送。这样还可以防止消息重复。</p>
<p>当然了，消息持久化也很重要，可以将消息保存在服务器或者本地的数据库中，即使在网络中断或者其他异常情况下，也能从数据库中恢复消息。</p>
<h2 id="quic" class="heading-element"><span>6 QUIC</span>
  <a href="#quic" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="quic是如何实现可靠传输的udp如何实现可靠传输" class="heading-element"><span>6.1 QUIC是如何实现可靠传输的？（UDP如何实现可靠传输？）</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%e7%9a%84udp%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">把TCP可靠传输的特性（序号，确认应答，超时重传，流量控制）在应用层实现一遍。</font></p>
<ul>
<li><strong>基于UDP</strong>：QUIC 建立在 UDP 之上，通过在 UDP 数据报中封装自己的数据包来实现可靠传输。</li>
<li><strong>可靠传输</strong>：QUIC 提供了类似于 TCP 的可靠传输机制，包括序列号、确认应答、重传和流量控制。</li>
<li><strong>多路复用</strong>：QUIC 支持多条独立的流，解决了 TCP 的队头阻塞问题。</li>
<li><strong>拥塞控制</strong>：QUIC 实现了拥塞控制算法，确保高效的数据传输。</li>
</ul>
<h3 id="quic是如何解决tcp队头阻塞问题的" class="heading-element"><span>6.2 QUIC是如何解决TCP队头阻塞问题的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3tcp%e9%98%9f%e5%a4%b4%e9%98%bb%e5%a1%9e%e9%97%ae%e9%a2%98%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP的队头阻塞（Head-of-Line Blocking）问题是指在数据传输过程中，如果某个数据包丢失了，后续的数据包即使已经到达接收方，也无法被处理，因为接收方必须按顺序处理数据包。</p>
<p>QUIC通过以下机制解决了这个问题：</p>
<ol>
<li><strong>多路复用</strong>：QUIC允许多个独立的流在同一个连接中传输，每个流都有自己的序列号和确认机制。这意味着即使某个流的数据包丢失了，也不会影响其他流的数据传输。</li>
<li><strong>独立流处理</strong>：接收方可以独立处理每个流的数据包，即使某个流的数据包丢失了，接收方仍然可以处理其他流的数据包，避免了队头阻塞。</li>
</ol>
<h3 id="quic是如何做流量控制的" class="heading-element"><span>6.3 QUIC是如何做流量控制的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>QUIC的流量控制机制与TCP类似，但更为灵活和高效：</p>
<ol>
<li><strong>流级别的流量控制</strong>：每个流都有自己的流量控制窗口，发送方在发送数据之前，必须确保数据大小不超过接收方为该流设定的窗口大小。</li>
<li><strong>连接级别的流量控制</strong>：除了流级别的流量控制，QUIC还支持连接级别的流量控制，限制整个连接上的未确认数据总量，防止网络拥塞。</li>
<li><strong>动态调整窗口大小</strong>：QUIC可以根据网络状况动态调整流量控制窗口的大小，提高数据传输的效率和适应性。</li>
</ol>
<h3 id="quic是如何迁移连接的" class="heading-element"><span>6.4 QUIC是如何迁移连接的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%81%e7%a7%bb%e8%bf%9e%e6%8e%a5%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p>
<p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过以下机制：</p>
<ol>
<li><strong>连接ID</strong>：QUIC为每个连接分配一个唯一的连接ID，连接ID与客户端和服务器的IP地址和端口无关。因此，即使客户端的IP地址或端口发生变化，只要连接ID不变，连接仍然有效。</li>
<li><strong>路径验证</strong>：在迁移连接时，QUIC会验证新的路径是否可用，确保数据能够通过新路径传输。</li>
<li><strong>迁移过程</strong>：当客户端检测到网络变化（例如，从WiFi切换到移动网络）时，会通知服务器新的地址和端口。服务器验证新的路径后，继续通过新的路径传输数据。</li>
<li><strong>无缝切换</strong>：通过连接ID和路径验证机制，QUIC实现了连接的无缝迁移，避免了因网络变化导致的连接中断和数据丢失。</li>
</ol>
<h2 id="ip" class="heading-element"><span>7 IP</span>
  <a href="#ip" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="ip-协议的定义和作用" class="heading-element"><span>7.1 IP 协议的定义和作用？</span>
  <a href="#ip-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>IP 协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在<strong>网际层</strong>，主要目的就是为了提高网络的可扩展性。</p>
<p>通过<strong>网际协议 IP</strong>，可以把参与互联的，性能各异的网络<strong>看作一个统一的网络</strong>。</p>
<p>和传输层 TCP 相比，IP 协议是一种无连接/不可靠、尽力而为的数据包传输服务，和 TCP 协议一起构成了 TCP/IP 协议的核心。</p>
<blockquote>
<p><strong>IP 协议有哪些作用？</strong></p>
</blockquote>
<p>IP 协议主要有以下几个作用：</p>
<ul>
<li><strong>寻址和路由</strong>：在 IP 数据报中携带源 IP 地址和目的 IP 地址来表示该数据包的源主机和目标主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至目标主机。</li>
<li><strong>分段和重组</strong>：IP 数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP 协议通过给每个 IP 数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的 IP 数据报。</li>
<li><strong>差错处理</strong>：虽然 IP 是尽力而为的协议，不保证数据报一定到达目的地，但它包含一些基本的差错处理机制，例如校验和（checksum），用于检测数据报头部的错误。</li>
<li><strong>控制信息</strong>：IP 头部包含了多个字段，用于控制和管理数据报的传输，如生存时间（TTL，Time to Live）字段，防止数据报在网络中无限循环。</li>
</ul>
<blockquote>
<p><strong>传输层协议和网络层协议有什么区别？</strong></p>
</blockquote>
<p><font oclor="red">网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。</font></p>
<h3 id="ip-地址有哪些分类" class="heading-element"><span>7.2 IP 地址有哪些分类？</span>
  <a href="#ip-%e5%9c%b0%e5%9d%80%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%86%e7%b1%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>IP地址（Internet Protocol Address）是用于标识网络中设备的唯一地址。IP地址有两种版本：IPv4和IPv6。IPv4是目前最广泛使用的版本，IPv6是为解决IPv4地址耗尽问题而设计的新版本。</p>
<p>IPv4地址是32位长的二进制数，通常表示为四个十进制数（每个数对应8位）之间用点分隔（例如，192.168.1.1）。IPv4地址可以按其用途和结构分为A，B，C，D，E五大类：</p>
<ul>
<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位，主要用于大型网络；</li>
<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位，主要用于中型网络；</li>
<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位，主要用于小型网络；</li>
<li>D 类地址 (224~239)：以 1110 开头，保留为多播地址，用于一对多通信；</li>
<li>E 类地址 (240~255)：以 1111 开头，保留位为将来使用，用于实验和研究。</li>
</ul>
<p>IPv4有以下特殊地址：</p>
<ul>
<li><strong>本地回环地址（Loopback Address）</strong>：127.0.0.0 到 127.255.255.255，用于主机自我测试，通常使用127.0.0.1。</li>
<li><strong>广播地址（Broadcast Address）</strong>：用于将信息发送到网络上的所有设备。例如，192.168.1.255。</li>
<li>私有地址（Private Address）：用于局域网（LAN）内部通信，不可在互联网上使用。包括以下范围：
<ul>
<li>A类：10.0.0.0 到 10.255.255.255</li>
<li>B类：172.16.0.0 到 172.31.255.255</li>
<li>C类：192.168.0.0 到 192.168.255.255</li>
</ul>
</li>
</ul>
<p>IPv6地址是128位长的二进制数，通常表示为八组十六进制数之间用冒号分隔（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。IPv6地址类型主要有以下几种：</p>
<ul>
<li><strong>单播地址（Unicast Address）</strong>：标识单一接口的地址。
<ul>
<li>全球单播地址（Global Unicast Address）：类似于IPv4的公有地址。</li>
<li>链路本地地址（Link-Local Address）：仅在单一链路上有效，前缀为fe80::/10。</li>
<li>站点本地地址（Site-Local Address）：类似于IPv4的私有地址，但已被弃用，前缀为fec0::/10。</li>
</ul>
</li>
<li><strong>多播地址（Multicast Address）</strong>：用于一对多通信，前缀为ff00::/8。</li>
<li><strong>任播地址（Anycast Address）</strong>：分配给多个接口，但数据包仅发送到距离最近的接口</li>
</ul>
<h3 id="域名和-ip-的关系一个-ip-可以对应多个域名吗一个域名可以对应多个ip吗" class="heading-element"><span>7.3 域名和 IP 的关系？一个 IP 可以对应多个域名吗？一个域名可以对应多个IP吗？</span>
  <a href="#%e5%9f%9f%e5%90%8d%e5%92%8c-ip-%e7%9a%84%e5%85%b3%e7%b3%bb%e4%b8%80%e4%b8%aa-ip-%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ba%94%e5%a4%9a%e4%b8%aa%e5%9f%9f%e5%90%8d%e5%90%97%e4%b8%80%e4%b8%aa%e5%9f%9f%e5%90%8d%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ba%94%e5%a4%9a%e4%b8%aaip%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>域名（Domain Name）</strong>：人类可读的地址，用于标识和访问网站及其他网络资源（例如，<code>www.example.com</code>）。</li>
<li><strong>IP地址（Internet Protocol Address）</strong>：计算机可读的地址，用于标识网络中的设备（例如，<code>192.168.1.1</code>）。</li>
</ul>
<p>域名和IP地址之间是通过DNS（Domain Name System）来进行映射和解析的。</p>
<p>一个域名可以对应多个 IP，但这种情况 DNS 做负载均衡的，在用户访问过程中，一个域名只能对应一个 IP。</p>
<p>而一个IP却可以对应多个域名，是一对多的关系。</p>
<h3 id="ipv4-地址不够如何解决" class="heading-element"><span>7.4 IPV4 地址不够如何解决？</span>
  <a href="#ipv4-%e5%9c%b0%e5%9d%80%e4%b8%8d%e5%a4%9f%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>DHCP：动态主机配置协议，<font color="red">动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用</font>。</li>
<li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效地分配 IPv4 的地址空间，但无法从根本上解决地址耗尽的问题。</li>
<li>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题，<font color="red">然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT 方法可以将该主机 IP 地址转换为全球 IP 地址</font>。该协议能够有效解决 IP 地址不足的问题。</li>
<li>IPv6：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个 IP 地址也够用，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>
</ul>
<h3 id="说下-arp-协议的工作过程" class="heading-element"><span>7.5 说下 ARP 协议的工作过程？</span>
  <a href="#%e8%af%b4%e4%b8%8b-arp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ARP（Address Resolution Protocol，地址解析协议）是用于将IP地址解析为对应物理网络地址（如MAC地址）的协议，主要在IPv4网络中使用。它在局域网（LAN）中起到了关键作用，使设备能够通过IP地址找到对应的硬件地址，从而实现数据帧在局域网中的正确传输。</p>
<ol>
<li><strong>ARP请求</strong>：当主机 A 要发送数据给主机 B 时，首先会在自己的 ARP 缓存中查找主机 B 的 MAC 地址。如果没有找到，主机 A 会向网络中广播一个 ARP 请求数据包，请求网络中的所有主机告诉它们的 MAC 地址；这个请求包含了请求设备和目标设备的 IP 和 MAC 地址。</li>
<li><strong>ARP应答</strong>：网络中的所有主机都会收到这个 ARP 请求，但只有主机 B 会回复 ARP 应答，告诉主机 A 自己的 MAC 地址。并且主机 B 会将主机 A 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中，以便下次通信时直接使用。</li>
<li><strong>数据传输</strong>：在获得主机B的MAC地址后，主机A（也会将主机 B 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中）就可以将目标MAC地址设置为主机B的MAC地址，从而正确地构建以太网帧并发送到局域网中，这些数据帧会通过交换机或集线器等网络设备正确地传送到主机B。</li>
</ol>
<h3 id="为什么既有-ip-地址又有-mac-地址" class="heading-element"><span>7.6 为什么既有 IP 地址，又有 MAC 地址？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%97%a2%e6%9c%89-ip-%e5%9c%b0%e5%9d%80%e5%8f%88%e6%9c%89-mac-%e5%9c%b0%e5%9d%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>MAC 地址和 IP 地址都有什么作用？</strong></p>
</blockquote>
<ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>
</ul>
<blockquote>
<p><strong>为什么有了 MAC 地址还需要 IP 地址？</strong></p>
</blockquote>
<p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是最多共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256T 的内存，显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<blockquote>
<p><strong>为什么有了 IP 地址还需要 MAC 地址？</strong></p>
</blockquote>
<ul>
<li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候，或者在分配 IP 的过程中。我们需要 MAC 地址来区分不同的设备。</li>
<li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li>
</ul>
<h3 id="icmp-协议的功能" class="heading-element"><span>7.7 ICMP 协议的功能？</span>
  <a href="#icmp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8a%9f%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ICMP（Internet Control Message Protocol，网际控制报文协议） 是用于在IP网络中传递控制和错误信息的协议。它是在网络层（OSI模型的第三层）之上运行的协议，主要用于在IP网络中进行诊断、错误报告和控制消息的传递。ICMP协议的功能包括但不限于以下几点：</p>
<ul>
<li><strong>错误报告</strong>：ICMP用于向发送者报告网络层发生的错误，例如目标不可达、超时、路由器发生故障等。</li>
<li><strong>路由器发现</strong>：ICMP可用于路由器的发现和配置，例如路由器通告消息（Router Advertisement）和路由器请求消息（Router Solicitation）。</li>
<li><strong>Ping测试</strong>：ICMP的Echo请求和Echo应答消息被用于Ping测试，以测试主机之间的连通性和延迟。</li>
<li><strong>TTL过期</strong>：ICMP的TTL（Time to Live）过期消息用于报告数据包在网络中被丢弃的情况，通常由于数据包在转发过程中超过了其TTL值。</li>
<li><strong>片段超时</strong>：ICMP的片段超时消息用于报告IP数据报在传输过程中被丢弃的情况，通常由于数据包片段未能在超时时间内到达目的地而被丢弃。</li>
<li><strong>重定向</strong>：ICMP的重定向消息用于告知发送者修改其路由表以改进数据包的转发效率。</li>
<li><strong>MTU探测</strong>：ICMP的路径MTU探测（Path MTU Discovery）用于发现通向目标主机的最大传输单元（MTU）以避免分片。</li>
<li><strong>多播/任播测试</strong>：ICMP用于进行多播和任播地址的测试和诊断。</li>
</ul>
<p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 ICMP 的。</p>
<p><font color="red">在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</font></p>
<p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p>
<h3 id="ping的工作原理" class="heading-element"><span>7.8 ping的工作原理</span>
  <a href="#ping%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ping，<strong>Packet Internet Groper</strong>，一个网络工具，主要用来测试网络连接的可达性和延迟。</p>
<p>ping 的过程主要基于 ICMP（Internet Control Message Protocol，互联网控制消息协议）实现，其基本过程包括：</p>
<ol>
<li>当执行 Ping 命令，如<code>ping www.google.com</code>，Ping 首先解析域名获取 IP 地址，然后向目标 IP 发送一个 ICMP Echo Request 消息。</li>
<li>当目标 IP 收到 ICMP Echo Request 消息后，它会生成一个 ICMP Echo Reply 消息并返回，即 Ping 响应消息。</li>
<li>发起 Ping 命令的设备接收到 ICMP Echo Reply 消息后，计算并显示从发送 Echo Request 到接收到 Echo Reply 的时间（通常称为往返时间 RTT，Round-Trip Time），以及可能的丢包情况。</li>
</ol>
<p>Ping 通常会发送多个请求，以便提供平均响应时间和丢包率等信息，以便我们了解网络连接的质量。</p>
<h3 id="断网了还能ping通127001吗" class="heading-element"><span>7.9 断网了，还能ping通127.0.0.1吗？</span>
  <a href="#%e6%96%ad%e7%bd%91%e4%ba%86%e8%bf%98%e8%83%bdping%e9%80%9a127001%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通常情况下，即使网络连接断开，也可以通过回环接口（Loopback Interface）ping通本地主机的回环地址127.0.0.1。回环地址是本地主机自身的虚拟网络接口，用于在本地主机内部进行通信，不经过物理网络设备，因此即使网络断开也可以正常工作。</p>
<p>回环接口是网络协议栈中的一个虚拟接口，用于模拟数据在网络中的传输。当数据发送到回环地址时，操作系统会将数据直接传输给回环接口，然后再从回环接口发送到目标地址，实现了数据的回环传输。</p>
<h3 id="127001-和-localhost-以及-0000-有区别吗" class="heading-element"><span>7.10 127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</span>
  <a href="#127001-%e5%92%8c-localhost-%e4%bb%a5%e5%8f%8a-0000-%e6%9c%89%e5%8c%ba%e5%88%ab%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>127.0.0.1</strong>：127.0.0.1是回环地址（Loopback Address），通常用于本地主机内部进行通信。当数据发送到127.0.0.1时，操作系统会将数据传输给回环接口，然后再从回环接口发送到目标地址，实现了数据的回环传输。127.0.0.1始终指向本地主机自身，不会通过网络传输，用于测试本地主机的网络协议栈是否正常工作以及网络服务是否可用。</li>
<li><strong>localhost</strong>：localhost是一个主机名（Hostname），通常映射到回环地址127.0.0.1。当在计算机上使用localhost时，实际上是在使用回环地址127.0.0.1，用于访问本地主机上的网络服务。localhost是一个常见的网络标识符，用于指代本地主机。</li>
<li><strong>0.0.0.0</strong>：0.0.0.0是一个特殊的IP地址，通常用于表示任意主机或任意地址。当服务器配置为监听0.0.0.0时，表示它将接受来自任何IP地址的连接，可以用于在所有可用网络接口上监听服务。在某些情况下，0.0.0.0也用于指示目标地址未指定或未知。</li>
</ol>
<h2 id="网络安全" class="heading-element"><span>8 网络安全</span>
  <a href="#%e7%bd%91%e7%bb%9c%e5%ae%89%e5%85%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说有哪些安全攻击" class="heading-element"><span>8.1 说说有哪些安全攻击？</span>
  <a href="#%e8%af%b4%e8%af%b4%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%94%bb%e5%87%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>络安全攻击主要分为两种类型，<strong>被动攻击</strong>和<strong>主动攻击</strong></p>
<ul>
<li><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。<font color="red">由于攻击者没有修改数据，使得这种攻击很难被检测到。</font></li>
<li><strong>主动攻击</strong>：直接对现有的数据和服务造成影响，常见的主动攻击类型有：
<ul>
<li><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</li>
<li><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</li>
<li><strong>拒绝服务 Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</li>
</ul>
</li>
</ul>
<h3 id="dns-劫持了解吗" class="heading-element"><span>8.2 DNS 劫持了解吗？</span>
  <a href="#dns-%e5%8a%ab%e6%8c%81%e4%ba%86%e8%a7%a3%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DNS劫持是一种网络攻击，通过篡改DNS（Domain Name System）解析结果来劫持用户的网络流量。DNS劫持攻击者会修改DNS解析请求或响应，将用户重定向到恶意网站或者欺骗页面。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DNS_Attack_Example.png" alt="03e093a40b15980c362ca54c98199b29" style="zoom:50%;" />
<p>DNS劫持可以通过多种方式实现，其中包括：</p>
<ol>
<li><strong>本地DNS劫持</strong>：攻击者在受害者计算机或网络中植入恶意软件，使其修改本地主机的DNS设置，将合法的DNS服务器替换为攻击者控制的恶意DNS服务器。</li>
<li><strong>路由器DNS劫持</strong>：攻击者入侵路由器或者通过社会工程手段获取路由器管理权限，然后修改路由器的DNS设置，使其指向恶意DNS服务器。</li>
<li><strong>ISP级别的DNS劫持</strong>：攻击者控制了受害者所使用的ISP（Internet Service Provider，互联网服务提供商）的DNS服务器，通过篡改ISP的DNS解析结果来实现DNS劫持。</li>
<li><strong>中间人攻击</strong>：攻击者通过中间人攻击拦截DNS请求或响应，然后篡改其中的域名解析结果，将用户重定向到恶意网站或者欺骗页面。</li>
</ol>
<blockquote>
<p><strong>怎么应对 DNS 劫持？</strong></p>
</blockquote>
<ul>
<li>直接通过 IP 地址访问网站，避开 DNS 劫持</li>
<li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选 DNS 服务器的地址固定为 8.8.8.8。</li>
</ul>
<h3 id="什么是-csrf-攻击如何避免" class="heading-element"><span>8.3 什么是 CSRF 攻击？如何避免？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-csrf-%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种网络安全攻击，<font color="red">利用用户在已认证的Web应用程序上的身份验证信息执行未经授权的操</font>作。攻击者通过诱使受害者在访问包含恶意代码的网页时，触发向目标网站发送请求的行为，从而在用户不知情的情况下执行攻击者预先设定的操作，如转账、更改密码等。</p>
<p>CSRF攻击通常包含以下步骤：</p>
<ol>
<li>攻击者准备好一个包含恶意请求的页面，例如一个钓鱼网站或者注入了恶意代码的广告。</li>
<li>受害者在已经登录的情况下访问了包含恶意请求的页面。</li>
<li>受害者的浏览器自动发送了被伪造的请求到目标网站，由于受害者已经在目标网站登录，因此请求被认为是合法的，从而执行了攻击者的操作。</li>
</ol>
<p>要防止CSRF攻击，可以采取以下措施：</p>
<ol>
<li><strong>使用CSRF Token</strong>：在Web应用程序中引入CSRF Token，确保每个请求都包含一个随机生成的Token，并在服务端验证Token的有效性。攻击者无法获取到有效的CSRF Token，因此无法伪造有效的请求。</li>
<li><strong>检查Referer头</strong>：Web应用程序可以检查请求的Referer头，确保请求来自合法的来源。但需要注意的是，Referer头可能会被篡改或者缺失，因此不能单独依赖Referer头来防止CSRF攻击。</li>
<li><strong>限制敏感操作</strong>：对于涉及到敏感操作的请求，应该要求用户输入额外的身份验证信息，例如密码、验证码等，以增加攻击者执行CSRF攻击的难度。</li>
<li><strong>使用SameSite属性</strong>：在设置Cookie时，可以使用SameSite属性来限制Cookie的发送，防止第三方网站携带Cookie发送CSRF攻击。可以将Cookie设置为SameSite=Strict或者SameSite=Lax，以限制Cookie仅在同源请求中发送。</li>
<li><strong>定期审查和更新代码</strong>：定期审查和更新Web应用程序的代码，修补已知的安全漏洞，并遵循安全最佳实践，以减少CSRF攻击的风险。</li>
<li><strong>添加校验 token</strong>：以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li>
</ol>
<h3 id="什么是-dosddosdrdos-攻击" class="heading-element"><span>8.4 什么是 DoS、DDoS、DRDoS 攻击？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-dosddosdrdos-%e6%94%bb%e5%87%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DoS（Denial of Service，拒绝服务）攻击、DDoS（Distributed Denial of Service，分布式拒绝服务）攻击和DRDoS（Distributed Reflection Denial of Service，分布式反射拒绝服务）攻击都是针对网络服务的攻击手法，旨在使目标系统无法正常提供服务，从而导致服务不可用或严重受损。</p>
<ol>
<li><strong>DoS 攻击</strong>：DoS攻击是由单个攻击者发起的攻击，通过向目标系统发送大量的请求或者恶意数据包，耗尽目标系统的资源（如带宽、处理能力、存储空间等），从而使正常用户无法访问或使用目标系统的服务。DoS攻击可以采用多种手段实现，包括网络层攻击（如SYN Flood、UDP Flood）、应用层攻击（如HTTP Flood、Slowloris攻击）等。</li>
<li><strong>DDoS 攻击</strong>：DDoS攻击是由多个攻击者协同发起的攻击，通过分布在全球各地的大量“僵尸”计算机（也称为“肉鸡”或“僵尸网络”）向目标系统发送大量的请求或者恶意数据包，造成目标系统过载，从而使其无法正常提供服务。DDoS攻击通常规模更大、更难以应对，因为攻击流量来自于多个来源，并且攻击者可以很容易地控制和伪装攻击流量的来源。</li>
<li><strong>DRDoS 攻击</strong>：DRDoS攻击是一种利用第三方系统的资源反射攻击目标系统的攻击方式。攻击者向第三方系统发送请求，伪装成目标系统的IP地址，并请求返回大量的响应数据，这些响应数据会发送到目标系统，造成目标系统的过载。DRDoS攻击利用了第三方系统的反射响应特性，使攻击者能够轻易地放大攻击流量，并且很难追溯到攻击者的真实身份。</li>
</ol>
<blockquote>
<p><strong>如何防范 DDoS?</strong></p>
</blockquote>
<p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。瓷碗，负载均衡，CDN 等技术都能有效对抗 DDos 攻击。</p>
<h3 id="什么是-xss-攻击如何避免" class="heading-element"><span>8.5 什么是 XSS 攻击，如何避免?</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-xss-%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的网络安全攻击，攻击者通过在受害者的浏览器中注入恶意脚本，来执行恶意操作。这些脚本通常以HTML、JavaScript等形式存在，可以窃取用户的会话信息、篡改网页内容、重定向用户到恶意网站等。XSS攻击通常分为以下几种类型：</p>
<ol>
<li><strong>存储型 XSS</strong>：攻击者将恶意脚本存储到目标网站的数据库中，当用户访问包含恶意脚本的页面时，脚本会从服务器端加载并执行。</li>
<li><strong>反射型 XSS</strong>：攻击者将恶意脚本作为参数或者URL的一部分，发送给目标用户，当用户点击恶意链接时，脚本会在用户的浏览器中执行。</li>
<li><strong>DOM-based XSS</strong>：攻击者利用客户端的DOM环境，通过修改页面的DOM结构来执行恶意脚本。</li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/typical_XSS_Example.png" alt="一个典型的 XSS" style="zoom:50%;" />
<blockquote>
<p><strong>如何应对 XSS 攻击？</strong></p>
</blockquote>
<ul>
<li>对输入进行过滤，过滤标签等，只允许合法值。</li>
<li>HTML 转义</li>
<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以 script 开头的非法链接。</li>
<li>限制输入长度</li>
<li>将Cookie设置为HttpOnly标志，可以防止JavaScript访问Cookie，从而减少XSS攻击的风险。</li>
</ul>
<h3 id="对称加密与非对称加密有什么区别" class="heading-element"><span>8.6 对称加密与非对称加密有什么区别？</span>
  <a href="#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e4%b8%8e%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对称加密和非对称加密是两种常见的加密算法，它们之间有几个关键区别：</p>
<ol>
<li><strong>密钥数量</strong>：
<ul>
<li>对称加密使用相同的密钥来加密和解密数据，因此只需要一个密钥。发送方使用该密钥将数据加密，接收方使用相同的密钥将数据解密。</li>
<li>非对称加密使用一对密钥：公钥和私钥。公钥用于加密数据，私钥用于解密数据。因此，发送方使用接收方的公钥来加密数据，接收方使用自己的私钥来解密数据。</li>
</ul>
</li>
<li><strong>密钥分发</strong>：
<ul>
<li>对称加密需要确保加密和解密双方都安全地共享相同的密钥。这意味着必须在通信双方之间建立一个安全的渠道来传输密钥，否则密钥可能会被窃取或篡改。</li>
<li>非对称加密不需要在通信双方之间共享密钥。接收方将自己的公钥公开发布，发送方使用该公钥加密数据，接收方使用自己的私钥解密数据。因此，不需要建立安全的通道来传输密钥。</li>
</ul>
</li>
<li><strong>性能</strong>：
<ul>
<li>对称加密通常比非对称加密更快速，因为它使用的密钥较少，加密和解密过程更简单。</li>
<li>非对称加密通常比对称加密更慢，因为它使用更复杂的数学运算来加密和解密数据。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>对称加密通常用于加密大量数据，如传输文件或通信内容。</li>
<li>非对称加密通常用于加密小块数据，如数字签名、SSL/TLS握手过程等。</li>
</ul>
</li>
</ol>
]]></description></item><item><title>数据结构与算法 面试题目总结</title><link>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 20:13:44 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="排序算法" class="heading-element"><span>1 排序算法</span>
  <a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最差时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">数据对象稳定性</th>
<th style="text-align:center">算法基本思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">反复交换相邻逆序的元素，直到没有逆序对</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">数组不稳定、链表稳定</td>
<td style="text-align:center">反复选择未排序部分中的最小（大）元素，放在已排序部分的末尾</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">逐一选择未排序元素，将其插入到已排序部分的正确位置</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(\log_2 n)$$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">选择基准，将数组分为小于和大于基准的两部分，递归排序</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">构建最大（小）堆，将堆顶元素与末尾元素交换，调整堆</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">递归地将数组分为两部分，分别排序后合并</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">分组进行插入排序，逐渐减少间隔，直到间隔为1</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$$O(n + m)$$</td>
<td style="text-align:center">$$O(n + m)$$</td>
<td style="text-align:center">$$O(n + m)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">统计每个元素的出现次数，根据计数对元素进行排序</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(m)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">将元素分配到不同的桶中，分别排序后合并</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$$O(k \cdot n)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">取决于实现</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">逐位排序，从最低有效位到最高有效位进行</td>
</tr>
</tbody>
</table>
<h2 id="栈与队列的区别" class="heading-element"><span>2 栈与队列的区别</span>
  <a href="#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；</li>
<li>栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。</li>
<li>队列先进先出，栈先进后出。</li>
<li>栈只能在表尾插入删除，队列在表尾插入表头删除。</li>
<li>应用场景不同：
<ul>
<li>栈：括号问题的求解等</li>
<li>队列：计算机系统中各种资源的管理等。</li>
</ul>
</li>
<li>遍历速度不同：
<ul>
<li>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快；</li>
<li>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</li>
</ul>
</li>
</ul>
<h2 id="两个栈实现一个队列" class="heading-element"><span>3 两个栈实现一个队列</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e9%98%9f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个栈来实现一个队列，可以有效地利用栈的特性（后进先出）来模拟队列的特性（先进先出）。我们可以使用两个栈来分离入队和出队操作，具体实现步骤如下：</p>
<ul>
<li><strong>栈1</strong>（<code>stack1</code>）用于处理入队操作。</li>
<li><strong>栈2</strong>（<code>stack2</code>）用于处理出队操作。</li>
</ul>
<ol>
<li>入队列：直接压入元素至<code>stack1</code>即可</li>
<li>出队列：如果<code>stack2</code>不为空，把<code>stack2</code>中的栈顶元素直接弹出。否则，把<code>stack1</code>的所有元素全部弹出压入<code>stack2</code>中，再弹出<code>stack2</code>的栈顶元素</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stack1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack1</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Queue is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="两个队列实现栈" class="heading-element"><span>4 两个队列实现栈</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个队列来实现一个栈，可以利用队列的特性（先进先出）来模拟栈的特性（后进先出）。我们可以使用两个队列来分离入栈和出栈操作，具体实现步骤如下：</p>
<ul>
<li><strong>队列1</strong>（<code>queue1</code>）用于存储元素。</li>
<li><strong>队列2</strong>（<code>queue2</code>）作为辅助队列用于操作元素。</li>
</ul>
<ol>
<li><strong>入栈操作</strong>：将元素直接入队到<code>queue1</code>中。</li>
<li><strong>出栈操作</strong>：
<ul>
<li>将<code>queue1</code>中的所有元素（除了最后一个）逐个出队并入队到<code>queue2</code>中。</li>
<li>最后一个元素是栈顶元素，将其出队。</li>
<li>交换<code>queue1</code>和<code>queue2</code>，以保持<code>queue1</code>始终为主队列。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Stack is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="链表与数组的区别" class="heading-element"><span>5 链表与数组的区别</span>
  <a href="#%e9%93%be%e8%a1%a8%e4%b8%8e%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>数组静态分配内存，链表动态分配内存；。</li>
</ul>
<ul>
<li>数组在内存中连续，链表不连续。</li>
<li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)。</li>
<li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li>
<li><font color="red">数组元素在栈区，链表元素在堆区</font>。</li>
</ul>
<h2 id="什么是堆" class="heading-element"><span>6 什么是堆？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p>
<p><strong>最大堆的根结点中的元素在整个堆中是最大的；</strong></p>
<p><strong>最小堆的根结点中的元素在整个堆中是最小的。</strong></p>
<h2 id="什么是二叉排序树" class="heading-element"><span>7 什么是二叉排序树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ol>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<h2 id="什么是平衡二叉树" class="heading-element"><span>8 什么是平衡二叉树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p><font color="red">平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进</font>。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。</p>
<p>旋转是平衡二叉树维护平衡性的核心操作，包括以下几种：</p>
<ul>
<li>单右旋转（Right Rotation）：用于修复左子树过高的情况。</li>
<li>单左旋转（Left Rotation）：用于修复右子树过高的情况。</li>
<li>双旋转（Double Rotation）：包括先左后右旋转和先右后左旋转，用于修复特定的不平衡情况。</li>
</ul>
<h2 id="什么是b树" class="heading-element"><span>9 什么是B树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%afb%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>B树是一种自平衡的多路查找树，其中每个节点可以有多个子节点和多个键。B树具有以下特性：</p>
<ul>
<li><strong>节点包含多个键和子节点</strong>：每个节点可以存储多个键和子节点。节点中的键按照递增顺序存储。</li>
<li><strong>根节点至少有两个子节点</strong>（如果不是叶节点）。</li>
<li><strong>内部节点的子节点数受限</strong>：一个内部节点至少有$$[m/2]$$个子节点，最多有 $$m$$个子节点（这里的$m$是B树的阶）。</li>
<li><strong>所有叶子节点处于同一层</strong>：B树的所有叶子节点都在同一层，保证树的平衡性。</li>
</ul>
<p>B树的性质如下：</p>
<ul>
<li><strong>平衡性</strong>：B树是自平衡的，所有叶子节点处在同一层，树的高度通常较小，因而能够保证较快的搜索、插入和删除操作。</li>
<li><strong>高效的磁盘I/O操作</strong>：由于节点可以包含多个键和子节点，B树通常用于磁盘存储中，减少磁盘I/O操作的次数。</li>
<li><strong>时间复杂度</strong>：搜索、插入和删除操作的时间复杂度均为$O(\log n)$，其中$n$是树中的键的总数。</li>
</ul>
<p>B树的操作如下：</p>
<ul>
<li><strong>搜索</strong>：从根节点开始，根据当前节点中的键范围，递归或迭代地选择相应的子节点进行搜索，直到找到目标键或到达叶子节点。</li>
<li>插入：
<ul>
<li>在叶子节点插入新键。</li>
<li>如果叶子节点已满，则进行分裂操作，将中间键提升到父节点，并将叶子节点分裂为两个节点。</li>
<li>如果父节点也满，则递归进行分裂，直到树根。</li>
</ul>
</li>
<li>删除：
<ul>
<li>从树中删除键。</li>
<li>如果删除键导致节点下溢（键数少于$[m/2]$），则进行合并或借用操作，以保持B树的平衡性。</li>
</ul>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small" data-sub-html="<h2>clip_image020</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png" alt="clip_image020" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large 2x" data-title="clip_image020" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="trie-树" class="heading-element"><span>10 Trie 树</span>
  <a href="#trie-%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/trie1.png" alt="字典树(Trie) - OI Wiki" style="zoom:50%;" />
<h2 id="b树" class="heading-element"><span>11 B+树</span>
  <a href="#b%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">B+树通常用于数据库和操作系统的文件系统中</font>，B+树的结构如下：</p>
<ul>
<li><strong>根节点（Root Node）</strong>：B+树的根节点可以是叶子节点，也可以是内部节点。</li>
<li><strong>内部节点（Internal Nodes）</strong>：存储键值用于导航，不存储实际数据。每个内部节点包含若干个键和指向子节点的指针。</li>
<li><strong>叶子节点（Leaf Nodes）</strong>：存储所有的实际数据，并且包含指向相邻叶子节点的指针，形成一个双向链表。</li>
</ul>
<p>B+树的性质：</p>
<ul>
<li><strong>有序性</strong>：所有键按升序排列。</li>
<li><strong>平衡性</strong>：树的所有叶子节点处于同一层级，保证了平衡性。</li>
<li><strong>多路性</strong>：每个节点可以有多个子节点，具体数量由树的阶（order）决定。</li>
</ul>
<p>B+树的操作：</p>
<ul>
<li><strong>查找（Search）</strong>：从根节点开始，依次比较键值，沿着指向子节点的指针递归查找，直到找到目标叶子节点。</li>
<li><strong>插入（Insert）</strong>：将新键插入适当的叶子节点，如果叶子节点满了，则分裂叶子节点并将中间键上移到父节点，递归进行分裂直到树恢复平衡。</li>
<li><strong>删除（Delete）</strong>：从叶子节点删除键，如果删除导致节点键数目不足，则进行节点合并或键重新分配，直到树恢复平衡。</li>
</ul>
<p>B+树的优点：</p>
<ul>
<li><strong>高效的范围查询</strong>：由于所有数据都存储在叶子节点中，并且叶子节点形成双向链表，B+树能够高效地进行范围查询（range query）。</li>
<li><strong>高存储利用率</strong>：内部节点只存储键，数据存储在叶子节点中，节点分裂和合并更加高效。</li>
<li><strong>低树高（Tree Height）</strong>：B+树的多路性使得其树高较低，查找、插入和删除操作的时间复杂度为$O(\log_mn$，其中$m$为树的阶。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small" data-sub-html="<h2>ds-bplus-tree2</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg" alt="ds-bplus-tree2" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large 2x" data-title="ds-bplus-tree2" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是红黑树" class="heading-element"><span>12 什么是红黑树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%a2%e9%bb%91%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>红黑树（为了解决平衡树在插入、删除等操作需要频繁调整的情况）是一种自平衡的二叉查找树（BST），广泛用于计算机科学中实现高效的数据存储和检索。它通过在每个节点上附加一个颜色属性（红或黑）来保持树的平衡，从而确保树的高度在对数级别，提供较好的时间复杂度性能。</p>
<p>红黑树的性质：</p>
<ol>
<li><strong>每个结点不是红色就是黑色；</strong></li>
<li><strong>根节点是黑色的</strong>；</li>
<li><strong>叶子节点（NIL节点）是黑色</strong>：红黑树中的叶子节点，即树尾端的所有NULL节点，都是黑色的。</li>
<li><strong>红色节点的父节点和子节点必须是黑色的，即不能有两个连续的红色节点。</strong></li>
<li><strong>从任一节点到其每个叶子的所有路径包含相同数量的黑色节点</strong>：这保证了没有一条路径会比其他路径长出太多，从而确保了树的平衡。</li>
</ol>
<p>红黑树的操作：红黑树的操作包括插入、删除和查找，基本的操作步骤与普通的二叉查找树类似，但在维护平衡性方面有所不同。</p>
<ol>
<li>
<p>插入操作</p>
<ol>
<li>
<p><strong>普通BST插入</strong>：按二叉查找树的插入规则，将新节点插入适当位置。</p>
</li>
<li>
<p><strong>节点染色为红色</strong>：新插入的节点初始为红色。</p>
</li>
<li>
<p><strong>调整平衡</strong>：通过旋转和重新染色来保持红黑树的性质。</p>
<ul>
<li>
<p><strong>情况1：插入节点的父节点是黑色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：插入节点的父节点是红色</strong>：根据叔节点的颜色，有不同的调整方法，包括重新染色和旋转。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>删除操作</p>
<ol>
<li>
<p><strong>普通BST删除</strong>：按二叉查找树的删除规则，找到并删除节点。</p>
</li>
<li>
<p><strong>调整平衡</strong>：删除节点后可能破坏红黑树的性质，需要通过旋转和重新染色来恢复平衡。</p>
<ul>
<li>
<p><strong>情况1：删除节点是红色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：删除节点是黑色</strong>：通过双重黑色节点的概念和调整，包括重新染色和旋转，来恢复红黑树的平衡。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>红黑树的优点：</p>
<ul>
<li><strong>自平衡</strong>：通过颜色属性和旋转操作，红黑树可以保持平衡，确保基本操作的时间复杂度为$$O(\log n)$$。</li>
<li><strong>高效查找</strong>：由于平衡性，红黑树在最坏情况下的高度为$$2\log(n+1)$$，保证了查找操作的高效性。</li>
<li><strong>高效插入和删除</strong>：插入和删除操作在进行平衡调整时，旋转和重新染色的成本较低，确保了高效性。</li>
</ul>
<p>红黑树广泛应用于许多计算机系统和软件中，包括：</p>
<ul>
<li><strong>关联容器</strong>：C++的STL中的map和set，Java的TreeMap和TreeSet都基于红黑树实现。</li>
<li><strong>内存管理</strong>：Linux内核中的内存管理使用红黑树来管理空闲内存块。</li>
<li><strong>数据库索引</strong>：一些数据库系统使用红黑树作为索引结构，实现高效的数据检索。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是哈希表哈希表的实现方式怎么避免哈希冲突" class="heading-element"><span>13 什么是哈希表？哈希表的实现方式？怎么避免哈希冲突</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%93%88%e5%b8%8c%e8%a1%a8%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e6%80%8e%e4%b9%88%e9%81%bf%e5%85%8d%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>哈希表（Hash Table，也叫散列表），是根据键值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把键值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<p>哈希函数也称为散列函数，它接受一个键作为输入，并将其映射到哈希表的一个位置上。理想的哈希函数应该能够将键均匀地分布到哈希表的不同位置上，同时具有良好的计算效率。常见的哈希函数包括取余法、乘法哈希法、MD5、SHA等。选择合适的哈希函数取决于应用场景和性能要求。</p>
<p>当两个不同的键经过哈希函数映射后得到相同的位置时，就会发生哈希冲突。为了解决这个问题，常见的冲突解决方法包括：</p>
<ol>
<li><strong>开放定址法（Open Addressing）</strong>：当发生冲突时，顺序地查找下一个可用的位置，直到找到一个空槽位。常见的开放定址法包括线性探测、二次探测、双重哈希等。</li>
<li><strong>链地址法（Chaining）</strong>（最常用）：将哈希表的每个槽位都连接一个链表（或其他数据结构），当发生冲突时，将冲突的元素插入到对应位置的链表中。这样，相同哈希值的元素都存储在同一个链表中。</li>
<li><strong>再哈希法（Rehashing）</strong>：使用另一个哈希函数计算新的哈希值，然后再次查找空槽位。这样可以减少冲突的概率，提高哈希表的性能。</li>
<li><strong>建立公共溢出区</strong>：将哈希表的一部分空间作为溢出区，当发生冲突时，将冲突的元素存储在溢出区中。这样，哈希表的主要部分仍然保持较低的负载因子，提高了性能。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small" data-sub-html="<h2>image-20240601201150022</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png" alt="image-20240601201150022" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large 2x" data-title="image-20240601201150022" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>C/C++ 面试题目总结</title><link>https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 16:11:20 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<ol>
<li>
<p>const知道吗？解释其作用</p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
</li>
<li>
<p>宏定义 #define 和 const 常量</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏定义 #define</th>
<th style="text-align:center">const 常量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">宏定义，相当于字符替换         |</td>
<td style="text-align:center">常量声明    |</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">预处理器处理</font> |</td>
<td style="text-align:center">编译器处理   |</td>
</tr>
<tr>
<td style="text-align:center">无类型安全检查             |</td>
<td style="text-align:center">有类型安全检查 |</td>
</tr>
<tr>
<td style="text-align:center">不分配内存               |</td>
<td style="text-align:center">要分配内存   |</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">存储在代码段</font> |</td>
<td style="text-align:center">存储在数据段  |</td>
</tr>
<tr>
<td style="text-align:center">可通过 <code>#undef</code> 取消          |</td>
<td style="text-align:center">不可取消    |</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>static的作用</p>
<ol>
<li>修饰普通变量，<font color="red">修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间</font>，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，<font color="red">表明函数的作用范围</font>，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，<font color="red">修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员</font>。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，<font color="red">但是在 static 函数内不能访问非静态成员</font>。</li>
</ol>
</li>
<li>
<p>说说this指针</p>
<ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，<strong>编译程序先将对象的地址赋给 <code>this</code> 指针</strong>，然后调用成员函数，<font color="red">每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针</font>。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用<code>this</code>指针：
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>说说inline内联函数</p>
<p>相当于把内联函数里面的内容写在调用内联函数处，即不用执行进入函数的步骤，直接执行函数体；相当于宏，却比宏多了类型检查，真正具有函数特性；编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数（但虚函数也可以是内联函数，但是当虚函数表现出多态性时不能内联）。</p>
<p>优点：</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点：</p>
<ol start="4">
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。<font color="red">内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器</font>。</li>
</ol>
</li>
<li>
<p>说说volatile关键字</p>
<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以<font color="red">使用 volatile 告诉编译器不应对这样的对象进行优化</font>。</li>
<li>volatile 关键字声明的变量，<font color="red">每次访问时都必须从内存中取出值</font>（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
</li>
<li>
<p>说说assert()</p>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p><code>static_assert</code> 是一个编译时断言，用于在编译期间检查常量表达式是否为 <code>true</code>。它定义在 C++11 及更高版本的标准中。<code>static_assert</code> 通常用于模板编程和常量表达式中，以确保某些编译时条件成立。与 <code>assert</code> 不同的是，<code>static_assert</code> 在编译时进行检查，因此它不会影响运行时性能。</p>
</li>
<li>
<p>说说sizeof()</p>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
</li>
<li>
<p><code>#pragma pack(n)</code></p>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐，<code>#pragma pack(pop)</code>  恢复对齐状态</p>
</li>
<li>
<p><code>extern &quot;C&quot;</code></p>
<p>被 <code>extern</code> 限定的函数或变量是 <code>extern</code> 类型的，被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和链接的</p>
</li>
<li>
<p>C++ 中 struct 和 class</p>
<p>总的来说，<font color="red">struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体</font>。</p>
<p>最本质的一个区别就是默认的访问控制，struct 默认的数据访问控制是 public 的，class 默认的成员变量访问控制是 private 的。</p>
</li>
<li>
<p>union 联合</p>
<p>联合（union）是一种节省空间的特殊的类，<font color="red">一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值</font>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
</li>
<li>
<p>C 实现 C++ 类</p>
<p><font color="red">C 实现 C++ 的面向对象特性（封装、继承、多态）</font></p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
</li>
<li>
<p>explicit（显式）关键字</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li>
</ul>
</li>
<li>
<p>friend 友元类和友元函数</p>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
</li>
<li>
<p>谈谈using</p>
<p>using 关键字在 C++ 中有多种用途，主要包括类型别名、引入命名空间中的标识符。并且C++11 引入了别名模板，可以使用 <code>using</code> 创建模板的别名。</p>
<p>尽量少使用 using 指示：<code>using namespace std;</code>，会污染命名空间</p>
</li>
<li>
<p><code>::</code> 范围解析运算符</p>
<ol>
<li>
<p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>         <span class="c1">// 全局（::）的 count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>       <span class="c1">// 测试 1：设置全局的 count 的值为 12
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>   <span class="c1">// 类 A 的 count（A::count）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈<code>decltype</code>关键字</p>
<p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类，返回值为所属类型。语法：<code>decltype ( expression )</code></p>
</li>
<li>
<p>谈谈引用</p>
<p>在 C++ 中，引用（reference）是一种为已存在的变量创建别名的机制。引用可以让你通过另一个名字访问同一个变量。C++ 中的引用主要分为以下几种类型：</p>
<ol>
<li>
<p>左值引用（L-value References）：左值引用用于引用内存中已经存在的对象，通常用于函数参数传递和返回值。</p>
</li>
<li>
<p>右值引用（R-value References）：右值引用在 C++11 引入（<code>int&amp;&amp; rvalueRef = 10</code>），主要用于引用临时对象（右值），支持移动语义和完美转发，优化性能。</p>
</li>
<li>
<p>引用折叠（Reference Collapsing）：引用折叠是一种复杂的规则，决定了多层引用的结果。它在模板编程和完美转发中非常重要。</p>
<p><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code>
<code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></p>
</li>
</ol>
</li>
<li>
<p>成员初始化列表
好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：
<ul>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈面向对象</p>
<p>面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范式，基于“对象”的概念，用于组织代码和数据。OOP 提供了一种更自然和直观的方法来解决复杂的软件问题，使程序设计更加模块化和可维护。面向对象的三大特性：</p>
<ol>
<li><strong>封装（Encapsulation）</strong> ：封装是将数据和操作数据的方法捆绑在一起，形成一个自包含的单元—对象。<font color="red">封装通过定义类中的私有成员变量和公有成员函数，隐藏内部实现细节，只暴露必要的接口。封装提高了代码的安全性和可维护性</font>。</li>
<li><strong>继承（Inheritance）</strong> ：继承是一种机制，<font color="red">通过创建一个新的类（子类），该类可以继承一个或多个已有类（基类）的属性和方法，从而实现代码的重用和扩展</font>。继承支持多态性，并且使得代码更具层次性。</li>
<li><strong>多态（Polymorphism）</strong>：多态是指一个函数或方法可以有多种不同的表现形式。<font color="red">在C++中多态主要通过虚函数和函数重载实现，使得不同的对象可以用统一的接口进行操作，从而提高代码的灵活性和扩展性</font>。</li>
</ol>
</li>
<li>
<p>C++多态</p>
<p>C++ 多态分类及实现：</p>
<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
<li>
<p>谈谈虚析构函数</p>
<p>虚析构函数（Virtual Destructor）是面向对象编程中一个重要的概念，特别是在 C++ 中。它的主要目的是确保在通过基类指针删除派生类对象时，派生类的析构函数能够正确调用，从而防止资源泄漏和未定义行为。</p>
</li>
<li>
<p>在C++中，希望一个类不能被实例化，可以怎么做？</p>
<ol>
<li>
<p><strong>将类声明为抽象基类（Abstract Base Class, ABC）：</strong> <font color="red">如果一个类至少有一个纯虚函数，那么这个类就是抽象基类，无法被实例化</font>。纯虚函数是在基类中声明但不定义的虚函数，它在基类中的声明形式如下：<code>virtual void func() = 0;</code>。纯虚函数使得派生类必须提供自己的实现，否则派生类也将成为抽象基类。</p>
<p>如果其中没有其他合适的函数，可以把析构函数定义为纯虚析构函数</p>
</li>
<li>
<p><strong>声明类的构造函数为protected或private：</strong> 如果一个类的构造函数被声明为<code>protected</code>或<code>private</code>，那么在类的外部就不能直接调用这个构造函数来创建类的对象。只有类本身和它的友元函数或类可以访问它的私有或保护成员。</p>
</li>
</ol>
</li>
<li>
<p>虚函数、纯虚函数</p>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。而纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
</li>
<li>
<p>谈谈虚函数指针、虚函数表</p>
<p>虚函数指针是存储在对象中的特殊指针，用于指向对象的虚函数表。<font color="red">每个对象都有一个虚函数指针，它指向对象的虚函数表的首地址。</font>通过虚函数指针，可以在运行时动态地调用适当的虚函数。</p>
<p>虚函数表是存储在内存中的一张表格，用于存储类的虚函数地址。<font color="red">每个类（含有虚函数的类）都有一个对应的虚函数表，其中存放了该类所有虚函数的地址</font>。虚函数表是在编译阶段创建的，每个类的虚函数表在程序运行时都会存在于内存中。</p>
<p>虚函数指针指向虚函数表的首地址，通过虚函数指针可以访问到对象的虚函数表。当调用对象的虚函数时，编译器会使用虚函数指针找到对象的虚函数表，然后根据函数在虚函数表中的索引找到相应的虚函数地址，并进行调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span><span class="o">*</span> <span class="n">vptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="o">**</span><span class="p">)</span><span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表中第一个虚函数地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">funcAddr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 转换为函数指针并调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">funcAddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">func</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>谈谈虚继承</p>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，<font color="red">每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）</font>（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
</li>
<li>
<p>虚继承、虚函数</p>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：
<ul>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li><font color="red">虚基类表存储的是虚基类相对直接继承类的偏移</font></li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的抽象类、接口类、聚合类</p>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的模板机制</p>
<p>在C++中，模板（Template）是一种通用的代码生成机制，允许程序员编写通用的代码来处理不同类型的数据，而不需要为每种数据类型编写特定的代码。模板是C++中强大的特性之一，它提高了代码的重用性、可读性和可维护性。</p>
<ol>
<li>
<p>类模板（Class Templates）：类模板是一种用于创建通用类的模板，允许类中的数据成员和成员函数的类型参数化。通过类模板，可以定义一个通用的类，可以处理多种不同类型的数据。</p>
</li>
<li>
<p>函数模板（Function Templates）：函数模板是一种用于创建通用函数的模板，允许函数中的参数类型参数化。通过函数模板，可以定义一个通用的函数，可以处理多种不同类型的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">maximum</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板特化（Template Specialization）：模板特化是指针对某些特定的类型，为模板定义一个特殊的实现。当模板在处理特定类型时需要特殊的行为时，可以使用模板特化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Stack&lt;std::string&gt;::pop(): empty stack&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">element</span> <span class="o">=</span> <span class="n">elements</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板参数（Template Parameters）：模板参数是在定义模板时指定的参数，它可以是类型参数或非类型参数。类型参数指定了模板中的数据类型，而非类型参数可以是整数、指针等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>C++的new/delete和malloc/delete有什么区别？</p>
<p>C++中的<code>new</code>和<code>malloc()</code>都用于在堆上动态分配内存，但它们之间有一些重要的区别：</p>
<ol>
<li><code>new</code> 是C++中的关键字，可以为指定的类型动态分配内存，并返回相应类型的指针。而<code>malloc()</code>是C标准库函数，它返回<code>void*</code>类型的指针，需要手动进行类型转换，将其转换为所需类型的指针。这样的操作在C++中不够安全，可能导致编译器无法检测到的类型错误。</li>
<li><code>new</code> 分配内存时会调用对象的构造函数，确保对象被正确初始化。<code>malloc()</code> 只是简单地分配一块内存，并不会调用对象的构造函数。</li>
<li><code>new</code> 可以根据所需类型的大小自动计算要分配的内存空间大小，无需手动计算。而<code>malloc()</code> 需要手动指定要分配的内存空间大小，需要调用<code>sizeof</code>函数来计算所需的字节数。</li>
<li>在内存分配失败时，<code>new</code> 会抛出异常（<code>std::bad_alloc</code>），需要使用异常处理机制来处理。而<code>malloc()</code> 分配内存失败时会返回空指针（<code>NULL</code>），需要手动检查返回值并进行错误处理。</li>
<li>使用<code>new</code>分配的内存需要使用<code>delete</code>关键字进行释放，而使用<code>malloc()</code>分配的内存需要使用<code>free()</code>函数进行释放。</li>
</ol>
<p>本质：<code>new / new[]</code>：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。<code>delete/delete[]</code>：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p>
</li>
<li>
<p>delete this 合法吗？</p>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
</li>
<li>
<p>C++如何定义一个只能在堆上（栈上）生成对象的类？</p>
<ul>
<li>只能在堆上：将析构函数设置为私有。C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li>
<li>只能在栈上：将 new 和 delete 重载为私有。在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li>
</ul>
</li>
<li>
<p>介绍一下C++的智能指针</p>
<p>C++中的智能指针是一种特殊的指针对象，可以自动管理动态分配的内存，避免内存泄漏和悬空指针等常见问题。智能指针通过包装原始指针，提供了自动释放内存的机制，从而简化了内存管理的工作。常见的智能指针包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>（<code>auto_ptr</code>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。）。</p>
<ol>
<li><code>std::unique_ptr</code>是一种独占式智能指针，即同一时间只能有一个<code>std::unique_ptr</code>拥有某个对象的所有权。当<code>std::unique_ptr</code>超出作用域或被显式释放时，它所管理的对象会被自动释放。不能复制或赋值给其他<code>std::unique_ptr</code>，但可以通过<code>std::move()</code>来转移所有权。<font color="red">适用于需要严格所有权管理的情况，例如资源管理类对象</font>。</li>
<li><code>std::shared_ptr</code>是一种共享式智能指针，可以拥有多个<code>std::shared_ptr</code>共享同一个对象。使用引用计数来跟踪对象的引用次数，当引用次数为0时，对象会被自动释放。可以复制和赋值给其他<code>std::shared_ptr</code>，引用计数会增加。<font color="red">适用于需要多个指针共享同一资源的情况，例如多个对象共享一个动态分配的对象</font>。</li>
<li><code>std::weak_ptr</code>是一种弱引用智能指针，它不会增加对象的引用计数，也不会影响对象的生命周期。用于解决<code>std::shared_ptr</code>的循环引用问题，通过打破循环引用，<strong>防止内存泄漏</strong>。可以通过<code>lock()</code>方法获取一个指向被管理对象的<code>std::shared_ptr</code>，如果对象已经被释放，则返回空指针。</li>
</ol>
</li>
<li>
<p>谈谈C++的强制类型转换</p>
<p>在C++中，有四种主要的强制类型转换方式：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。用法：<code>static_cast&lt;typename&gt;(object)</code></p>
<ol>
<li>
<p><code>static_cast</code>用于进行静态类型转换，通常用于较为安全的转换，例如基本数据类型之间的转换、类层次结构中的向上转换（派生类指针转为基类指针）和向下转换（基类指针转为派生类指针）等。<font color="red">静态转换在编译时进行，不提供运行时类型检查</font>。</p>
</li>
<li>
<p><code>dynamic_cast</code>用于进行动态类型转换，用于安全地在类层次结构中进行向上或向下转换，并且提供了运行时类型检查。当进行向下转换时，如果指针不指向有效的派生类对象，则返回空指针。<font color="red">只能用于具有虚函数的类（即多态类）之间的转换。</font></p>
</li>
<li>
<p><code>const_cast</code>用于添加或删除对象的const属性、volatile属性，<font color="red">主要用于消除类型的const限制</font>。注意：不应该用于修改本来就不可修改的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 去除const属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// 合法，修改了const对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>reinterpret_cast</code>用于进行底层的重新解释转换，例如将一个指针转换为一个整数，或者一个整数转换为一个指针。这种转换非常危险，可能会导致未定义的行为，因此应该尽量避免使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 将int指针转换为void指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">newXPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 将void指针转换为int指针
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈运行时类型信息 (RTTI)</p>
<p>运行时类型信息（RTTI, Runtime Type Information）是C++提供的一种机制，用于在运行时识别对象的类型。RTTI允许程序在运行时获取关于对象类型的信息，主要包括两个关键特性：<code>typeid</code>操作符和<code>dynamic_cast</code>操作符。</p>
<ol>
<li><code>typeid</code>操作符用于获取表达式或对象的类型信息。<code>typeid</code>返回一个<code>std::type_info</code>对象，该对象包含了类型的信息，可以通过其成员函数来获取类型名等信息。</li>
<li><code>dynamic_cast</code>用于多态类型的转换</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnotherDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 成功转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AnotherDerived</span><span class="o">*</span> <span class="n">ad</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">AnotherDerived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 转换失败，返回nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is a Derived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is not an AnotherDerived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>RTTI通常用于以下场景：</p>
<ul>
<li><strong>安全类型转换</strong>：在复杂的类层次结构中，使用<code>dynamic_cast</code>进行安全的向下转换，确保类型转换的正确性。</li>
<li><strong>类型检查</strong>：使用<code>typeid</code>进行类型检查，调试和记录对象的实际类型信息，帮助诊断问题。</li>
</ul>
</li>
<li>
<p>谈谈C++中怎么处理异常</p>
<p>在C++中，异常处理是一种机制，用于捕获和处理程序运行过程中发生的错误或异常情况，从而避免程序崩溃。C++通过<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现异常处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能抛出异常的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理标准库异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Standard exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理整型异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Integer exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理其他所有类型的异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unknown exception caught&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>throw</code>表达式用于抛出异常，可以抛出任何类型的对象。</p>
<p>C++允许用户定义自己的异常类，通常继承自<code>std::exception</code>，并重写<code>what()</code>方法来提供异常信息。</p>
</li>
<li>
<p>STL容器</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">有无序</th>
<th style="text-align:center">可不可重复</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机读改 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">支持随机访问，大小固定，不能动态调整</td>
</tr>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">支持随机访问，动态调整大小，使用连续内存存储，插入删除效率视位置而定</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">双端队列</td>
<td style="text-align:center">头尾插入、头尾删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问，但随机访问效率略低于vector</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单向链表</td>
<td style="text-align:center">插入、删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不支持随机访问，只能单向遍历，适用于只需前向访问和修改的场景</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双向链表</td>
<td style="text-align:center">插入、删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不支持随机访问，支持双向遍历，适用于频繁插入和删除的场景</td>
</tr>
<tr>
<td style="text-align:center">stack</td>
<td style="text-align:center">deque / list</td>
<td style="text-align:center">顶部插入、顶部删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">适用于后进先出（LIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
</tr>
<tr>
<td style="text-align:center">queue</td>
<td style="text-align:center">deque / list</td>
<td style="text-align:center">尾部插入、头部删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">适用于先进先出（FIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
</tr>
<tr>
<td style="text-align:center">priority_queue</td>
<td style="text-align:center">vector + max-heap</td>
<td style="text-align:center">插入、删除 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">使用最大堆实现，适用于需要动态获取最大元素的场景，底层使用vector存储</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">自动排序且元素唯一，适用于需要有序且无重复元素的场景</td>
</tr>
<tr>
<td style="text-align:center">multiset</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">自动排序，允许重复元素，适用于需要有序且可重复元素的场景</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">键值对存储，键唯一，自动按键排序，适用于需要按键有序访问且键唯一的场景</td>
</tr>
<tr>
<td style="text-align:center">multimap</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">键值对存储，键可重复，自动按键排序，适用于需要按键有序访问且键可重复的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_set</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">使用哈希表实现，元素唯一，无序存储，适用于快速查找和插入的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_multiset</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">使用哈希表实现，允许重复元素，无序存储，适用于需要快速查找和插入且元素可重复的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_map</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">键值对存储，键唯一，使用哈希表实现，无序存储，适用于需要快速按键查找和插入的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_multimap</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">键值对存储，键可重复，使用哈希表实现，无序存储，适用于需要快速按键查找和插入且键可重复的场景</td>
</tr>
</tbody>
</table>
</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】GFS</title><link>https://hezephyr.github.io/posts/04.gfs/</link><pubDate>Tue, 28 May 2024 16:24:28 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.gfs/</guid><description><![CDATA[<h2 id="分布式存储系统难点" class="heading-element"><span>1 分布式存储系统难点</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f%e9%9a%be%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在设计大型分布式系统或存储系统时，初衷通常是为了获得显著的性能提升，通过数百台计算机的资源来并行完成大量工作。因此，性能问题成为最初的关注点。一个自然的想法是将数据分片（Sharding），分布到大量服务器上，从而并行读取数据。</p>
<p>当你在成百上千台服务器上进行分片时，服务器故障将成为常态。如果你有数千台服务器，每天甚至每小时都可能有服务器宕机。因此，需要自动化的方法来修复错误，而不是依赖人工介入。为此，自动容错系统至关重要，这引出了容错（fault tolerance）的概念。</p>
<p>实现容错最有效的方法之一是使用数据复制，只需维护2-3个数据副本，当其中一个故障时，可以使用另一个。因此，要实现容错，必须进行数据复制（replication）。</p>
<p>然而，数据复制带来了不一致性（inconsistency）问题。拥有多个数据副本，如果管理不当，副本之间可能不一致。理想情况下，可以任意使用任一副本进行容错，但如果副本不一致，应用程序将面临麻烦。因此，数据复制不可避免地会引发不一致性问题。</p>
<p>通过精巧的设计，可以减少甚至避免不一致性，使数据表现得符合预期。但要实现这一点，服务器之间需要进行额外的网络交互，这会降低性能。因此，如果追求一致性（consistency），必须付出性能的代价，这与最初的高性能目标相悖。</p>
<p>尽管可以构建高性能系统，但不可避免地会陷入性能与一致性的权衡之中。在实际应用中，为了获得良好的一致性，必须付出相应的代价。如果不愿付出代价，就需要忍受一定程度的不确定性。很多系统中都存在这种权衡，人们往往不愿为高一致性牺牲性能。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=small" data-sub-html="<h2>image-20240528101751499</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png" alt="image-20240528101751499" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=large 2x" data-title="image-20240528101751499" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="错误的设计" class="heading-element"><span>2 错误的设计</span>
  <a href="#%e9%94%99%e8%af%af%e7%9a%84%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于强一致性系统，应用程序或客户端感受到的就像在与一台服务器通信。尽管系统由数百台计算机组成，但理想的强一致模型让它看起来像只有一台服务器，一份数据，并且一次只处理一个请求。这种设计确保了每个请求能看到之前所有请求按顺序执行的结果。</p>
<p>对于存储服务器来说，它通常包含一块磁盘。执行写请求可能意味着向磁盘写入数据或对数据进行自增操作。如果是一次修改操作，并且我们有一个以 key-value 为索引的数据表单，那么我们会更新这个表单。如果是读取操作，只需从表单中取出之前写入的数据即可。为了保证这个简单服务的行为可预期，需要遵循一个规则：每次只执行一个请求。这样，每个请求都能看到之前所有请求按顺序执行后的结果。如果服务器按某种顺序依次处理写请求，当你读取数据时，你就能看到预期的数据。</p>
<p>举例来说，客户端 C1 发起写请求将 X 设置为 1，同时客户端 C2 发起写请求将 X 设置为 2。待 C1 和 C2 的写请求都执行完毕后，客户端 C3 发送读取 X 的请求，得到一个结果；客户端 C4 也发送读取 X 的请求，得到另一个结果。此时，问题是这两个客户端看到的结果会是什么。</p>
<p>即使在一个非常简单的系统中，仍会出现一些模糊场景，使你无法确定系统的执行过程及其输出结果。你只能根据结果判断系统是否保持了一致性。</p>
<p>如果 C3 读取 X 得到 2，那么 C4 也应该读取到 2，因为这表明写 X 为 2 的请求是第二个执行的写请求。当 C4 读取 X 时，写 X 为 2 应该仍然是第二个写请求。</p>
<p>然而，单服务器设计存在容错能力差的问题。如果服务器故障或磁盘损坏，系统将无法使用。因此，现实中我们会构建多副本的分布式系统，这引发了一系列新的问题。</p>
<p>假设我们有两台服务器，每台服务器都有数据的一份完整拷贝，并在磁盘上存储一个 key-value 表单。我们希望这两个表单完全一致，这样当一台服务器故障时，可以切换到另一台服务器继续读写操作。</p>
<p>两个表单完全一致意味着，<font color="red">每一个写请求都必须在两台服务器上执行，而读请求只需要在一台服务器上执行</font>，否则就没有容错性了。因为如果读请求也需要从两台服务器读数据，那么一台服务器故障我们就没法提供服务了。现在问题来了，假设客户端C1和C2都想执行写请求，其中一个要写X为1，另一个写X为2。C1会将写X为1的请求发送个两个服务器，因为我们想要更新两台服务器上的数据。C2也会将写X为2的请求发送给两个服务器。</p>
<p>这里会出现什么错误呢？是的，我们没有做任何事情来保障两台服务器以相同的顺序处理这2个请求。如果服务器1（S1）先处理C1的请求，那么在它的表单里面，X先是1，之后S1看到了来自C2的请求，会将自己表单中的X覆盖成2。但是，如果S2恰好以不同的顺序收到客户端请求，那么S2会先执行C2的请求，将X设置为2，之后收到C1的请求，将X设置为1。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=small" data-sub-html="<h2>image-20240528104959963</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png" alt="image-20240528104959963" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=large 2x" data-title="image-20240528104959963" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>之后，如果另外一些客户端，假设C3从S1读数据，C4从S2读数据，我们就会面临一个可怕的场景：这两个客户端读取的数据不一样。但是从前一个例子中的简单模型可以看出，相连的读请求应该读出相同的数据。</p>
<p>这里的问题可以以另一种方式暴露出来。假设我们尝试修复上面的问题，我们让客户端在S1还在线的时候，只从S1读取数据，S1不在线了再从S2读取数据。这样最开始所有的客户端读X都能得到2。但是突然，如果S1故障了，尽管没有写请求将X改成1，客户端读X得到的数据将会从2变成1。因为S1故障之后，所有的客户端都会切换到S2去读数据。这种数据的神奇变化与任何写操作都没有关联，并且也不可能在前一个例子的简单模型中发生。</p>
<p>当然，这里的问题是可以修复的，修复需要服务器之间更多的通信，并且复杂度也会提升。由于获取强一致会带来不可避免的复杂性的提升，有大量的方法可以在好的一致性和一些小瑕疵行为之间追求一个平衡。</p>
<h2 id="gfs设计目标" class="heading-element"><span>3 GFS设计目标</span>
  <a href="#gfs%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Google的目标是构建一个大型且快速的文件系统（GFS），以便各种应用程序都能全局访问数据。传统的方法是为每个应用程序构建特定的存储系统，但这会导致重复建设。GFS 作为一个全局通用的存储系统，允许不同应用程序共享和访问数据。例如，存储了大量互联网抓取数据后，其他用户可以通过申请权限查看这些数据，因为大家使用的是同一个存储系统。这样，Google 内部的人员可以根据名字读取 GFS 中可共享的内容。</p>
<p>为了实现大容量和高速性能，GFS 将数据文件自动分割并存储在多台服务器上，这样可以并行读取同一个文件，从而获得更高的聚合吞吐量。文件分割存储还允许存储比单个磁盘更大的文件。由于存储系统分布在数百台服务器上，GFS 具备自动故障修复功能，不需要人工干预来修复服务器或迁移数据。</p>
<p>GFS 的一些特征并非设计目标。例如，GFS 只在一个数据中心内运行，多个副本并未分布在全球各地。理论上，数据副本应该地理分散，但实现起来很难，所以 GFS 局限于单个数据中心内。</p>
<p>此外，GFS 面向 Google 内部使用，供工程师开发应用程序，并不直接面向普通用户。虽然 Google 可能会出售基于 GFS 的服务，但 GFS 本身并不对外提供。</p>
<p>最后，GFS 专注于对大型顺序文件的读写优化。例如，银行账户系统需要能够读写小数据块的数据库，而 GFS 针对 TB 级别的文件进行优化，只支持顺序处理而非随机访问。某种程度上，它更像批处理系统，注重巨大的吞吐量而非低延迟，每次操作都涉及 MB 级别的数据。</p>
<h2 id="master节点" class="heading-element"><span>4 Master节点</span>
  <a href="#master%e8%8a%82%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>假设我们有上百个客户端和一个Master节点。虽然实际中可以有多台机器作为Master节点，但GFS中Master采用Active-Standby模式（系统包含两个或多个实例，其中一个实例（Active）正在运行并处理所有的请求，而其他实例（Standby）则处于待命状态，准备在Active实例发生故障时立即接管工作。），所以只有一个Master节点在工作。Master节点保存了文件名和存储位置的对应关系。除此之外，还有大量的Chunk服务器，每个Chunk服务器上都有1-2块磁盘。</p>
<p>Master节点管理文件和Chunk的信息，而Chunk服务器存储实际数据。这种设计将管理和存储分开处理，提高了系统效率。在GFS中，Master节点知道每个文件对应的所有Chunk handle，这些Chunk每个是64MB大小，共同构成一个文件。例如，一个1GB的文件会分成多个Chunk，Master节点知道每个Chunk存储在哪。读取文件时，需要先向Master节点查询Chunk位置，然后从对应的Chunk服务器读取数据。</p>
<p>我们需要了解Master节点内保存的数据内容，这里我们关心的主要是两个表单：</p>
<ol>
<li><strong>文件名到Chunk handle的对应关系</strong>：Master节点有一个表单记录了文件名到Chunk handle数组的对应关系。</li>
<li><strong>Chunk handle到Chunk数据的对应关系</strong>：另一个表单记录了Chunk handle和它们的数据的对应关系，包括每个Chunk的服务器列表、当前版本号、主Chunk（Primary Chunk）和租约过期时间。</li>
</ol>
<p>这些数据都存储在内存中，但为了防止数据丢失，Master节点也将部分数据存储在磁盘上。Master节点的写操作会记录到磁盘的日志（log）中，并定期生成检查点（CheckPoint）。</p>
<p>有些数据需要存在磁盘上，而有些不用。它们分别是：</p>
<ul>
<li><strong>Chunk Handle数组</strong>（非易失性，NV）：保存到磁盘上。</li>
<li><strong>Chunk服务器列表</strong>（易失性，V）：不用写入磁盘，重启后可重新获取。</li>
<li><strong>版本号</strong>（非易失性，NV）：写入磁盘，确保数据一致性。</li>
<li><strong>主Chunk的handle</strong>（易失性，V）：不写入磁盘，重启后可重新分配。</li>
<li><strong>租约过期时间</strong>（易失性，V）：不写入磁盘。</li>
</ul>
<p>当文件扩展到新的64MB或主Chunk变更时，Master节点会向磁盘日志中追加记录。这种日志追加方式比数据库高效，因为它只需顺序写入，不涉及磁盘的随机访问。</p>
<p>Master节点故障重启时，会从最近的检查点开始恢复状态，然后通过执行日志中的记录恢复到最新状态。这种方式避免了从日志最开始重建状态的低效问题。</p>
<h2 id="读文件" class="heading-element"><span>5 读文件</span>
  <a href="#%e8%af%bb%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于读请求来说，应用程序或GFS客户端会提供一个文件名和读取的偏移量（offset）。首先，客户端将这些信息发送给Master节点。Master节点从自己的文件表单中查找文件名，获取对应的Chunk handle数组。每个Chunk大小为64MB，因此可以通过偏移量除以64MB来确定对应的Chunk handle。接着，Master节点从Chunk表单中找到包含该Chunk的服务器列表，并将这个列表返回给客户端。</p>
<p>具体步骤如下：</p>
<ol>
<li>客户端（或应用程序）将文件名和偏移量发送给Master节点。</li>
<li>Master节点将Chunk Handle（即Chunk ID）和服务器列表发送给客户端。</li>
</ol>
<p>客户端接下来可以从服务器列表中选择一个服务器来读取数据。根据GFS论文的描述，客户端会选择一个在网络上最近的服务器（在Google的数据中心中，通过IP地址的差异可以判断网络位置的远近），然后将读请求发送到这个服务器。由于客户端每次可能只读取1MB或64KB的数据，它可能会多次读取同一个Chunk的不同部分。为此，客户端会缓存Chunk和服务器的对应关系，这样在后续读取相同Chunk数据时，不需要每次都向Master请求相同的信息。</p>
<p>接下来，客户端会与选定的Chunk服务器通信，将Chunk Handle和偏移量发送给该服务器。Chunk服务器在本地硬盘上将每个Chunk存储为独立的Linux文件，并通过普通的Linux文件系统进行管理。可以推测，Chunk文件会按照Handle（即ID）命名。因此，Chunk服务器需要做的就是根据文件名找到对应的Chunk文件，从文件中读取相应的数据段，并将数据返回给客户端。</p>
<h2 id="写文件" class="heading-element"><span>6 写文件</span>
  <a href="#%e5%86%99%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于应用程序来说，写文件的过程与读文件的接口非常类似，都是通过调用GFS的库函数进行操作。在写文件时，应用程序会告诉库函数，要将缓冲区中的数据追加到指定文件中。为了简化讨论，我们只考虑GFS论文中的记录追加（Record Append）的情况。</p>
<p>所以再次描述一下，对于写文件，客户端会向Master节点发送请求说：我想向这个文件名对应的文件追加数据，请告诉我文件中最后一个Chunk的位置。</p>
<p>当有多个客户端同时写同一个文件时，一个客户端并不能知道文件究竟有多长。因为如果只有一个客户端在写文件，客户端自己可以记录文件长度，而多个客户端时，一个客户端没法知道其他客户端写了多少。例如，不同客户端写同一份日志文件，没有一个客户端会知道文件究竟有多长，因此也就不知道该往什么样的偏移量，或者说向哪个Chunk去追加数据。这个时候，客户端可以向Master节点查询哪个Chunk服务器保存了文件的最后一个Chunk。</p>
<p>对于读操作，可以从任何最新的Chunk副本读取数据，但写操作必须通过Chunk的主副本（Primary Chunk）进行。Master节点需要确保Chunk的主副本存在。如果不存在，Master节点会查找所有存有该Chunk最新副本的Chunk服务器。Master节点确定哪些副本是最新的（副本中保存的版本号与Master中记录的Chunk的版本号一致），并从中选择一个作为Primary，其余作为Secondary。</p>
<p>之后，Master节点增加Chunk的版本号，并将新的版本号写入磁盘。Master节点通知Primary和Secondary服务器新的Chunk版本号，并指定它们的角色。Primary和Secondary服务器将新版本号存储在本地磁盘中，以便在重启时报告给Master。</p>
<p>所以客户端将要追加的数据发送给Primary和Secondary服务器，这些服务器将数据写入临时位置。所以最开始，这些数据不会追加到文件中。当所有服务器确认数据已写入临时位置后，客户端向Primary发送消息，要求将数据追加到文件中。Primary按照顺序处理来自多个客户端的并发请求，确保每次只执行一个请求。Primary将数据写入Chunk的末尾，并通知所有Secondary服务器也将数据写入它们的Chunk末尾。</p>
<p>Secondary服务器将数据写入本地磁盘后，向Primary发送确认消息。如果所有Secondary服务器成功写入数据并回复“yes”，Primary向客户端返回写入成功。如果任何Secondary服务器写入失败，Primary向客户端返回写入失败。</p>
<p>如果客户端接到写入失败的消息，应重新发起整个追加过程。首先，客户端再次与Master节点交互，找到文件末尾的Chunk，然后重新向Primary和Secondary发起追加操作。</p>
<h2 id="gfs的一致性" class="heading-element"><span>7 GFS的一致性</span>
  <a href="#gfs%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在GFS中，追加数据的过程相对复杂。我们通过一个例子来解释这一过程。</p>
<ol>
<li>
<p>**数据追加请求：**客户端发送一个追加数据的请求，例如数据A，要将数据A追加到文件末尾。Chunk的三个副本（一个Primary和两个Secondary）都成功将数据A追加到了Chunk中，因此Chunk中的第一个记录是A。</p>
</li>
<li>
<p>**网络问题导致的部分写入：**第二个客户端加入，想要追加数据B。但由于网络问题，消息只被Primary和一个Secondary收到并处理。因此，两个副本追加了数据B，而另一个副本没有。</p>
</li>
<li>
<p>**后续写入：**第三个客户端想要追加数据C，并且Primary选择了偏移量并通知Secondary。三个副本都成功追加了数据C。</p>
</li>
<li>
<p>**处理写入失败：**由于网络问题，第二个客户端会收到写入失败的回复，并重新发起追加数据B的请求。假设这次数据B没有丢包，三个副本都成功追加了数据B。现在，三个副本都在线，并且都有最新的版本号。</p>
</li>
<li>
<p>**读取数据的影响：**客户端读取文件时，读取的内容取决于读取的是哪个副本。例如：</p>
<ul>
<li>读取第一个副本时，可能会看到数据A、B、C，然后是重复的B。</li>
<li>读取第三个副本时，可能会看到数据A、一个空白数据、然后是C、B。</li>
</ul>
<p>所以不同的读请求可能得到不同的结果，具体取决于读取的是哪个副本。</p>
</li>
<li>
<p>**处理写入失败的复杂情况：**在最坏情况下，某个Secondary未能成功执行数据追加操作，客户端从Primary收到写入失败的回复。在客户端重新发送写文件请求之前，客户端可能故障，导致数据D只存在于某些副本中，而其他副本完全没有。</p>
</li>
</ol>
<p>在GFS的这种工作方式下，如果Primary返回写入成功，一切正常。如果Primary返回写入失败，不同副本的数据可能不同。GFS的设计简单，但可能会暴露一些奇怪的数据顺序问题。应用程序需要容忍数据乱序，或通过在文件中写入序列号来识别顺序。如果应用程序对数据顺序敏感，可以避免并发写入，例如，电影文件的写入应使用一个客户端顺序追加数据。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=small" data-sub-html="<h2>4f013eecba1d5a096fdac0325605e35f</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png" alt="4f013eecba1d5a096fdac0325605e35f" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=large 2x" data-title="4f013eecba1d5a096fdac0325605e35f" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果要将GFS升级为强一致系统，需要考虑以下几点：</p>
<ol>
<li>**检测重复请求：**Primary需要能够检测重复的请求，确保数据不会重复写入。</li>
<li>**Secondary的强制执行：**Secondary必须执行Primary的请求，而不能简单地返回错误。对于永久性故障的Secondary，需要有机制将其移除。</li>
<li>**两阶段提交：**写请求需要两个阶段：首先Primary向Secondary发出请求并等待确认；如果所有Secondary都确认，Primary再指示实际执行操作。</li>
<li>**处理Primary崩溃：**当Primary崩溃时，新Primary需要与Secondary同步，确保操作历史一致。</li>
<li>**Secondary的租约系统：**Secondary需要一个类似Primary的租约系统，确保在合法时间内响应客户端请求。</li>
</ol>
<p>总体而言，GFS取得了巨大的成功，许多Google的应用都依赖于它。例如，BigTable和MapReduce等关键基础架构都是构建在GFS之上的，因此GFS在Google内部得到了广泛应用。然而，GFS也有其局限性，最严重的问题在于它只有一个Master节点，这带来了以下几个问题：</p>
<ol>
<li>
<p>**内存限制：**Master节点必须为每个文件和每个Chunk维护表单。随着使用量的增加，文件数量不断上升，最终Master节点会耗尽内存来存储这些表单。虽然可以增加内存，但单台计算机的内存总有上限，这成为了早期遇到的一个显著问题。</p>
</li>
<li>
<p>**处理能力：**单个Master节点需要处理数千个客户端的请求，而其CPU每秒只能处理数百个请求。尤其当Master节点还需要将部分数据写入磁盘时，这个问题变得更加严重，导致客户端数量很快超过了单个Master的处理能力。</p>
</li>
<li>
<p>**复杂的语义：**应用程序发现很难处理GFS复杂的语义，特别是副本数据同步问题（或不同步问题），这在一定程度上增加了开发难度。</p>
</li>
<li>
<p>**故障切换：**从GFS论文中可以了解到，Master节点的故障切换不是自动的。当Master节点永久故障时，需要人工干预来更换新的服务器，这可能需要几十分钟甚至更长时间来处理。对于某些应用程序来说，这样的停机时间是不可接受的。</p>
</li>
</ol>
<h2 id="faq" class="heading-element"><span>8 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li>应用程序如何知道Chunk的哪些部分由填充和重复记录组成？</li>
</ol>
<p>为了检测填充，应用程序可以在有效记录的开头放置一个可预测的幻数，或者包含一个校验和，该校验和可能仅在记录有效时才有效。应用程序可以通过在记录中包含唯一 ID 来检测重复项。然后，如果它读取的记录与之前的记录具有相同的 ID，它就知道它们是彼此的重复项。 GFS 为处理这些情况的应用程序提供了一个库。 GFS 设计的这一方面有效地将复杂性从 GFS 转移到了应用程序，但这可能并不理想。</p>
<ol start="2">
<li>怎样知道一个文件存储在哪台机器上？</li>
</ol>
<p>根据master中文件到chunk再到chunk位置的映射来定位具体的chunkserver。</p>
<ol start="3">
<li>论文提到了引用计数——它们是什么？</li>
</ol>
<p>它们是快照写时复制实现的一部分。当GFS创建快照时，它不会复制块，而是增加每个块的引用计数器。这使得创建快照的成本很低。如果客户端写入一个chunk并且主服务器注意到引用计数大于 1，则主服务器首先创建一个副本，以便客户端可以更新该副本（而不是属于快照一部分的块）。您可以将此视为延迟复制，直到绝对必要为止。希望并非所有块都会被修改，并且可以避免制作一些副本。</p>
<ol start="4">
<li>什么是租约？</li>
</ol>
<p>对于 GFS，租约是master授予 chunkserver 充当特定 chunk 的主chunkserver的能力的一段时间。master保证在租约期间不会分配不同的主chunkserver，并且主服务器同意在租约到期之前停止充当主chunkserver（除非主chunkserver要求master延长租约）。租约是避免主chunkserver必须反复询问master是否仍然是主chunkserver的一种方法—它知道它可以在下一分钟（或无论租约间隔是多少）充当主chunkserver，而无需再次与master通信。</p>
<ol start="5">
<li>什么是内部碎片？为什么惰性分配有帮助？</li>
</ol>
<p>内部碎片是当系统使用大于所请求分配所需的分配单元时浪费的空间。如果 GFS 以 64MB 为单位分配磁盘空间，那么一个 1 字节的文件将浪费近 64MB 的磁盘空间。 GFS 通过延迟分配磁盘空间来避免这个问题。每个块都是一个Linux文件，Linux文件系统使用的块大小为几十KB；<font color="red">因此，当应用程序创建一字节 GFS 文件时，该文件的块仅消耗 1 个 Linux 磁盘块，而不是 64 MB</font>。</p>
<ol start="6">
<li>Google 还在使用 GFS 吗？</li>
</ol>
<p>有传言称 GFS 已被 Colossus 所取代，总体目标相同，但在主性能和容错性方面有所改进。此外，Google内部的许多应用程序已经转向更多类似数据库的存储系统，例如BigTable和Spanner。然而，GFS 的大部分设计仍然存在于 HDFS（Hadoop 开源 MapReduce 的存储系统）中。</p>
</blockquote>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】 测试分布式系统的线性一致性</title><link>https://hezephyr.github.io/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Wed, 22 May 2024 09:33:17 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description><![CDATA[<p><a href="https://anishathalye.com/testing-distributed-systems-for-linearizability/"target="_blank" rel="external nofollow noopener noreferrer">Testing Distributed Systems for Linearizability 原文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正确实现一个分布式系统是非常有挑战的一件事情，因为需要很好的处理并发和失败这些问题。网络包可能被延迟，重复，乱序或者丢弃，机器可能在任何时候宕机。即使一些计被论文证明是正确的，也仍然很难再实现中避免 bug。</p>
<p>除非我们使用形式方法，不然，即使我们假设实现是正确的，我们也需要去测试系统。测试分布式系统也是一件非常有挑战的事情。并发和不确定性使得我们在测试的时候非常难抓住 bug，尤其是在一些极端情况下面才会出现的 bug，譬如同时机器宕机或者极端网络延迟。</p>
<h2 id="正确性" class="heading-element"><span>2 正确性</span>
  <a href="#%e6%ad%a3%e7%a1%ae%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在讨论测试分布式系统的正确性之前，我们首先定义下什么是 “正确性”。即使对于一些简单的系统，要完全的确定系统符合预期也是一件相当复杂的事情。</p>
<p>考虑一个简单的 key-value store，譬如 etcd，支持两个操作：<code>Put(key, value)</code> 和 <code>Get(key)</code>，首先，我们需要考虑它在顺序情况下面的行为。</p>
<h3 id="顺序规范" class="heading-element"><span>2.1 顺序规范</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e8%a7%84%e8%8c%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通常对于一个 key-value store，我们对于它在顺序操作下面的行为都能有一个直观的认识：<code>Get</code> 操作如果在 <code>Put</code> 的后面，那么一定能得到 <code>Put</code> 的结果。譬如，如果 <code>Put(&quot;x&quot;, &quot;y&quot;)</code> ，那么后面的 <code>Get(&quot;x&quot;)</code> 就能得到 &ldquo;y&rdquo;，如果得到了 &ldquo;z&rdquo;，那么这就是不对的。</p>
<p>我们使用 Python 定义一个简单的 key-value store：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>上面的代码比较简单，但包含了足够的信息，包括初始状态是怎样的，内部状态是如何被操作的结果改变的，从 key-value存储里面操作返回的结果是怎样的。这里需要留意下 <code>Get()</code> 对于不存在的 key 的处理，通常会返回一个空字符串。</p>
<h2 id="线性一致性" class="heading-element"><span>3 线性一致性</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>接下来，我们来考虑我们的 key-value store在并发下面会有怎样的行为。需要注意顺序规范并没有指明在并发操作下面会发生什么。譬如，顺序规范并没有说 key-value store 在下面这个场景下可以允许的操作。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们并不能立刻知道 <code>Get(&quot;x&quot;)</code> 这个操作会允许返回怎样的结果。直觉上，我们可以说<code>Get(&quot;x&quot;)</code> 是跟 <code>Put(&quot;x&quot;, &quot;y&quot;)</code> 和 <code>Put(&quot;x&quot;, &quot;z&quot;)</code> 一起执行的，所以它能可能返回一个值，甚至也可能返回 <code>&quot;&quot;</code>。 如果有另一个 <code>Get(&quot;x&quot;)</code> 的操作在更后面执行，我们可以说这个一定能返回 <code>&quot;z&quot;</code>，因为它是最后一次写入的值，而且那个时候并没有其他的并发写入。</p>
<p>对于一个基于顺序规范的并发操作来说，我们会用一个一致性模型，也就是线性一致性来说明它的正确性。在一个线性一致性的系统里面，任何操作都可能在调用或者返回之间原子和瞬间执行。除了线性一致性，还有一些其他一致性的模型，但多数分布式系统都提供了线性一致性的操作：线性一致性是一个强的一致性模型，并且基于线性一致性系统，很容易去构建其他的系统。考虑到如下对 key-value store 操作的历史例子：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这个历史是一个线性的。在下面图片的蓝色地方，我们现实的标明了线性一致的点。这个顺序历史 <code>Put(&quot;x&quot;, &quot;0&quot;)</code>, <code>Get(&quot;x&quot;) -&gt; &quot;0&quot;</code>, <code>Put(&quot;x&quot;, &quot;1&quot;)</code>, <code>Get(&quot;x&quot;) -&gt; &quot;1&quot;</code>，对于顺序规范来说就是一个正确的历史。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>对应的，下面的历史就不是线性一致的。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>对于顺序规范来说，这个历史并不是线性一致的：我们并不能在这个历史的操作里面指定出线性一致的点。我们可以画出 client 1，2 和 3 的，但我们并不能画出 client 4 的，因为这明显是一个过期的值。类似的，我们可以画出 client 1，2 和 4 的，那么 client 2 的操作一定会在 4 的操作开始的后面，但这样我们就不能处理 client 3，它只可能合法的返回 <code>&quot;&quot;</code>或者 <code>&quot;0&quot;</code>。</p>
<h2 id="测试" class="heading-element"><span>4 测试</span>
  <a href="#%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了一个正确性的定义，我们就可以考虑如何去测试分布式系统了。通常的做法就是对于正确的操作，不停的进行随机的错误注入，类似机器宕机，网络隔离等。我们甚至能模拟整个网络，这样我们就能做长时间的网络延迟等。因为测试时随机的，我们需要跑很多次从而确定一个系统的实现是正确的。</p>
<h3 id="临时测试" class="heading-element"><span>4.1 临时测试</span>
  <a href="#%e4%b8%b4%e6%97%b6%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们实际如何做正确操作的测试呢？在最简单的软件里面，我们可以使用输入输出测试，譬如 <code>assert(expected_output == f(input))</code>，我们也可以在分布式系统上面使用一个类似的方法，譬如，对于 key-value store，当多个 client 开始执行操作的时候，我们可以有如下的测试：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果测试挂掉了，那么这个系统一定不是线性一致性的，当然，这个测试并不是很完备，因为有可能不是线性一致的系统也可能通过这个测试。</p>
<h3 id="线性一致性-1" class="heading-element"><span>4.2 线性一致性</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个更好的办法就是并发的客户端完全跑随机的操作。譬如，循环的去调用 <code>kvstore.put(rand(), rand())</code> 和 <code>kvstore.get(rand())</code>，有可能会只用很少的 key 去增大冲突的概率。但在这种情况下，我们如何定义什么是正确的操作呢？在上面的简单的测试里面，因为每个 client 都操作的是一个独立的 key，所以我们可以非常明确的知道输出结果。</p>
<p>但是 clients 并发的操作同一堆 keys，事情就变得复杂了。我们并不能预知每个操作的返回值因为这并没样一个唯一的答案。但我们可以用另一个办法：我们可以记录整个操作的历史，然后去验证这个操作历史是线性一致的。</p>
<h4 id="线性一致性验证" class="heading-element"><span>4.2.1 线性一致性验证</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7%e9%aa%8c%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">一个线性一致性验证器会使用一个顺序规范和一个并发操作的历史，然后执行一个判定程序去检查这个历史在规范下面是否线性一致。</font></p>
<h4 id="np-完备" class="heading-element"><span>4.2.2 NP 完备</span>
  <a href="#np-%e5%ae%8c%e5%a4%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>但不幸的是，线性一致性验证是 NP 完备的。这个证明非常简单：我们能说明线性一致性验证是 NP 问题，并且也能展示一个 NP 困难问题能被简化成线性一致性验证。明显的，线性一致性验证是 NP 问题，譬如，所有操作的线性一致性点，根据相关的顺序规范，我们可以在多项式时间里验证。</p>
<p>为了说明线性一致性验证是 NP 困难的，我们可以将子集合问题简化成线性一致性验证。对于子集合问题，我们给出非负数的集合 $S={s_1,s_2,…,s_n}$ 和目标结果 $t$，然后我们必须确定是否存在一个子集 $S$ 的和等于 $t$。我们可以将这个问题简化成如下的线性一致性验证。考虑顺序规范：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>以及历史：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当且仅当子集和问题的答案为“是”时，该历史才可线性化。如果历史是可线性化的，那么我们可以采用在 <code>Get()</code> 操作之前具有线性化点的所有操作 <code>Add(s_i)</code> ，并且这些操作对应于中的元素 $s_i$总和为 $t$ 的子集。如果该集合确实有一个总和为$t$的子集，那么我们可以通过与子集中的元素$s_i$对应的操作 <code>Add(s_i)</code> 来构造线性化放置在 <code>Get()</code> 操作之前，并使其余操作发生在 <code>Get()</code> 操作之后。</p>
<h4 id="实现" class="heading-element"><span>4.2.3 实现</span>
  <a href="#%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>即使线性一致性验证是 NP 完全的，在实际中，它仍然能在一些小的历史上面很好的工作。线性一致性验证器的实现会用一个可执行的规范，加上一个历史，执行一个搜索过程去构造一个线性化，并使用一些技巧来限制减少搜索的空间。</p>
<p>现有的线性化检查器如 Knossos，用于 Jepsen 测试系统。但不幸的是，在测试一些分布式 key-value store 的时候，Knossos 并不能很好的工作，它可能只能适用于一些少的并发 clients，以及只有几百的事件的历史。但在一些测试里面，有很多的 clients，以及会生成更多的历史事件。</p>
<p>为了解决 Knossos 的问题，作者开发了 Procupine，一个用 Go 写的更快的线性一致性验证工具。Porcupine 使用一个用 Go 开发的执行规范去验证历史是否是线性的。根据实际测试的情况，Porcupine 比 Knossos 快很多倍。</p>
<p><a href="https://github.com/anishathalye/porcupine"target="_blank" rel="external nofollow noopener noreferrer">Procupine Github<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h4 id="效果" class="heading-element"><span>4.2.4 效果</span>
  <a href="#%e6%95%88%e6%9e%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>使用故障注入和线性化检查来测试可线性化分布式系统是一种有效的方法。</p>
<p>作为对比，在使用专门的测试用 Porcupine 测试 key-value store 的时候，作者使用了这两种方式。作者在实现它自己的 key-value store 的时候引入不同的设计错误，譬如在修改之后会出现过期读，来看这些测试是否会挂掉。专门测试会捕捉到很多 bugs，但并没有能力去捕捉到更多的狡猾的 bugs。相对而言，作者现在还没找到一个正确性的 bug 是线性一致性测试不能抓住的。</p>
<ol>
<li>形式方法能够保证一个分布式系统的正确性。例如，UM PLSE 研究小组最近使用 Coq proof assistnt 来验证了 Raft 一致性协议。但不幸的的是，验证需要特定的知识，另外验证实际的系统需要做大量的工作。没准有一天，验证能被用在实际系统上面，但现在，主要还是测试，而不是验证。</li>
<li>理论上，所有的生产系统都会有一个形式规范，而且一些系统也已经有了，譬如 Raft 就有一个用 TLA+ 写的形式规范。但不幸的是，大部分的系统是没有的。</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程</title><link>https://hezephyr.github.io/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 15 May 2024 09:55:12 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/</guid><description><![CDATA[<h2 id="为什么选择go" class="heading-element"><span>1 为什么选择Go</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9go" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在实现分布式系统时，选择合适的编程语言非常重要。Go有以下特点：</p>
<ul>
<li>优秀的线程支持；</li>
<li>便捷的RPC机制、类型；</li>
<li>内存安全以及垃圾回收机制。</li>
</ul>
<p>这使Go成为了一个理想的选择。Go不仅相对简单，而且其垃圾回收机制使线程管理更加容易，避免了使用后释放问题。由于这些优势，Go在分布式系统中被广泛应用。</p>
<p><a href="https://golang.org/doc/effective_go.html"target="_blank" rel="external nofollow noopener noreferrer">Go Tutorial<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="线程与go中的goroutine" class="heading-element"><span>2 线程与Go中的Goroutine</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e4%b8%8ego%e4%b8%ad%e7%9a%84goroutine" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>线程是一种有用的结构工具，允许一个程序同时执行多项任务，每个线程串行执行，就像非线程程序一样。Go中称线程为Goroutine，每个Goroutine在执行时包含自己的程序计数器、寄存器和栈，但共享内存。使用线程可以提高I/O并发性和多核性能，同时也方便后台任务的处理。</p>
<h3 id="为什么使用线程" class="heading-element"><span>2.1 为什么使用线程？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>I/O并发性</strong>：客户端可以并行向多个服务器发送请求并等待回复，服务器可以同时处理多个客户端请求。</li>
<li><strong>多核性能</strong>：在多核处理器上并行执行代码，提高计算效率。</li>
<li><strong>便捷性</strong>：后台线程可以定期检查各个<code>worker</code>线程是否仍然活跃。</li>
</ol>
<h3 id="线程的替代方案" class="heading-element"><span>2.2 线程的替代方案</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>事件驱动编程（Event-driven programming）是一种替代传统多线程编程的方式，通过在单线程中显式交错处理活动来实现I/O并发性。这种编程模型常用于处理大量I/O操作的场景，例如网络服务器和图形用户界面（GUI）应用。</p>
<p>在事件驱动编程中，系统维护一个事件循环（event loop），不断检查并处理事件队列中的事件。每个事件通常对应某种外部输入或状态变化，如网络请求到达、用户点击按钮或定时器到期。事件处理程序（event handler）被注册到特定事件上，当相应事件发生时，处理程序被调用来执行预定义的操作。</p>
<h3 id="线程编程挑战" class="heading-element"><span>2.3 线程编程挑战</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e7%bc%96%e7%a8%8b%e6%8c%91%e6%88%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>安全共享数据</strong>：多个线程同时访问共享数据时可能导致竞争条件，常用的解决方案是使用锁（如Go的<code>sync.Mutex</code>）或者避免共享可变数据。</li>
<li><strong>线程间协调</strong>：一个线程生产数据，另一个线程消费数据，需要使用Go的通道（<code>channel</code>）或条件变量（<code>sync.Cond</code>）或等待组（<code>sync.WaitGroup</code>）进行协调。</li>
<li><strong>死锁</strong>：线程之间通过锁或<code>channel</code>或RPC相互等待资源时可能导致死锁，需要小心避免。</li>
</ol>
<h2 id="以网络爬虫为例的线程应用" class="heading-element"><span>3 以网络爬虫为例的线程应用</span>
  <a href="#%e4%bb%a5%e7%bd%91%e7%bb%9c%e7%88%ac%e8%99%ab%e4%b8%ba%e4%be%8b%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>网络爬虫的目标是抓取所有网页内容，常见的实现方式有串行和并发两种。并发爬虫利用线程提高抓取效率，但也需要解决避免重复抓取和循环依赖的问题。</p>
<p>在本例中，我们使用一个填充的<code>Fetcher</code>来模拟抓取。<code>fetcher</code>结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">fakeResult</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">body</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">fakeFetcher</span><span class="p">)</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">url</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found:   %s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">urls</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;missing: %s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not found: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fetcher is a populated fakeFetcher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">fetcher</span> <span class="p">=</span> <span class="nx">fakeFetcher</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;The Go Programming Language&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/cmd/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Packages&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/cmd/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/fmt/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/os/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/fmt/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Package fmt&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/os/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Package os&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="串行爬虫" class="heading-element"><span>3.1 串行爬虫</span>
  <a href="#%e4%b8%b2%e8%a1%8c%e7%88%ac%e8%99%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>串行爬虫通过递归调用实现深度优先搜索，使用一个共享的map记录已抓取的URL，防止重复抓取。然而，这种方式只能一次抓取一个页面，速度较慢。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Serial</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">fetched</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Use a map to keep track of fetched URLs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Recursively fetch URLs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Serial</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">,</span> <span class="nx">fetched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>我们是否可以在<code>Serial()</code>调用前面放一个<code>go</code>呢</p>
</blockquote>
<p>在 <code>Serial()</code> 调用前添加 <code>go</code> 关键字会导致并发执行多个爬虫任务，从而可能导致重复抓取相同的页面。这是因为每个爬虫任务都会尝试从未抓取过的页面开始递归抓取，而并发执行可能导致多个爬虫同时选择相同的页面作为起始点，进而重复抓取。</p>
<h3 id="并发爬虫" class="heading-element"><span>3.2 并发爬虫</span>
  <a href="#%e5%b9%b6%e5%8f%91%e7%88%ac%e8%99%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="使用锁" class="heading-element"><span>3.3 使用锁</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个页面的抓取在独立的线程中进行，为了确保抓取过程的正确性，我们使用了互斥锁来保护共享的 <code>fetchState</code> 结构体，避免了重复抓取和并发冲突的问题。在抓取过程中，我们使用了递归调用 <code>ConcurrentMutex</code> 函数来处理当前页面的所有子链接。每当发现一个新的子链接时，我们启动一个新的 Goroutine 来并发地抓取该链接，从而实现了多个页面的并行抓取。使用 <code>sync.WaitGroup</code> 来等待所有的子链接抓取任务完成，确保主线程在所有任务完成后才返回，以避免提前结束抓取过程。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">fetchState</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>      <span class="c1">// protect concurrent crawls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fetched</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span> <span class="c1">// Used to store crawled URLs. The key is URL and the value is whether it has been crawled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">fs</span> <span class="o">*</span><span class="nx">fetchState</span><span class="p">)</span> <span class="nf">testAndSet</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span><span class="p">.</span><span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">r</span> <span class="c1">// Return to previous crawling status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ConcurrentMutex</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">fs</span> <span class="o">*</span><span class="nx">fetchState</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">fs</span><span class="p">.</span><span class="nf">testAndSet</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">done</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// Create a wait group that waits for all subtasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">done</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1">// Increase the counter of the waiting group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">u</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Start a Go coroutine to concurrently crawl sub-links
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">defer</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nf">ConcurrentMutex</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">,</span> <span class="nx">fs</span><span class="p">)</span> <span class="c1">// Recursive call ConcurrentMutex, fetching sub-links.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}(</span><span class="nx">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// Wait for all subtasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用通道" class="heading-element"><span>3.4 使用通道</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%80%9a%e9%81%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个<code>worker</code>线程将抓取到的URL发送到一个通道，<code>coordinator</code>从通道中读取URL并启动新的<code>worker</code>线程。这种方式避免了锁的使用，但需要小心避免通道阻塞导致的死锁。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">urls</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">coordinator</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">1</span>                           <span class="c1">// 记录正在处理的任务数量，初始值为 1，因为最开始只有一个初始 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fetched</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// 记录已经抓取的 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">urls</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>           <span class="c1">// 不断从通道中接收抓取到的链接列表，直到通道被关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span> <span class="c1">// 遍历接收到的链接列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">fetched</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fetched</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">				<span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">				<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">ch</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span> <span class="c1">// 启动一个新的 worker 协程抓取该链接的子链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 如果当前没有正在处理的任务，则退出循环，结束并发抓取过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ConcurrentChannel 函数是并发抓取的入口函数，利用通道协调并发抓取的过程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ConcurrentChannel</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 创建一个字符串切片类型的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>               <span class="c1">// 启动一个匿名函数的 Go 协程，用于向通道发送 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">url</span><span class="p">}</span> <span class="c1">// 向通道发送包含初始 URL 的字符串切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">coordinator</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span> <span class="c1">// 调用 coordinator 函数，开始并发抓取的协调过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>worker</code> 函数中，每个<code>worker</code>线程会尝试抓取指定的URL，并将抓取到的子链接发送到通道中。如果抓取失败，则发送一个空的字符串切片到通道，以便通知<code>coordinator</code>任务失败。</p>
<p>在 <code>coordinator</code> 函数中，<code>coordinator</code>不断从通道中读取抓取到的链接列表，然后遍历这些链接，如果发现之前未抓取过的新链接，则将其标记为已抓取并启动一个新的<code>worker</code>线程进行抓取。同时，<code>coordinator</code>会维护一个计数器 <code>n</code> 来记录当前正在处理的任务数量，当所有任务都处理完成后，<code>coordinator</code>结束并发抓取的过程。</p>
<p>在 <code>ConcurrentChannel</code> 函数中，我们首先创建了一个字符串切片类型的通道，并启动了一个匿名的 Goroutine 来向通道发送初始的 URL。然后，调用 <code>coordinator</code> 函数开始并发抓取的协调过程。</p>
<blockquote>
<ol>
<li><code>coordinator</code>如何知道它已经完成？</li>
</ol>
<p><code>coordinator</code>知道它已完成的条件是 <code>n</code> 计数器的值归零。<code>coordinator</code>通过维护 <code>n</code> 计数器来跟踪当前正在处理的任务数量，每个<code>worker</code>线程处理完成后会将 <code>n</code> 减一。当 <code>n</code> 计数器的值为零时，表示所有的任务都已经完成，<code>coordinator</code>就知道自己的工作已经完成。</p>
<ol start="2">
<li>通道在这里有两个作用：</li>
</ol>
<p>- 通信值：<code>worker</code>线程将抓取到的链接列表发送到通道中，以便<code>coordinator</code>可以读取并处理。
- 事件通知：通道的关闭可作为事件通知，当通道关闭时，<code>coordinator</code>会知道所有的<code>worker</code>线程都已完成，并且没有新的任务需要处理。</p>
</blockquote>
<h2 id="远程过程调用rpc" class="heading-element"><span>4 远程过程调用（RPC）</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="介绍" class="heading-element"><span>4.1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="远程过程调用rpc-1" class="heading-element"><span>4.2 远程过程调用（RPC）</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>远程过程调用（RPC）是分布式系统中的关键技术之一，它使得客户端和服务器之间的通信变得简单而直观。在分布式系统中，不同的节点可能分布在不同的物理机器上，RPC允许这些节点之间进行远程通信，就像调用本地函数一样，无需了解底层的网络协议细节。</p>
<p>RPC的目标是实现易于编程的客户端/服务器通信，它隐藏了底层网络通信的复杂性，为开发人员提供了简单的接口。通过RPC，开发人员可以专注于业务逻辑的实现，而无需担心网络通信的细节。</p>
<p>在RPC中，数据在客户端和服务器之间通过网络传输，因此需要将数据转换为“有线格式”（wire format）。RPC库负责处理数据的序列化和反序列化，以确保数据可以在网络上传输并在另一端正确解析。</p>
<p>RPC消息的基本结构是请求-响应模式。<font color="red">客户端发送请求给服务器，服务器处理请求并发送响应给客户端。</font>这种简单的请求-响应模式使得RPC成为了一种非常有效的通信方式。</p>
<p>在RPC的软件结构中，通常会有以下几个组件：</p>
<ul>
<li>客户端应用程序：负责发起RPC请求的应用程序。</li>
<li>存根函数（Stub functions）：客户端应用程序调用的接口函数，实际上是一个本地代理，负责将RPC调用转发给远程服务器。</li>
<li>服务器处理函数（Handler functions）：服务器端实际执行业务逻辑的函数。</li>
<li>调度器（Dispatcher）：负责将RPC请求分发给正确的处理函数。</li>
<li>RPC库：提供了RPC通信所需的基本功能，例如序列化、网络通信等。</li>
</ul>
<p>通过RPC，不同语言编写的客户端和服务器可以进行通信，实现了跨语言的可移植性和互操作性。</p>
<h3 id="go的rpc实现" class="heading-element"><span>4.3 Go的RPC实现</span>
  <a href="#go%e7%9a%84rpc%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Go中，实现RPC需要定义请求和回复的结构体，并使用Go的RPC库来处理通信。下面是一个示例，展示了如何在Go中实现一个简单的键值存储服务器（key/value storage server），并使用RPC进行通信。</p>
<ul>
<li>
<p>请求回复结构体</p>
<p>在键值存储服务器的示例中，我们定义了用于Put和Get操作的请求和回复结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PutArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PutReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GetArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GetReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>服务器端（Server）</p>
<p>在服务器端，首先需要定义一个对象，并在该对象上注册处理函数作为RPC处理程序。这些处理函数将处理客户端发送的RPC请求。服务器接受TCP连接并将其传递给RPC库。RPC库负责读取每个请求，并为每个请求创建一个新的Goroutine进行处理。处理函数会读取请求参数，并根据请求调用相应的方法。处理完请求后，服务器将回复信息进行序列化，并通过TCP连接发送回客户端。<font color="red">服务器端的处理函数必须使用锁进行同步，因为RPC库为每个请求创建了一个新的Goroutine。</font>处理函数需要读取请求参数并修改回复信息，因此需要确保并发访问的安全性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KV</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// 互斥锁，保护数据并发访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">KV</span><span class="p">{</span><span class="nx">data</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}}</span> <span class="c1">// 创建键值存储服务器实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcs</span> <span class="o">:=</span> <span class="nx">rpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>              <span class="c1">// 创建一个 RPC 服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcs</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">kv</span><span class="p">)</span>                    <span class="c1">// 注册 kv 为 RPC 服务器的服务对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1234&#34;</span><span class="p">)</span>   <span class="c1">// 监听 TCP 端口 1234
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 启动一个协程来处理客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span> <span class="c1">// 接受客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">go</span> <span class="nx">rpcs</span><span class="p">.</span><span class="nf">ServeConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// 启动一个协程来为客户端提供服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// 关闭监听器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get 方法用于处理客户端发送的 Get 请求，获取指定键的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Put 方法用于处理客户端发送的 Put 请求，存储键值对。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>客户端（Client）</p>
<p>在客户端，首先需要使用Dial函数建立与服务器的TCP连接。然后，客户端需要定义RPC请求的参数结构体和回复结构体，并实现对应的处理函数。客户端通过调用Call函数发起RPC调用，指定连接、函数名称、参数以及存放回复的位置。RPC库负责对参数进行序列化，并将请求发送给服务器。然后，客户端等待并接收服务器的回复，并将回复反序列化为指定的回复结构体。Call函数的返回值指示是否成功接收到了回复，通常还包括服务级别的错误信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// connect 函数用于与键值存储服务器建立连接，并返回一个 RPC 客户端对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">connect</span><span class="p">()</span> <span class="o">*</span><span class="nx">rpc</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1234&#34;</span><span class="p">)</span> <span class="c1">// 使用 TCP 协议连接服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;dialing:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// 如果连接失败，则记录错误并终止程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">connect</span><span class="p">()</span>                         <span class="c1">// 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">GetArgs</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span>                        <span class="c1">// 构造 Get 请求的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">GetReply</span><span class="p">{}</span>                         <span class="c1">// 准备接收服务器的响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KV.Get&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span> <span class="c1">// 调用远程方法 Get，并传递参数 args，将响应写入 reply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>     <span class="c1">// 关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// 返回服务器返回的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// put 函数用于向键值存储服务器发送 Put 请求，存储键值对。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">connect</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">PutArgs</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">PutReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KV.Put&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>其他细节：</p>
<ul>
<li>
<p>绑定（Binding）：客户端如何知道要与哪台服务器通信？</p>
<p>在Go的RPC中，服务器的名称和端口是Dial函数的参数。在大型系统中，通常会有一种名称或配置服务器来管理这些信息。</p>
</li>
<li>
<p>序列化（Marshalling）：数据格式化为数据包。Go的RPC库可以传递字符串、数组、对象、映射等类型的数据。Go通过复制指向的数据来传递指针，但不能传递通道或函数。RPC库只序列化导出字段（即大写字母开头的字段）。</p>
</li>
</ul>
<h3 id="处理rpc中的失败" class="heading-element"><span>4.4 处理RPC中的失败</span>
  <a href="#%e5%a4%84%e7%90%86rpc%e4%b8%ad%e7%9a%84%e5%a4%b1%e8%b4%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在分布式系统中，网络故障和服务器故障是不可避免的。简单的解决方案是“尽力而为”的RPC，即在超时后重试请求，但这可能导致重复操作。</p>
<p>这种方法的缺点是，重试请求可能导致操作被重复执行。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果第二个<code>Put</code>请求因网络故障重试多次，可能会导致不一致的结果：</p>
<p>更好的解决方案是“至多一次”的RPC，“至多一次”的RPC通过以下机制实现更可靠的行为：</p>
<ul>
<li>客户端在未收到响应时重新发送请求。</li>
<li>服务器检测重复请求，并返回之前的响应，而不是重新执行处理函数。</li>
</ul>
<p>为了检测重复请求，客户端在每个请求中包含一个唯一的ID（XID）。每个请求使用相同的 XID 重新发送服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if seen[xid] {
</span></span><span class="line"><span class="cl">  reply = old[xid]
</span></span><span class="line"><span class="cl">} else {
</span></span><span class="line"><span class="cl">  reply = handler()
</span></span><span class="line"><span class="cl">  old[xid] = reply
</span></span><span class="line"><span class="cl">  seen[xid] = true
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一些“至多一次”复杂性问题：</strong></p>
<ul>
<li>
<p>如果两个客户端使用相同的XID？</p>
<ul>
<li>解决方案：使用大随机数生成唯一ID。</li>
</ul>
</li>
<li>
<p>如何避免seen[xid]表过大？</p>
<ul>
<li>每个客户端有一个唯一ID，使用序列号。</li>
<li>客户端在每次RPC中包含“已见到的最大回复”信息，类似于TCP序列号和确认号。</li>
</ul>
</li>
<li>
<p><strong>服务器崩溃和重启：</strong></p>
<ul>
<li>
<p>如果“至多一次”信息保存在内存中，服务器重启后将忘记这些信息，可能会接受重复请求。</p>
<p>解决方案：将重复检测信息写入磁盘，或使用复制服务器同步这些信息。</p>
</li>
</ul>
</li>
</ul>
<p>Go的RPC库是“至多一次”策略的简单实现：</p>
<ul>
<li>打开TCP连接。</li>
<li>将请求写入TCP连接。</li>
<li>Go RPC从不重发请求，因此服务器不会看到重复请求。</li>
<li>如果未收到回复，Go RPC代码返回错误（可能是由于TCP超时）。</li>
</ul>
<blockquote>
<p>关于“恰好一次”的RPC</p>
<p>“恰好一次”的RPC包括无限重试、重复检测和容错服务，这种方法更复杂，在实际系统中需要实现容错机制。</p>
<p>例如，lab 4中将探讨“恰好一次”RPC的实现。</p>
</blockquote>
<h2 id="faq" class="heading-element"><span>5 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li>Go通道是如何工作的？Go如何确保它们在多个goroutines之间同步？</li>
</ol>
<p>可以在<a href="https://go.dev/src/runtime/chan.go"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>查看源码，尽管不易理解。高层次上，<font color="red">通道是一个包含缓冲区和锁的结构体</font>。发送到通道涉及获取锁，等待（可能释放CPU）直到某个线程接收，并交付消息。接收涉及获取锁并等待发送者。可以使用Go的sync.Mutex和sync.Cond自己实现通道。</p>
<ol start="2">
<li>我使用通道唤醒另一个goroutine，通过在通道上发送一个虚拟的bool值。但如果另一个goroutine已经在运行（因此没有在通道上接收），发送goroutine会阻塞。我应该怎么做？</li>
</ol>
<p>尝试使用条件变量（Go的sync.Cond）而不是通道。条件变量非常适合通知可能（或可能不）等待某事的goroutines。由于通道是同步的，如果不确定通道另一端是否有goroutine在等待，使用通道会显得很尴尬。</p>
<ol start="3">
<li>如何让一个goroutine等待来自多个不同通道的输入？如果没有任何内容可读取，则尝试在任何一个通道上接收都会阻塞，从而阻止 goroutine 检查其他通道。</li>
</ol>
<p>尝试为每个通道创建一个单独的goroutine，每个goroutine阻塞在其通道上。这不是总能实现，但在可行时通常是最简单的方法。否则，尝试使用Go的select。</p>
<ol start="4">
<li>什么时候应该使用sync.WaitGroup而不是通道？反之亦然？</li>
</ol>
<p>WaitGroup用途较为特殊；它仅在等待一堆活动完成时有用。通道用途更广泛；例如，可以通过通道传递值。尽管比WaitGroup需要多写几行代码，但也可以使用通道等待多个goroutines。</p>
<ol start="5">
<li>如何创建一个通过互联网连接的Go通道？如何指定用于发送消息的协议？</li>
</ol>
<p>Go通道仅在单个程序内工作；通道不能用于与其他程序或计算机通信。可以查看Go的RPC包，它允许你通过互联网与其他Go程序通信：
<a href="https://golang.org/pkg/net/rpc/"target="_blank" rel="external nofollow noopener noreferrer">https://golang.org/pkg/net/rpc/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol start="6">
<li>一些重要/有用的Go特定并发模式有哪些？</li>
</ol>
<p>这是一个关于该主题的幻灯片，由Go专家编写：
<a href="https://talks.golang.org/2012/concurrency.slide"target="_blank" rel="external nofollow noopener noreferrer">https://talks.golang.org/2012/concurrency.slide<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol start="7">
<li>切片是如何实现的？</li>
</ol>
<p>切片是一个对象，包含指向数组的指针以及该数组的开始和结束索引。这种安排允许多个切片共享一个底层数组，每个切片可能暴露数组元素的不同范围。这里有一个更详细的讨论：
<a href="https://blog.golang.org/go-slices-usage-and-internals"target="_blank" rel="external nofollow noopener noreferrer">https://blog.golang.org/go-slices-usage-and-internals<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
Go切片比Go数组更灵活，因为数组的大小是其类型的一部分，而以切片作为参数的函数可以接受任何长度的切片。</p>
<ol start="8">
<li>什么时候使用同步RPC调用，什么时候使用异步RPC调用？</li>
</ol>
<p>大多数代码需要在继续执行前获得RPC回复；在这种情况下，使用同步RPC是合理的。但有时客户端希望启动许多并发RPC；在这种情况下，异步可能更好。或者客户端希望在等待RPC完成时做其他工作，可能是因为服务器很远（所以光速时间很高）或因为服务器可能不可达，从而RPC经历长时间的超时。我(Robert)从未在Go中使用异步RPC。当我想发送RPC但不必等待结果时，我创建一个goroutine，并让这个goroutine进行同步Call()。</p>
<ol start="9">
<li>开发人员在开始使用Go时常见的问题有哪些？</li>
</ol>
<p>以下是一些常见问题：</p>
<p>- 未在并发访问时使用锁保护映射。使用Go的竞态检测器！
- 使用通道时的死锁。
- 在创建goroutine时未捕获变量。
- 泄漏的goroutines。</p>
<ol start="10">
<li>Go是否支持继承？（像Java/C++那样的“扩展”方式？）</li>
</ol>
<p>Go不支持C++风格的继承，但有接口和嵌入结构体，可以完成在C++中使用继承的许多事情。这是Go设计中备受争议的部分；可以搜索“golang generics”。</p>
<ol start="11">
<li>我对选择值接收器或指针接收器仍有些困惑。能否提供一些具体的实际例子说明我们应该选择哪一个？</li>
</ol>
<p>当你想修改接收器的状态时，必须使用指针接收器。如果结构体非常大，你可能想使用指针接收器，因为值接收器操作的是一个副本。如果两者都不适用，可以使用值接收器。然而，要小心使用值接收器；例如，如果结构体中有一个互斥锁，你不能将其作为值接收器，因为互斥锁会被复制，从而失去其作用。</p>
</blockquote>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】 分布式系统介绍</title><link>https://hezephyr.github.io/posts/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 14 May 2024 14:12:32 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</guid><description><![CDATA[<h2 id="概念" class="heading-element"><span>1 概念</span>
  <a href="#%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当我们谈论分布式系统时，我们指的是一组通过网络连接的计算机，它们协同工作以完成某种共同的任务或目标。</p>
<p>在分布式系统中，通信是通过消息传递进行的。<font color="red">这意味着各个计算节点之间通过发送和接收消息来进行通信，而不是通过共享内存。</font>这种消息传递模型使得分布式系统的设计和实现更为灵活，因为每个节点可以独立地运行，并通过消息传递来进行协作。</p>
<p>尽管消息传递模型具有很多优点，但也需要注意到它引入了一些复杂性。例如，需要考虑消息的传递延迟、顺序和可靠性等问题。因此，在设计分布式系统时，需要仔细考虑如何有效地管理消息传递，以确保系统的正确性和性能。</p>
<blockquote>
<p>TIP：在设计系统或解决问题时，应该始终优先考虑在单台计算机上解决。只有在问题规模超出单台计算机的处理能力，或者需要满足高可用性、容错性等需求时，才需要考虑采用分布式系统。因此，深入了解问题的性质和需求，以及权衡利弊，是设计分布式系统的关键。</p>
</blockquote>
<h2 id="驱动力和挑战" class="heading-element"><span>2 驱动力和挑战</span>
  <a href="#%e9%a9%b1%e5%8a%a8%e5%8a%9b%e5%92%8c%e6%8c%91%e6%88%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当人们构建分布式系统时，驱动力主要包括以下几个方面：</p>
<ol>
<li><strong>追求更高的计算性能</strong>：分布式系统能够利用大量的计算资源，实现并行运算，充分利用多个CPU、大容量内存和磁盘资源。</li>
<li><strong>实现容错性</strong>：即使在其中一台计算机发生故障时，系统仍然能够保持正常运行。</li>
<li><strong>解决空间分布性问题</strong>：某些问题天然具有空间分布性，需要跨越不同地理位置的计算资源和数据进行协同处理。例如，银行跨地域的资金转移需要协调不同地点的数据和操作，这就需要分布式系统来实现数据的同步和协调，以确保交易的准确性和可靠性。</li>
<li><strong>提高安全性</strong>：分布式系统可以通过将系统分散在多个计算机上来提高安全性。不信任的代码或系统可能存在潜在的安全风险，通过在分布式环境中运行代码并采用加密通信等安全措施，可以有效降低风险，并限制错误和攻击的影响范围。</li>
</ol>
<p>分布式系统的挑战源自其驱动力：</p>
<ol>
<li><strong>并发执行和复杂交互</strong>：分布式系统中存在大量并发执行的部分，以及复杂的交互关系。这导致了在并发编程中遇到各种问题，例如同步、异步操作的管理以及处理时间依赖性。</li>
<li><strong>意外故障</strong>：分布式系统由多个组成部分和计算机网络组成，因此容易受到意外故障的影响。与单个计算机不同，这些组件可能在工作或停止状态之间切换，同时还受到网络中断或不稳定性的影响。</li>
<li><strong>性能预期</strong>：分布式系统的设计旨在实现更高的性能，例如利用大量计算资源实现并行处理。但实际评估多台计算机或磁盘臂的性能存在一定挑战，需要仔细的设计和调整以实现预期的性能水平。</li>
</ol>
<h2 id="抽象和实现工具" class="heading-element"><span>3 抽象和实现工具</span>
  <a href="#%e6%8a%bd%e8%b1%a1%e5%92%8c%e5%ae%9e%e7%8e%b0%e5%b7%a5%e5%85%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式系统基础架构主要包括<font color="red">存储、通信（网络）和计算</font>这三种类型。我们的目标是设计简单的接口，使第三方应用程序能够轻松使用这些分布式存储和计算功能，这样才能简单的在这些基础架构之上，构建第三方应用程序。</p>
<p>通过这种抽象接口，我们可以将分布式系统的复杂性隐藏在系统内部，使用户专注于应用程序的开发。举例来说，在存储方面，用户可以将整个系统视为非分布式系统，类似于一个文件系统或者常规的编程模型，而不必担心分布式系统的细节。我们的目标是构建一个接口，使其看起来像一个非分布式存储和计算系统，但实际上却具备了分布式系统的高性能和容错性。</p>
<p>但实际上，很难能找到一个抽象来描述分布式的存储或者计算，使得它们能够像非分布式系统一样有简单易懂的接口。</p>
<p>抽象的实际实现是我们首先要考虑的问题。在构建分布式系统时，人们使用了许多工具：</p>
<ul>
<li><strong>RPC（Remote Procedure Call）</strong>：RPC旨在掩盖在不可靠网络上通信的复杂性，使得远程调用过程更为简单直接。</li>
<li><strong>线程</strong>：线程是一种重要的编程技术，可用于充分利用多核心计算机。它不仅仅是为了提高计算机的利用率，更重要的是提供了结构化的并发操作方式，简化了程序员对并发操作的处理。</li>
<li><strong>分布式文件系统</strong>：分布式文件系统是分布式系统中常用的存储工具之一，它提供了分布式的数据存储和访问接口。通过分布式文件系统，可以实现数据的分布式存储和管理，从而支持大规模数据处理和分布式计算任务的执行。</li>
</ul>
<h2 id="分布式系统特性" class="heading-element"><span>4 分布式系统特性</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%89%b9%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="可扩展性" class="heading-element"><span>4.1 可扩展性</span>
  <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>分布式系统的主要特性是可扩展性（Scalability）。可扩展性指的是，增加计算资源后系统能够以相应的方式提高性能或吞吐量。举例来说，如果一台计算机能够解决一定量的问题，那么增加第二台计算机后，系统能够以更快的速度解决相同数量的问题，或者在相同时间内处理更多的问题。如果由两台计算机组成的系统能够实现两倍的性能或吞吐量，那就达到了可扩展性的标准。</p>
<p>这是一个极为强大的特性，因为只需花钱就可以购买计算机。如果构建的系统能够通过增加计算机数量来提高性能或吞吐量，那将是一个巨大的成就。相比之下，通过雇佣程序员来优化系统或应用更优的算法通常是一种昂贵的方法。我们希望通过增加计算机数量，从十台提升到一千台，来应对一百倍的流量。</p>
<p>例如在构建一个常规网站时，通常会有一个HTTP服务器、一些用户和浏览器以及基于Python或PHP的Web服务器，它们与数据库进行交互。</p>
<p>在初始阶段，一台计算机可以运行Web服务器和数据库，或者将Web服务器和数据库分别部署在两台计算机上。但是，当网站突然迎来数以亿计的用户登录请求时，单一服务器显然无法满足需求。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=small" data-sub-html="<h2>image-20240513103410005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web" alt="image-20240513103410005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=large 2x" data-title="image-20240513103410005" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了应对高流量，第一步是购买更多的Web服务器，并将用户分配到不同的服务器上。这样，不同的用户可以访问不同的Web服务器，但它们需要访问相同的数据，因此所有的Web服务器都需要与后端数据库通信。在这个阶段，通过添加更多的Web服务器来提高代码效率是一个有效的方法，前提是单个服务器不会给数据库带来过大的压力。</p>
<p>然而，可扩展性并非无限的。随着Web服务器数量的增加，数据库很可能成为性能的瓶颈。即使增加更多的Web服务器也无法解决问题。在某个临界点，系统中添加更多计算机将不再有效，而瓶颈将转移到其他地方，比如从Web服务器转移到数据库。</p>
<p>在这种情况下，必须进行一些重构工作。然而，重构一个单一的数据库是困难的，尽管可以将数据库拆分为多个来提高性能，但这需要大量的工作。</p>
<h3 id="可用性" class="heading-element"><span>4.2 可用性</span>
  <a href="#%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在构建系统时，使用单台计算机往往具有较高的可靠性。单台计算机通常可以长时间稳定运行，这是因为计算机和操作系统都很可靠，而且电源也很稳定。然而，如果系统由数千台计算机构成，即使每台计算机都能稳定运行一年，每天也会有多台计算机发生故障。</p>
<p>因此，大型分布式系统面临的一个主要问题是放大一些罕见问题的影响。在这样的系统中，总会有一些机器故障、运行错误、执行缓慢或执行错误任务的情况发生。网络问题也是一个常见的挑战，比如网线踩断或交换机故障。这些小问题在大规模系统中会变成持续不断的问题。</p>
<p>因此，在设计系统时必须考虑系统的容错性，即使发生错误也要能够继续运行。同时，为了简化应用开发人员的工作，需要构建一个基础架构，能够尽可能屏蔽和掩盖错误。</p>
<p>容错有多种概念和表述方式，其中一个重要思想是可用性（Availability）。通过精心设计，系统可以在特定类型的错误发生时继续提供服务，就像没有错误一样。某些系统通过多副本的方式实现可用性。比如，构建一个有两个拷贝的多副本系统，其中一个故障了，另一个仍然可以正常运行。可用性意味着在特定的故障范围内，系统仍能提供服务。</p>
<p>另一种容错特性是自我可恢复性（Recoverability），即在出现问题后系统停止工作，不再响应请求，等待修复，然后恢复正常运行。</p>
<p>可恢复性是一个重要的需求，尽管它比可用性更弱。在故障发生到修复期间，系统将完全停止工作。但修复后，系统应能正确运行，因此可恢复性至关重要。对于可恢复的系统，通常需要采取一些措施，如将最新数据存储在磁盘中，以便在供电恢复后检索。甚至对于具备可用性的系统，在实际应用中，也需要具备可恢复性。</p>
<p>为了实现这些特性，有两个关键工具。</p>
<ul>
<li>一个是非易失存储（Non-volatile storage），如硬盘或闪存，用于存储系统状态的checkpoint或日志。这样，即使出现电源故障，系统也能从存储中读取最新状态，并继续运行。</li>
<li>另一个重要工具是复制（Replication），即通过多副本系统实现容错。管理复制的多副本系统可能会面临同步偏移等问题，这在容错系统中是一个挑战。</li>
</ul>
<h3 id="一致性" class="heading-element"><span>4.3 一致性</span>
  <a href="#%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最后一个很重要的特性是一致性（Consistency）。一致性定义了操作的行为，特别是在分布式系统中。在分布式存储系统中，例如键值（KV）服务，put操作将一个值存储到一个键中，而get操作从键中获取值。在分布式系统中，多个副本可能存在不同版本的数据，因此一致性变得至关重要。</p>
<p>强一致性（Strong Consistency）要求get请求总是返回最近一次完成的put请求写入的值，这确保了数据的完全一致。然而，实现强一致性需要大量的通信和延迟。弱一致性（Weak Consistency）不保证get请求获取到最新的数据，但通常可以提供更高的性能。</p>
<p>因此，为了尽可能减少通信，特别是当副本相距很远时，人们会构建弱一致性系统，只需要更新最近的数据副本，并且只需要从最近的副本获取数据，并允许读取旧数据。当然，为了使弱一致性更具实际意义，人们会定义更多的规则。</p>
<h2 id="mapreduce论文阅读笔记" class="heading-element"><span>5 MapReduce论文阅读笔记</span>
  <a href="#mapreduce%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a href="https://blog.csdn.net/hzf0701/article/details/138770454?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">MapReduce论文阅读笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>优秀的CS学习网站</title><link>https://hezephyr.github.io/posts/01.%E8%AF%BE%E7%A8%8B%E7%BD%91%E7%AB%99/</link><pubDate>Sat, 11 May 2024 21:46:26 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E8%AF%BE%E7%A8%8B%E7%BD%91%E7%AB%99/</guid><description><![CDATA[<h2 id="操作系统" class="heading-element"><span>1 操作系统</span>
  <a href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="nju操作系统设计与实现" class="heading-element"><span>1.1 NJU操作系统：设计与实现</span>
  <a href="#nju%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>先修要求：</p>
<ul>
<li>C语言</li>
<li>一些汇编语言基础</li>
<li>计算机基础</li>
</ul>
<p>这是NJU jyy老师的操作系统课程，每年都会在B站更新最新的操作系统课程视频，当然过往课程也可以找到。</p>
<p><a href="https://jyywiki.cn/OS/2022/index.html"target="_blank" rel="external nofollow noopener noreferrer">2022年OS 网站<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://www.bilibili.com/video/BV1Cm4y1d7Ur/?spm_id_from=333.788&amp;vd_source=cf653f235f52de98cb93354b5c75a0bc"target="_blank" rel="external nofollow noopener noreferrer">2022年OS 视频<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/"target="_blank" rel="external nofollow noopener noreferrer">课程教程OSTEP<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://jyywiki.cn/OS/2022/index.html"target="_blank" rel="external nofollow noopener noreferrer">2022年OS Lab<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="mit6s081-operating-system-engineering" class="heading-element"><span>1.2 MIT6.S081: Operating System Engineering</span>
  <a href="#mit6s081-operating-system-engineering" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>先修要求：</p>
<ul>
<li>C语言</li>
<li>一些汇编语言基础</li>
<li>计算机基础</li>
</ul>
<p><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html"target="_blank" rel="external nofollow noopener noreferrer">课程网站<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://www.youtube.com/watch?v=L6YqHxYHa7A"target="_blank" rel="external nofollow noopener noreferrer">课程视频<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/"target="_blank" rel="external nofollow noopener noreferrer">课程视频翻译文档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf"target="_blank" rel="external nofollow noopener noreferrer">课程教材<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html"target="_blank" rel="external nofollow noopener noreferrer">课程作业<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="分布式系统" class="heading-element"><span>2 分布式系统</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="mit6824after-2022-65840-distributed-system" class="heading-element"><span>2.1 MIT6.824(after 2022, 6.5840): Distributed System</span>
  <a href="#mit6824after-2022-65840-distributed-system" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>先修要求：</p>
<ul>
<li>Go语言</li>
<li>操作系统</li>
<li>并发编程</li>
<li>计算机体系结构</li>
</ul>
<p><a href="https://pdos.csail.mit.edu/6.824/"target="_blank" rel="external nofollow noopener noreferrer">课程网站<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://www.bilibili.com/video/BV1CU4y1P7PE/?spm_id_from=333.337.search-card.all.click"target="_blank" rel="external nofollow noopener noreferrer">课程视频-中文字幕<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824"target="_blank" rel="external nofollow noopener noreferrer">课程中文文档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="http://nil.csail.mit.edu/6.824/2022/"target="_blank" rel="external nofollow noopener noreferrer">课程作业<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Andrew文件系统</title><link>https://hezephyr.github.io/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:38:23 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Andrew 文件系统是卡内基梅隆大学 (CMU) 于 1980 年代引入的。该项目由CMU著名教授 M. Satyanarayanan（简称“Satya”）领导，其主要目标很简单：<strong>扩展性</strong>。具体来说，如何设计一个分布式文件系统，使得服务器可以支持尽可能多的客户端？</p>
<p>有趣的是，设计和实现的许多方面都会影响可扩展性。最重要的是客户端和服务器之间的<strong>协议设计</strong>。例如，在 NFS 中，协议强制客户端定期检查服务器以确定缓存的内容是否已更改；由于每次检查都会占用服务器资源（包括CPU和网络带宽），因此频繁进行这样的检查将限制服务器可以响应的客户端数量，从而限制可扩展性。</p>
<p>AFS 与 NFS 的不同之处还在于，从一开始，合理的用户可见行为就是首要关注的问题。在 NFS 中，缓存一致性很难描述，因为它直接取决于低级实现细节，包括客户端缓存超时间隔。在AFS中，缓存一致性很简单且易于理解：当文件被打开时，客户端通常会从服务器接收到最新的一致副本。</p>
<p>我们将讨论两个版本的 AFS。第一个版本（我们称之为 AFSv1，但实际上最初的系统被称为 ITC 分布式文件系统有一些基本设计，但扩展性不尽如人意，这导致了重新设计和最终协议（我们称之为 AFSv2，或简称 AFS）。</p>
<h2 id="afsv1" class="heading-element"><span>2 AFSv1</span>
  <a href="#afsv1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>2.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">AFS 所有版本的基本原则之一是在访问文件的客户端计算机的本地磁盘上缓存整个文件。</font>当您 <code>open()</code> 文件时，将从服务器获取整个文件（如果存在）并将其存储在本地磁盘上的文件中。后续应用程序的<code>read()</code>和<code>write()</code>操作将被重定向到存储文件的本地文件系统；因此，这些操作不需要网络通信并且速度很快。最后，在 <code>close()</code> 时，文件（如果已被修改）被刷新回服务器。请注意与 NFS 的明显对比，NFS 缓存块（不是整个文件，尽管 NFS 当然可以缓存整个文件的每个块）并在客户端内存（而不是本地磁盘）中进行缓存。</p>
<p>让我们进一步了解细节。当客户端应用程序第一次调用 <code>open()</code> 时，AFS 客户端代码（AFS 设计者称之为 <strong>Venus</strong>）将向服务器发送一条 Fetch 协议消息。 Fetch 协议消息会将所需文件的整个路径名（例如，<code>/home/zfhe/notes.txt</code>）传递到文件服务器（他们称之为 <strong>Vice</strong> 的组），然后文件服务器将遍历路径名，找到所需的文件，并将整个文件发回给客户端。然后，客户端代码会将文件缓存在客户端的本地磁盘上（通过将其写入本地磁盘）。正如我们上面所说，后续的 <code>read()</code> 和 <code>write()</code> 系统调用在 AFS 中严格是本地的（不发生与服务器的通信）；它们只是重定向到文件的本地副本。由于 <code>read()</code> 和 <code>write()</code> 调用的行为就像对本地文件系统的调用一样，因此一旦访问了一个块，它也可能会缓存在客户端内存中。因此，AFS 还使用客户端内存来缓存其本地磁盘中的块副本。最后，完成后，AFS 客户端检查文件是否已被修改（即，它已被打开用于写入）；如果是，它将使用存储协议消息将新版本刷新回服务器，并将整个文件和路径名发送到服务器进行持久存储。</p>
<p>下次访问文件时，AFSv1 的效率会更高。具体来说，客户端代码首先联系服务器（使用 TestAuth 协议消息）以确定文件是否已更改。如果没有，客户端将使用本地缓存的副本，从而通过避免网络传输来提高性能。下面展示了AFSv1中的一些协议消息。请注意，该协议的早期版本仅缓存文件内容；例如，目录仅保存在服务器上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">TestAuth 		Test whether a file has changed
</span></span><span class="line"><span class="cl">				(used to validate cached entries)
</span></span><span class="line"><span class="cl">GetFileStat 	Get the stat info for a file
</span></span><span class="line"><span class="cl">				Fetch Fetch the contents of file
</span></span><span class="line"><span class="cl">Store 			Store this file on the server
</span></span><span class="line"><span class="cl">SetFileStat 	Set the stat info for a file
</span></span><span class="line"><span class="cl">ListDir 		List the contents of a directory</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存在的问题" class="heading-element"><span>2.2 存在的问题</span>
  <a href="#%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>AFS 第一个版本的一些关键问题促使设计人员重新考虑他们的文件系统。为了详细研究这些问题，AFS 的设计者花费了大量时间测量他们现有的原型，以找出问题所在。这样的实验是一件好事，因为测量是理解系统如何工作以及如何改进系统的关键；因此，获得具体、良好的数据是系统建设的必要组成部分。在他们的研究中，作者发现 AFSv1 的两个主要问题：</p>
<ul>
<li><strong>路径遍历成本太高</strong>：当执行 Fetch 或 Store 协议请求时，客户端将整个路径名（例如 <code>/home/zfhe/notes.txt</code>）传递给服务器。服务器为了访问该文件，必须执行完整的路径名遍历，首先在根目录中查找<code>home</code>，然后在<code>home</code>中查找<code>zfhe</code>，依此类推，一直沿着路径遍历，直到最后找到所需的文件。由于许多客户端同时访问服务器，AFS 的设计者发现服务器花费了大量的 CPU 时间只是沿着目录路径查找。</li>
<li><strong>客户端发出过多的TestAuth 协议消息</strong>：与NFS 及其过多的GETATTR 协议消息非常相似，，AFSv1 也产生了大量流量，用于通过 TestAuth 协议信息检查本地文件（或其状态信息）是否有效。因此，服务器要花费大量时间告诉客户端是否可以使用其缓存的文件副本。大多数情况下，答案是文件没有变化。</li>
</ul>
<p>AFSv1 实际上还存在两个问题：<strong>服务器之间的负载不均衡</strong>，并且<strong>服务器对每个客户端使用单独的进程，从而导致上下文切换和其他开销</strong>。通过引入<strong>卷</strong>解决了负载不均衡问题，管理员可以跨服务器移动卷以均衡负载； AFSv2 中通过使用线程而不是进程构建服务器来解决上下文切换问题。然而，我们在这里重点关注上面限制系统规模的两个主要协议问题。</p>
<p>上述两个问题限制了AFS的可扩展性；服务器CPU成为系统的瓶颈，每台服务器只能服务20个客户端而不至于过载。服务器接收到太多 TestAuth 消息，并且当它们接收到 Fetch 或 Store 消息时，会花费太多时间遍历目录层次结构。因此，AFS 设计者面临着一个问题：</p>
<blockquote>
<center>如何设计可扩展的文件协议 
</center>
<p>应如何重新设计协议以最大限度地减少服务器交互的数量，即如何减少 TestAuth 消息的数量？此外，他们如何设计协议以使这些服务器交互高效？通过解决这两个问题，新协议将产生更具可扩展性的 AFS 版本。</p>
</blockquote>
<h2 id="afsv2" class="heading-element"><span>3 AFSv2</span>
  <a href="#afsv2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>AFSv2 引入了<strong>回调</strong>的概念，以减少客户端/服务器交互的次数。<font color="red">回调只是服务器对客户端的一个承诺，即当客户端缓存的文件被修改时，服务器将通知客户端。</font>在系统中添加这种状态后，客户端就不再需要联系服务器来了解缓存文件是否仍然有效。相反，它会假定文件是有效的，直到服务器告诉它否则；请注意<strong>轮询</strong>与<strong>中断</strong>之间的类比。</p>
<p>AFSv2 还引入了**文件标识符（FID）**的概念（类似于 NFS <strong>文件句柄</strong>），而不是路径名来指定客户端感兴趣的文件。AFS 中的 FID 由一个卷标识符、一个文件标识符和一个 &ldquo;唯一标识符 &ldquo;组成（以便在删除文件时重复使用卷和文件标识符）。因此，客户端不再向服务器发送整个路径名，并让服务器遍历路径名以找到所需的文件，而是逐步遍历路径名，缓存结果，并希望减少对服务器的负载。</p>
<p>例如，如果客户端访问文件<code>/home/zfhe/notes.txt</code>，而 <code>home</code> 是挂载在 <code>/</code> 上的 AFS 目录（即 <code>/</code> 是本地根目录，但 <code>home</code> 及其子目录在 AFS 中），客户端将首先获取 <code>home</code> 的目录内容，将其放入本地磁盘缓存，并在 <code>home</code> 上设置回调。然后，客户机将取回 <code>zfhe</code> 目录，将其放入本地磁盘缓存，并在 <code>zfhe</code> 上设置回调。最后，客户端会获取<code>notes.txt</code>，将这个常规文件缓存到本地磁盘，并设置回调，最后向调用应用程序返回一个文件描述符。这个过程如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=small" data-sub-html="<h2>image-20240424210624267</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png" alt="image-20240424210624267" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240424210624267.png?size=large 2x" data-title="image-20240424210624267" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>不过，与 NFS 的主要区别在于，每次获取目录或文件时，AFS 客户端都会与服务器建立回调，从而确保服务器会通知客户端其缓存状态的变化。这样做的好处显而易见：虽然对<code>/home/zfhe/notes.txt</code> 的首次访问会产生许多客户端-服务器信息（如上所述），但同时也会为所有目录以及<code>notes.txt</code> 文件建立回调，因此后续访问完全是本地操作，根本不需要与服务器交互。因此，在客户端缓存文件的常见情况下，AFS 的行为几乎与本地磁盘文件系统相同。如果访问一个文件不止一次，那么第二次访问的速度应该与本地访问文件的速度一样快。</p>
<h3 id="缓存一致性" class="heading-element"><span>3.2 缓存一致性</span>
  <a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<center>缓存一致性不是万能的
</center>
<p>在讨论分布式文件系统时，很多人都会提到文件系统提供的缓存一致性。然而，这种基本一致性并不能解决多个客户端访问文件的所有问题。例如，如果你正在建立一个代码库，有多个客户端执行代码的检入和检出，你就不能简单地依赖底层文件系统来为你完成所有工作；<font color="red">相反，你必须使用显式文件级锁定，以确保在发生这种并发访问时发生 &ldquo;正确 &ldquo;的事情。</font>事实上，任何真正关心并发更新的应用程序都会增加额外的机制来处理冲突。基本一致性主要适用于临时使用，也就是说，当用户登录到不同的客户端时，他们希望在客户端上显示其文件的合理版本。如果对这些协议抱有更高的期望，就会让自己陷入失败、失望和充满泪水的沮丧之中。</p>
</blockquote>
<p>当我们讨论 NFS 时，我们考虑了缓存一致性的两个方面：<strong>更新可见性</strong>和<strong>缓存陈旧性</strong>。</p>
<ul>
<li>对于更新可见性，问题是：服务器何时会使用新版本的文件进行更新？</li>
<li>对于缓存陈旧性，问题是：一旦服务器有了新版本，客户端多久才能看到新版本而不是旧的缓存副本？</li>
</ul>
<p>由于<strong>回调</strong>和<strong>全文件缓存</strong>，AFS 提供的缓存一致性很容易描述和理解。有两个重要的情况需要考虑：<font color="red">不同机器上的进程之间的一致性，以及同一机器上的进程之间的一致性。</font></p>
<p>在不同的计算机之间，AFS 使更新在服务器上可见，并在同一时间（即更新的文件关闭时）使缓存的副本失效。客户端打开一个文件，然后写入（可能重复）。当它最终关闭时，新文件将刷新到服务器（因此可见）。此时，服务器会“中断”任何具有缓存副本的客户端的回调；**中断是通过联系每个客户端并通知它对文件的回调不再有效来完成的。**此步骤确保客户端将不再读取文件的过时副本；这些客户端上的后续打开将需要从服务器重新获取文件的新版本（并且还将用于在文件的新版本上重新建立回调）。</p>
<p>AFS 对同一台机器上的进程之间的这种简单模型进行了例外处理。在这种情况下，对文件的写入对其他本地进程立即可见（即，进程不必等到文件关闭才能查看其最新更新）。这使得使用单台机器的行为完全符合您的预期，因为此行为基于典型的 UNIX 语义。只有当切换到不同的机器时，你才能检测到更通用的AFS一致性机制。</p>
<p>有一个有趣的跨机器案例值得进一步讨论。具体来说，在不同机器上的进程同时修改文件的罕见情况下，AFS 自然会采用所谓的“<strong>最后写入者获胜</strong>”方法（也许应该称为“<strong>最后关闭者获胜</strong>”）。具体来说，最后调用 <code>close()</code> 的客户端将最后更新服务器上的整个文件，因此将成为“获胜”文件，即保留在服务器上供其他人查看的文件。结果是一个由一个客户端或另一个客户端完整生成的文件。请注意与 NFS 等基于块的协议的区别：在 NFS 中，当每个客户端更新文件时，各个块的写入可能会被刷新到服务器，因此服务器上的最终文件可能是两个客户端更新的混合体。在许多情况下，这种混合文件输出没有多大意义，即想象一下 JPEG 图像被两个客户端分段修改；由此产生的写入组合不太可能构成有效的 JPEG。</p>
<p>下图中显示了其中一些不同场景的时间线。这些列显示了 $Client_1$ 上的两个进程（$P_1$ 和 $P_2$）及其缓存状态、$Client_2$ 上的一个进程 ($P_3$) 及其缓存状态以及服务器 (Server) 的行为，所有这些都在一个名为 $F$ 的文件上进行操作。对于服务器来说，图中只是显示了左边操作完成后的文件内容。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=small" data-sub-html="<h2>image-20240424212508074</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png" alt="image-20240424212508074" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cache_Consistency_Timeline.png?size=large 2x" data-title="image-20240424212508074" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="崩溃恢复" class="heading-element"><span>3.3 崩溃恢复</span>
  <a href="#%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>从上面的描述中，你可能会感觉到崩溃恢复比 NFS 更复杂。你是对的。例如，假设服务器 (S) 在短时间内无法与客户端(C1) 取得联系，比如客户端 C1 正在重启。当 C1 不可用时，S 可能已尝试向其发送一条或多条回调召回消息；例如，假设 C1 在本地磁盘上缓存了文件 F，然后 C2（另一个客户端）更新了 F，从而导致 S 向所有缓存该文件的客户端发送消息，要求它们从本地缓存中删除该文件。<font color="red">由于 C1 在重启时可能会错过这些关键信息，因此在重新加入系统时，C1 应将其所有缓存内容视为可疑内容。</font>因此，在下一次访问文件 F 时，C1 应首先询问服务器（通过 TestAuth 协议消息）其缓存的文件 F 副本是否仍然有效；如果有效，C1 可以使用它；如果无效，C1 应从服务器获取更新的版本。</p>
<p>服务器崩溃后的恢复也比较复杂。由此产生的问题是，回调是保存在内存中的；因此，当服务器重启时，它不知道哪台客户机拥有哪些文件。<font color="red">因此，服务器重启后，服务器的每个客户端都必须意识到服务器已经崩溃，并将其所有缓存内容视为可疑内容，并且（如上所述）在使用文件之前重新确定其有效性。</font></p>
<p>因此，服务器崩溃是一件大事，因为必须确保每个客户端都能及时意识到服务器崩溃，否则客户端就有可能访问过期文件。实现这种恢复的方法有很多，例如，当服务器重新启动并运行时，让服务器向每个客户端发送一条消息（说 &ldquo;不要相信你的缓存内容！&quot;），或者让客户端定期检查服务器是否还活着（即所谓的 &ldquo;心跳消息&rdquo;）。正如你所看到的，建立一个可扩展性更强、更合理的缓存模型是有代价的；在 NFS 中，客户端几乎不会注意到服务器崩溃。</p>
<h3 id="可扩展性和性能" class="heading-element"><span>3.4 可扩展性和性能</span>
  <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7%e5%92%8c%e6%80%a7%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>采用新协议后，对 AFSv2 进行了测量，发现其可扩展性远远超过原始版本。事实上，每台服务器可以支持大约 50 个客户端（而不是 20 个）。另一个好处是，客户端的性能往往非常接近本地性能，因为在普通情况下，所有文件访问都是本地的；文件读取通常会进入本地磁盘缓存（也可能进入本地内存）。只有在客户端创建新文件或写入现有文件时，才需要向服务器发送存储信息，从而用新内容更新文件。</p>
<p>我们还可以通过比较常见的文件系统访问情况和 NFS 来了解 AFS 的性能。下图显示了定性比较的结果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=small" data-sub-html="<h2>image-20240424213449188</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png" alt="image-20240424213449188" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_AFS_VS_NFS.png?size=large 2x" data-title="image-20240424213449188" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，我们分析了不同大小文件的典型读写模式。小文件有 $N_s$ 个块；中等文件有 $N_m$ 个块；大文件有 $N_L$ 个块。我们假定，小型和中型文件适合放在客户端内存中；大型文件适合放在本地磁盘上，但不适合放在客户端内存中。</p>
<p>为便于分析，我们还假设，通过网络访问远程服务器的文件块需要 $L_{net}$ 时间单位。访问本地内存需要 $L_{mem}$，访问本地磁盘需要 $L_{disk}$。一般假设是$L_{net} &gt; L_{disk} &gt; L_{mem}$。</p>
<p>最后，我们假设对文件的首次访问不在任何缓存中发生。如果相关缓存有足够的容量容纳文件，我们假设对文件的后续访问（即 &ldquo;重读&rdquo;）会在缓存中命中。</p>
<p>图中各列显示了特定操作（如小文件顺序读取）在 NFS 或 AFS 上大致花费的时间。最右边一列显示的是 AFS 与 NFS 的比例。</p>
<p>我们得出以下结论。首先，在许多情况下，每个系统的性能大致相当。例如，在首次读取文件时（如工作负载 1、3、5），从远程服务器获取文件的时间占主导地位，而且在两个系统上的时间相似。在这种情况下，您可能会认为 AFS 的速度会慢一些，因为它必须将文件写入本地磁盘；但是，本地（客户端）文件系统缓存会对这些写入进行缓冲，因此上述成本很可能是隐性的。同样，你可能会认为 AFS 从本地缓存副本读取文件的速度会更慢，这也是因为 AFS 将缓存副本存储在磁盘上。然而，AFS 也能从本地文件系统缓存中获益；AFS 上的读取可能会在客户端内存缓存中进行，性能与 NFS 类似。</p>
<p>其次，在大文件顺序重读（工作负载 6）过程中出现了一个有趣的差异。由于 AFS 有一个很大的本地磁盘缓存，当文件再次被访问时，它会从本地磁盘缓存中访问文件。相比之下，NFS 只能缓存客户端内存中的数据块；因此，如果重新读取大文件（即大于本地内存的文件），NFS 客户端将不得不从远程服务器重新获取整个文件。因此，假设远程访问确实比本地磁盘慢，在这种情况下，AFS 比 NFS 快 $\frac{L_{net}}{L_{disk}}$ 的系数。我们还注意到，在这种情况下，NFS 会增加服务器负载，这也会对扩展性产生影响。</p>
<p>第三，我们注意到，顺序写入（新文件）在两个系统上的执行情况类似（工作负载 8、9）。在这种情况下，AFS 会将文件写入本地缓存副本；当文件关闭时，AFS 客户端会根据协议强制将文件写入服务器。NFS 会在客户端内存中缓冲写入，也许会因为客户端内存压力而强制将某些块写入服务器，但在文件关闭时肯定会将它们写入服务器，以保持 NFS 的关闭时刷新一致性。你可能会认为 AFS 的速度会更慢，因为它会将所有数据写入本地磁盘。但是，你要知道，<font color="red">它是在向本地文件系统写入数据；这些写入的数据首先提交到页面缓存，然后才（在后台）提交到磁盘，因此 AFS 可以利用客户端操作系统内存缓存基础架构的优势来提高性能。</font></p>
<p>第四，我们注意到 AFS 在顺序文件覆盖（工作负载 10）上的性能更差。到目前为止，我们假定写入的工作负载也在创建新文件；在这种情况下，文件存在，然后被覆盖写入。对于 AFS 来说，重写可能是一种特别糟糕的情况，因为客户端首先会完整地获取旧文件，然后再将其重写。与此相反，NFS 只需覆盖块，从而避免了最初的（无用的）读取。</p>
<p>最后，访问大文件中一小部分数据的工作负载在 NFS 上的表现要比 AFS 好得多（工作负载 7、11）。在这些情况下，AFS 协议会在打开文件时获取整个文件；但不幸的是，只会执行少量的读取或写入操作。更糟糕的是，<font color="red">如果文件被修改，整个文件都会被写回服务器，对性能的影响会加倍</font>。NFS 作为基于块的协议，执行的 I/O 与读取或写入的大小成正比。总之，我们看到 NFS 和 AFS 的假设不同，因此实现的性能结果也不同，这并不奇怪。这些差异是否重要，始终是一个工作负载问题。</p>
<blockquote>
<center>工作负载的重要性
</center>
<p>评估任何系统的一大挑战是<strong>工作负载的选择</strong>。由于计算机系统的使用方式多种多样，因此有多种工作负载可供选择。存储系统设计人员应如何确定哪些工作负载是重要的，以便做出合理的设计决策？</p>
<p>AFS 的设计者根据衡量文件系统使用方式的经验，做出了某些工作负载假设；特别是，他们假设大多数文件不经常共享，并且整体上按顺序访问。考虑到这些假设，AFS 设计就非常有意义了。</p>
<p>然而，这些假设并不总是正确的。例如，假设有一个应用程序定期将信息附加到日志中。这些小日志写入会将少量数据添加到现有的大文件中，这对于 AFS 来说是相当有问题的。还存在许多其他困难的工作负载，例如事务数据库中的随机更新。</p>
</blockquote>
<h2 id="afs其他改进" class="heading-element"><span>4 AFS：其他改进</span>
  <a href="#afs%e5%85%b6%e4%bb%96%e6%94%b9%e8%bf%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>就像我们在引入 Berkeley FFS（添加了符号链接和许多其他功能）时看到的那样，AFS 的设计者在构建系统时抓住了机会添加了许多功能，使系统更易于使用和管理。<font color="red">例如，AFS 为客户端提供了真正的全局命名空间，从而确保所有文件在所有客户端计算机上都以相同的方式命名。</font>相比之下，NFS 允许每个客户端以他们喜欢的任何方式安装 NFS 服务器，因此只有按照约定（以及大量的管理工作），文件才能在客户端之间以类似的方式命名。</p>
<p>AFS 还非常重视安全性，并采用了对用户进行身份验证的机制，并确保如果用户愿意，可以将一组文件保持私有。相比之下，NFS 多年来对安全性的支持相当原始。</p>
<p>AFS 还包括用于灵活的用户管理访问控制的设施。因此，在使用 AFS 时，用户可以很好地控制谁可以访问哪些文件。 NFS 与大多数 UNIX 文件系统一样，对此类共享的支持要少得多。</p>
<p>最后，如前所述，AFS 添加了一些工具，使系统管理员能够更简单地管理服务器。在系统管理方面，AFS 遥遥领先于该领域。</p>
]]></description></item><item><title>网络文件系统</title><link>https://hezephyr.github.io/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:37:27 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="基本的分布式文件系统" class="heading-element"><span>1 基本的分布式文件系统</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式客户端/服务器计算最早应用于分布式文件系统领域。在这种环境中，<strong>有多台客户机和一台（或几台）服务器</strong>；服务器将数据存储在磁盘上，客户机通过格式良好的协议信息请求数据。下图描述了基本设置。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Generic_Client_Server_System.png" alt="image-20240423230842288" style="zoom:50%;" />
<p>从图中可以看出，服务器拥有磁盘，客户端通过网络发送消息来访问这些磁盘上的目录和文件。我们为什么要费心这样的安排呢？ （即，为什么我们不让客户端使用他们的本地磁盘？）嗯，<font color="red">主要是这种设置允许在客户端之间轻松共享数据。</font>因此，如果您访问一台计算机（客户端 0）上的文件，然后使用另一台计算机（客户端 2），您将拥有相同的文件系统视图。您的数据自然会在这些不同的机器之间共享。第二个好处是<strong>集中管理</strong>；例如，备份文件可以从少数服务器计算机而不是多个客户端完成。另一个优势可能是安全性。将所有服务器放在上锁的机房中可以防止出现某些类型的问题。</p>
<p>因此关键问题是：</p>
<blockquote>
<p>如何构建分布式文件系统？需要考虑哪些关键方面？什么容易出错？我们可以从现有系统中学到什么？</p>
</blockquote>
<p>我们现在将研究简化的分布式文件系统的架构。一个简单的客户端/服务器分布式文件系统比我们迄今为止研究的文件系统具有更多的组件。在客户端，有一些客户端应用程序通过<strong>客户端文件系统</strong>访问文件和目录。客户端应用程序向客户端文件系统发出系统调用（例如 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>close()</code>、<code>mkdir()</code> 等），以便访问存储在服务器上的文件。因此，对于客户端应用程序来说，除了性能之外，文件系统似乎与本地（基于磁盘的）文件系统没有任何不同。这样，分布式文件系统提供了对文件的<strong>透明</strong>访问，这是一个显而易见的目标；毕竟，谁会愿意使用一个需要不同的应用程序接口或者使用起来很麻烦的文件系统呢？</p>
<p>客户端文件系统的作用是执行服务这些系统调用所需的操作。例如，如果客户端发出 <code>read()</code> 请求，客户端文件系统可能会向<strong>服务器端文件系统</strong>（或者通常称为<strong>文件服务器</strong>）发送消息以读取特定块；然后，文件服务器将从磁盘（或其自己的内存缓存）读取该块，并将包含请求数据的消息发送回客户端。然后，客户端文件系统会将数据复制到提供给 <code>read()</code> 系统调用的用户缓冲区中，从而完成请求。请注意，客户端上同一块的后续 <code>read()</code> 可能会缓存在客户端内存中，甚至缓存在客户端磁盘上；在最好的情况下，不需要产生网络流量。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=small" data-sub-html="<h2>image-20240423231648503</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png" alt="image-20240423231648503" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Distributed_File_System_Architecture.png?size=large 2x" data-title="image-20240423231648503" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从这个简单的概述中，您应该了解到客户端/服务器分布式文件系统中有两个重要的软件部分：客户端文件系统和文件服务器。它们的行为共同决定了分布式文件系统的行为。现在是时候研究一个特定的系统了：Sun 的<strong>网络文件系统 (NFS)</strong>。</p>
<h2 id="网络文件系统nfs" class="heading-element"><span>2 网络文件系统（NFS）</span>
  <a href="#%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9fnfs" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Sun Microsystems 公司开发的分布式系统是最早也是相当成功的分布式系统之一，被称为 Sun 网络文件系统（或 NFS）。在定义 NFS 时，Sun 采用了一种不同寻常的方法：Sun 没有构建一个专有的封闭系统，而是开发了一个开放协议，简单地规定了客户机和服务器用于通信的确切信息格式。不同的团体可以开发自己的 NFS 服务器，从而在 NFS 市场上竞争，同时保持互操作性。这种做法取得了成功：如今有许多公司都在销售 NFS 服务器（包括 Oracle/Sun、NetApp、EMC、IBM 和其他公司），NFS 的广泛成功很可能归功于这种 &ldquo;开放市场 &ldquo;方法。</p>
<h3 id="重点简单快速的服务器崩溃恢复" class="heading-element"><span>2.1 重点：简单快速的服务器崩溃恢复</span>
  <a href="#%e9%87%8d%e7%82%b9%e7%ae%80%e5%8d%95%e5%bf%ab%e9%80%9f%e7%9a%84%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在本章中，我们将讨论经典的 NFS 协议（版本 2，又称 NFSv2），该协议是多年来的标准；在向 NFSv3 迁移时进行了一些小改动，在向 NFSv4 迁移时进行了更大规模的协议改动。然而，NFSv2 既精彩又令人沮丧，因此成为我们关注的焦点。在 NFSv2 中，协议设计的主要目标是简单快速地恢复服务器崩溃。在多客户端、单服务器的环境中，这一目标是非常合理的；服务器宕机（或不可用）的任何一分钟都会让所有客户端机器（及其用户）不高兴，并影响工作效率。因此，服务器垮了，整个系统也就垮了。</p>
<h4 id="快速崩溃恢复的关键无状态" class="heading-element"><span>2.1.1 快速崩溃恢复的关键：无状态</span>
  <a href="#%e5%bf%ab%e9%80%9f%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d%e7%9a%84%e5%85%b3%e9%94%ae%e6%97%a0%e7%8a%b6%e6%80%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>NFSv2 通过设计无状态协议实现了这一简单目标。根据设计，服务器不会跟踪每个客户端正在发生的任何事情。例如，服务器不知道哪些客户端正在缓存哪些数据块，也不知道每个客户端当前打开了哪些文件，更不知道文件的当前文件指针位置等。简而言之，服务器不会跟踪客户端正在做的任何事情；相反，协议的设计目的是在每个协议请求中提供完成请求所需的所有信息。</p>
<p>有状态（非无状态）协议的一个例子是 <code>open()</code> 系统调用。给定一个路径名，<code>open()</code> 返回一个文件描述符（整数）。该描述符将用于后续的 <code>read()</code> 或 <code>write()</code> 请求，以访问各种文件块，如下面这段代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">// get descriptor &#34;fd&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// read MAX bytes from foo (via fd)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// read MAX bytes from foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX</span><span class="p">);</span> <span class="c1">// read MAX bytes from foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">// close file
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在想象一下，客户端文件系统通过向服务器发送一条协议消息“打开文件‘foo’并给我返回一个描述符”来打开文件。然后，文件服务器在其本地打开该文件并将描述符发送回客户端。在后续读取中，客户端应用程序使用该描述符来调用 <code>read()</code> 系统调用；然后，客户端文件系统将消息中的描述符传递给文件服务器，表示“从我传递给您的描述符所引用的文件中读取一些字节”。</p>
<p>在这个例子中，文件描述符是客户端和服务器之间的一段<strong>共享状态</strong>（Ousterhout 称之为<strong>分布式状态</strong>）。正如我们上面所暗示的，共享状态使崩溃恢复变得复杂。想象一下，服务器在第一次读取完成后、客户端发出第二次读取之前崩溃了。服务器重新启动并运行后，客户端会发出第二次读取。不幸的是，服务器不知道 <code>fd</code> 引用的是哪个文件；该信息是短暂的（即在内存中），因此当服务器崩溃时就会丢失。为了处理这种情况，客户端和服务器必须参与某种<strong>恢复协议</strong>，客户端将确保在其内存中保留足够的信息，以便能够告诉服务器它需要知道什么（在这种情况下 ，该文件描述符 <code>fd</code> 引用文件 <code>foo</code>)</p>
<p>当您考虑有状态服务器必须处理客户端崩溃这一事实时，情况会变得更糟。例如，想象一下，一个客户端打开一个文件然后崩溃了。 <code>open()</code> 使用了服务器上的文件描述符；服务器如何知道可以关闭给定文件？在正常操作中，客户端最终会调用 <code>close()</code> ，从而通知服务器应该关闭文件。然而，当客户端崩溃时，服务器永远不会收到 <code>close()</code>，因此必须注意到客户端已崩溃才能关闭文件。</p>
<p>出于这些原因，NFS 的设计者决定采用无状态方法：每个客户端操作都包含完成请求所需的所有信息。不需要花哨的崩溃恢复；服务器刚刚重新开始运行，而客户端在最坏的情况下可能必须重试请求。</p>
<h4 id="nfsv2-协议" class="heading-element"><span>2.1.2 NFSv2 协议</span>
  <a href="#nfsv2-%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>由此，我们得出了 NFSv2 协议的定义。我们的问题陈述很简单：</p>
<blockquote>
<center>如何定义无状态文件协议
</center>
<p>如何定义网络协议以实现无状态操作？显然，像 <code>open()</code> 这样的有状态调用不能作为讨论的一部分（因为这需要服务器跟踪打开的文件）；但是，客户端应用程序会希望调用 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>close()</code> 和其他标准 API 调用来访问文件和目录。因此，作为一个细化的问题，我们该如何定义协议才能既无状态又支持 POSIX 文件系统 API 呢？</p>
</blockquote>
<p>理解 NFS 协议设计的关键之一是理解<strong>文件句柄</strong>。文件句柄用于唯一描述特定操作要操作的文件或目录；因此，许多协议请求都包含一个文件句柄。</p>
<p>你可以认为文件句柄有三个重要组成部分：<strong>卷标识符</strong>、<strong>inode号</strong>和生成号；这三者共同构成了客户端希望访问的文件或目录的唯一标识符。</p>
<ul>
<li>卷标识符告知服务器该请求指向哪个文件系统（一个 NFS 服务器可以导出多个文件系统）；</li>
<li>Inode号告诉服务器该请求访问的是该分区中的哪个文件。</li>
<li>最后，在重复使用inode号时需要使用生成号；每当重复使用一个inode号时，服务器就会递增生成号，以确保使用旧文件句柄的客户端不会意外访问新分配的文件。</li>
</ul>
<p>以下是协议中一些重要部分的摘要；完整的协议可从其他地方获得。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">NFSPROC_GETATTR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_SETATTR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_LOOKUP</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，要查找的文件/目录的名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：文件句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of file/directory to look up</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">file handle</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_READ</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄，偏移量，计数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：数据，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle, offset, count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">data, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_WRITE</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：文件句柄，偏移量，计数，数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">file handle, offset, count, data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_CREATE</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，文件名，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of file, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_REMOVE</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，要移除的文件名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of file to be removed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_MKDIR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，目录名，属性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：文件句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of directory, attributes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">file handle</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_RMDIR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录文件句柄，要移除的目录名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：无</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory file handle, name of directory to be removed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">nothing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">NFSPROC_READDIR</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 期望：目录句柄，要读取的字节数，标识符</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 返回：目录条目，标识符（以获取更多条目）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">expects</span><span class="p">:</span><span class="w"> </span><span class="l">directory handle, count of bytes to read, cookie</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">returns</span><span class="p">:</span><span class="w"> </span><span class="l">directory entries, cookie (to get more entries)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们简要介绍一下协议的重要组成部分。首先，LOOKUP 协议报文用于获取文件句柄，然后使用该句柄访问文件数据。客户端传递<strong>一个目录文件句柄和要查找的文件名</strong>，服务器会将该文件（或目录）的句柄及其属性传回客户端。</p>
<p>例如，假设客户端已经拥有文件系统根目录 (<code>/</code>) 的目录文件句柄（实际上，这可以通过 NFS <strong>挂载协议</strong>获得，这是客户端和服务器首次连接的方式；为简洁起见，我们在此不讨论挂载协议）。如果在客户端运行的应用程序打开文件 <code>/foo.txt</code>，客户端文件系统就会向服务器发送一个查找请求，将根文件句柄和文件名 <code>foo.txt</code> 传递给服务器；如果请求成功，就会返回 <code>foo.txt</code> 的文件句柄（和属性）。</p>
<p>如果你想知道，属性只是文件系统跟踪每个文件的元数据，包括文件创建时间、最后修改时间、大小、所有权和权限信息等字段，也就是在文件上调用 <code>stat()</code> 时会返回的信息。</p>
<p>一旦有了文件句柄，客户端就可以对文件发出 READ 和 WRITE 协议消息，分别读取或写入文件。读取协议消息要求传递文件句柄、文件偏移量和要读取的字节数。然后，服务器就能发出读取命令（毕竟，句柄会告诉服务器要从哪个卷和哪个 inode 读取，偏移量和字节数会告诉服务器要读取文件的哪个字节），并将数据返回给客户端（如果读取失败，则返回错误信息）。写入（WRITE）的处理方式与此类似，只是数据从客户端传递到服务器，并只返回一个成功代码。</p>
<p>最后一个有趣的协议信息是 GETATTR 请求；给定一个文件句柄后，它只需获取该文件的属性，包括文件的最后修改时间。在下文讨论缓存时，我们将看到该协议请求在 NFSv2 中的重要性。</p>
<h3 id="从协议到分布式文件系统" class="heading-element"><span>2.2 从协议到分布式文件系统</span>
  <a href="#%e4%bb%8e%e5%8d%8f%e8%ae%ae%e5%88%b0%e5%88%86%e5%b8%83%e5%bc%8f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>希望您现在已经了解如何将该协议转变为跨客户端文件系统和文件服务器的文件系统。<font color="red">客户端文件系统跟踪打开的文件，并且通常将应用程序请求转换为相关的协议消息集。服务器只是响应协议消息，每个消息都包含完成请求所需的所有信息。</font></p>
<p>例如，让我们考虑一个读取文件的简单应用程序。在下图中，我们显示了应用程序进行了哪些系统调用，以及客户端文件系统和文件服务器响应此类调用时执行的操作。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=small" data-sub-html="<h2>image-20240424131608950</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png" alt="image-20240424131608950" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_Reading_A_File.png?size=large 2x" data-title="image-20240424131608950" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>首先，注意客户端如何跟踪文件访问的所有相关状态，包括<strong>整数文件描述符</strong>到 <strong>NFS 文件句柄</strong>的映射以及当前文件指针。这使得客户端能够将每个读取请求（您可能已经注意到，没有明确指定要读取的偏移量）转换为格式正确的读取协议消息，该消息准确地告诉服务器要读取文件中的哪些字节。成功读取后，客户端更新当前文件位置；后续读取将使用相同的文件句柄但偏移量不同。</p>
<p>其次，您可能会注意到服务器交互发生的位置。当文件第一次打开时，客户端文件系统会发送一个LOOKUP请求消息。事实上，如果必须遍历长路径名（例如，<code>/home/zfhe/foo.txt</code>），客户端将发送三个 LOOKUP：一个在目录 <code>/</code> 中查找 <code>home</code>，一个在 <code>home</code> 中查找 <code>zfhe</code>，最后一个在 <code>zfhe</code> 中查找 <code>foo.txt</code>。</p>
<p>第三，您可能会注意每个服务器请求都包含完成请求所需的全部信息。这个设计要点对于从服务器故障中从容恢复至关重要，我们现在将详细讨论；它确保服务器不需要状态就能响应请求。</p>
<h3 id="使用幂等操作处理服务器故障" class="heading-element"><span>2.3 使用幂等操作处理服务器故障</span>
  <a href="#%e4%bd%bf%e7%94%a8%e5%b9%82%e7%ad%89%e6%93%8d%e4%bd%9c%e5%a4%84%e7%90%86%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%95%85%e9%9a%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端向服务器发送信息时，有时会收不到回复。造成这种无法回复的原因有很多。在某些情况下，信息可能被网络丢弃；网络确实会丢失信息，因此请求或回复都可能丢失，这样客户端就永远不会收到回复。</p>
<p>也有可能是服务器崩溃了，因此目前没有响应信息。一段时间后，服务器将重新启动并重新开始运行，但在此期间，所有请求都已丢失。在所有这些情况下，客户端都会遇到一个问题：当服务器未能及时回复时该怎么办？</p>
<p>在 NFSv2 中，客户端以一种单一、统一和优雅的方式处理所有这些故障：<font color="red">只需重试请求即可。</font>具体来说，在发送请求后，客户端会设置一个计时器，在指定时间段后关闭。如果在定时器关闭前收到了回复，定时器就会被取消，一切正常。但是，如果在收到任何回复之前计时器就关闭了，客户端就会认为请求没有被处理，并重新发送请求。如果服务器回复了，则一切正常，客户端也顺利地解决了问题。</p>
<p>客户端之所以能简单地重试请求（不管失败的原因是什么），是因为大多数 NFS 请求都有一个重要特性：它们都是<strong>幂等</strong>的。<font color="red">当多次执行该操作的效果等同于单次执行该操作的效果时，我们就称该操作为幂等操作。</font>例如，如果将一个值存储到内存位置三次，与存储一次的效果相同；因此，&ldquo;将值存储到内存 &ldquo;就是一个幂等操作。但是，如果将一个计数器递增三次，其结果与只递增一次的结果不同，因此 &ldquo;递增计数器 &ldquo;不是幂等操作。<font color="red">更一般地说，任何只读取数据的操作显然都是幂等的，而更新数据的操作则必须更仔细地考虑，以确定它是否具有这种特性。</font></p>
<p>NFS 崩溃恢复设计的核心是大多数常见操作的幂等性。LOOKUP 和 READ 请求具有微不足道的幂等性，因为它们只从文件服务器读取信息，而不更新信息。更有趣的是，WRITE 请求也是幂等的。例如，如果 WRITE 失败，客户端只需重试即可。<font color="red">WRITE 消息包含数据、计数和（重要的）要写入数据的准确偏移量。</font>因此，只要知道多次写入的结果与单次写入的结果相同，就可以重复写入。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=small" data-sub-html="<h2>image-20240424140254771</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png" alt="image-20240424140254771" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Three_Types_Of_Loss.png?size=large 2x" data-title="image-20240424140254771" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这样，客户端就能以统一的方式处理所有超时。</p>
<ul>
<li>如果只是丢失了 WRITE 请求（上述情况 1），客户端将重试，服务器将执行写入操作，一切正常。</li>
<li>同样的情况也会发生，如果在发送请求时服务器碰巧宕机，但在发送第二个请求时又恢复运行，那么一切都会如愿以偿（情况 2）。</li>
<li>最后，服务器可能会接收到写入请求，向磁盘发出写入操作，并发送回复。这个回复可能会丢失（情况 3），再次导致客户机重新发送请求。当服务器再次收到请求时，它只会做完全相同的事情：将数据写入磁盘并回复说已经写入。如果这次客户端收到了回复，那么一切又都正常了，这样客户端就以统一的方式处理了信息丢失和服务器故障。</li>
</ul>
<p>不过有些操作很难做到幂等。例如，当你试图创建一个已经存在的目录时，你会被告知 mkdir 请求失败。因此，在 NFS 中，如果文件服务器接收到 MKDIR 协议信息并成功执行，但却丢失了回复，那么客户端可能会重复该操作并遭遇失败，而实际上该操作一开始是成功的，只是在重试时失败了。因此，生活并不完美。</p>
<blockquote>
<center>TIP：幂等性非常强大 
</center>
<p>在构建可靠系统时，幂等性是一个有用的属性。当一个操作可以多次发出时，处理操作失败就容易得多；你可以重试。如果操作不是幂等的，生活就会变得更加困难。</p>
</blockquote>
<h2 id="提高性能客户端缓存" class="heading-element"><span>3 提高性能：客户端缓存</span>
  <a href="#%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bc%93%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>分布式文件系统的优点有很多，但通过网络发送所有读写请求可能会导致很大的性能问题：网络通常速度不快，尤其是与本地内存或磁盘相比。那么，又一个问题：如何提高分布式文件系统的性能？</p>
<p>答案是<strong>客户端缓存</strong>。 NFS 客户端文件系统将从服务器读取的文件数据（和元数据）缓存在客户端内存中。因此，虽然第一次访问的成本很高（即，它需要网络通信），但后续访问很快就会从客户端内存中得到服务。</p>
<p>高速缓存还充当写入的临时缓冲区。当客户端应用程序首次写入文件时，客户端会先将数据缓冲在客户端内存中（与从文件服务器读取的数据位于同一缓存中），然后再将数据写出到服务器。这种写入缓冲非常有用，因为它将应用程序 <code>write()</code> 延迟与实际写入性能解耦，即应用程序对 <code>write()</code> 的调用立即成功（并且只是将数据放入客户端文件系统的缓存中）；只有稍后数据才会被写出到文件服务器。</p>
<p>因此，NFS 客户端缓存数据并且性能通常很好，我们就完成了，对吗？不幸的是，不完全是。将缓存添加到具有多个客户端缓存的任何类型的系统中都会带来一个巨大且有趣的挑战，我们将其称为<strong>缓存一致性问题</strong>。</p>
<h3 id="缓存一致性问题" class="heading-element"><span>3.2 缓存一致性问题</span>
  <a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>缓存一致性问题最好用两个客户端和一个服务器来说明。假设客户端 C1 读取文件 F，并在其本地缓存中保留该文件的副本。现在想象一个不同的客户端 C2 覆盖文件 F，从而更改其内容；我们将文件的新版本称为 F（版本 2）或 F[v2]，将旧版本称为 F[v1]，这样我们就可以保持两者不同（当然，文件具有相同的名称，只是内容不同）。最后，还有第三个客户端 C3，它尚未访问文件 F。</p>
<p>您可能会看到即将出现的问题，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=small" data-sub-html="<h2>image-20240424142910926</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png" alt="image-20240424142910926" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/NFS_The_Cache_Consistency_Problem.png?size=large 2x" data-title="image-20240424142910926" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>事实上，有两个子问题。</p>
<ul>
<li>第一个子问题是客户端 C2 在将其写入传播到服务器之前可能会在其缓存中缓冲一段时间；在这种情况下，虽然 F[v2] 位于 C2 的内存中，但来自另一个客户端（例如 C3）对 F 的任何访问都将获取文件的旧版本 (F[v1])。因此，通过在客户端缓冲写入，其他客户端可能会获得该文件的过时版本，这可能是不合需要的；事实上，想象一下这样的情况：您登录到机器 C2，更新 F，然后登录到 C3 并尝试读取文件，结果却得到旧副本！当然，这可能会令人沮丧。因此，我们将这方面的缓存一致性问题称为<font color="red">更新可见性</font>；一个客户端的更新何时对其他客户端可见？</li>
<li>缓存一致性的第二个子问题是<font color="red">陈旧的缓存</font>；在这种情况下，C2 最终将其写入刷新到文件服务器，因此服务器具有最新版本（F[v2]）。然而，C1 的缓存中仍然有 F[v1]；如果在 C1 上运行的程序读取文件 F，它将获得陈旧版本 (F[v1])，而不是最新副本 (F[v2])，这（通常）是不可取的。</li>
</ul>
<p>NFSv2 实现通过两种方式解决这些缓存一致性问题。</p>
<ul>
<li>首先，为了解决更新可见性，客户端实现有时称为“关闭时刷新”（也称为“关闭到打开”）一致性语义；具体来说，<font color="red">当客户端应用程序写入文件并随后关闭文件时，客户端会将所有更新（即缓存中的脏页）刷新到服务器</font>。通过关闭时刷新一致性，NFS 可确保后续从另一个节点打开时将看到最新的文件版本。</li>
<li>其次，为了解决陈旧缓存问题，NFSv2 客户端在使用其缓存内容之前首先检查文件是否已更改。具体来说，<font color="red">在使用缓存块之前，客户端文件系统将向服务器发出 GETATTR 请求以获取文件的属性。</font>重要的是，属性包括有关文件最后一次在服务器上修改的时间的信息；如果修改时间比文件被提取到客户端缓存的时间更新，则客户端会使该文件无效，从而将其从客户端缓存中删除，并确保后续读取将转到服务器并检索最新的文件的版本。另一方面，如果客户端发现它具有该文件的最新版本，它将继续使用缓存的内容，从而提高性能。</li>
</ul>
<p>当 Sun 的原始团队针对陈旧缓存问题实施此解决方案时，他们意识到了一个新问题：突然，NFS 服务器被 GETATTR 请求淹没。遵循的一个良好的工程原则是针对常见情况进行设计，并使其运行良好；在这里，尽管常见情况是仅从单个客户端访问文件（可能重复），**但客户端始终必须向服务器发送 GETATTR 请求以确保没有其他人更改该文件。**因此，客户端轰炸服务器，不断询问“有人更改了这个文件吗？”，而大多数时候没有人更改过。</p>
<p>为了（在某种程度上）解决这种情况，每个客户端都添加了属性缓存。客户端在访问文件之前仍然会验证文件，但大多数情况下只会查看属性缓存以获取属性。特定文件的属性在第一次访问该文件时被放置在缓存中，然后在一定时间（例如 3 秒）后超时。因此，在这三秒钟内，所有文件访问都将确定可以使用缓存的文件，从而在与服务器没有网络通信的情况下执行此操作。</p>
<h3 id="评估-nfs-缓存一致性" class="heading-element"><span>3.3 评估 NFS 缓存一致性</span>
  <a href="#%e8%af%84%e4%bc%b0-nfs-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>关于 NFS 缓存一致性的最后几句话。添加关闭时刷新行为是为了“有意义”，但引入了一定的性能问题。具体来说，如果在客户端上创建了临时或短暂的文件，然后很快将其删除，它仍然会被强制发送到服务器。更理想的实现可能会将这些短暂的文件保留在内存中，直到它们被删除，从而完全消除服务器交互，也许会提高性能。</p>
<p>更重要的是，在 NFS 中添加属性缓存使得人们很难理解或推断到底获得的文件版本是什么。有时你会得到最新版本；有时，您会得到旧版本，只是因为您的属性缓存尚未超时，因此客户端很乐意为您提供客户端内存中的内容。尽管这在大多数情况下都很好，但它偶尔会（而且仍然如此！）导致奇怪的行为。这样我们就描述了 NFS 客户端缓存的奇怪之处。它是一个有趣的例子，其中实现的细节用于定义用户可观察的语义，而不是相反。</p>
<h2 id="对服务器端写缓冲的影响" class="heading-element"><span>4 对服务器端写缓冲的影响</span>
  <a href="#%e5%af%b9%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e5%86%99%e7%bc%93%e5%86%b2%e7%9a%84%e5%bd%b1%e5%93%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>到目前为止，我们的重点一直放在客户端缓存上，这也是最有趣的问题所在。不过，NFS 服务器往往也是拥有大量内存的装备精良的机器，因此它们也有缓存问题。当从磁盘读取数据（和元数据）时，NFS 服务器会将其保存在内存中，随后对数据（和元数据）的读取将不会转到磁盘，这有可能（小幅）提高性能。</p>
<p>更有趣的是写缓冲。NFS 服务器在强制写入稳定存储（如磁盘或其他持久性设备）之前，绝对不会返回成功的 WRITE 协议请求。虽然它们可以在服务器内存中放置数据副本，但向客户端返回 WRITE 协议请求成功可能会导致不正确的行为。</p>
<p>答案就在于我们对客户端如何处理服务器故障的假设。想象一下客户端发出的以下写入序列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">a_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// fill first block with a’s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">b_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// fill second block with b’s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">c_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// fill third block with c’s
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些写入会先用 a 块、b 块和 c 块覆盖文件的三个块。因此，如果文件最初看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span></span><span class="line"><span class="cl">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
</span></span><span class="line"><span class="cl">zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可能期望这些写入后的最终结果是这样的，其中 x、y 和 z 将分别被 a、b 和 c 覆盖。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
</span></span><span class="line"><span class="cl">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
</span></span><span class="line"><span class="cl">cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，为了举例，我们假设这三个客户端写入作为三个不同的 WRITE 协议消息发送到服务器。假设服务器收到第一个 WRITE 消息并将其发送到磁盘，并且客户端通知其成功。现在假设第二次写入只是缓冲在内存中，并且服务器在将其强制写入磁盘之前也会向客户端报告其成功；不幸的是，服务器在将其写入磁盘之前崩溃了。服务器很快重启，收到第三个写请求，也成功了。</p>
<p>因此，对于客户端来说，所有请求都成功了，但令我们惊讶的是文件内容如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
</span></span><span class="line"><span class="cl">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy &lt;--- oops
</span></span><span class="line"><span class="cl">cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</span></span></code></pre></td></tr></table>
</div>
</div><p>因为服务器在将第二次写入提交到磁盘之前告诉客户端第二次写入成功，所以文件中会留下旧的块，这可能是灾难性的，具体取决于应用程序。</p>
<p>为了避免这个问题，NFS 服务器必须将每次写入提交到稳定（持久）存储，然后再通知客户端成功；这样做使客户端能够在写入期间检测到服务器故障，从而重试直到最终成功。这样做可以确保我们永远不会像上面的示例一样最终出现文件内容混合的情况。</p>
<p>这一要求在 NFS 服务器实现中引起的问题是，如果不小心的话，写入性能可能会成为主要的性能瓶颈。事实上，一些公司（例如 Network Appliance）的成立只是为了构建一个可以快速执行写入的 NFS 服务器；他们使用的一个技巧是首先将<strong>写入操作放入电池支持的内存中</strong>，从而能够快速回复写入请求，而不必担心丢失数据，并且无需立即写入磁盘；第二个技巧是使用专门设计的文件系统设计，以便在最终需要时快速写入磁盘。</p>
<h2 id="总结" class="heading-element"><span>5 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>在 NFS 中实现快速、简单的崩溃恢复这一主要目标的关键在于<strong>无状态协议的设计</strong>。崩溃后，服务器可以快速重新启动并再次开始服务请求；客户端只需<strong>重试</strong>请求，直到成功为止。</li>
<li>使请求具有<strong>幂等性</strong>是NFS 协议的一个核心方面。当多次执行某个操作的效果与执行一次相同时，该操作就是幂等的。在NFS中，幂等性使客户端能够无忧重试，并统一客户端丢失消息重传以及客户端处理服务器崩溃的方式。</li>
<li>性能问题决定了对<strong>客户端缓存</strong>和<strong>写缓冲</strong>的需求，但会带来<strong>缓存一致性问题</strong>。</li>
<li>NFS 实现提供了一种通过多种方式实现缓存一致性的工程解决方案：**关闭时刷新（关闭到打开）**方法可确保当文件关闭时，其内容被强制传输到服务器，从而使其他客户端能够观察到文件的更新。属性缓存减少了向服务器检查文件是否已更改的频率（通过 GETATTR 请求）。</li>
<li><font color="red">NFS 服务器必须在返回成功之前向持久介质提交写入；否则，可能会导致数据丢失。</font></li>
<li>为了支持NFS 集成到操作系统中，Sun 引入了<strong>VFS/Vnode</strong> 接口，使多个文件系统实现能够在同一操作系统中共存。</li>
</ul>
]]></description></item><item><title>分布式系统</title><link>https://hezephyr.github.io/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:36:36 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式系统改变了世界的面貌。当您的网络浏览器连接到地球上其他地方的网络服务器时，它正在参与看似简单形式的<strong>客户端/服务器</strong>（CS）分布式系统。然而，当您联系 Google 或 Facebook 等现代网络服务时，您不仅仅是在与一台机器进行交互。在幕后，这些复杂的服务是由大量（即数千台）机器构建的，每台机器相互协作以提供站点的特定服务。</p>
<p>构建分布式系统时会出现许多新的挑战。我们主要关注的是失败；<font color="red">机器、磁盘、网络和软件都会时不时地出现故障，因为我们不（并且可能永远不会）知道如何构建“完美”的组件和系统</font>。然而，当我们构建现代 Web 服务时，我们希望它对客户来说似乎永远不会失败；我们怎样才能完成这个任务呢？</p>
<blockquote>
<p>关键：如何构建在组件出现故障时仍能正常工作的系统？</p>
</blockquote>
<p>有趣的是，虽然失败是构建分布式系统的主要挑战，但它也代表着机遇。是的，机器会出故障；但一台机器发生故障并不意味着整个系统一定会发生故障。通过将一组机器集合在一起，我们可以构建一个似乎很少发生故障的系统，尽管它的组件经常发生故障。这一事实是分布式系统的核心魅力和价值，也是为什么它们成为您使用的几乎所有现代网络服务（包括 Google、Facebook 等）的基础。</p>
<blockquote>
<center>TIP：通信本质上是不可靠的 
</center>
<p>在几乎所有情况下，最好将通信视为一种本质上不可靠的活动。bit损坏、链路和机器瘫痪或无法工作，以及传入数据包缺乏缓冲空间，都会导致同样的结果：数据包有时无法到达目的地。<font color="red">要在这种不可靠的网络之上建立可靠的服务，我们必须考虑能够应对数据包丢失的技术。</font></p>
</blockquote>
<p>还存在其他重要问题。系统<strong>性能</strong>往往至关重要；由于网络将我们的分布式系统连接在一起，系统设计者往往必须仔细考虑如何完成既定任务，尽量减少发送信息的数量，并进一步提高通信效率（<strong>低延迟、高带宽</strong>）。</p>
<p>最后，<strong>安全</strong>也是一个必要的考虑因素。确保远程方的真实身份成为一个核心问题。此外，确保第三方无法监视或改变两个人之间正在进行的通信也是一个挑战。</p>
<p>在本介绍中，我们将讨论分布式系统中最基本的新问题：<strong>通信</strong>。也就是说，分布式系统中的机器应该如何相互通信？？我们将从最基本的可用原语（消息）开始，并在它们之上构建一些更高级别的原语。正如我们上面所说，故障将成为焦点：通信层应如何处理故障？</p>
<h2 id="通信基础" class="heading-element"><span>2 通信基础</span>
  <a href="#%e9%80%9a%e4%bf%a1%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">现代网络的核心原则是通信从根本上来说是不可靠的。</font>无论是在广域互联网中，还是在 Infiniband 等局域高速网络中，数据包经常会丢失、损坏或无法到达目的地。</p>
<p>造成数据包丢失或损坏的原因有很多。有时，在传输过程中，某些位会由于电气或其他类似问题而翻转。有时，系统中的某个元件（例如网络链路或数据包路由器甚至远程主机）会因某种原因损坏或无法正常工作；网络电缆确实会被意外切断，至少有时是这样。</p>
<p>然而，<font color="red">更根本的是由于网络交换机、路由器或端点内缺乏缓冲而导致的数据包丢失。</font>具体来说，即使我们可以保证所有链路正常工作，并且系统中的所有组件（交换机、路由器、终端主机）都按预期启动并运行，但由于以下原因，仍然有可能发生丢失。</p>
<p>想象一下一个数据包到达路由器；要处理数据包，必须将其放置在路由器内存中的某个位置。如果许多此类数据包同时到达，则路由器内的内存可能无法容纳所有数据包。此时路由器唯一的选择是丢弃一个或多个数据包。同样的行为也发生在终端主机上；当你向一台机器发送大量消息时，机器的资源很容易被淹没，从而再次出现丢包。</p>
<p>因此，数据包丢失是网络中的基础。那么问题就变成了：我们该如何应对？</p>
<h2 id="不可靠通信层" class="heading-element"><span>3 不可靠通信层</span>
  <a href="#%e4%b8%8d%e5%8f%af%e9%9d%a0%e9%80%9a%e4%bf%a1%e5%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>一种简单的方法是：我们不去处理它。因为某些应用程序知道如何处理数据包丢失，所以有时让它们与基本的不可靠消息传递层进行通信是有用的，这是人们经常听到的<strong>端到端</strong>论点的一个例子。<strong>UDP/IP</strong> 网络协议栈就是这种不可靠层的一个很好的例子，目前几乎所有的现代系统都有这种协议栈。使用 UDP 时，进程使用<strong>socket</strong> API 创建<strong>通信端点</strong>；其他机器（或同一机器）上的进程向原始进程发送 UDP 数据报（数据报是固定大小的报文，最大不超过某个最大值）。</p>
<blockquote>
<center>端到端论点
</center>
<p>端到端论点认为，系统的最高层，即通常位于 &ldquo;端 &ldquo;的应用程序，最终是分层系统中唯一能真正实现某些功能的地方。在具有<a href="https://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf"target="_blank" rel="external nofollow noopener noreferrer">里程碑意义的论文中<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，Saltzer 等人通过一个极好的例子论证了这一点：两台机器之间的可靠文件传输。<center>如果要将文件从机器 A 传输到机器 B，并确保最终到达机器 B 的字节与开始到达机器 A 的字节完全相同，就必须进行 &ldquo;端到端 &ldquo;检查；而网络或磁盘等较低级别的可靠机制则无法提供这种保证。</center></p>
<p>与此形成鲜明对比的是一种试图通过在系统较低层增加可靠性来解决可靠文件传输问题的方法。例如，我们建立了一个可靠的通信协议，并用它来建立可靠的文件传输。该通信协议保证发送方发送的每个字节都能被接收方按顺序接收，例如使用超时/重试、确认和序列号。不幸的是，使用这样的协议并不能实现可靠的文件传输；试想一下，在通信开始之前，发送方内存中的字节就已经损坏，或者接收方将数据写入磁盘时发生了什么不好的事情。在这种情况下，即使字节在网络上可靠地传输，我们的文件传输最终也是不可靠的。要建立可靠的文件传输，必须包括端到端的可靠性检查，例如，在整个传输完成后，读回接收方磁盘上的文件，计算校验和，并将校验和与发送方的文件进行比较。</p>
<p>这句格言的推论是，有时让下层提供额外功能确实可以提高系统性能或优化系统。因此，你不应该排除在系统中的较低层次使用这种机制；相反，你应该仔细考虑这种机制的效用，考虑到它在整个系统或应用程序中的最终用途。</p>
</blockquote>
<p>下面这两段代码显示了构建在 UDP/IP 之上的简单客户端和服务器。客户端可以向服务器发送消息，然后服务器做出响应。通过这么少量的代码，您就拥有了开始构建分布式系统所需的一切！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// client.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;udp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addrSend</span><span class="p">,</span> <span class="n">addrRecv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">UDP_Open</span><span class="p">(</span><span class="n">CLIENT_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_FillSockAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addrSend</span><span class="p">,</span> <span class="s">&#34;localhost&#34;</span><span class="p">,</span> <span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client:: sending message [%s]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrSend</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Client:: Failed to send message</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client:: waiting for reply...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrRecv</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Client:: Failed to read message</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client:: read %d bytes (message: %s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//server.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;udp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUFFER_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">UDP_Open</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to create socket</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;server:: waiting for data...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;server:: read %d bytes (message: %s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">reply</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sprintf</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="s">&#34;goodbye world&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">rc</span> <span class="o">=</span> <span class="nf">UDP_Write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;server:: reply</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>UDP 是不可靠通信层的一个很好的例子。而发送方从不会因此被告知数据包丢失。但是，这并不意味着 UDP 完全不防范任何故障。例如，UDP 包含一个校验和来检测某些形式的数据包损坏。</p>
<p>然而，由于许多应用程序只是想将数据发送到目的地而不担心数据包丢失，因此我们需要更多。具体来说，我们需要在不可靠的网络上进行可靠的通信。</p>
<h2 id="可靠的通信层" class="heading-element"><span>4 可靠的通信层</span>
  <a href="#%e5%8f%af%e9%9d%a0%e7%9a%84%e9%80%9a%e4%bf%a1%e5%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了构建可靠的通信层，我们需要一些新的机制和技术来处理丢包。让我们考虑一个简单的示例，其中客户端通过不可靠的连接向服务器发送消息。我们必须回答的第一个问题：发送者如何知道接收者确实收到了消息？</p>
<p>我们将使用的技术称为<strong>确认</strong>，简称 <code>ack</code>。想法很简单：发送者向接收者发送消息；然后接收者发回一条短消息以确认其收到。下图描述了该过程。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=small" data-sub-html="<h2>image-20240423123154950</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png" alt="image-20240423123154950" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Acknowledgement.png?size=large 2x" data-title="image-20240423123154950" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当发送方收到消息的确认时，它就可以放心，接收方确实收到了原始消息。但是，如果发送方没有收到确认，该怎么办？</p>
<p>为了处理这种情况，我们需要一个额外的机制，称为<strong>超时</strong>。当发送者发送消息时，发送者现在设置一个计时器在一段时间后关闭。如果此时未收到确认，则发送方断定消息已丢失。然后，发送者只需<strong>重试</strong>发送，再次发送相同的消息，希望这次能够成功。为了使这种方法发挥作用，发送者必须保留消息的副本，以备需要再次发送时使用。<strong>超时和重试</strong>的结合导致一些人将这种方法称为<strong>超时/重试</strong>，下图显示了一个示例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=small" data-sub-html="<h2>image-20240423123849662</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png" alt="image-20240423123849662" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Request.png?size=large 2x" data-title="image-20240423123849662" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>不幸的是，这种形式的超时/重试还不够。下图显示了可能导致问题的数据包丢失示例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=small" data-sub-html="<h2>image-20240423123930417</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png" alt="image-20240423123930417" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Message_Plus_Ack_Dropped_Reply.png?size=large 2x" data-title="image-20240423123930417" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，丢失的不是原始消息，而是确认消息。从发送方的角度来看，情况似乎是一样的：没有收到确认，因此需要超时和重试。但从接收者的角度来看，情况就大不一样了：现在同一条消息已经收到两次了！虽然在某些情况下这可能是可以的，但一般来说是不行的；想象一下当您下载文件并且在下载过程中重复额外的数据包时会发生什么。因此，当我们的目标是建立一个可靠的消息层时，我们通常还希望保证接收者<strong>只接收每条消息一次</strong>。</p>
<p>为了使接收方能够检测到重复的消息传输，发送方必须以某种独特的方式识别每条消息，并且接收方需要某种方式来跟踪它之前是否已经看过每条消息。当接收方看到重复传输时，它只是确认消息，但（关键）不会将消息传递给接收数据的应用程序。因此，发送方收到 <code>ack</code>，但消息不会被接收两次，从而保留了上述的恰好一次语义。有多种方法可以检测重复消息。例如，发送者可以为每条消息生成一个唯一的ID；接收者可以追踪它所见过的每一个ID。这种方法可行，但成本高昂，需要无限的内存来跟踪所有 ID。</p>
<p>有一种更简单的方法可以解决这个问题，只需要很少的内存，这种机制被称为<strong>序列计数器</strong>。使用序列计数器时，发送方和接收方商定一个计数器的起始值（如 $1$），由双方共同维护。每当发送一条信息时，计数器的当前值就会随信息一起发送；这个计数器值（$N$）就是信息的 ID。信息发送后，发送方会递增计数器值（到 $N + 1$）。</p>
<p>接收方使用其计数器值作为该发送方发来信息的 ID 的预期值。如果接收到的信息 ID（N）与接收者的计数器（也是 N）相匹配，接收者就会接收该信息并将其上传给应用程序；在这种情况下，接收者就会断定这是第一次收到该信息。然后，接收方递增计数器（到 $N + 1$），等待下一条信息。</p>
<p>如果丢失了应答，发送方将超时并重新发送信息 $N$。这一次，接收方的计数器更高（$N + 1$），因此接收方知道自己已经收到了这条信息。因此，它会接收信息，但不会将其上传给应用程序。通过这种简单的方式，序列计数器可用于避免重复。</p>
<p>最常用的可靠通信层被称为 TCP/IP，简称 TCP。TCP 比我们上面描述的要复杂得多，包括处理网络拥塞、多个未处理请求以及数百种其他小调整和优化的机制。</p>
<blockquote>
<center>TIP：小心设置超时值 
</center>
<p>正如您可能从讨论中猜到的那样，正确设置超时值是使用超时重试消息发送的一个重要方面。</p>
<ul>
<li>如果超时太小，发送方将不必要地重新发送消息，从而浪费发送方的CPU时间和网络资源。</li>
<li>如果超时太大，则发送方等待太长时间才能重新发送，从而降低发送方的感知性能。</li>
</ul>
<p>因此，从单个客户端和服务器的角度来看，“正确”值是等待足够长的时间来检测数据包丢失，但不再等待。</p>
<p>然而，正如我们将在以后的章节中看到的那样，分布式系统中通常不仅仅只有一个客户端和服务器。在许多客户端向单个服务器发送数据的情况下，服务器上的数据包丢失可能表明服务器过载。如果为真，客户端可能会以不同的自适应方式重试；例如，在第一次超时后，<strong>客户端可能会将其超时值增加到更高的值，可能是原始值的两倍</strong>。这种指数退避方案在早期的 Aloha 网络中首创并在早期以太网中采用，避免了因过度重发而导致资源过载的情况。稳健的系统努力避免这种性质的过载。</p>
</blockquote>
<h2 id="通信抽象" class="heading-element"><span>5 通信抽象</span>
  <a href="#%e9%80%9a%e4%bf%a1%e6%8a%bd%e8%b1%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>给定了基本的消息传递层，我们现在讨论本章中的下一个问题：在构建分布式系统时我们应该使用什么通信抽象？</p>
<p>多年来，系统界开发了许多方法。其中一项工作是将操作系统的抽象概念扩展到分布式环境中运行。例如，<strong>分布式共享内存（DSM）系统</strong>能让不同机器上的进程共享一个大型虚拟地址空间。这种抽象将分布式计算变成了类似于多线程应用程序的东西；<font color="red">唯一的区别是，这些线程运行在不同的机器上，而不是同一机器上的不同处理器上。</font></p>
<p>大多数 DSM 系统的工作方式是通过操作系统的虚拟内存系统。在一台机器上访问一个页面时，可能会发生两种情况。</p>
<ul>
<li>在第一种（最佳）情况下，页面已经在本地计算机上，因此可以快速获取数据。</li>
<li>第二种情况是，页面当前在其他机器上。页面故障发生后，页面故障处理程序会向其他机器发送信息，以获取页面，并将其安装到请求进程的页表中，然后继续执行。</li>
</ul>
<p>由于多种原因，这种方法目前并未得到广泛应用。DSM 面临的最大问题是如何<strong>处理故障</strong>。例如，设想一下，如果一台机器发生故障，那么这台机器上的页面会发生什么情况？如果分布式计算的数据结构遍布整个地址空间怎么办？在这种情况下，这些数据结构的一部分将突然不可用。当部分地址空间丢失时，处理故障是非常困难的；<strong>想象一下，在一个链表中，&ldquo;下一个 &ldquo;指针指向的地址空间部分已经消失。</strong></p>
<p>另一个问题是性能。在编写代码时，我们通常会假设访问内存的成本很低。在 DSM 系统中，有些访问是廉价的，但有些访问却会导致页面故障，并从远程机器上获取昂贵的数据。因此，这种 DSM 系统的程序员必须非常小心地组织计算，使其几乎不发生任何通信，这在很大程度上违背了这种方法的初衷。尽管在这一领域进行了大量研究，但几乎没有产生实际影响；如今，<font color="red">没有人使用 DSM 构建可靠的分布式系统</font>。</p>
<h2 id="远程过程调用-rpc" class="heading-element"><span>6 远程过程调用 (RPC)</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8-rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>操作系统抽象对于构建分布式系统来说是一个糟糕的选择，而<strong>编程语言（PL）抽象</strong>则更有意义。最主要的抽象基于**远程过程调用（简称 RPC）**的思想。</p>
<p><font color="red">远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单明了。</font>因此，对客户端来说，只需进行一次过程调用，一段时间后就会返回结果。服务器只需定义一些它希望导出的例程。RPC 系统一般由两部分组成：<strong>存根生成器（有时称为协议编译器）和运行时库</strong>。下面我们将详细介绍其中的每一部分。</p>
<h3 id="存根生成器" class="heading-element"><span>6.1 存根生成器</span>
  <a href="#%e5%ad%98%e6%a0%b9%e7%94%9f%e6%88%90%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>存根生成器的工作很简单：通过自动化来消除将函数参数和结果打包到消息中的一些痛苦。这样做会带来许多好处：通过设计可以避免手工编写此类代码时出现的简单错误；此外，存根编译器也许可以优化此类代码，从而提高性能。</p>
<p>这种编译器的输入只是服务器希望导出到客户端的一组调用。从概念上讲，它可能像这样简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>存根生成器采用这样的接口并生成一些不同的代码片段。</p>
<ul>
<li>对于客户端，生成一个<strong>客户端存根</strong>，其中包含接口中指定的各个功能；<font color="red">希望使用此 RPC 服务的客户端程序将与此客户端存根链接并调用它以进行 RPC。</font>在内部，客户端存根中的每个函数都执行执行远程过程调用所需的所有工作。对于客户端来说，代码只是显示为函数调用（例如，客户端调用 <code>func1(x)</code>）；在内部，<code>func1()</code> 的客户端存根中的代码执行以下操作：
<ul>
<li>**创建消息缓冲区。**消息缓冲区通常只是某个大小的连续字节数组。</li>
<li><strong>将所需信息打包到消息缓冲区中。<strong>该信息包括要调用的函数的某种标识符，以及函数需要的所有参数（例如，在上面的示例中，<code>func1</code> 是一个整数）。将所有这些信息放入单个连续缓冲区的过程有时称为参数的</strong>编组</strong>或消息的<strong>序列化</strong>。</li>
<li>**将消息发送到目标RPC 服务器。**与 RPC 服务器的通信以及使其正确运行所需的所有细节均由 <strong>RPC 运行时库</strong>处理，如下所述。</li>
<li>**等待回复。**由于函数调用通常是同步的，因此调用将等待其完成。</li>
<li><strong>解压返回代码和其他参数。<strong>如果函数仅返回单个返回码，则此过程很简单；然而，更复杂的函数可能会返回更复杂的结果（例如，列表），因此存根可能也需要解压这些结果。此步骤也称为</strong>解组或反序列化</strong>。</li>
<li><strong>返回调用者</strong>。最后，只需从客户端存根返回到客户端代码即可。</li>
</ul>
</li>
<li>对于服务器，也会生成代码。在服务器上采取的步骤如下：
<ul>
<li><strong>解压消息。<strong>此步骤称为</strong>解组或反序列化</strong>，<font color="red">从传入消息中取出信息，提取函数标识符和参数。</font></li>
<li><strong>调用实际函数</strong>。最后！我们已经到达了实际执行远程函数的阶段。 RPC 运行时调用 ID 指定的函数并传入所需的参数。</li>
<li>**将结果打包。**返回参数被打包回单个回复缓冲区。</li>
<li><strong>发送回复</strong>。回复最终发送给调用者。</li>
</ul>
</li>
</ul>
<p>存根编译器还需要考虑其他一些重要问题。</p>
<ul>
<li>
<p>首先是复杂参数，即如何打包和发送复杂的数据结构？例如，当调用 <code>write()</code> 系统调用时，需要传递三个参数：一个整数文件描述符、一个指向缓冲区的指针和一个表示要写入多少字节（从指针开始）的大小。如果一个 RPC 程序包传递了一个指针，它就需要知道如何解释该指针，并执行正确的操作。通常，这可以通过两种方式实现：一种是众所周知的类型（例如，用于传递给定大小的数据块的<code>buffer_t</code>，RPC 编译器可以理解），另一种是为数据结构注释更多信息，使编译器知道哪些字节需要序列化。</p>
</li>
<li>
<p>另一个重要问题是服务器的并发组织。简单的服务器只是在一个简单的循环中等待请求，并一次处理一个请求。但是，正如你可能已经猜到的那样，这样做的效率会非常低：<font color="red">如果一个 RPC 调用阻塞（例如，在 I/O 上），服务器资源就会被浪费</font>。</p>
<p>因此，大多数服务器都是以某种并发方式构建的。一种常见的组织方式是<strong>线程池</strong>。在这种组织结构中，服务器启动时会创建一组有限的线程；<font color="red">当消息到达时，它会被分派到这些工作线程中的一个，然后工作线程会执行 RPC 调用的工作，并最终回复</font>；在此期间，主线程会不断接收其他请求，并可能将其分派给其他工作线程。这种组织方式可以在服务器内实现并发执行，从而提高服务器的利用率；同时也会产生标准成本，主要是编程复杂度，因为 RPC 调用现在可能需要使用<strong>锁和其他同步原语</strong>，以确保其正确运行。</p>
</li>
</ul>
<h3 id="运行时库" class="heading-element"><span>6.2 运行时库</span>
  <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%ba%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>运行时库负责处理 RPC 系统中的大部分繁重工作；大部分性能和可靠性问题都由运行时库处理。下面我们将讨论构建这样一个运行时库所面临的一些主要挑战。</p>
<p>我们必须克服的首要挑战之一是如何定位远程服务。这个<strong>命名</strong>问题是分布式系统中的常见问题，在某种意义上超出了我们当前讨论的范围。最简单的方法是利用现有的命名系统，例如当前互联网协议提供的主机名和端口号。在这种系统中，客户端必须知道运行所需的 RPC 服务的机器的主机名或 IP 地址，以及它正在使用的端口号（端口号只是一种识别机器上正在进行的特定通信活动的方法，允许同时使用多个通信通道）。然后，协议套件必须提供一种机制，将数据包从系统中的任何其他机器路由到特定地址。</p>
<p><font color="red">一旦客户端知道应该与哪台服务器通信以获取特定的远程服务，下一个问题就是 RPC 应该基于哪种传输级协议。</font>具体来说，RPC 系统应该使用 TCP/IP 这样可靠的协议，还是建立在 UDP/IP 这样不可靠的通信层之上？</p>
<p>天真地认为，选择似乎很容易：显然，我们希望请求能可靠地传送到远程服务器，显然，我们希望能可靠地收到回复。因此，我们应该选择可靠的传输协议，如 TCP，对吗？</p>
<p>不幸的是，在可靠通信层之上构建 RPC 会导致性能严重低下。回想一下上文讨论的可靠通信层的工作原理：<strong>确认加超时/重试</strong>。因此，当客户端向服务器发送 RPC 请求时，服务器会以确认的方式作出响应，以便调用者知道请求已收到。同样，当服务器发送回复给客户端时，客户端也会发出确认响应，以便服务器知道它已收到。在可靠的通信层之上建立请求/响应协议（如 RPC），需要发送两条 &ldquo;额外 &ldquo;信息。</p>
<p>因此，<font color="red">许多 RPC 程序包都建立在不可靠的通信层（如 UDP）之上</font>。这样做可以提高 RPC 层的效率，但却增加了为 RPC 系统提供可靠性的责任。RPC 层通过使用超时/重试和确认来达到所需的责任水平，这一点与我们上面所描述的非常相似。通过使用某种形式的序列号，通信层可以保证每个 RPC 恰好发生一次（在无故障的情况下），或最多发生一次（在出现故障的情况下）。</p>
<h3 id="其他问题" class="heading-element"><span>6.3 其他问题</span>
  <a href="#%e5%85%b6%e4%bb%96%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>RPC 运行时还必须处理一些其他问题。例如，当远程调用需要很长时间才能完成时会发生什么？考虑到我们的超时机制，长时间运行的远程调用可能会对客户端显示为失败，从而触发重试，因此这里需要注意。一种解决方案是在未立即生成回复时使用显式确认（从接收方到发送方）；这让客户端知道服务器收到了请求。然后，经过一段时间后，客户端可以定期询问服务器是否仍在处理该请求；如果服务器一直说“是”，客户端应该很高兴并继续等待（毕竟，有时过程调用可能需要很长时间才能完成执行）。</p>
<p>运行时还必须处理带有大参数的过程调用，这些参数大于单个数据包所能容纳的参数。<font color="red">一些较低级别的网络协议提供此类发送方分段（将较大的数据包分解为一组较小的数据包）和接收方重组（将较小的部分分解为一个较大的逻辑整体）；如果没有，RPC 运行时可能必须自己实现此类功能。</font></p>
<p>许多系统处理的一个问题是字节排序问题。您可能知道，某些机器以所谓的大端顺序存储值，而其他机器则使用小端顺序。大端存储从最高有效位到最低有效位的字节（例如，整数），很像阿拉伯数字；小端则相反。两者都是存储数字信息的同等有效的方式；这里的问题是如何在不同字节序的机器之间进行通信。</p>
<p>RPC 包通常通过在其消息格式中提供明确定义的字节顺序来处理此问题。在Sun的RPC包中，<strong>XDR（外部数据表示）层</strong>提供了此功能。如果发送或接收消息的机器与 XDR 的字节顺序匹配，则消息将按预期发送和接收。但是，如果通信的机器具有不同的字节顺序，则必须转换消息中的每条信息。因此，字节顺序的差异可能会带来很小的性能成本。</p>
<p>最后一个问题是是否向客户端公开通信的异步特性，从而实现一些性能优化。具体来说，<font color="red">典型的 RPC 是同步进行的，即当客户端发出过程调用时，它必须等待过程调用返回才能继续。</font>由于等待时间可能很长，并且客户端可能还有其他工作要做，因此某些 RPC 包允许您异步调用 RPC。当发出异步RPC时，RPC包发送请求并立即返回；然后客户端可以自由地执行其他工作，例如调用其他 RPC 或其他有用的计算。客户端有时会希望看到异步 RPC 的结果；因此，它回调 RPC 层，告诉它等待未完成的 RPC 完成，此时可以访问返回参数。</p>
]]></description></item><item><title>数据完整性和保护</title><link>https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/</link><pubDate>Sat, 11 May 2024 21:35:46 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/</guid><description><![CDATA[<h2 id="磁盘故障模式" class="heading-element"><span>1 磁盘故障模式</span>
  <a href="#%e7%a3%81%e7%9b%98%e6%95%85%e9%9a%9c%e6%a8%a1%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。</p>
<p>但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分工作正常，但在成功访问一个或多个块时遇到问题。具体来说，有两种类型的单块故障很常见且值得考虑：<font color="red">静默扇区错误 (LSE) 和块损坏</font>。我们现在将更详细地讨论每一个。</p>
<p>当磁盘扇区（或扇区组）受到某种损坏时，就会出现 LSE。例如，如果磁盘磁头由于某种原因（<strong>磁头撞击</strong>，正常运行中不应该发生的情况）接触到磁盘表面，可能会损坏磁盘表面，导致位无法读取。宇宙射线也会使位翻转，导致内容错误。幸运的是，硬盘会使用<strong>磁盘内纠错码 (ECC)</strong> 来确定块中的磁盘位是否正确，并在某些情况下对其进行修复；如果位不正确，而硬盘又没有足够的信息来修复错误，则在请求读取时磁盘会返回错误信息。</p>
<p>还有一种情况是，磁盘块损坏的方式无法被磁盘本身检测到。例如，存在漏洞的磁盘固件可能会将块写入错误位置；在这种情况下，磁盘 ECC 显示块内容正常，但从客户端的角度来看，随后访问时会返回错误的块。同样，当数据块通过故障总线从主机传输到磁盘时，也可能会损坏数据块；磁盘会存储损坏的数据，但这些数据并不是客户想要的。这类故障特别隐蔽，因为它们是<strong>静默故障</strong>；磁盘在返回故障数据时不会显示问题。</p>
<p>Prabhakaran 等人将这种更现代的磁盘故障观点称为部分故障磁盘故障模型。在这种观点中，磁盘仍有可能全部失效（就像传统的故障-停止模型中的情况一样）；但是，磁盘也有可能看似正常工作，但有一个或多个区块变得不可访问（即 LSE）或包含错误的内容（即损坏）。因此，在访问看似正常工作的磁盘时，偶尔会在尝试读取或写入给定块时返回错误（<strong>非静默部分故障</strong>），偶尔也会简单地返回错误数据（<strong>静默部分故障</strong>）。</p>
<p>这两类故障都比较罕见，但究竟有多罕见呢？下图总结了两份 Bairavasundaram 研究报告的部分结论。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=small" data-sub-html="<h2>image-20240422202738169</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png" alt="image-20240422202738169" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=large 2x" data-title="image-20240422202738169" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该图显示了在研究过程中（约 3 年，超过 150 万台硬盘）至少出现过一次 LSE 或块损坏的硬盘百分比。该图将结果进一步细分为 &ldquo;廉价 &ldquo;硬盘（通常为 SATA 硬盘）和 &ldquo;昂贵 &ldquo;硬盘（通常为 SCSI 或光纤通道硬盘）。正如您所看到的，虽然购买更好的硬盘降低了这两类问题的发生频率（大约降低了一个数量级），但它们仍然经常发生，因此您需要仔细考虑如何在存储系统中处理它们。</p>
<p>关于 LSE 的一些其他发现包括：</p>
<ul>
<li>具有多个 LSE 的昂贵驱动器与较便宜的驱动器一样可能产生额外错误；</li>
<li>对于大多数驱动器，第二年的年错误率会增加；</li>
<li>LSE 数量随着磁盘大小的增加而增加；</li>
<li>大多数磁盘具有LSE 少于 50 个；</li>
<li>具有 LSE 的磁盘更有可能产生额外的 LSE；</li>
<li>存在大量的空间和时间局部性；</li>
<li>磁盘清理很有用（大多数 LSE 都是通过这种方式找到的） 。</li>
</ul>
<p>关于损坏的一些发现：</p>
<ul>
<li>同一驱动器类别中不同驱动器型号的损坏几率差异很大；</li>
<li>型号之间的老化影响不同；</li>
<li>工作负载和磁盘大小对损坏影响很小</li>
<li>大多数损坏的磁盘只有少数损坏；</li>
<li>损坏在磁盘内或 RAID 中的磁盘之间不是独立的；</li>
<li>存在空间局部性和一些时间局部性</li>
<li>与LSE 的相关性很弱</li>
</ul>
<p><font color="red">一个可靠的存储系统，需要有检测和恢复 LSE 和块损坏的机制</font></p>
<h2 id="处理静默扇区错误lse" class="heading-element"><span>2 处理静默扇区错误（LSE）</span>
  <a href="#%e5%a4%84%e7%90%86%e9%9d%99%e9%bb%98%e6%89%87%e5%8c%ba%e9%94%99%e8%af%aflse" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>考虑到这两种新的部分磁盘故障模式，我们现在应该尝试看看我们可以对它们做些什么。让我们首先解决两者中较容易的一个，即静默扇区错误。</p>
<blockquote>
<p>关键问题：存储系统应如何处理静默扇区错误？需要多少额外的机制来处理这种形式的部分故障？</p>
</blockquote>
<p>事实证明，静默扇区错误的处理相当简单，因为它们（根据定义）很容易检测到。当存储系统尝试访问块并且磁盘返回错误时，存储系统应该简单地使用它所拥有的任何冗余机制来返回正确的数据。例如，</p>
<ul>
<li>在镜像 RAID 中，系统应该访问备用副本；</li>
<li>在基于奇偶校验的 RAID-4 或 RAID-5 系统中，系统应从奇偶校验组中的其他块重建该块。</li>
</ul>
<p>因此，诸如 LSE 等容易检测到的问题可以通过标准冗余机制轻松恢复。</p>
<p>LSE的不断增多影响了多年来RAID设计。在RAID-4/5系统中，当整个磁盘故障和LSE同时发生时，会出现一个特别有趣的问题。具体而言，在整个磁盘失败时，RAID尝试通过读取奇偶校验组中所有其他磁盘并重新计算缺失值来<strong>重建</strong>该磁盘（比如说，到一个热备用上）。如果在重建过程中，在任何其他一块磁盘上遇到LSE，则会出现问题：无法成功完成重建。</p>
<p>为了解决这个问题，一些系统增加了额外的冗余度。例如，NetApp的<strong>RAID-DP</strong>相当于两块奇偶校验硬盘而不是一块。当在重建过程中发现LSE时，额外的奇偶校验有助于重构丢失的数据块。正如始终如此地存在成本那样，在每条条带保持两块奇偶校验硬盘更昂贵；然而，NetApp <strong>WAFL</strong>文件系统的日志结构化性质在许多情况下可以减轻这种成本。剩下的成本是空间方面，在第二个奇偶校验区块形式上需要额外一块硬盘。</p>
<h2 id="检测损坏校验和" class="heading-element"><span>3 检测损坏：校验和</span>
  <a href="#%e6%a3%80%e6%b5%8b%e6%8d%9f%e5%9d%8f%e6%a0%a1%e9%aa%8c%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们解决更具挑战性的问题，即通过数据损坏导致的静默故障。当数据损坏导致磁盘返回坏数据时，我们如何防止用户获得坏数据？</p>
<blockquote>
<p>关键问题：鉴于此类故障的隐匿性，存储系统可以采取哪些措施来检测何时发生损坏？需要什么技术？如何有效地实施它们？</p>
</blockquote>
<p>与静默扇区错误不同，损坏检测是一个关键问题。客户端如何知道某个块已经坏了？一旦知道某个特定块损坏，<strong>恢复就与以前相同</strong>：您需要该块的其他副本（希望是一个未损坏的副本！）。因此，我们在这里重点关注<strong>检测技术</strong>。</p>
<p>现代存储系统用于保持数据完整性的主要机制称为<strong>校验和</strong>。<font color="red">校验和只是一个函数的结果，该函数将一块数据（例如 4KB 块）作为输入，并根据所述数据计算函数，生成数据内容的小摘要（例如 4 或 8 字节），该摘要称为校验和。</font>这种计算的目标是使系统能够通过将校验和与数据一起存储来检测数据是否已被损坏或更改，然后在<strong>以后访问时确认数据的当前校验和与原始存储值相匹配</strong>。</p>
<h3 id="常用校验和函数" class="heading-element"><span>3.2 常用校验和函数</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>许多不同的函数用于计算校验和，它们的强度（即，它们在保护数据完整性方面的能力）和速度（即，它们的计算速度）各不相同。这里出现了系统中常见的权衡：通常，获得的保护越多，成本就越高。</p>
<p>有些人使用的一种简单的校验和函数是基于异或 (XOR) 的。对于基于 XOR 的校验和，校验和是通过对正在校验和的数据块的每个块进行异或来计算的，从而生成表示整个块的 XOR 的单个值。</p>
<p>为了更具体地说明这一点，假设我们正在 16 字节的块上计算 4 字节的校验和（这个块当然太小，不能真正成为磁盘扇区或块，但它将用于示例）。 16 个数据字节（十六进制）如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">365e c4cd ba14 8a92 ecef 2c3a 40be f666</span></span></code></pre></td></tr></table>
</div>
</div><p>如果用二进制表示，我们会得到以下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0011 0110 0101 1110 1100 0100 1100 1101
</span></span><span class="line"><span class="cl">1011 1010 0001 0100 1000 1010 1001 0010
</span></span><span class="line"><span class="cl">1110 1100 1110 1111 0010 1100 0011 1010
</span></span><span class="line"><span class="cl">0100 0000 1011 1110 1111 0110 0110 0110</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们以每行 4 个字节为一组排列数据，因此很容易看出校验和的结果：在每列上执行 XOR 即可得到最终的校验和值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0010 0000 0001 1011 1001 0100 0000 0011</span></span></code></pre></td></tr></table>
</div>
</div><p>结果（十六进制）为<code>0x201b9403</code>。 XOR 是一种合理的校验和方法，但有其局限性。例如，<font color="red">如果每个校验和单元中同一位置的两个位发生变化，则校验和将无法检测到损坏。</font>为此，人们研究了其他校验和函数。</p>
<p>另一种基本的校验函数是加法。这种方法的优点是速度快；计算时只需对每块数据执行 2 的补码加法，忽略溢出。它可以检测到数据的许多变化，但如果数据发生移位等情况，则效果不佳。</p>
<p>Fletcher校验和是一种略微复杂的算法，以John G. Fletcher的名字命名。它的计算非常简单，只需计算两个校验字节 $s_1$ 和 $s_2$。具体来说，假设数据块 $D$ 由字节 $d_1 \dots  d_n$ 组成；$s_1$ 的定义如下：$s_1 = (s_1 + d_i) \mod 255$（对所有 $d_i$ 进行计算）；$s_2$ 的定义如下：$s_2 = (s_2 + s_1) \mod 255$（同样对所有 $d_i$ 进行计算）。Fletcher 校验和与 CRC 几乎一样强（见下文），能检测出所有单bit、双bit错误和许多突发错误。</p>
<p>最后一种常用的校验和称为<strong>循环冗余校验（CRC）</strong>。假设要计算数据块 D 的校验和，只需将 D 视为一个大的二进制数（毕竟只是一串bit），然后除以一个约定的值（$k$）。除数的余数就是 CRC 的值。事实证明，我们可以相当高效地实现这种二进制模运算，因此 CRC 在网络中也很流行。</p>
<p>无论使用哪种方法，显而易见的是，没有完美的校验和：<font color="red">两个内容不相同的数据块有可能具有完全相同的校验和，这就是所谓的冲突。</font>这个事实应该是直观的：毕竟，计算校验和是把一个大的东西（如 4KB），生成一个小得多的摘要（如 4 或 8 字节）。因此，在选择一个好的校验和函数时，我们试图找到一个既能尽量减少冲突几率，又能保持计算简便的函数。</p>
<h3 id="校验和布局" class="heading-element"><span>3.3 校验和布局</span>
  <a href="#%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%b8%83%e5%b1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在您已经了解了如何计算校验和，接下来我们来分析如何在存储系统中使用校验和。我们必须解决的第一个问题是校验和的布局，即校验和应该如何存储在磁盘上？</p>
<p>最基本的方法只是存储每个磁盘扇区（或块）的校验和。给定一个数据块 D，让我们调用该数据的校验和 <code>C(D)</code>。因此，如果没有校验和，磁盘布局如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=small" data-sub-html="<h2>image-20240422211734250</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png" alt="image-20240422211734250" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=large 2x" data-title="image-20240422211734250" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>使用校验和时，布局会为每个块添加一个校验和：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=small" data-sub-html="<h2>image-20240422211817034</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png" alt="image-20240422211817034" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=large 2x" data-title="image-20240422211817034" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>由于校验和通常很小（如 8 字节），而磁盘只能以扇区大小的块（512 字节）或其倍数写入，因此出现的一个问题是如何实现上述布局。硬盘制造商采用的一种解决方案是用 520 字节扇区格式化硬盘；每个扇区额外的 8 字节可用于存储校验和。</p>
<p>对于不具备这种功能的磁盘，文件系统必须想办法将校验和存储到 512 字节的块中。其中一种方法如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=small" data-sub-html="<h2>image-20240422211938622</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png" alt="image-20240422211938622" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=large 2x" data-title="image-20240422211938622" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此方案中，$n$ 个校验和一起存储在一个扇区中，后面是 $n$ 个数据块，然后是下一个的 $n$ 个块的另一个校验和扇区，依此类推。这种方法的优点是可以在所有磁盘上工作，但效率可能较低；例如，如果文件系统想要覆盖块<code>D1</code>，则必须读入包含<code>C(D1)</code>的校验和扇区，更新其中的<code>C(D1)</code>，然后写出校验和扇区和新的数据块<code>D1</code>（因此，一次读取和两次写入）。早期的方法（每个扇区一个校验和）仅执行一次写入。</p>
<h3 id="使用校验和" class="heading-element"><span>3.4 使用校验和</span>
  <a href="#%e4%bd%bf%e7%94%a8%e6%a0%a1%e9%aa%8c%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在确定了校验和布局之后，我们就可以着手了解如何使用校验和了。读取数据块 D 时，客户端（即文件系统或存储控制器）也会从磁盘读取其校验和$C_s(D)$，我们称之为<strong>存储校验和</strong>（因此使用了下标 $C_s$）。然后，客户端对检索到的数据块 D 计算校验和，我们称之为<strong>计算校验和</strong> $C_c(D)$。此时，客户端会比较存储的校验和与计算的校验和；如果两者相等（即 $C_s(D) == C_c(D)$），则数据很可能没有损坏，因此可以安全地返回给用户。如果它们不匹配（即 $C_s(D) != C_c(D)$），这意味着数据在存储后发生了变化（因为存储的校验和反映的是数据当时的值）。在这种情况下，我们的校验和帮助我们检测到了数据损坏。</p>
<p>有了损坏，我们自然会问该如何处理？如果存储系统有冗余副本，答案很简单：尝试使用它。如果存储系统没有这样的副本，答案很可能是返回错误。不管是哪种情况，都要认识到损坏检测并不是灵丹妙药；如果没有其他办法获取未损坏的数据，那就只能走霉运了。</p>
<h2 id="一个新问题错误写入" class="heading-element"><span>4 一个新问题：错误写入</span>
  <a href="#%e4%b8%80%e4%b8%aa%e6%96%b0%e9%97%ae%e9%a2%98%e9%94%99%e8%af%af%e5%86%99%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>上述基本方案在一般的块损坏情况下效果很好。然而，现代磁盘有几种不同寻常的故障模式，需要不同的解决方案。</p>
<p>第一种故障模式称为<strong>误写</strong>。磁盘和 RAID 控制器会出现这种情况，它们会将数据正确写入磁盘，只是写错了位置。在单磁盘系统中，这意味着磁盘将数据块 $D_x$ 写入的地址不是 $x$，而是 $y$（从而 &ldquo;破坏 &ldquo;了 $D_y$）；此外，在多磁盘系统中，控制器也可能将 $D_{i,x}$ 写入的地址不是磁盘 $i$ 的 $x$，而是其他磁盘 $j$。因此关键问题是：</p>
<blockquote>
<p>存储系统或磁盘控制器应如何检测错误写入？校验和需要哪些附加功能？</p>
</blockquote>
<p>答案很简单：在每个校验和中增加一点信息。在这种情况下，增加一个**物理标识符（物理 ID）**是非常有用的。例如，如果现在存储的信息包含校验和 $C(D)$以及块的磁盘编号和扇区编号，那么客户端就很容易确定正确的信息是否存在于特定位置。具体来说，如果客户端读取的是磁盘 $10$ 上的块 $4$（$D_{10,4}$），则存储的信息应包括该磁盘编号和扇区偏移量，如下图所示。如果信息不匹配，就说明发生了错误写入，此时就会检测到损坏。下面是双磁盘系统中添加信息的示例。请注意，该图和之前的其他图一样，并不是按比例绘制的，因为校验和通常很小（如 8 字节），而数据块却大得多（如 4 KB 或更大）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=small" data-sub-html="<h2>image-20240422213501062</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png" alt="image-20240422213501062" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=large 2x" data-title="image-20240422213501062" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从磁盘上的格式可以看出，磁盘上现在有相当多的冗余信息：对于每个块，磁盘编号在每个数据块内重复出现，而相关块的偏移量也保留在数据块本身旁边。冗余信息的存在不足为奇，因为冗余是错误检测（在本例中）和恢复（在其他情况下）的关键。虽然完美的磁盘并不严格需要一点额外的信息，但如果出现问题，这些信息却能帮助检测出问题所在。</p>
<h2 id="最后一个问题写入丢失" class="heading-element"><span>5 最后一个问题：写入丢失</span>
  <a href="#%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98%e5%86%99%e5%85%a5%e4%b8%a2%e5%a4%b1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>不幸的是，错误写入并不是我们要解决的最后一个问题。具体来说，一些现代存储设备还存在一个称为<strong>写入丢失</strong>的问题，当设备通知上层写入已完成但实际上从未被持久化时，就会发生这种情况；因此，剩下的是块的旧内容而不是更新的新内容。</p>
<p>这里明显的问题是：上面的任何校验和策略（例如基本校验和或物理标识）是否有助于检测丢失的写入？不幸的是，答案是否定的：旧块可能有匹配的校验和，并且上面使用的物理 ID（磁盘号和块偏移量）也将是正确的。</p>
<p>因此，我们的最后一个关键问题是：</p>
<blockquote>
<p>存储系统或磁盘控制器应如何检测丢失的写入？校验和还需要哪些附加功能？</p>
</blockquote>
<p>有许多可能的解决方案可以帮助。一种经典方法是执行<strong>写入验证</strong>或<strong>写入后读取</strong>；通过在写入后立即读回数据，系统可以确保数据确实到达磁盘表面。然而，这种方法非常慢，<font color="red">完成写入所需的 I/O 数量会增加一倍</font>。</p>
<p>有些系统在系统的其他地方添加校验和来检测丢失的写入。例如，Sun 的 Zettabyte 文件系统 (ZFS) 在每个文件系统inode中包含一个校验和，并为文件中包含的每个块提供间接块。因此，即使对块本身的写入丢失，inode 内的校验和也不会与旧数据匹配。只有当对inode和数据的写入同时丢失时，这种方案才会失败，这是一种不太可能（但不幸的是，有可能！）的情况。</p>
<h2 id="扫描" class="heading-element"><span>6 扫描</span>
  <a href="#%e6%89%ab%e6%8f%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>说了这么多，你可能会问：这些校验和什么时候会被检查？当然，在应用程序访问数据时会进行一定量的校验，但大多数数据很少被访问，因此会保持未校验状态。对于可靠的存储系统来说，未校验的数据是有问题的，因为bit损坏最终会影响特定数据的所有副本。</p>
<p>为了解决这个问题，许多系统都采用了各种形式的磁盘扫描。通过定期读取系统中的每个块，并检查校验和是否仍然有效，磁盘系统可以降低某个数据项的所有副本损坏的几率。典型的系统每晚或每周安排一次扫描。</p>
<h2 id="校验和的开销" class="heading-element"><span>7 校验和的开销</span>
  <a href="#%e6%a0%a1%e9%aa%8c%e5%92%8c%e7%9a%84%e5%bc%80%e9%94%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在结束之前，我们现在讨论使用校验和进行数据保护的一些开销。正如计算机系统中常见的那样，有两种不同类型的开销：空间和时间。</p>
<p>空间开销有两种形式。</p>
<ul>
<li>第一个是<strong>在磁盘（或其他存储介质）本身上</strong>；每个存储的校验和都会占用磁盘空间，无法再用于存储用户数据。典型的比率可能是每 4 KB 数据块 8 字节校验和，磁盘空间开销为 0.19%。</li>
<li>第二种类型的空间开销来自<strong>系统的内存</strong>。访问数据时，内存中必须有空间用于存放校验和以及数据本身。但是，如果系统只是检查校验和，然后在完成后将其丢弃，则这种开销是短暂的，不必担心。只有当校验和保存在内存中（为了防止内存损坏的额外保护级别），这个小开销才会被观察到。</li>
</ul>
<p>虽然空间开销很小，但校验和引起的时间开销可能非常明显。至少，CPU 必须计算每个块的校验和，无论是在存储数据时（以确定存储的校验和的值）还是在访问数据时（再次计算校验和并将其与存储的校验和进行比较）。许多使用校验和（包括网络栈）的系统采用的一种<font color="red">减少 CPU 开销的方法是将数据复制和校验和合并为一项简化的活动；因为无论如何都需要复制（例如，将数据从内核页缓存复制到用户缓冲区），因此组合复制/校验和可能非常有效。</font></p>
<p>除了 CPU 开销之外，某些校验和方案还会产生额外的 I/O 开销，特别是当校验和与数据分开存储时（因此需要额外的 I/O 来访问它们），以及后台扫描所需的任何额外 I/O。前者可以通过设计来减少；后者可以进行调整，从而限制其影响，或许可以通过控制此类扫描活动的发生时间来实现（如半夜）。</p>
]]></description></item><item><title>基于闪存的SSD</title><link>https://hezephyr.github.io/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/</link><pubDate>Sat, 11 May 2024 21:34:54 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在硬盘驱动器占据主导地位数十年后，一种新型的持久存储设备最近在世界上占据了重要地位。这种设备一般被称为<strong>固态存储设备</strong>，它不像硬盘驱动器那样有机械或移动部件，而是由晶体管构成，就像内存和处理器一样。然而，与典型的随机存取存储器（如 DRAM）不同，这种固态存储设备（又称 SSD）在断电的情况下仍能保留信息，因此是持久存储数据的理想选择。</p>
<p>我们将重点讨论的技术是<strong>闪存</strong>（更具体地说，是基于 NAND 的闪存，它具有更好的成本效益，即每存储容量单位的成本较低。这使得 NAND 型闪存在大容量存储设备中得到广泛应用，如固态硬盘（SSD）和闪存卡等），它是由 Fujio Masuoka 在 20 世纪 80 年代发明的，。我们将看到，闪存具有一些独特的特性。</p>
<ul>
<li>例如，要写入闪存的某一大块（即一个<strong>闪存页</strong>），首先必须擦除更大的一块（即一个<strong>闪存块</strong>），而擦除的代价可能相当昂贵。</li>
<li>此外，过于频繁地写入页面会导致页面磨损。</li>
</ul>
<p>这两个特性使得构建基于闪存的固态硬盘成为一项有趣的挑战：</p>
<blockquote>
<p>如何构建基于闪存的固态硬盘 如何构建基于闪存的固态硬盘？如何处理擦除的昂贵特性？考虑到反复擦写会损耗设备，我们如何才能制造出使用寿命长的设备？技术进步的脚步会停止吗？或者不再令人惊叹？</p>
</blockquote>
<p>闪存芯片设计用于在单个晶体管中存储一个或多个bit；晶体管内捕获的电荷水平被映射为二进制值。在单层单元 (SLC) 闪存中，晶体管内仅存储单个位（即 1 或 0）；对于多层单元 (MLC) 闪存，两个位被编码为不同的电荷级别，例如，00、01、10 和 11 分别由低、稍低、稍高和高电平表示。甚至还有三层单元 (TLC) 闪存以及四层单元(QLC)闪存，每个单元编码 3 位、4位。如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=small" data-sub-html="<h2>image-20240420214539405</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png" alt="image-20240420214539405" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/From_Bits_To_Banks_Example.png?size=large 2x" data-title="image-20240420214539405" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>总体而言，SLC芯片性能更高，但价格也更高。</p>
<h2 id="从bit到组平面" class="heading-element"><span>2 从bit到组/平面</span>
  <a href="#%e4%bb%8ebit%e5%88%b0%e7%bb%84%e5%b9%b3%e9%9d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如古希腊人所说，存储一个bit（或几个bit）并不能构成一个存储系统。因此，闪存芯片被组织成由大量单元组成的组或平面。</p>
<p>一个组以两种不同大小的单位进行访问：</p>
<ul>
<li><strong>块</strong>（有时称为<strong>擦除块</strong>），通常大小为 128 KB 或 256 KB；</li>
<li><strong>页</strong>，大小为几 KB（如 4KB）。</li>
</ul>
<p>每个存储组内有大量的块，每个块内又有大量的页。在考虑闪存时，你必须记住这个新术语，它不同于我们在磁盘和 RAID 中提到的块，也不同于我们在虚拟内存中提到的页。</p>
<p>下图显示了一个闪存平面的块和页的示例；在这个简单的示例中，有三个块，每个块包含四个页。我们将在下文中了解区分块和页的原因；事实证明，这种区分对于闪存操作（如读写）至关重要，对于设备的整体性能更是如此。你将了解到的最重要（也是最奇怪）的事情是，<font color="red">要写入块中的页面，首先必须擦除整个块</font>；这一棘手的细节使得构建基于闪存的固态硬盘成为一项有趣且值得挑战的任务，也是本章后半部分的主题。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=small" data-sub-html="<h2>image-20240420214355415</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks" alt="image-20240420214355415" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Simple_Flash_Chip_Pages_Within_Blocks?size=large 2x" data-title="image-20240420214355415" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="基本闪存操作" class="heading-element"><span>3 基本闪存操作</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e9%97%aa%e5%ad%98%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="读取擦除和编程" class="heading-element"><span>3.1 读取、擦除和编程</span>
  <a href="#%e8%af%bb%e5%8f%96%e6%93%a6%e9%99%a4%e5%92%8c%e7%bc%96%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>鉴于这种闪存组织结构，闪存芯片可支持三种低级操作。<font color="red">读取命令用于从闪存中读取一个页面；擦除和编程同时用于写入。</font>详情如下：</p>
<ul>
<li><strong>读取（一页）</strong>：闪存芯片的客户端只需向设备指定读取命令和相应的页码，即可读取任何页面（如 2KB 或 4KB）。这种操作通常相当快，10 微秒左右，与设备上的位置无关，（或多或少）也与上一次请求的位置无关（与磁盘完全不同），能够均匀快速地访问任何位置意味着该设备是随机存取设备。</li>
<li><strong>擦除（一个块）</strong>：在写入闪存中的页面之前，设备的特性要求首先擦除页面所在的整个块。重要的是，擦除会破坏块中的内容（通过将每个位设置为 1）；因此，在执行擦除之前，必须确保块中任何您需要的数据都已复制到其他地方（内存或其他闪存块）。擦除命令耗时较长，需要几毫秒才能完成。完成后，整个块将被重置，每一页都可以进行编程。</li>
<li><strong>编程（一页）</strong>：擦除块后，可使用编程命令将页面中的部分 1 变为 0，并将页面中的所需内容写入闪存。对页面进行编程的成本比擦除块低，但比读取页面的成本高，在现代闪存芯片上通常需要 100 微秒左右。</li>
</ul>
<p>对闪存芯片的一种理解是，每个页面都有一个与之相关的状态。<font color="red">页面开始时处于<code>INVALID</code>状态。通过擦除页面所在的块，可以将页面（以及该块中的所有页面）的状态设置为<code>ERASED</code>状态</font>，从而重置块中每个页面的内容，而且（重要的是）还可以对它们进行编程。当你对一个页面进行编程时，它的状态将变为 <code>VALID</code>，这意味着它的内容已被设置并可被读取。读取不会影响这些状态（尽管你只能读取已编程的页面）。一旦页面被编程，更改其内容的唯一方法就是擦除页面所在的整个块。下面是一个 4页块中各种擦除和编程操作后状态转换的示例：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=small" data-sub-html="<h2>image-20240420221943937</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png" alt="image-20240420221943937" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base_Flash_Operations_Example.png?size=large 2x" data-title="image-20240420221943937" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="详细示例" class="heading-element"><span>3.2 详细示例</span>
  <a href="#%e8%af%a6%e7%bb%86%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于写入过程（即擦除和编程）非常不寻常，让我们通过一个详细的示例来确保其合理性。在这个例子中，假设我们在一个 4 页的块中有以下 4 个 8 位页面（尺寸都很小，但在本例中很有用）；每个页面都是<code>VALID</code>，因为每个页面之前都被编程过。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=small" data-sub-html="<h2>image-20240420222159745</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png" alt="image-20240420222159745" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Example_1.png?size=large 2x" data-title="image-20240420222159745" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设我们希望写入第 0 页，并用新内容填充它。要写入任何页，我们必须首先擦除整个块。假设我们这样做了，从而使块处于这种状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=small" data-sub-html="<h2>image-20240420222254944</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png" alt="image-20240420222254944" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Erase.png?size=large 2x" data-title="image-20240420222254944" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在，我们可以继续对页面0进行编程，例如，用内容 <code>00000011</code> 来覆盖旧的第 0 页（内容 <code>00011000</code>）。这样，我们的程序块看起来就像这样了：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=small" data-sub-html="<h2>image-20240420222359099</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png" alt="image-20240420222359099" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Basic_Flash_Operation_Program.png?size=large 2x" data-title="image-20240420222359099" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在坏消息来了：第 1、2 和 3 页的内容已经全部丢失！因此，在覆盖块内的任何页面之前，我们必须先将我们关心的任何数据移动到其他位置（如内存或闪存上的其他位置）。擦除的性质将对我们如何设计基于闪存的固态硬盘产生重大影响，我们很快就会了解到这一点。</p>
<h3 id="总结" class="heading-element"><span>3.3 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>读取页面很简单：只需读取页面即可。闪存芯片在这方面做得很好，而且速度很快；就性能而言，它们有可能大大超过现代磁盘驱动器的随机读取性能，而现代磁盘驱动器由于机械寻道和旋转成本而速度较慢。</p>
<p>写入页面则比较麻烦；首先必须擦除整个块（注意先将我们关心的任何数据转移到另一个位置），然后对所需页面进行编程。这不仅成本高昂，而且频繁重复这种编程/擦除循环会导致闪存芯片最大的可靠性问题：<strong>磨损</strong>。<font color="red">在设计使用闪存的存储系统时，写入的性能和可靠性是重点</font>。我们很快就会了解到现代固态硬盘是如何解决这些问题的，尽管存在这些限制，但仍能提供出色的性能和可靠性。</p>
<h2 id="闪存性能和可靠性" class="heading-element"><span>4 闪存性能和可靠性</span>
  <a href="#%e9%97%aa%e5%ad%98%e6%80%a7%e8%83%bd%e5%92%8c%e5%8f%af%e9%9d%a0%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>因为我们有兴趣用原始闪存芯片构建存储设备，所以有必要了解它们的基本性能特征。下图粗略总结了 SLC、MLC 和 TLC 闪存（每个单元分别存储 1、2 和 3 位信息）的读取、编程和擦除的基本操作延迟。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=small" data-sub-html="<h2>image-20240420223008434</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png" alt="image-20240420223008434" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Raw_Flash_Performance_Characteristics.png?size=large 2x" data-title="image-20240420223008434" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从表中可以看出，读取延迟非常好，只需 10 微秒即可完成。编程延迟更高且变化更大，SLC 低至 200 微秒，但当每个单元中装入更多位时，程序延迟会更高；为了获得良好的写入性能，您必须并行使用多个闪存芯片。最后，擦除非常昂贵，通常需要几毫秒。处理这种成本是现代闪存设计的核心。</p>
<p>现在让我们考虑一下闪存芯片的可靠性。与机械磁盘不同，机械磁盘可能会因多种原因而发生故障（包括可怕的物理磁头碰撞，即驱动器磁头实际上与记录表面接触），闪存芯片是纯硅，从这个意义上讲，需要担心的可靠性问题较少，主要担心的是<strong>磨损</strong>：<font coor="red">当闪存块被擦除和编程时，它会慢慢产生一点额外的电荷。随着时间的推移，随着额外电荷的积累，区分 0 和 1 变得越来越困难。当变得不可能时，该块就变得无法使用。</font></p>
<p>目前，块的典型寿命尚不清楚。制造商将基于 MLC 的模块评价为具有 10,000 次 P/E（编程/擦除）循环寿命；也就是说，每个块在失败之前可以被擦除和编程 10,000 次。基于 SLC 的芯片由于每个晶体管仅存储一位，因此具有较长的使用寿命，通常为 100,000 个 P/E 周期。然而，最近的研究表明，寿命比预期的要长得多。</p>
<p>闪存芯片内的另一个可靠性问题被称为<strong>干扰</strong>。当访问闪存中的特定页面时，相邻页面中的某些位可能会被翻转；这种位翻转被称为<strong>读取干扰或编程干扰</strong>，具体取决于页面是被读取还是被编程。</p>
<blockquote>
<center>向后兼容性的重要性
</center>
<p>向后兼容性始终是分层系统中需要考虑的问题。通过定义两个系统之间的稳定接口，可以在接口的每一侧实现创新，同时确保持续的互操作性。这种方法在许多领域都非常成功：操作系统为应用程序提供相对稳定的 API，磁盘为文件系统提供相同的基于块的接口，IP 网络堆栈中的每一层都为上一层提供固定不变的接口。</p>
<p>毫不奇怪，这种刚性可能有一个缺点，因为在一代中定义的接口可能不适用于下一代。在某些情况下，考虑完全重新设计整个系统可能会很有用。 Sun ZFS 文件系统 就是一个很好的例子；通过重新考虑文件系统和 RAID 的交互，ZFS 的创建者设想（然后实现）了一个更有效的集成整体。</p>
</blockquote>
<h2 id="从原始闪存到基于闪存的-ssd" class="heading-element"><span>5 从原始闪存到基于闪存的 SSD</span>
  <a href="#%e4%bb%8e%e5%8e%9f%e5%a7%8b%e9%97%aa%e5%ad%98%e5%88%b0%e5%9f%ba%e4%ba%8e%e9%97%aa%e5%ad%98%e7%9a%84-ssd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>鉴于我们对闪存芯片的基本了解，我们现在面临下一个任务：如何将一组基本的闪存芯片变成看起来像典型存储设备的东西。标准存储接口是一种简单的基于块的接口，在给定块地址的情况下，可以读取或写入大小为 512 字节（或更大）的<strong>块（扇区）</strong>。<font color="red">基于闪存的 SSD 的任务是在其内部的原始闪存芯片之上提供标准块接口</font>。</p>
<p><font color="red">在内部，SSD 由一定数量的闪存芯片（用于持久存储）组成。 SSD 还包含一定量的易失性（即非持久性）内存（例如 SRAM）</font>，这样的内存对于数据的缓存和缓冲以及映射表很有用，我们将在下面了解。最后，SSD 包含协调设备操作的控制逻辑。简化框图如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=small" data-sub-html="<h2>image-20240420224040136</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png" alt="image-20240420224040136" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Flash_Based_SSD_Logical.png?size=large 2x" data-title="image-20240420224040136" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>该控制逻辑的基本功能之一是满足客户端的读写，根据需要将其转化为内部闪存操作。**闪存转换层（FTL）**正是提供了这种功能。 <font color="red">FTL 接受逻辑块（构成设备接口）上的读写请求，并将其转换为底层物理块和物理页（构成实际闪存设备）上的低级读取、擦除和编程命令。</font> FTL 应该以提供卓越的性能和高可靠性为目标来完成这项任务。</p>
<p>正如我们将看到的，卓越的性能可以通过技术的组合来实现。一个关键是<strong>并行</strong>利用多个闪存芯片；虽然我们不会进一步讨论这项技术，但可以说所有现代 SSD 都在内部使用多个芯片来获得更高的性能。另一个性能目标是<strong>减少写入放大</strong>，写入放大定义为 FTL 向闪存芯片发出的总写入流量（以字节为单位）除以客户端向 SSD 发出的总写入流量（以字节为单位）。正如我们将在下面看到的，简单的 FTL 构建方法将导致高写入放大和低性能。高可靠性将通过几种不同方法的组合来实现。如上所述，一个主要问题是磨损。如果单个块被频繁地擦除和编程，它将变得不可用；因此，FTL 应尝试尽可能均匀地跨闪存块分布写入，确保设备的所有块大致同时磨损；这样做称为<strong>磨损均衡</strong>，是任何现代 FTL 的重要组成部分。</p>
<p>另一个可靠性问题是编程干扰。为了最大限度地减少这种干扰，FTL 通常会按从低页到高页的顺序对擦除块内的页进行编程。这种顺序编程方法最大限度地减少了干扰并被广泛使用。</p>
<h2 id="ftl-组织结构" class="heading-element"><span>6 FTL 组织结构</span>
  <a href="#ftl-%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="直接映射" class="heading-element"><span>6.1 直接映射</span>
  <a href="#%e7%9b%b4%e6%8e%a5%e6%98%a0%e5%b0%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最简单的 FTL 组织结构我们称之为<strong>直接映射</strong>。在这种方法中，逻辑页 $N$ 的读取直接映射到物理页 $N$ 的读取。对逻辑页 N 的写入则更为复杂；FTL 首先要读入页面 $N$ 所在的整个块，然后擦除该块，最后对旧页面和新页面进行编程。</p>
<p>你可能已经猜到，直接映射 FTL 在性能和可靠性方面都存在很多问题。性能问题出现在每次写入时：设备必须读入整个数据块（成本高昂），擦除（成本相当高昂），然后编程（成本高昂）。最终结果是严重的写入放大（与块中的页数成正比），因此写入性能很差，甚至比典型硬盘的机械寻道和旋转延迟还要慢。</p>
<p>更糟糕的是这种方法的可靠性。如果文件系统元数据或用户文件数据被反复覆盖，同一数据块就会被一次又一次地擦除和编程，使其迅速损耗，并可能丢失数据。直接映射方法只是将磨损的控制权过多地交给了客户端工作负载；如果工作负载不能将写入负载均匀地分散到逻辑块中，那么包含常用数据的底层物理块就会很快磨损。出于可靠性和性能方面的考虑，直接映射 FTL 都不是一个好主意。</p>
<h3 id="日志结构的-ftl" class="heading-element"><span>6.2 日志结构的 FTL</span>
  <a href="#%e6%97%a5%e5%bf%97%e7%bb%93%e6%9e%84%e7%9a%84-ftl" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="基本原理" class="heading-element"><span>6.2.1 基本原理</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>由于这些原因，如今大多数 FTL 都是<strong>日志结构</strong>的，这一理念在存储设备（如我们现在看到的）和其上的文件系统（如我们将在<strong>日志结构文件系统</strong>一章中看到的）中都很有用。在写入逻辑块 $N$ 时，设备会将写入内容附加到当前正在写入的块中的下一个空闲位置；我们称这种写入方式为<strong>日志</strong>。为方便后续读取块 $N$，设备会保存一个<strong>映射表</strong>（在内存中，并以某种形式持久存在于设备上）；该表存储了系统中每个逻辑块的物理地址。</p>
<p>让我们举例说明基于日志的基本方法是如何工作的。对于客户端来说，设备看起来就像一个典型的磁盘，可以读写 512 字节的扇区（或扇区组）。为简单起见，假设客户端正在读取或写入 4KB 大小的块。让我们进一步假设SSD包含大量 16KB 大小的块，每个块分为 4 个 4KB 页面（但闪存块通常由更多页面组成）。</p>
<p>假设客户端发出以下操作序列：</p>
<ul>
<li>Write(100) with contents <code>a1</code></li>
<li>Write(101) with contents <code>a2</code></li>
<li>Write(2000) with contents <code>b1</code></li>
<li>Write(2001) with contents <code>b2</code></li>
</ul>
<p>SSD 客户端（如文件系统）使用这些<strong>逻辑块地址</strong>（如 100）来记忆信息的位置。</p>
<p>在内部，设备必须将这些块写入转化为原始硬件支持的擦除和编程操作，并以某种方式记录每个逻辑块地址在固态硬盘的哪个物理页面存储数据。假设固态硬盘的所有块目前都无效，因此必须先擦除这些块，然后才能对任何页面进行编程。这里显示的是固态硬盘的初始状态，所有页面都标记为<code>INVALID(i)</code>：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=small" data-sub-html="<h2>image-20240420225506248</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png" alt="image-20240420225506248" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Initial_State_Example.png?size=large 2x" data-title="image-20240420225506248" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当SSD收到第一个写入（逻辑块100）时，FTL决定将其写入物理块0，其中包含四个物理页：0、1、2和3。因为该块没有被擦除，所以我们还不能写入；设备必须首先向块 0 发出擦除命令。这样做会导致以下状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=small" data-sub-html="<h2>image-20240420225602726</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png" alt="image-20240420225602726" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_State_Example_1.png?size=large 2x" data-title="image-20240420225602726" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在可以对 0 块进行编程了。大多数固态硬盘会按顺序（即从低到高）写入页面，从而减少与<strong>程序干扰</strong>有关的可靠性问题。然后，固态硬盘将逻辑块 100 写入物理页 0：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=small" data-sub-html="<h2>image-20240420225654860</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png" alt="image-20240420225654860" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Example_1.png?size=large 2x" data-title="image-20240420225654860" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>但如果客户要读取逻辑块 100 呢？如何找到它的位置？SSD必须将对逻辑块 100 的读取转换为对物理页 0 的读取。为了适应这种功能，当 FTL 将逻辑块 100 写入物理页 0 时，它会在<strong>内存映射表</strong>中记录这一事实。我们还将在图表中跟踪该映射表的状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=small" data-sub-html="<h2>image-20240420225849479</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png" alt="image-20240420225849479" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example.png?size=large 2x" data-title="image-20240420225849479" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在您可以看到当客户端写入 SSD 时会发生什么。 SSD找到写入位置，通常只是选择下一个空闲页面；然后，它使用块的内容对该页进行编程，并将逻辑到物理的映射记录在其映射表中。后续读取只需使用该表将客户端提供的逻辑块地址<strong>转换</strong>为读取数据所需的物理页号。</p>
<p>现在让我们检查示例写入流中的其余写入：101、2000 和 2001。写入这些块后，设备的状态为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=small" data-sub-html="<h2>image-20240420230124321</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png" alt="image-20240420230124321" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Program_State_Trace_Example_2.png?size=large 2x" data-title="image-20240420230124321" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>基于日志的方法从本质上提高了性能（只需偶尔擦除一次，完全避免了直接映射方法中代价高昂的读取-修改-写入），并大大提高了可靠性。FTL 现在可以在所有页面上分散写入，执行所谓的<strong>磨损均衡</strong>，延长设备的使用寿命；我们将在下文进一步讨论损耗均衡。</p>
<blockquote>
<center>FTL 映射信息持久性
</center>
<p>您可能想知道：如果设备断电会发生什么？内存映射表消失了吗？显然，此类信息不会真正丢失，否则该设备将无法充当持久存储设备。 SSD 必须具有某种恢复映射信息的方法。</p>
<p>最简单的做法是在每个页面上记录一些映射信息，即所谓的<strong>带外 (OOB) 区域</strong>。当设备断电并重新启动时，它必须通过扫描 OOB 区域并重建内存中的映射表。这种基本方法也有其问题；扫描大型 SSD 来查找所有必要的映射信息的速度很慢。为了克服这个限制，一些高端设备使用更复杂的日志记录和检查点技术来加速恢复。</p>
</blockquote>
<p>不幸的是，这种基本的日志结构方法有一些缺点。</p>
<ul>
<li>第一个是逻辑块的覆盖会导致我们称之为<strong>垃圾</strong>的东西，即驱动器周围的旧版本数据并占用空间。设备必须定期执行**垃圾回收（GC）**以找到所述块和可用空间以供将来写入；过多的垃圾回收会增加写入放大并降低性能。</li>
<li>二是内存映射表成本高；设备越大，此类表需要的内存就越多。我们现在依次讨论每一个。</li>
</ul>
<h4 id="垃圾回收" class="heading-element"><span>6.2.2 垃圾回收</span>
  <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>任何日志结构方法（例如此方法）的第一个成本是创建垃圾，因此必须执行垃圾回收（即死块回收）。让我们用之前例子来理解这一点。回想一下，逻辑块 100、101、2000 和 2001 已写入设备。</p>
<p>现在，我们假设再次写入块 100 和 101，内容为 <code>c1</code> 和 <code>c2</code>。写入操作将写入下一个空闲页（在本例中为物理页 4 和 5），并且映射表也会相应更新。请注意，设备必须首先擦除块 1 才能进行此类编程：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=small" data-sub-html="<h2>image-20240421130023025</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png" alt="image-20240421130023025" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_Erase_And_Program_Example.png?size=large 2x" data-title="image-20240421130023025" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们现在遇到的问题应该很明显：物理页 0 和 1 虽然标记为 <code>VALID</code>，但其中有垃圾，即旧版本的块 100 和 101。由于设备的日志结构特性，覆盖会产生垃圾块，设备必须回收这些垃圾块，以便为新的写入提供可用空间。</p>
<p>查找垃圾块（也称为死块）并将其回收以备将来使用的过程称为<strong>垃圾回收</strong>，它是所有现代固态硬盘的重要组成部分。基本过程很简单：找到包含一个或多个垃圾页的块，读入该块中的活（非垃圾）页，将这些活页写入日志，最后回收整个块用于写入。</p>
<p>下面我们举例说明。设备决定要回收上述 0 号块中的所有死页。块 0 有两个死块（第 0 页和第 1 页）和两个活块（第 2 页和第 3 页，分别包含块 2000 和 2001）。为此，设备将：</p>
<ul>
<li>从块 0 读取有效数据（第 2 页和第 3 页）</li>
<li>将有效数据写入日志末尾</li>
<li>擦除块 0（将其释放供以后使用）</li>
</ul>
<p>为了让垃圾回收程序发挥作用，每个块内必须有足够的信息，以便固态硬盘确定每个页面是有效还是无效。实现这一目的的一种自然方法是在每个块内的某个位置存储有关每个页面内存储了哪些逻辑块的信息。然后，设备就可以使用映射表来确定块中的每个页面是否保存有效数据。</p>
<p>在我们上面的示例中（垃圾回收之前），块 0 包含逻辑块 100、101、2000 和 2001。通过检查映射表（在垃圾收集之前，映射表包含 <code>100-&gt;4</code>、<code>101-&gt;5</code>、<code>2000-&gt;2</code>、<code>2001-&gt;3</code>），设备可以轻松确定固态硬盘块内的每个页面是否包含有效信息。例如，2000 和 2001 显然仍由映射指向；而 100 和 101 则不是，因此是垃圾回收的候选对象。在我们的示例中，当垃圾回收过程完成后，设备的状态为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=small" data-sub-html="<h2>image-20240421132028102</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png" alt="image-20240421132028102" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SSD_After_Garbage_Collection.png?size=large 2x" data-title="image-20240421132028102" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>可以看出，垃圾回收的成本很高，需要读取和重写有效数据。最理想的回收对象是只包含死页的块；在这种情况下，数据块可以立即被擦除并用于新数据，而无需进行昂贵的数据迁移。</p>
<p>为了降低 GC 成本，一些固态硬盘对设备进行了超额配置；通过增加额外的闪存容量，可以延迟清理并将其推至后台，或许可以在设备不太忙的时候进行。增加容量还能增加内部带宽，可用于清理，从而不影响客户端的感知带宽。许多现代硬盘都以这种方式进行超额配置，这是实现出色整体性能的关键之一。</p>
<blockquote>
<center>一种称为 TRIM 的新存储 API
</center>
<p>当我们想到硬盘驱动器时，我们通常只想到最基本的读写接口：读和写（通常还有某种<strong>缓存刷新</strong>命令，确保写入实际上已被持久化，但为了简单起见，有时我们会忽略这一点）。对于日志结构的 SSD，以及任何保持逻辑到物理块的灵活且不断变化的映射的设备，一个新的接口非常有用，称为<strong>修剪</strong>操作。</p>
<p>修剪操作采用一个地址（可能还有一个长度），并简单地通知设备该地址（和长度）指定的块已被删除；因此，设备不再需要跟踪有关给定地址范围的任何信息。<font color="red">对于标准硬盘驱动器，修剪并不是特别有用，因为驱动器具有块地址到特定盘片、磁道和扇区的静态映射。</font></p>
<p>然而，对于日志结构的 SSD，知道不再需要某个块非常有用，因为 SSD 可以从 FTL 中删除此信息，并在垃圾回收期间回收物理空间。</p>
<p>尽管我们有时将接口和实现视为独立的实体，但在这种情况下，我们看到实现塑造了接口。通过复杂的映射，了解不再需要哪些块可以更有效的实现。</p>
</blockquote>
<h4 id="映射表大小" class="heading-element"><span>6.2.3 映射表大小</span>
  <a href="#%e6%98%a0%e5%b0%84%e8%a1%a8%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>日志结构的第二个成本是可能会产生非常大的映射表，设备的每个 4 KB 页都有一个条目。例如，对于大型 1 TB SSD，每 4 KB 页一个 4 字节条目会导致设备需要 1 GB 内存，仅用于这些映射！因此，这种页级 FTL 方案是不切实际的。</p>
<h5 id="基于块的映射" class="heading-element"><span>6.2.3.1 基于块的映射</span>
  <a href="#%e5%9f%ba%e4%ba%8e%e5%9d%97%e7%9a%84%e6%98%a0%e5%b0%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>降低映射成本的一种方法是只为设备的每个块而不是每个页保留一个指针，从而将映射信息量减少 $\frac{Size_{block}}{ Size_{page}}$ 倍。<font color="red">这种<strong>块级 FTL</strong> 类似于在虚拟内存系统中具有更大的页面大小；在这种情况下，您可以为 VPN 使用更少的位，并在每个虚拟地址中使用更大的偏移量。</font></p>
<p>不幸的是，由于性能原因，在基于日志的 FTL 中使用基于块的映射效果不佳。当发生“小写入”（即小于物理块大小的写入）时，就会出现最大的问题。在这种情况下，FTL 必须从旧块中读取大量有效数据并将其复制到新块中（以及来自小写入的数据）。这种数据复制极大地增加了写放大，从而降低了性能。</p>
<p>为了更清楚地说明这个问题，我们来看一个例子。假设客户端之前写出了逻辑块 2000、2001、2002 和 2003（内容为 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>），并且它们位于物理块 1 内的物理页 4、5、6 和 7。对于每页映射，转换表必须记录这些逻辑块的四个映射：2000→4、2001→5、2002→6、2003→7。</p>
<p>相反，如果我们使用块级映射，FTL 只需要记录所有这些数据的单个地址转换。然而，地址映射与我们之前的示例略有不同。具体来说，我们认为设备的逻辑地址空间被分割成闪存中物理块大小的块。因此，<font color="red">逻辑块地址由两部分组成：块号和偏移量</font>。因为我们假设每个物理块中有四个逻辑块，所以逻辑地址的偏移部分需要 2 位；其余（最高有效）位形成块号。</p>
<p>逻辑块2000、2001、2002和2003都具有相同的块编号(500)，并且具有不同的偏移量(分别为0、1、2和3)。因此，通过块级映射，FTL 记录块 500 映射到块 1（从物理页 4 开始），如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=small" data-sub-html="<h2>image-20240421185518878</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png" alt="image-20240421185518878" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Based_On_Map_Example_1.png?size=large 2x" data-title="image-20240421185518878" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在基于块的 FTL 中，读取数据非常简单。首先，FTL 会从客户端提供的逻辑块地址中提取块号，方法是从地址的最高位取出。然后，FTL 在表中查找块号到物理页的映射。最后，FTL 将逻辑地址的偏移量与块的物理地址相加，计算出所需闪存页的地址。</p>
<p>例如，如果客户端发出对逻辑地址 2002 的读取，设备会提取逻辑块编号 (500)，在映射表中查找转换（查找 4），并将逻辑地址 (2) 的偏移量加到转换结果中 (4)，由此得到的物理页地址（6）就是数据所在的位置；然后，FTL 就可以向该物理地址发出读取指令，获取所需的数据（<code>c</code>）。</p>
<p>但如果客户向逻辑块 2002（内容为 <code>c'</code>）写入数据呢？在这种情况下，FTL 必须读入 2000、2001 和 2003，然后在新的位置写出所有四个逻辑块，并相应地更新映射表。如下图所示，逻辑块 1（数据原来所在的位置）可以被擦除并重新使用。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=small" data-sub-html="<h2>image-20240421190033073</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png" alt="image-20240421190033073" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Based_Mapping_Write_Example.png?size=large 2x" data-title="image-20240421190033073" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从这个例子中可以看出，虽然块级映射大大减少了转换所需的内存量，但当写入的内容小于设备的物理块大小时，就会造成严重的性能问题；由于实际物理块可能是 256KB 或更大，这种写入可能会经常发生。因此，我们需要一个更好的解决方案。</p>
<h5 id="混合映射" class="heading-element"><span>6.2.3.2 混合映射</span>
  <a href="#%e6%b7%b7%e5%90%88%e6%98%a0%e5%b0%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>为了实现灵活的写入并降低映射成本，许多现代 FTL 采用混合映射技术。通过这种方法，FTL 会保留一些已擦除的块并将所有写入定向到它们；这些称为<strong>日志块</strong>。由于 FTL 希望能够将任何页写入日志块内的任何位置，而无需进行纯基于块的映射所需的所有复制，因此它会保留这些日志块的每页映射。</p>
<p>因此，FTL 在其内存中逻辑上有两种类型的映射表：我们称之为日志表的一小组每页映射，以及数据表中的一大组每块映射。当寻找特定的逻辑块时，FTL首先会查阅日志表；如果在那里找不到逻辑块的位置，FTL 将查阅数据表以找到其位置，然后访问所请求的数据。</p>
<p>混合映射策略的关键是保持较小的日志块数量。为了保持日志块的数量较少，FTL 必须定期检查日志块（每页都有一个指针）并将它们切换为只能由单个块指针指向的块。该切换是根据块的内容通过三种主要技术之一来完成的。</p>
<p>例如，假设 FTL 之前已写出逻辑页 1000、1001、1002 和 1003，并将它们放置在物理块 2 中（物理页 8、9、10、11）；假设写入1000、1001、1002和1003的内容分别为<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=small" data-sub-html="<h2>image-20240421192827944</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png" alt="image-20240421192827944" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Hybird_Mapping_Example_1.png?size=large 2x" data-title="image-20240421192827944" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设客户机以完全相同的顺序，在当前可用的日志块之一（例如物理块 0（物理页 0、1、2 和 3））中覆盖这些块（数据 <code>a'</code>、<code>b'</code>、<code>c'</code> 和 <code>d'</code>）。在这种情况下，FTL 将处于以下状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=small" data-sub-html="<h2>image-20240421192951355</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png" alt="image-20240421192951355" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Example.png?size=large 2x" data-title="image-20240421192951355" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>因为这些块的写入方式与以前完全相同，所以 FTL 可以执行所谓的切换合并。在这种情况下，日志块（0）现在成为块0、1、2和3的存储位置，并由单个块指针指向；旧块 (2) 现在已被擦除并用作日志块。在这种最佳情况下，所需的所有每页指针都被单个块指针替换。</p>
<p>这种切换合并是混合FTL的最佳情况。遗憾的是，有时 FTL 并不那么幸运。试想一下，我们有相同的初始条件（逻辑块 1000 &hellip; 1003 存储在物理块 2 中），但客户端覆盖了逻辑块 1000 和 1001。您认为在这种情况下会发生什么？为什么处理起来更具挑战性？</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=small" data-sub-html="<h2>image-20240421193357635</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png" alt="image-20240421193357635" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FTL_Hybird_Mapping_Write_Partial_Example.png?size=large 2x" data-title="image-20240421193357635" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了重新组合该物理块的其他页面，从而能够仅通过单个块指针引用它们，FTL 执行所谓的<strong>部分合并</strong>。在此操作中，从物理块2读取逻辑块1002和1003，然后将其附加到日志中。 SSD的结果状态与上面的切换合并相同；然而，在这种情况下，FTL 必须执行额外的 I/O 才能实现其目标，从而增加了写放大。</p>
<p>FTL 遇到的最后一种情况称为<strong>完全合并</strong>，需要更多的工作。在这种情况下，FTL 必须将许多其他块中的页面汇集在一起以执行清理。例如，假设逻辑块 0、4、8 和 12 写入日志块 A。要将此日志块切换为块映射页，FTL 必须首先创建包含逻辑块 0、1、2 的数据块、 和 3，因此 FTL 必须从其他地方读取 1、2 和 3，然后一起写出 0、1、2 和 3。接下来，合并必须对逻辑块 4 执行相同的操作，找到 5、6 和 7 并将它们协调为单个物理块。必须对逻辑块 8 和 12 执行相同的操作，然后（最后）可以释放日志块 A。毫不奇怪，频繁的完全合并会严重损害性能，因此应尽可能避免。</p>
<h5 id="页面映射加缓存" class="heading-element"><span>6.2.3.3 页面映射加缓存</span>
  <a href="#%e9%a1%b5%e9%9d%a2%e6%98%a0%e5%b0%84%e5%8a%a0%e7%bc%93%e5%ad%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>鉴于上述混合方法的复杂性，其他人提出了更简单的方法来减少页面映射 FTL 的内存负载。最简单的方法可能是只在内存中缓存 FTL 的活动部分，从而减少所需的内存量。</p>
<p>这种方法效果不错。例如，如果给定的工作负载只访问一小部分页面，那么这些页面的转换就会存储在内存中的 FTL 中，这样性能就会非常出色，而不会产生高昂的内存成本。当然，这种方法也可能表现不佳。<font color="red">如果内存中无法包含必要的转换工作集，那么每次访问都需要额外读取闪存，以便在访问数据本身之前首先调入缺失的映射。</font>更糟糕的是，为了给新映射腾出空间，FTL 可能不得不剔除旧映射，如果该映射是脏映射（即尚未持续写入闪存），还将产生额外的写入。不过，在很多情况下，工作负载会显示出本地性，这种缓存方法既能减少内存开销，又能保持较高的性能。</p>
<h2 id="磨损均衡" class="heading-element"><span>7 磨损均衡</span>
  <a href="#%e7%a3%a8%e6%8d%9f%e5%9d%87%e8%a1%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后，现代 FTL 必须实现的一项相关背景活动是<strong>磨损均衡</strong>，如上所述。基本思想很简单：因为多个擦除/编程周期会磨损闪存块，所以 FTL 应尽力将工作均匀地分布到设备的所有块上。通过这种方式，所有块将大致在同一时间磨损，而不是一些“常用”块很快变得无法使用。</p>
<p>基本的日志结构方法在分散写入负载方面做得很好，垃圾回收也有帮助。然而，有时一个块会填充长期存在的数据，这些数据不会被覆盖；在这种情况下，垃圾回收永远不会回收该块，因此它不会收到其公平份额的写入负载。</p>
<p>为了解决这个问题，FTL 必须定期从这些块中读取所有有效数据，并将其重新写入其他地方，从而使该块可再次写入。这种磨损均衡过程会增加 SSD 的写入放大，从而降低性能，因为需要额外的 I/O 来确保所有块以大致相同的速率磨损。</p>
<h2 id="ssd性能与成本" class="heading-element"><span>8 SSD性能与成本</span>
  <a href="#ssd%e6%80%a7%e8%83%bd%e4%b8%8e%e6%88%90%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="性能" class="heading-element"><span>8.1 性能</span>
  <a href="#%e6%80%a7%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>与硬盘驱动器不同，基于闪存的 SSD 没有机械组件，实际上在很多方面与 DRAM 更相似，因为它们是“随机访问”设备。与磁盘驱动器相比，最大的性能差异是在执行随机读取和写入时实现的；虽然典型的磁盘驱动器每秒只能执行几百次随机 I/O，但 SSD 可以做得更好。在这里，我们使用现代 SSD 的一些数据来看看 SSD 的性能到底有多好；我们特别感兴趣的是 FTL 如何很好地隐藏原始芯片的性能问题。</p>
<p>下表显示了三种不同 SSD 和一种顶级硬盘的一些性能数据。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=small" data-sub-html="<h2>image-20240421194457078</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png" alt="image-20240421194457078" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240421194457078.png?size=large 2x" data-title="image-20240421194457078" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>左边两列显示随机 I/O 性能，右边两列显示顺序I/O性能；前三行显示三种不同 SSD（来自Samsung、Seagate和Intel）的数据，最后一行显示硬盘驱动器（或 HDD）的性能，在本例中为Seagate高端驱动器。</p>
<p>我们可以从表中了解到一些有趣的事实。</p>
<ul>
<li>首先，也是最引人注目的，是 SSD 和独立硬盘之间随机 I/O 性能的差异。虽然 SSD 在随机 I/O 中获得数十甚至数百 MB/秒，但这种“高性能”硬盘的峰值仅为几 MB/秒（事实上，我们四舍五入为 2 MB/秒） 。</li>
<li>其次，您可以看到，就顺序I/O性能而言，差异要小得多；虽然 SSD 的性能更好，但如果您只需要顺序I/O性能，硬盘驱动器仍然是一个不错的选择。第三，可以看到SSD随机读性能不如SSD随机写性能。随机写入性能如此出人意料的好，得益于很多SSD的日志结构设计，将随机写入转化为顺序写入，提高了性能。</li>
<li>最后，由于 SSD 在顺序 I/O 和随机 I/O 之间表现出一些性能差异，因此如何为硬盘驱动器构建文件系统的许多技术仍然适用于 SSD；尽管顺序 I/O 和随机 I/O 之间的差异幅度较小，但仍有足够的差距需要仔细考虑如何设计文件系统以减少随机 I/O。</li>
</ul>
<h3 id="成本" class="heading-element"><span>8.2 成本</span>
  <a href="#%e6%88%90%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>正如我们在上面看到的，即使在执行顺序 I/O 时，SSD 的性能也大大超过了现代硬盘驱动器。那么，为什么 SSD 没有完全取代硬盘作为存储介质的选择呢？答案很简单：<strong>成本</strong>，或更具体地说，是<strong>每单位容量的成本</strong>。目前，250 GB 驱动器的 SSD 成本约为 150 美元；这样的 SSD 每 GB 成本为 60 美分。传统的硬盘驱动器存储 1 TB 的成本约为 50 美元，这意味着每 GB 成本为 5 美分。这两种存储介质的成本仍然存在10倍以上的差异。</p>
<p><font color="red">这些性能和成本差异决定了如何构建大规模存储系统。</font>如果性能是主要考虑因素，那么 SSD 是一个很好的选择，特别是在随机读取性能很重要的情况下。另一方面，如果您正在组装一个大型数据中心并希望存储大量信息，那么巨大的成本差异将促使您转向HDD。当然，混合方法是有意义的——一些存储系统同时配备了 SSD 和HDD，<font color="red">使用较少数量的 SSD 来存储更常用的“热”数据并提供高性能，同时存储其余的“冷”数据（较少使用）硬盘上的数据以节省成本。只要价格差距存在，硬盘就会一直存在。</font></p>
<h2 id="总结-1" class="heading-element"><span>9 总结</span>
  <a href="#%e6%80%bb%e7%bb%93-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><strong>闪存芯片</strong>由许多存储体组成，每个存储体都组织成<strong>擦除块</strong>（有时简称为块）。每个块进一步细分为一定数量的<strong>页面</strong>。</li>
<li>块很大（128KB–2MB）并包含许多页，而页相对较小（1KB–8KB）。</li>
<li>要从闪存读取，请发出<strong>带有地址和长度的读取命令</strong>；这允许客户读取一页或多页。</li>
<li>写入闪存更为复杂。首先，客户端必须擦除整个块（这会删除块内的所有信息）。然后，客户端可以对每个页面精确地<strong>编程</strong>一次，从而完成写入。</li>
<li>新的<strong>修剪</strong>操作可用于告诉设备何时不再需要特定块（或块范围）。</li>
<li>闪存可靠性主要由<strong>磨损</strong>决定；如果一个块被频繁地擦除和编程，它将变得不可用。</li>
<li>基于闪存的<strong>固态存储设备</strong>（SSD）的行为就像普通的基于块的读/写磁盘一样。通过使用<strong>闪存转换层</strong> (FTL)，它将客户端的读取和写入转换为对底层闪存芯片的读取、擦除和编程。</li>
<li>大多数FTL 都是<strong>日志结构</strong>的，这通过最小化擦除/编程周期来降低写入成本。内存中的转换层跟踪逻辑写入在物理介质中的位置。</li>
<li>日志结构FTL 的一个关键问题是垃圾回收的成本，这会导致写入放大。</li>
<li>另一个问题是映射表的大小，它可能会变得非常大。<font color="red">使用<strong>混合映射</strong>或仅缓存 FTL 的热门部分是可能的补救措施。</font></li>
<li>最后一个问题是<strong>磨损均衡</strong>。 FTL 必须偶尔从主要读取的块中迁移数据，以确保所述块也接收其擦除/编程负载份额。</li>
</ul>
]]></description></item><item><title>日志结构文件系统</title><link>https://hezephyr.github.io/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:33:51 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>20 世纪 90 年代初，伯克利分校的一个由 John Ousterhout 教授和研究生 Mendel Rosenblum 领导的小组开发了一种新的文件系统，称为<font color="red">日志结构文件系统</font>。他们这样做的动机基于以下观察：</p>
<ul>
<li><strong>系统内存不断增长</strong>：随着内存变大，内存中可以缓存更多数据。随着越来越多的数据被缓存，磁盘流量越来越多地由写入组成，因为读取由缓存提供服务。因此，文件系统的性能很大程度上取决于其写入性能。</li>
<li><strong>随机I/O 性能和顺序I/O 性能之间存在很大差距</strong>：多年来硬盘传输带宽大幅增加；随着更多的位被封装到驱动器的表面，访问所述位时的带宽增加。然而，寻道和旋转延迟成本却缓慢下降；让廉价的小型电机更快地旋转盘片或更快地移动磁盘臂是一项挑战。因此，如果您能够以顺序方式使用磁盘，那么与导致寻道和旋转的方法相比，您将获得相当大的性能优势。</li>
<li><strong>现有文件系统在许多常见工作负载上表现不佳</strong>：例如，FFS将执行大量写入来创建一个大小为一个块的新文件：一个用于新的inode，一个用于更新inode位图，一个用于包含该文件的目录数据块，一个用于更新目录inode，一个用于作为新文件一部分的新数据块，并且还需要对数据位图进行一次写入以标记数据块已被分配。因此，尽管 FFS 将所有这些块放置在同一块组内，但 FFS 需要进行许多短寻道和随后的旋转延迟，因此性能远低于峰值顺序带宽。</li>
<li><strong>文件系统不支持RAID</strong>：例如，RAID-4 和RAID-5 都存在<strong>小写入问题</strong>，即对单个块的逻辑写入会导致发生4 个物理I/O。现有文件系统不会尝试避免这种最坏情况的 RAID 写入行为。</li>
</ul>
<p>因此，理想的文件系统将关注写入性能，并尝试利用磁盘的顺序带宽。此外，它在常见工作负载上表现良好，这些工作负载不仅写出数据，而且还经常更新磁盘上的元数据结构。最后，它在 RAID 和单个磁盘上都能很好地工作。 Rosenblum 和 Ousterhout 推出的新型文件系统称为 <strong>LFS</strong>，是<strong>日志结构文件系统</strong>的缩写。当写入磁盘时，LFS 首先将所有更新（包括元数据！）缓冲在内存段中；当该段已满时，它会通过一次长的、顺序的传输写入未使用的磁盘部分。 LFS 永远不会覆盖现有数据，而是始终将段写入空闲位置。由于段很大，因此磁盘（或 RAID）可以得到有效利用，文件系统的性能也接近顶峰。</p>
<blockquote>
<center>关键：如何使所有写入顺序写入？
</center>
<p>文件系统如何将所有写入转换为顺序写入？对于读取，此任务是不可能的，因为要读取的所需块可能位于磁盘上的任何位置。然而，对于写入，文件系统总是有一个选择，而我们希望利用的正是这个选择。</p>
</blockquote>
<h2 id="按顺序写入磁盘" class="heading-element"><span>2 按顺序写入磁盘</span>
  <a href="#%e6%8c%89%e9%a1%ba%e5%ba%8f%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>因此，我们面临的第一个挑战是：<font color="red">如何将文件系统状态的所有更新转化为一系列对磁盘的顺序写入？</font>为了更好地理解这一点，让我们举一个简单的例子。假设我们正在向文件写入一个数据块 D。将数据块写入磁盘可能会导致以下磁盘布局，D 被写入磁盘地址 A0：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=small" data-sub-html="<h2>image-20240420101924372</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png" alt="image-20240420101924372" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_A0.png?size=large 2x" data-title="image-20240420101924372" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>然而，当用户写入数据块时，写入磁盘的不仅是数据，还有其他需要更新的元数据。在这种情况下，我们也把文件的 inode (I) 写入磁盘，并让它指向数据块 D。写入磁盘后，数据块和 inode 的如下图所示（<strong>注意</strong>，inode 看起来和数据块一样大，但一般情况下并非如此；在大多数系统中，数据块的大小为 4 KB，而 inode 则小得多，约为 128 字节）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=small" data-sub-html="<h2>image-20240420102116005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png" alt="image-20240420102116005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/write_D_To_Disk_Metadata.png?size=large 2x" data-title="image-20240420102116005" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这种简单地将所有更新（如数据块、inodes 等）按顺序写入磁盘的基本思想是 LFS 的核心。理解了这一点，你就掌握了基本思想。但正如所有复杂的系统一样，细节决定成败。</p>
<h2 id="顺序有效地写入" class="heading-element"><span>3 顺序有效地写入</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e6%9c%89%e6%95%88%e5%9c%b0%e5%86%99%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>不幸的是，顺序写入磁盘（单独）不足以保证高效写入。例如，想象一下，如果我们在时间 $T$ 向地址 $A$ 写入一个块。然后我们等待一会儿，并在时间 $T + \delta$ 的地址 $A + 1$（按顺序排列的下一个块地址）写入磁盘。不幸的是，在第一次和第二次写入之间，磁盘发生了旋转；当您发出第二次写入时，它将在提交之前等待大部分旋转（具体来说，如果旋转需要时间 $T_{rotation}$，则磁盘将等待 $T_{rotation}-\delta$，然后才能将第二次写入提交到磁盘表面）。因此，您可以看到，仅仅按顺序写入磁盘不足以实现峰值性能；相反，您必须向驱动器<font color="red">发出大量连续写入（或一次大型写入）才能获得良好的写入性能</font>。</p>
<p>为了实现这一目标，LFS 使用一种称为<strong>写入缓冲</strong>的古老技术。在写入磁盘之前，LFS 会跟踪内存中的更新；当它收到足够数量的更新时，它会立即将它们全部写入磁盘，从而确保磁盘的有效使用。</p>
<p>LFS 一次写入的大块更新被称为一个段。尽管这个术语在计算机系统中被滥用，但在这里它只是指 LFS 用来分组写入的一个相对较大的块。因此，当写入磁盘时，LFS 将更新缓冲在内存中的段中，然后将该段全部写入磁盘。只要段足够大，这些写入就会高效。</p>
<p>下面是一个示例，其中 LFS 将两组更新缓冲到一个小段中；实际的段更大（几MB）。第一个更新是对文件 <code>j</code> 的四个块写入；第二个是向文件 <code>k</code> 添加一个块。然后，LFS 将七个块的整个段一次性提交到磁盘。这些块的最终磁盘布局如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=small" data-sub-html="<h2>image-20240420103434967</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png" alt="image-20240420103434967" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Data_To_Disk_Efficient.png?size=large 2x" data-title="image-20240420103434967" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="缓冲多大" class="heading-element"><span>4 缓冲多大</span>
  <a href="#%e7%bc%93%e5%86%b2%e5%a4%9a%e5%a4%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>这就提出了以下问题：在写入磁盘之前，LFS 应该缓冲多少个更新？当然，答案取决于磁盘本身，特别是定位开销与传输速率相比有多高。</p>
<p>例如，假设每次写入之前的定位（即旋转和寻道开销）大约需要 $T_{position}$秒。进一步假设磁盘传输速率为$R_{peak}\text{ MB/s}$。在这样的磁盘上运行时，LFS 在写入之前应该缓冲多少？</p>
<p>思考这个问题的方法是，每次写入时，您都会付出固定的定位成本开销。因此，您需要写多少才能摊销该成本？你写的越多越好（显然），并且你越接近达到峰值带宽。</p>
<p>为了获得具体的答案，我们假设我们正在写 $D\text{ MB}$。写这块数据的时间（$T_{write}$）是定位时间$T_{position}$加上传输时间$\frac{D}{R_{peak}}$，或者：
$$
T_{write}=T_{position}+\frac{D}{R_{peak}}
$$
因此，有效写入率（$R_{effective}$）就是写入的数据量除以写入的总时间：
$$
R_{effective}=\frac{D}{T_{write}}=\frac{D}{T_{position}+\frac{D}{R_{peak}}}
$$
我们感兴趣的是让有效率 ($R_{effective}$) 接近峰值率。具体来说，我们希望有效速率是峰值速率的某个分数 $F$，其中 $0 &lt; F &lt; 1$（典型的 F 可能是 $0.9$，或峰值速率的 $90%$）。在数学形式上，这意味着我们需要$R_{effective}=F\times R_{peak}$ 。</p>
<p>至此，我们可以求解$D$：
$$
R_{effective}=\frac{D}{T_{write}}=\frac{D}{T_{position}+\frac{D}{R_{peak}}}
$$</p>
<p>$$
D=F\times R_{peak}\times(T_{position}+\frac{D}{R_{peak}})
$$</p>
<p>$$
D=(F\times R_{peak}\times T_{position})+(F\times R_{peak}\times \frac{D}{R_{peak}})
$$</p>
<p>$$
D=\frac{F}{1-F}\times R_{peak}\times T_{position}
$$</p>
<p>举个例子，磁盘的定位时间为$10\text{ ms}$，峰值传输率为$100\text{ MB/s}$；假设我们想要峰值的 $90%$ 的有效带宽 ($F = 0.9$)。在本例中，$D = \frac{0.9}{0.1}\times 100\text{ MB/s} \times 0.01 \text{ s} = 9\text{ MB}$。尝试一些不同的值，看看我们需要缓冲多少才能接近峰值带宽。需要多少才能达到峰值的 $95%$？ $99%$？</p>
<h2 id="问题查找-inode" class="heading-element"><span>5 问题：查找 Inode</span>
  <a href="#%e9%97%ae%e9%a2%98%e6%9f%a5%e6%89%be-inode" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了了解如何在 LFS 中查找 inode，让我们简要回顾一下如何在典型的 UNIX 文件系统中查找 inode。在典型的文件系统（例如 FFS）甚至旧的 UNIX 文件系统中，查找 inode 很容易，因为它们被组织在数组中并放置在磁盘上的固定位置。</p>
<p>例如，旧的 UNIX 文件系统将所有inode保存在磁盘的固定部分。因此，给定 inode number和起始地址，要查找特定 inode，只需将 inode number乘以 inode 的大小，然后将其添加到磁盘阵列的起始地址，即可计算出其准确的磁盘地址。 基于数组的索引（给定 inode number）既快速又简单。</p>
<p>在 FFS 中查找给定 inode number的 inode 只是稍微复杂一些，因为 FFS 将 inode 表分割成块，并将一组 inode 放置在每个柱面组中。因此，我们必须知道每个inode块有多大以及每个inode的起始地址。之后的计算类似，也很容易。</p>
<p>在LFS，生活更加困难。为什么？好吧，我们已经成功地将inode分散在整个磁盘上！更糟糕的是，我们永远不会就地覆盖，因此最新版本的索引节点（即我们想要的）不断移动。</p>
<h2 id="通过间接解决方案inode-map" class="heading-element"><span>6 通过间接解决方案：Inode Map</span>
  <a href="#%e9%80%9a%e8%bf%87%e9%97%b4%e6%8e%a5%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88inode-map" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了解决这个问题，LFS 的设计者通过一个名为 inode map（imap）的数据结构，在 inode number和 inode 之间引入了一层间接关系。imap 是一种将 inode number作为输入并生成该 inode 最新版本磁盘地址的结构。因此，可以想象它通常是作为一个简单的数组来实现的，每个条目有 4 个字节（磁盘指针）。当 inode 被写入磁盘时，imap 就会根据新的位置进行更新。</p>
<p>不幸的是，imap 需要保持持久性（即写入磁盘），这样做可以让 LFS 在崩溃时跟踪 inode 的位置，从而按预期运行。因此，有一个问题：imap 应该放在磁盘的哪个位置？</p>
<p>当然，它可以位于磁盘的固定位置。遗憾的是，由于它经常更新，这就需要在更新文件结构后再写入 imap，因此性能会受到影响（也就是说，<font color="red">在每次更新和 imap 的固定位置之间会有更多的磁盘寻道</font>）。</p>
<p>相反，LFS 会在写入所有其他新信息的位置旁边放置 inode 映射块。因此，在向文件 <code>k</code> 添加数据块时，LFS 实际上是将新数据块、其 inode 和 inode 映射的一部分一起写入磁盘，如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=small" data-sub-html="<h2>image-20240420111904512</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png" alt="image-20240420111904512" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Map_Example_1.png?size=large 2x" data-title="image-20240420111904512" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在这张图中，<font color="red">存储在标记为 imap 的块中的 imap 数组的一块告诉 LFS inode k 位于磁盘地址 A1；这个 inode 又告诉 LFS 它的数据块 D 位于地址 A0</font>。</p>
<h2 id="完成解决方案检查点区域" class="heading-element"><span>7 完成解决方案：检查点区域</span>
  <a href="#%e5%ae%8c%e6%88%90%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%a3%80%e6%9f%a5%e7%82%b9%e5%8c%ba%e5%9f%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="如何找到inode-map" class="heading-element"><span>7.1 如何找到inode map</span>
  <a href="#%e5%a6%82%e4%bd%95%e6%89%be%e5%88%b0inode-map" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>你可能已经注意到这里的问题了。既然inode map的各个部分也分布在磁盘上，我们如何找到inode map呢？归根结底，没有什么神奇的：文件系统必须在磁盘上有一些固定且已知的位置才能开始文件查找。</p>
<p>LFS 在磁盘上为此提供了一个固定位置，称为<font color="red">检查点区域 (CR)</font>。检查点区域包含指向最新的 inode map片段的指针（即地址），因此可以通过首先读取 CR 来找到 inode map片段。请注意，检查点区域仅定期更新（例如每 30 秒左右），因此性能不会受到不良影响。因此，磁盘布局的整体结构包含一个检查点区域（指向 inode map的最新部分）；每个 inode 映射片段都包含 inode 的地址； inode 指向文件（和目录），就像典型的 UNIX 文件系统一样。</p>
<p>下面是检查点区域（注意它位于磁盘的起始位置，地址为 0）以及单个 imap 块、inode 和数据块的示例。一个真正的文件系统当然会有一个大得多的 CR（事实上，它会有两个，我们稍后会了解到）、许多 imap 块，当然还有更多的 inode、数据块等。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=small" data-sub-html="<h2>image-20240420132426842</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png" alt="image-20240420132426842" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CR_Example_1.png?size=large 2x" data-title="image-20240420132426842" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="从磁盘读取文件" class="heading-element"><span>7.2 从磁盘读取文件</span>
  <a href="#%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了确保你理解 LFS 的工作原理，现在让我们来了解一下从磁盘读取文件的过程。假设内存中什么都没有。我们必须读取的第一个磁盘数据结构是检查点区域。检查点区域包含指向整个 inode map的指针（即磁盘地址），因此 LFS 会读入整个 inode map并缓存在内存中。在此之后，当得到文件的 inode number时，LFS 只需在 imap 中查找 inode number到 inode磁盘地址的映射，然后读入最新版本的 inode。</p>
<p>此时，LFS 会根据需要使用直接指针、间接指针或双向间接指针，完全按照典型 UNIX 文件系统的方式读取文件块。在普通情况下，<strong>LFS 从磁盘读取文件时执行的 I/O 次数应与典型文件系统相同</strong>；整个 imap 已被缓存，因此 LFS 在读取过程中所做的额外工作就是在 imap 中查找 inode 的地址。</p>
<h3 id="关于目录" class="heading-element"><span>7.3 关于目录</span>
  <a href="#%e5%85%b3%e4%ba%8e%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>到目前为止，我们已经通过仅考虑inode和数据块来简化了我们的讨论。但是，要访问文件系统中的文件（例如 <code>/home/zfhe/foo</code>），还必须访问某些目录。那么LFS是如何存储目录数据的呢？</p>
<p>幸运的是，目录结构与经典 UNIX 文件系统基本相同，因为目录只是（名称、inode number）映射的集合。例如，当在磁盘上创建文件时，LFS 必须写入新的 inode、一些数据以及引用该文件的目录数据及其 inode。请记住，LFS 将在磁盘上按顺序执行此操作（在缓冲更新一段时间后）。因此，在目录中创建文件<code>foo</code> 将导致磁盘上出现以下新结构：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=small" data-sub-html="<h2>image-20240420133133412</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png" alt="image-20240420133133412" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directories_Example_LFS_1.png?size=large 2x" data-title="image-20240420133133412" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>inode map的片段包含目录文件 <code>dir</code> 以及新创建的文件 <code>f</code> 的位置信息。因此，当访问文件 <code>foo</code> （inode number为 $k$）时，您首先会在inode map（通常缓存在内存中）中查找目录 <code>dir</code> ($A3$) 的inode的位置；然后读取目录 inode，它给出目录数据的位置 ($A2$)；读取此数据块即可获得 <code>(foo, k)</code> 的名称到 inode number的映射。然后再次查阅inode map，找到inode number k（$A1$）的位置，最后在地址$A0$处读取所需的数据块。</p>
<p>LFS 中 inode 映射还解决了另一个严重问题，称为<font color="red">递归更新问题</font>。任何从不就地更新（例如 LFS），而是将更新移动到磁盘上的新位置的文件系统都会出现此问题。</p>
<p>具体来说，每当更新inode时，它在磁盘上的位置就会发生变化。如果我们不小心的话，这也会导致指向该文件的目录的更新，然后会强制要求更改该目录的父目录，依此类推，一直沿着文件系统树向上更新。</p>
<p>LFS通过inode map巧妙地避免了这个问题。尽管inode的位置可能会发生变化，但这种变化永远不会反映在目录本身中；相反，当目录保存相同的名称到inode number映射时，imap 结构会被更新。因此，通过间接，LFS 避免了递归更新问题。</p>
<h2 id="新问题垃圾回收" class="heading-element"><span>8 新问题：垃圾回收</span>
  <a href="#%e6%96%b0%e9%97%ae%e9%a2%98%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>8.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>您可能已经注意到 LFS 的另一个问题；它将文件的最新版本（包括其inode和数据）重复写入磁盘上的新位置。此过程在保持写入效率的同时，意味着 LFS 会将旧版本的文件结构分散在整个磁盘上。我们称这些旧版本为垃圾。例如，假设我们有一个由inode number $k$ 引用的现有文件，它指向单个数据块 $D0$。我们现在更新该块，生成新的inode和新的数据块。 LFS 的最终磁盘布局看起来像这样（注意，为了简单起见，我们省略了 imap 和其他结构；新的 imap 块也必须写入磁盘以指向新的 inode）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=small" data-sub-html="<h2>image-20240420150442686</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png" alt="image-20240420150442686" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/LFS_Write_Have_Garbage.png?size=large 2x" data-title="image-20240420150442686" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，您可以看到磁盘上的inode和数据块都有两个版本，一个是旧版本（左侧），另一个是当前的、即时的版本（右侧）。通过（逻辑上）更新数据块这一简单行为，LFS 必须持久化大量新结构，从而在磁盘上留下旧版本的数据块。</p>
<p>举个例子，想象我们将一个块附加到原始文件 <code>k</code> 上。在这种情况下，会生成新版本的 inode，但旧数据块仍由 inode 指向。因此它仍然是有效的，并且完全属于当前文件系统：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=small" data-sub-html="<h2>image-20240420150821548</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png" alt="image-20240420150821548" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/New_Append_In_LFS_Example.png?size=large 2x" data-title="image-20240420150821548" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>那么我们应该如何处理这些旧版本的inode、数据块等呢？可以保留这些旧版本并允许用户恢复旧文件版本（例如，当他们不小心覆盖或删除文件时，这样做可能非常方便）；这种文件系统称为<strong>版本控制文件系统</strong>，因为它跟踪文件的不同版本。</p>
<p>然而，LFS 仅保留文件的最新实时版本；因此（在后台），LFS 必须定期查找文件数据、inode和其他结构的这些旧的无效版本，并清理它们；因此，清理应该使磁盘上的块再次空闲以供后续写入使用。请注意，清理过程是垃圾回收的一种形式，这是编程语言中出现的一种技术，可以自动释放程序未使用的内存。</p>
<p>前面我们讨论了段的重要性，因为它们是在 LFS 中实现对磁盘进行大量写入的机制。事实证明，它们对于有效清理也是不可或缺的。想象一下，如果 LFS 清理器在清理过程中简单地遍历并释放单个数据块、inode等，会发生什么。结果：文件系统在磁盘上分配的空间之间混合了一定数量的空闲孔。写入性能将大幅下降，因为 LFS 无法找到大的连续区域来顺序且高性能地写入磁盘。</p>
<p>相反，LFS 清理器逐段工作，从而为后续写入清理大块空间。基本清理过程如下。 LFS 清理器定期读取一些旧的（部分使用的）段，确定这些段中哪些块是有效的，然后写出一组新的段，其中仅包含有效的块，从而释放旧的段以供写入。具体来说，我们期望清理程序读取 $M$ 个现有段，将其内容压缩为 $N$ 个新段（其中 $N &lt; M$ ），然后将 $N$ 个段写入磁盘的新位置。然后，旧的 $M$ 段将被释放，可供文件系统用于后续写入。</p>
<p>然而，我们现在面临两个问题。</p>
<ul>
<li>第一个是<strong>机制</strong>：LFS 如何判断段内哪些块是有效块，哪些块是无效块？</li>
<li>第二个是<strong>策略</strong>：清理程序应该多久运行一次，以及应该选择清理哪些部分？</li>
</ul>
<h3 id="确定块有效性" class="heading-element"><span>8.2 确定块有效性</span>
  <a href="#%e7%a1%ae%e5%ae%9a%e5%9d%97%e6%9c%89%e6%95%88%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们首先解决机制问题。给定磁盘段 $S$ 内的数据块 $D$，LFS 必须能够确定 $D$ 是否处于有效状态。为此，LFS 向描述每个块的每个段添加了一些额外信息。具体来说，LFS包括每个数据块$D$包括它的inode number（它属于哪个文件）和它的偏移量（它是文件的哪个块）。该信息记录在段头部的结构中，称为<font color="red">段摘要块</font>。</p>
<p>有了这些信息，就可以很容易地确定一个块是有效的还是无效的。对于位于磁盘上地址 $A$ 的块 $D$，查看段摘要块并找到其inode number $N$ 和偏移量 $T$ 。接下来，在 imap 中查找 $N$ 所在的位置并从磁盘读取 $N$（也许它已经在内存中，这样更好）。最后，使用偏移量 $T$ ，查看 inode（或某个间接块）以查看 inode 认为该文件的第 $T$ 个块位于磁盘上的位置。如果它准确地指向磁盘地址A，LFS可以断定块D是有效的。如果它指向其他地方，LFS 可以断定 D 没有在使用中（即它已失效），从而知道不再需要该版本。这是伪代码摘要：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">=</span> <span class="n">SegmentSummary</span><span class="p">[</span><span class="n">A</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">inode</span> <span class="o">=</span> <span class="nf">Read</span><span class="p">(</span><span class="n">imap</span><span class="p">[</span><span class="n">N</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// block D is alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="c1">// block D is garbage
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>下面是描述该机制的图，其中段摘要块（标记为 $SS$）记录了地址 $A0$ 处的数据块实际上是文件 <code>k</code> 偏移量 0 处的一部分。通过检查 <code>k</code> 的 imap，可以找到 inode，并看到它确实指向该位置。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=small" data-sub-html="<h2>image-20240420153237660</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png" alt="image-20240420153237660" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Mechanism_Find_Active_Block.png?size=large 2x" data-title="image-20240420153237660" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>LFS 会采取一些快捷方式来提高确定有效性过程的效率。例如，当文件被截断或删除时，LFS 会增加其版本号，并在 imap 中记录新的版本号。通过在磁盘段中记录版本号，LFS 只需将磁盘上的版本号与 imap 中的版本号进行比较，就能缩短上述较长时间的检查，从而避免额外的读取。</p>
<h3 id="策略问题清理哪些块以及何时清理" class="heading-element"><span>8.3 策略问题：清理哪些块以及何时清理</span>
  <a href="#%e7%ad%96%e7%95%a5%e9%97%ae%e9%a2%98%e6%b8%85%e7%90%86%e5%93%aa%e4%ba%9b%e5%9d%97%e4%bb%a5%e5%8f%8a%e4%bd%95%e6%97%b6%e6%b8%85%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除上述机制外，LFS 还必须包含一套策略，<font color="red">以确定何时清理以及哪些块值得清理；确定何时清理比较简单：定期、空闲时或磁盘已满而不得不清理时。</font></p>
<p>而确定清理哪些块则更具挑战性，这也是许多研究论文的主题。在最初的 <a href="https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf"target="_blank" rel="external nofollow noopener noreferrer">LFS 论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>中，作者描述了一种试图分离热段和冷段的方法。热段是指内容经常被覆盖的段，因此，对于这样的段，最好的策略是等待很长时间再进行清理，因为越来越多的数据块被覆盖（在新的段中），从而被释放出来以供使用。</p>
<p>相比之下，冷段可能会有一些无效块，但其余内容相对稳定。因此，作者得出结论，应该尽早清理冷段，晚些清理热段，并开发了一种启发式方法来实现这一目标。然而，与大多数策略一样，这种策略并不完美；<a href="https://dl.acm.org/doi/10.1145/268998.266700"target="_blank" rel="external nofollow noopener noreferrer">后来的方法<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>展示了如何做得更好。</p>
<h2 id="崩溃恢复和日志" class="heading-element"><span>9 崩溃恢复和日志</span>
  <a href="#%e5%b4%a9%e6%ba%83%e6%81%a2%e5%a4%8d%e5%92%8c%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>最后一个问题：如果 LFS 写入磁盘时系统崩溃，会发生什么？更新期间的崩溃对于文件系统来说是很棘手的，因此 LFS 也必须考虑这一点。</p>
<p><font color="red">在正常操作期间，LFS 缓冲段中的写入，然后（当段已满或经过一定时间时）将该段写入磁盘。 LFS 将这些写入组织在日志中，即检查点区域指向头段和尾段，每个段都指向下一个要写入的段。</font> LFS 还定期更新检查点区域。在这些操作（写入段、写入 CR）期间显然可能会发生崩溃。那么 LFS 如何处理写入这些结构期间的崩溃呢？</p>
<p>我们先来说第二种情况。为了确保 CR 更新以原子方式发生，LFS 实际上<strong>保留了两个 CR</strong>，分别位于磁盘的两端，并交替写入。 LFS 在使用指向 inode map的最新指针和其他信息更新 CR 时还实现了谨慎的协议；具体来说，它首先写出一个标头（带有时间戳），然后写出 CR 的主题，最后写出最后一个块（也带有时间戳）。如果系统在 CR 更新期间崩溃，LFS 可以通过查看一对不一致的时间戳来检测到这一情况。 LFS总是会选择使用最新的具有一致时间戳的CR，从而实现CR的一致更新。</p>
<p>现在我们来解决第一种情况。由于 LFS 大约每 30 秒写入一次 CR，因此文件系统的最后一个一致快照可能相当旧。因此，重新启动后，LFS 可以通过简单地读取检查点区域、它指向的 imap 片段以及后续文件和目录来轻松恢复；但是，最后几秒的更新将会丢失。</p>
<p>为了改进这一点，LFS 尝试通过数据库社区中称为<strong>前滚</strong>的技术来重建许多这些段。基本思想是从最后一个检查点区域开始，找到日志的末尾（包含在 CR 中），然后使用它来读取接下来的段并查看其中是否有任何有效的更新。如果有，LFS 会相应地更新文件系统，从而恢复自上一个检查点以来写入的大部分数据和元数据。</p>
]]></description></item><item><title>FSCK和日志</title><link>https://hezephyr.github.io/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/</link><pubDate>Sat, 11 May 2024 21:32:57 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/</guid><description><![CDATA[<h2 id="崩溃一致性" class="heading-element"><span>1 崩溃一致性</span>
  <a href="#%e5%b4%a9%e6%ba%83%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如我们到目前为止所看到的，文件系统管理一组数据结构来实现预期的抽象：文件、目录以及支持我们期望从文件系统获得的基本抽象所需的所有其他元数据。与大多数数据结构（例如，在正在运行的程序的内存中找到的数据结构）不同，文件系统数据结构必须持久存在，即它们必须长期存在，存储在即使断电也能保留数据的设备上（例如硬盘或基于闪存的 SSD）。</p>
<p>文件系统面临的一项主要挑战是如何在断电或系统崩溃的情况下更新持久数据结构。具体来说，如果在更新磁盘结构的过程中，有人被电源线绊倒并且机器断电，会发生什么情况？或者操作系统遇到bug而崩溃？由于断电和崩溃，更新持久数据结构可能非常棘手，并导致文件系统实现中出现一个新的有趣问题，称为<font color="red">崩溃一致性问题</font>。</p>
<p>这个问题很容易理解。想象一下，您必须更新两个磁盘上的结构 A 和 B，才能完成特定操作。由于磁盘一次仅服务一个请求，因此这些请求之一将首先到达磁盘（A 或 B）。如果系统在一次写入完成后崩溃或断电，磁盘上的结构将处于不一致的状态。因此，我们有一个所有文件系统都需要解决的关键问题：</p>
<blockquote>
<p>如何在崩溃的情况下更新磁盘？系统可能会崩溃或在任意两次写入之间断电，因此磁盘上的状态可能只会部分更新。崩溃后，系统启动并希望再次挂载文件系统（以便访问文件等）。鉴于崩溃可能在任意时间点发生，我们如何确保文件系统将磁盘映像保持在合理的状态？</p>
</blockquote>
<p>在本章中，我们将更详细地描述这个问题，并了解文件系统用来克服它的一些方法。我们将首先检查旧文件系统所采用的方法，称为 <strong>fsck</strong> 或<strong>文件系统检查器</strong>。然后，我们将注意力转向另一种方法，称为<strong>日志记录（也称为预写日志记录）</strong>，这种技术会为每次写入增加一点开销，但可以更快地从崩溃或断电中恢复。我们将讨论日志记录的基本机制，包括 Linux ext3（一种相对现代的日志文件系统）实现的几种不同风格的日志记录。</p>
<h2 id="详细示例" class="heading-element"><span>2 详细示例</span>
  <a href="#%e8%af%a6%e7%bb%86%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>2.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了开始我们对日志的研究，让我们来看一个例子。我们需要使用以某种方式更新磁盘结构的<strong>工作负载</strong>。假设工作负载很简单：向现有文件追加一个数据块。追加的方法是打开文件，调用 <code>lseek()</code> 将文件偏移量移动到文件末尾，然后在关闭文件之前向文件写入一个 4KB 的数据块。</p>
<p>我们还假设磁盘上使用的是标准的简单文件系统结构，类似于我们以前见过的文件系统。这个小例子包括一个 <strong>inode 位图</strong>（只有 8 位，每个 inode 一个）、一个<strong>数据位图</strong>（也是 8 位，每个数据块一个）、inodes（共 8 个，编号 0 至 7，分布在 4 个块中）和数据块（共 8 个，编号 0 至 7）。下面是该文件系统的示意图：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=small" data-sub-html="<h2>image-20240419123958722</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png" alt="image-20240419123958722" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_5.png?size=large 2x" data-title="image-20240419123958722" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>观察图片中的结构，可以看到一个已分配的 inode（inode number 2）和一个已分配的数据块（数据块 4），前者已在 inode 位图中标记，后者也在数据位图中标记。该 inode 被标记为 I[v1]，因为它是该 inode 的第一个版本；它将很快被更新（由于上述工作负载）。让我们也来看看这个简化的 inode 内部。在 I[v1] 中，我们可以看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">owner 		: remzi
</span></span><span class="line"><span class="cl">permissions : read-write
</span></span><span class="line"><span class="cl">size 		: 1
</span></span><span class="line"><span class="cl">pointer 	: 4
</span></span><span class="line"><span class="cl">pointer 	: null
</span></span><span class="line"><span class="cl">pointer 	: null
</span></span><span class="line"><span class="cl">pointer 	: null</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个简化的 inode 中，文件的<code>size</code>为 1（分配了一个块），第一个直接指针指向块 4（文件的第一个数据块 Da），所有其他三个直接指针都设置为 <code>null</code> （表明它们没有被使用）。当然，真正的inode还有更多的字段。</p>
<p>当我们追加到文件时，我们向其中添加一个新的数据块，因此必须更新三个磁盘结构：inode（必须指向新块并记录由于追加而产生的新的较大大小）、新的数据块Db，以及新版本的数据位图（称为B[v2]）来指示新的数据块已经被分配。</p>
<p>因此，在系统内存中，我们必须将三个块写入磁盘。更新后的索引节点（inode版本 2，简称 I[v2]）现在如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=small" data-sub-html="<h2>image-20240419124623098</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png" alt="image-20240419124623098" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_6.png?size=large 2x" data-title="image-20240419124623098" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为实现这一转换，文件系统必须向磁盘执行三次单独的写入操作，分别写入 inode (I[v2])、bitmap (B[v2]) 和数据块 (Db)。请注意，这些写入通常不会在用户发出 <code>write()</code> 系统调用时立即发生；相反，<font color="red">脏的 inode、位图和新数据会先在主内存（页面缓存或缓冲区缓存）中停留一段时间；然后，当文件系统最终决定将它们写入磁盘时（比如 5 秒或 30 秒后），文件系统会向磁盘发出必要的写入请求。</font></p>
<p>不幸的是，崩溃可能会发生，从而干扰对磁盘的更新。特别是，如果在写入其中一个或两个而不是全部三个之后发生崩溃，文件系统可能会处于一种奇怪的状态。</p>
<h3 id="崩溃场景" class="heading-element"><span>2.2 崩溃场景</span>
  <a href="#%e5%b4%a9%e6%ba%83%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了更好地理解这个问题，让我们看一些崩溃场景的例子。想象一下只有一次写入成功；因此存在三种可能的结果，我们在此列出：</p>
<ul>
<li>
<p><strong>仅将数据块 (Db) 写入磁盘。</strong></p>
<p>在这种情况下，数据就在磁盘上，但没有指向它的 inode，也没有位图显示该数据块已分配。因此，写入就好像从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题。</p>
</li>
<li>
<p><strong>只有更新的 inode（I[v2]）被写入磁盘。</strong></p>
<p>在这种情况下，inode 指向 Db 即将被写入的磁盘地址 (5)，但 Db 尚未被写入。因此，如果我们相信该指针，就会从磁盘读取<strong>垃圾数据</strong>（磁盘地址 5 的旧内容）。</p>
<p>此外，我们还遇到了一个新问题，我们称之<strong>为文件系统不一致</strong>。磁盘位图告诉我们，数据块 5 尚未分配，但 inode 却说它已经分配。位图和 inode 之间的不一致是文件系统数据结构的不一致；要使用文件系统，我们必须以某种方式解决这个问题。</p>
</li>
<li>
<p><strong>只有更新后的位图（B[v2]）被写入磁盘。</strong></p>
<p>在这种情况下，位图显示块 5 已分配，但却没有指向它的 inode。因此，文件系统再次出现不一致；如果不加以解决，这次写入将导致<strong>空间泄漏</strong>，因为文件系统永远不会使用块 5。</p>
</li>
</ul>
<p>在尝试向磁盘写入三个数据块的过程中，还有三种崩溃情况。在这些情况中，两次写入成功，最后一次写入失败：</p>
<ul>
<li>
<p><strong>inode (I[v2]) 和 bitmap (B[v2]) 被写入磁盘，但数据 (Db) 未被写入。</strong></p>
<p>在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图显示 5 正在使用中，因此从文件系统元数据的角度看一切正常。但有一个问题：5 中又出现了垃圾。</p>
</li>
<li>
<p><strong>写入了 inode (I[v2]) 和数据块 (Db)，但没有写入位图 (B[v2])</strong>。在这种情况下，我们的 inode 指向了磁盘上的正确数据，但 inode 和旧版本的位图 (B1) 之间再次出现不一致。因此，我们再次需要在使用文件系统前解决这个问题。</p>
</li>
<li>
<p><strong>位图 (B[v2]) 和数据块 (Db) 被写入，但 inode (I[v2]) 却没有被写入</strong>。在这种情况下，我们又遇到了 inode 和数据位图不一致的问题。然而，尽管块已被写入，位图也显示了它的使用情况，我们却不知道它属于哪个文件，因为没有 inode 指向该文件。</p>
</li>
</ul>
<h3 id="崩溃一致性问题" class="heading-element"><span>2.3 崩溃一致性问题</span>
  <a href="#%e5%b4%a9%e6%ba%83%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>希望从这些崩溃场景中，你能看到磁盘上的文件系统映像因崩溃而可能出现的诸多问题：文件系统数据结构不一致；空间泄漏；向用户返回垃圾数据等等。理想情况下，<font color="red">我们希望将文件系统从一种一致的状态（例如，在文件被附加之前）原子地移动到另一种一致的状态（例如，在将 inode、位图和新数据块写入磁盘之后）。</font>遗憾的是，我们无法轻易做到这一点，因为磁盘每次只提交一次写入，而在这些更新之间可能会发生崩溃或断电。我们将这一普遍问题称为崩溃一致性问题（也可称为一致性更新问题）。</p>
<h2 id="解决方案1文件系统检查器" class="heading-element"><span>3 解决方案#1：文件系统检查器</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%881%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%a3%80%e6%9f%a5%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>早期的文件系统采用一种简单的方法来解决崩溃一致性问题。基本上，它们决定任由不一致性发生，然后稍后（重启时）再修复它们。<code>fsck</code>就是这种懒惰方法的典型例子，它是一种 UNIX 工具，用于查找和修复此类不一致性；不同系统上也有类似的工具用于检查和修复磁盘分区。需要注意的是，这种方法并不能解决所有问题；例如，考虑上述文件系统看起来一致，但 inode 指向垃圾数据的情况。唯一真正的目标是确保文件系统元数据的内部一致性。</p>
<p>正如 McKusick 和 Kowalski 的<a href="https://www.usenix.org/conference/fast13/technical-sessions/presentation/ma"target="_blank" rel="external nofollow noopener noreferrer">论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>所总结的，<code>fsck</code> 工具的运行分为几个阶段。它在文件系统挂载和可用之前运行（<code>fsck</code> 假设运行时没有其他文件系统活动）；一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。以下是 <code>fsck</code> 工作的基本概要：</p>
<ul>
<li><strong>超级块</strong>：<code>fsck</code> 首先检查超级块看起来是否合理，主要是进行健全性检查，如确保文件系统大小大于已分配的块数。这些健全性检查的目的通常是发现可疑（损坏）的超级块；在这种情况下，系统（或管理员）可能会决定使用超级块的替代副本。</li>
<li><strong>空闲块</strong>：接下来，<code>fsck</code> 会扫描 inodes、间接块、双间接块等，以了解文件系统中当前分配的块。它利用这些知识生成正确版本的分配位图；因此，如果位图和 inodes 之间有任何不一致，可以通过信任 inodes 中的信息来解决。对所有 inodes 执行相同类型的检查，确保所有看起来正在使用的 inodes 都在 inode 位图中标记为正在使用。</li>
<li><strong>Inode状态</strong>：检查每个 inode 是否损坏或存在其他问题。例如，<code>fsck</code> 会确保每个已分配的 inode 都有一个有效的类型字段（如常规文件、目录、符号链接等）。如果 inode 字段存在不易修复的问题，该 inode 就会被视为可疑，并被 <code>fsck</code> 清除；inode 位图也会相应更新。</li>
<li><strong>Inode 链接</strong>：<code>fsck</code> 还会验证每个已分配 inode 的链接计数。链接计数表示包含对该特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，<code>fsck</code> 会从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录建立自己的链接计数。如果新计算的链接数与某个 inode 中的链接数不匹配，就必须采取纠正措施，通常是修复 inode 中的链接数。<font color="red">如果发现一个已分配的 inode，但没有目录指向它，它就会被移到<code>lost+found</code>目录&lt;/。</li>
<li><strong>重复</strong>：<code>fsck</code> 还会检查重复指针，即两个不同的 inode 指向同一块的情况。如果其中一个 inode 明显有问题，可能会被清除。或者，可以复制指向的块，从而根据需要给每个 inode 提供自己的副本。</li>
<li><strong>坏块</strong>：在扫描所有指针列表时，还会对坏块指针进行检查。如果一个指针明显指向超出其有效范围的内容，例如，它的地址指向的块大于分区大小，那么这个指针就被认为是 &ldquo;坏的&rdquo;。在这种情况下，<code>fsck</code> 不会做任何太聪明的事情；它只是从 inode 或间接块中删除（清除）指针。</li>
<li><strong>目录检查</strong>：<code>fsck</code> 无法理解用户文件的内容；但目录中包含文件系统本身创建的特定格式化信息。因此，<code>fsck</code> 会对每个目录的内容执行额外的完整性检查，确保&quot;. &ldquo;和&rdquo;.. &ldquo;是第一个条目，目录条目中引用的每个 inode 都已分配，并确保在整个层次结构中，没有任何目录被链接超过一次。</li>
</ul>
<p>如你所见，构建一个有效的 <code>fsck</code> 需要复杂的文件系统知识；要确保这样一段代码在所有情况下都能正确运行，是一项挑战。然而，<code>fsck</code>（以及类似方法）还有一个更大、也许更根本的问题：它们太慢了。在磁盘容量非常大的情况下，扫描整个磁盘以找到所有已分配块并读取整个目录树可能需要数分钟或数小时。随着磁盘容量的增加和 RAID 的普及，fsck 的性能变得令人望而却步。</p>
<p>从更高层次来看，<code>fsck</code> 的基本前提似乎有点不合理。想想我们上面的例子，只有三个数据块被写入磁盘；要扫描整个磁盘来修复在更新三个数据块时出现的问题，成本高得惊人。这种情况就好比你把钥匙掉在卧室的地板上，然后开始搜索整个房子的钥匙恢复算法，从地下室开始，逐个房间搜索。这样做虽然有效，但会造成浪费。因此，随着磁盘（和 RAID）的发展，研究人员和从业人员开始寻找其他解决方案。</p>
<h2 id="解决方案2日志或预写日志" class="heading-element"><span>4 解决方案#2：日志（或预写日志）</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%882%e6%97%a5%e5%bf%97%e6%88%96%e9%a2%84%e5%86%99%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>4.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>解决一致性更新问题的最流行的解决方案可能是从数据库管理系统领域窃取的一个想法。这种被称为<strong>预写日志</strong>的想法正是为了解决此类问题而发明的。在文件系统中，由于历史原因，我们通常将其称为<strong>预写日志记录</strong>。第一个做到这一点的文件系统是 Cedar，尽管许多现代文件系统都使用这个想法，包括 Linux ext3 和 ext4、reiserfs、IBM 的 JFS、SGI 的 XFS 和 Windows NTFS。</p>
<p>基本思路如下：更新磁盘时，在覆盖现有的结构之前，首先写下一个小注释（磁盘上其他某个众所周知的位置）描述您将要执行的操作。写这个注释是“预写”部分，我们将其写入我们组织为“<strong>日志</strong>”的结构中；因此，预写日志记录。</p>
<p>通过将注释写入磁盘，您可以保证如果在更新（覆盖）正在更新的结构期间发生崩溃，您可以返回并查看您所做的注释并重试；因此，您将确切地知道崩溃后要修复什么（以及如何修复），而不必扫描整个磁盘。根据设计，日志记录会在更新期间增加一些工作量，从而大大减少恢复期间所需的工作量。</p>
<p>现在我们将描述 <strong>Linux ext3</strong>（一种流行的日志文件系统）如何将日志合并到文件系统中。大多数磁盘结构与 <strong>Linux ext2</strong> 相同，例如，磁盘分为块组，每个块组包含 inode 位图、数据位图、inode 和数据块。新的关键结构是日志本身，它占用分区内或其他设备上的一些少量空间。因此，ext2 文件系统（没有日志）如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=small" data-sub-html="<h2>image-20240419132816961</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png" alt="image-20240419132816961" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext2_File_System_Structure_Example.png?size=large 2x" data-title="image-20240419132816961" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>假设日志放置在同一个文件系统映像中（尽管有时它放置在单独的设备上，或者作为文件系统中的文件），带有日志的 ext3 文件系统如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=small" data-sub-html="<h2>image-20240419132922656</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png" alt="image-20240419132922656" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Ext3_File_System_Structure_Example.png?size=large 2x" data-title="image-20240419132922656" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>真正的区别只是日志的存在，当然还有它的使用方式。</p>
<h3 id="数据日志" class="heading-element"><span>4.2 数据日志</span>
  <a href="#%e6%95%b0%e6%8d%ae%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>让我们看一个简单的例子来了解数据日志的工作原理。数据日志是 Linux ext3 文件系统的一种模式，本文的大部分讨论都是基于这种模式。</p>
<p>假设我们再次进行典型更新，希望将 inode (I[v2])、位图 (B[v2]) 和数据块 (Db) 再次写入磁盘。在将它们写入最终磁盘位置之前，我们首先要将它们写入日志（又称日记）。这就是日志中的内容：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=small" data-sub-html="<h2>image-20240419151824715</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png" alt="image-20240419151824715" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_1.png?size=large 2x" data-title="image-20240419151824715" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>可以看到，我们在这里写入了 5 个块。事务开始（TxB）告诉我们这次更新的信息，包括文件系统待更新的信息（例如，块 I[v2]、B[v2]和 Db 的最终地址），以及某种<strong>事务标识符（TID）</strong>。中间三个块只包含块本身的确切内容；这被称为<strong>物理日志</strong>，因为我们将更新的确切物理内容写入日志（另一种想法是<strong>逻辑日志</strong>，将更新的逻辑表述更紧凑地写入日志，例如 &ldquo;此更新希望将数据块 Db 附加到文件 X&rdquo;，这有点复杂，但可以节省日志空间，也许还能提高性能）。最后一个数据块（TxE）<strong>是该事务结束的标记</strong>，也包含 TID。</p>
<p>一旦事务安全地存储在磁盘上，我们就可以覆盖文件系统中的旧结构；这个过程称为<strong>检查点</strong>。因此，为了对文件系统进行检查点（即使其与日志中的待定更新保持同步），我们按照上述方式将I[v2]、B[v2] 和 Db 写入到它们的磁盘位置；如果这些写入成功完成，我们就对文件系统进行了检查点，基本上就完成了。因此，我们的初始操作序列为：</p>
<ol>
<li><strong>写日志</strong>：将事务写入日志，包括事务开始块、所有待处理的数据和元数据更新以及事务结束块；等待这些写入完成。</li>
<li><strong>检查点</strong>：将待处理的元数据和数据更新写入文件系统中的最终位置。</li>
</ol>
<p>在我们的示例中，我们首先将 TxB、I[v2]、B[v2]、Db 和 TxE 写入日志。当这些写入完成后，我们将通过检查点 I[v2]、B[v2] 和 Db 到它们在磁盘上的最终位置来完成更新。</p>
<p>当写入日志期间发生崩溃时，事情会变得有点棘手。在这里，我们尝试将事务中的一组块（例如，TxB、I[v2]、B[v2]、Db、TxE）写入磁盘。一种简单的方法是一次发出每一个，等待每一个完成，然后发出下一个。然而，这很慢。理想情况下，我们希望一次发出所有五个块写入，因为这会将五个写入转换为单个顺序写入，从而速度更快。然而，这是不安全的，原因如下：给定如此大的写入，磁盘内部可能会执行调度并以任何顺序完成大写入的小片段。因此，磁盘内部可以 (1) 写入 TxB、I[v2]、B[v2] 和 TxE，并且仅在稍后 (2) 写入 Db。不幸的是，如果磁盘在 (1) 和 (2) 之间断电，磁盘上的结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=small" data-sub-html="<h2>image-20240419195529232</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png" alt="image-20240419195529232" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_2.png?size=large 2x" data-title="image-20240419195529232" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<center>强制写入磁盘
</center>
<p>现代文件系统在强制两次磁盘写入之间保持顺序时需要额外的预防措施。过去，简单地等待第一次写入完成再进行第二次写入就足够了。然而，由于写入缓存的使用增加，这种方法不再有效。启用写入缓存后，磁盘可能会在将数据放置在内存缓存中后通知操作系统写入已完成，而不是立即将数据写入磁盘。这使得无法保证先前的写入在后续写入之前到达磁盘。</p>
<p>为了解决这个问题，一种解决方案是禁用写缓存，但这会影响性能。另一种现代方法是明确发出写屏障，确保在屏障之前发出的所有写入在屏障之后发出的任何写入之前到达磁盘。然而，最近的研究表明，一些磁盘制造商为了提高性能，可能会忽略写屏障请求，这可能导致错误操作。</p>
</blockquote>
<p>为什么会有这个问题？这个事务看起来是一个有效的事务（它有一个开始和结束，序列号匹配）。此外，文件系统无法查看第四个数据块并知道它是错误的；毕竟，它是任意的用户数据。因此，如果系统现在重启并运行恢复，它就会重放此事务，并无知地将垃圾数据块&rdquo;?? &ldquo;的内容复制到 Db 应该存放的位置。这对文件中的任意用户数据来说是很糟糕的；如果发生在文件系统的关键部分，如超级块上，情况就更糟了，可能导致文件系统无法挂载。</p>
<blockquote>
<center>优化日志写入
</center>
<p>文件系统首先要写出事务开始块和事务内容；只有在这些写入完成后，文件系统才能将事务结束块发送到磁盘，这样写入日志的效率特别低，通常会产生额外的旋转（因为磁盘通常需要等待正确的扇区旋转到磁头下方才能进行写入操作）。</p>
<p>Linux ext4中则提供了这样一个方法：将事务写入日志时，在开始和结束块中包含日志内容的校验和。这样做使文件系统能够一次写入整个事务，而不会产生等待；如果在恢复期间，文件系统发现事务中计算的校验和与存储的校验和不匹配，则可以断定事务写入期间发生了崩溃，从而丢弃文件系统更新。因此，通过对写入协议和恢复系统进行小的调整，文件系统可以实现更快的常见情况性能；最重要的是，系统稍微更可靠，因为从日志中读取的任何内容现在都受到校验和的保护。</p>
</blockquote>
<p>为避免这一问题，文件系统分两步进行事务写入。首先，文件系统将除 TxE 块外的所有块写入日志，并一次性完成这些写入操作。当这些写入完成后，日志将显示如下内容：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=small" data-sub-html="<h2>image-20240419201334299</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png" alt="image-20240419201334299" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_4.png?size=large 2x" data-title="image-20240419201334299" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这些写入完成后，文件系统会发出 TxE 块的写入，从而使日志处于最终安全状态：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=small" data-sub-html="<h2>image-20240419201416396</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png" alt="image-20240419201416396" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Content_Example_5.png?size=large 2x" data-title="image-20240419201416396" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这个过程的一个重要方面是磁盘提供的原子性保证。事实证明，磁盘保证任何 512 字节的写入要么发生要么不发生（绝不会写一半）；因此，要确保 TxE 的写入是原子性的，就应该把它变成一个单一的 512 字节块。因此，我们目前更新文件系统的协议分为三个阶段：</p>
<ol>
<li><strong>日志写入</strong>：将事务内容（包括 TxB、元数据和数据）写入日志；等待写入完成。</li>
<li><strong>日志提交</strong>：将事务提交块（包含 TxE）写入日志；等待写入完成；事务即被提交。</li>
<li><strong>检查点</strong>：将更新内容（元数据和数据）写入磁盘上的最终位置。</li>
</ol>
<h3 id="恢复" class="heading-element"><span>4.3 恢复</span>
  <a href="#%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们了解文件系统如何使用日志的内容从崩溃中恢复。在此更新序列期间随时可能发生崩溃。</p>
<ul>
<li>如果崩溃发生在事务安全写入日志之前（即，在上面的步骤 2 完成之前），那么我们的工作就很简单：只需跳过挂起的更新。</li>
<li>如果崩溃发生在事务提交到日志之后、检查点完成之前，文件系统可以按如下方式恢复更新。当系统启动时，文件系统恢复过程将扫描日志并查找已提交到磁盘的事务；因此，这些事务会被<strong>重放</strong>（按顺序），文件系统再次尝试将事务中的块写出到它们在磁盘上的最终位置。这种形式的日志记录是最简单的形式之一，称为<strong>重做日志</strong>。通过恢复日志中已提交的事务，文件系统确保磁盘上的结构是一致的，因此可以通过挂载文件系统并为新请求做好准备来继续进行。</li>
</ul>
<p>请注意，在检查点期间的任何时候发生崩溃都是正常的，即使在对块的最终位置的一些更新已经完成之后也是如此。在最坏的情况下，其中一些更新只是在恢复期间再次执行。由于恢复是一种罕见的操作（仅在意外系统崩溃后发生），因此无需担心一些冗余写入。</p>
<h3 id="批处理日志更新" class="heading-element"><span>4.4 批处理日志更新</span>
  <a href="#%e6%89%b9%e5%a4%84%e7%90%86%e6%97%a5%e5%bf%97%e6%9b%b4%e6%96%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>您可能已经注意到，基本协议可能会增加大量额外的磁盘流量。例如，假设我们在同一目录中连续创建两个文件，分别称为 <code>file1</code> 和 <code>file2</code>。要创建一个文件，必须更新许多磁盘结构，至少包括：inode 位图（分配新的 inode）、文件新创建的 inode、包含新目录条目的的父目录的数据块和父目录 inode（现在有新的修改时间）。通过日志记录，我们在逻辑上将所有这些信息提交到我们创建的两个文件的日志中；因为这些文件位于同一目录中，并且假设它们甚至在同一 inode 块中具有 inode，这意味着如果我们不小心，我们最终将一遍又一遍地写入这些相同的块，即相同的目录数据块和 inode 可能会被重复写入，造成了额外的磁盘流量和性能开销。。</p>
<p>为了解决这个问题，某些文件系统不会一次将每个更新提交到磁盘（例如，Linux ext3）；相反，我们可以将所有更新缓冲到全局事务中。在上面的例子中，当创建两个文件时，文件系统只是将内存中的 inode 位图、文件的 inode、目录数据和目录 inode 标记为脏，并将它们添加到形成当前事务的块列表中。当最终将这些块写入磁盘时（例如，5 秒超时后），将提交包含上述所有更新的单个全局事务。因此，通过缓冲更新，文件系统在许多情况下可以避免过多的磁盘写入流量。</p>
<h3 id="限制日志大小" class="heading-element"><span>4.5 限制日志大小</span>
  <a href="#%e9%99%90%e5%88%b6%e6%97%a5%e5%bf%97%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>因此，我们已经达成了更新磁盘上文件系统结构的基本协议。文件系统在内存中缓冲更新一段时间；当最终写入磁盘时，文件系统首先仔细地将事务的详细信息写入日志（也称为预写日志）；事务完成后，文件系统将这些块检查点到它们在磁盘上的最终位置。</p>
<p>然而，日志的大小是有限的。如果我们继续向其中添加事务（如下图所示），它很快就会填满。你认为接下来会发生什么？</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=small" data-sub-html="<h2>image-20240419203504591</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png" alt="image-20240419203504591" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Log_Size_Infinite_Example.png?size=large 2x" data-title="image-20240419203504591" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>日志满时会出现两个问题：</p>
<ul>
<li>第一个问题比较简单，但不那么关键：日志越大，恢复所需的时间就越长，因为恢复过程必须（按顺序）重放日志中的所有事务才能恢复。</li>
<li>第二个问题更为严重：当日志已满（或接近满）时，就无法再向磁盘提交任何事务，从而使文件系统变得 &ldquo;不那么有用&rdquo;（即无用）。</li>
</ul>
<p>为了解决这些问题，日志文件系统将日志视为循环数据结构，不断重复使用；这就是日志有时被称为<strong>循环日志</strong>的原因。为此，文件系统必须在检查点之后的一段时间内采取行动。具体来说，一旦事务被检查点化，文件系统就应释放日志中占用的空间，允许日志空间被重复使用。实现这一目的的方法有很多，例如，你可以简单地在日志超级块中标记日志中最旧和最新的非检查点事务，其他所有空间都是空闲的。下面是一个图表说明：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=small" data-sub-html="<h2>image-20240419203852114</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png" alt="image-20240419203852114" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Circular_Log_Example_1.png?size=large 2x" data-title="image-20240419203852114" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在日志超级块（不要与主文件系统超级块混淆）中，日志系统记录足够的信息以了解哪些事务尚未设置检查点，从而减少恢复时间并允许以循环方式重复使用日志。因此，我们在基本协议中添加了另一个步骤：</p>
<ol>
<li><strong>日志写入</strong>：将事务内容（包含 TxB 和更新内容）写入日志，等待这些写入完成。</li>
<li><strong>日志提交</strong>：将事务提交块（包含TxE）写入日志，等待写入完成，事务现已提交。</li>
<li><strong>检查点</strong>：将更新内容写入文件系统中的最终位置。</li>
<li><strong>释放</strong>：一段时间后，通过更新日志超级块在日志中将事务标记为已释放。</li>
</ol>
<p>这样我们就有了最终的数据日志协议。但仍然存在一个问题：我们将每个数据块写入磁盘两次，这是一个沉重的成本，特别是对于像系统崩溃这样罕见的情况。</p>
<h3 id="元数据日志" class="heading-element"><span>4.6 元数据日志</span>
  <a href="#%e5%85%83%e6%95%b0%e6%8d%ae%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>尽管现在恢复速度很快（扫描日志并重放一些事务，而不是扫描整个磁盘），但文件系统的正常操作比我们期望的要慢。特别是，对于每次写入磁盘，我们现在也首先写入日志，从而使写入流量加倍；在顺序写入工作负载期间，这种加倍尤其令人痛苦，现在该工作负载将以驱动器峰值写入带宽的一半进行。此外，在写入日志和写入主文件系统之间，存在成本高昂的查找，这显着增加了某些工作负载的开销。</p>
<p>由于将每个数据块写入磁盘两次的成本很高，因此人们尝试了一些不同的方法来提高性能。例如，我们上面描述的日志模式通常称为<strong>数据日志</strong>（如在 Linux ext3 中），因为它记录所有用户数据（除了文件系统的元数据）。一种更简单（也更常见）的日志形式有时称为<strong>有序日志</strong>（或只是<strong>元数据日志</strong>），它几乎相同，只是用户数据不写入日志。因此，当执行与上述相同的更新时，以下信息将被写入日志：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=small" data-sub-html="<h2>image-20240419205044904</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png" alt="image-20240419205044904" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Example_1.png?size=large 2x" data-title="image-20240419205044904" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>之前写入日志的数据块 Db 将被写入文件系统本身，避免了额外的写入；考虑到磁盘的大部分 I/O 流量都是数据，不重复写入数据大大减少了日志的 I/O 负载。不过，这一修改确实提出了一个有趣的问题：我们应该在什么时候将数据块写入磁盘？</p>
<p>为了更好地理解这个问题，我们再来看看追加文件的例子。更新由三个数据块组成：I[v2]、B[v2] 和 Db。前两个块都是元数据，会被记录下来，然后进行检查点处理；后一个块只会被写入文件系统一次。我们应该何时将 Db 写入磁盘？这重要吗？</p>
<p>事实证明，对于纯元数据日志，数据写入的顺序确实很重要。例如，如果我们在事务（包含 I[v2] 和 B[v2]）完成后将 Db 写入磁盘，会怎样？不幸的是，这种方法存在一个问题：文件系统是一致的，但 I[v2] 最终可能指向垃圾数据。具体来说，考虑 I[v2] 和 B[v2] 已被写入，但 Db 未被写入磁盘的情况。这时文件系统会尝试恢复。由于 Db 不在日志中，文件系统将重放对 I[v2] 和 B[v2] 的写入，并生成一个一致的文件系统（从文件系统元数据的角度来看）。但是，I[v2] 将指向垃圾数据，即 Db 所在槽中的任何数据。</p>
<p>为了确保这种情况不会发生，一些文件系统（如 Linux ext3）会在将相关元数据写入磁盘之前，先将数据块（常规文件）写入磁盘。</p>
<p>具体来说，协议如下：</p>
<ol>
<li><strong>数据写入</strong>：将数据写入最终位置，等待完成（等待是可选的，详见下文）。</li>
<li><strong>日志元数据写入</strong>：将起始块和元数据写入日志，等待写入完成。</li>
<li><strong>日志提交</strong>：将事务提交块（包含 TxE）写入日志，等待写入完成，事务（包括数据）现已提交。</li>
<li><strong>检查点元数据</strong>：将元数据更新内容写入文件系统中的最终位置。</li>
<li><strong>释放</strong>：之后，在日志超级块中标记事务释放。</li>
</ol>
<p>通过强制先写入数据，文件系统可以保证指针永远不会指向垃圾文件。事实上，&quot;<font color="red">先写被指向对象，再写指向该对象的对象</font> &ldquo;这一规则是崩溃一致性的核心，其他崩溃一致性方案也进一步利用了这一规则（详见下文）。</p>
<p>在大多数系统中，元数据日志（类似于 ext3 的有序日志）比完整数据日志更受欢迎。例如，Windows NTFS 和 SGI 的 XFS 都使用某种形式的元数据日志。 Linux ext3 允许您选择数据、有序或无序模式（<font color="red">在无序模式下，可以随时写入数据</font>）。所有这些模式都保持元数据一致；它们的数据语义各不相同。</p>
<p>最后，请注意，如上述协议所示，在向日志发出写入（步骤 2）之前强制完成数据写入（步骤 1）并不是正确性所必需的。具体来说，<font color="red">最好同时对数据、事务开始块和日志元数据进行写入；唯一真正的要求是步骤 1 和 2 在发布日志提交块（步骤 3）之前完成。</font></p>
<h3 id="棘手的情况块重用" class="heading-element"><span>4.7 棘手的情况：块重用</span>
  <a href="#%e6%a3%98%e6%89%8b%e7%9a%84%e6%83%85%e5%86%b5%e5%9d%97%e9%87%8d%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>有一些有趣的情况会让日志记录变得更加棘手，因此值得讨论。其中许多情况都与块重用有关；正如Stephen Tweedie（ext3 的主要幕后推手之一）所说：</p>
<blockquote>
<p>&ldquo;整个系统最可怕的部分是什么？是删除文件。与删除有关的一切都令人毛骨悚然。所有与删除有关的事情&hellip;&hellip;都会让你做噩梦，因为如果块被删除，然后重新分配，会发生什么？</p>
</blockquote>
<p>Tweedie给出的具体例子如下。假设你正在使用某种形式的元数据日志（因此文件的数据块没有日志）。假设有一个名为 <code>foo</code> 的目录。用户向 <code>foo</code> 添加条目（比如创建文件），因此 <code>foo</code> 的内容（因为目录被视为元数据）被写入日志；假设 <code>foo</code> 目录数据的位置是块 1000。日志内容如下</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=small" data-sub-html="<h2>image-20240419210221686</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png" alt="image-20240419210221686" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_1.png?size=large 2x" data-title="image-20240419210221686" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>此时，用户删除目录中的所有内容以及目录本身，从而释放块 1000 以供重复使用。最后，用户创建一个新文件（例如 <code>foobar</code>），最终会重用曾经属于 <code>foo</code> 的相同块（1000）。 <code>foobar</code> 的 inode 及其数据都提交到磁盘；但请注意，由于正在使用元数据日志，因此只有 <code>foobar</code> 的 inode 会提交到日志；文件 <code>foobar</code> 中块 1000 中新写入的数据未记录。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=small" data-sub-html="<h2>image-20240419210410107</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png" alt="image-20240419210410107" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Log_Example_2.png?size=large 2x" data-title="image-20240419210410107" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设发生了崩溃，并且所有这些信息仍在日志中。在重放期间，恢复过程只是重放日志中的所有内容，包括块 1000 中目录数据的写入；因此，重访会用旧目录内容覆盖当前文件 <code>foobar</code> 的用户数据！显然这不是一个正确的恢复操作，并且当用户读取文件 <code>foobar</code> 时肯定会感到惊讶。</p>
<p>对于这个问题有多种解决方案。例如，人们可以永远不会重用块，直到从日志中检查到删除所述块为止。 Linux ext3 所做的是<font color="red">向日志添加一种新类型的记录，称为撤销记录</font>。在上述情况下，删除目录将导致撤销记录写入日志。重放日志时，系统首先扫描此类撤销记录；任何此类撤销的数据都不会被重放，从而避免了上述问题。</p>
<h3 id="总结日记时间轴" class="heading-element"><span>4.8 总结日记：时间轴</span>
  <a href="#%e6%80%bb%e7%bb%93%e6%97%a5%e8%ae%b0%e6%97%b6%e9%97%b4%e8%bd%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=small" data-sub-html="<h2>image-20240419210913067</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png" alt="image-20240419210913067" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Data_Journaling_Timeline_Example_1.png?size=large 2x" data-title="image-20240419210913067" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在结束对日志的讨论之前，我们用时间轴总结一下我们讨论过的协议。上图显示了记录数据和元数据时的协议，而下图显示了只记录元数据时的协议。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=small" data-sub-html="<h2>image-20240419210939002</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png" alt="image-20240419210939002" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Metadata_Journaling_Timeline.png?size=large 2x" data-title="image-20240419210939002" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在每个图中，时间都是向下递增的，图中的每一行都显示了可以发出或可能完成写入的逻辑时间。例如，在数据日志协议（第一张图）中，事务开始块（TxB）的写入和事务内容的写入在逻辑上可以同时发出，因此可以按任意顺序完成；但事务结束块（TxE）的写入必须在前述写入完成后才能发出。同样，在事务结束块提交之前，也不能开始对数据和元数据块进行检查点写入。水平虚线表示必须遵守写入排序要求的位置。</p>
<p>元数据日志协议也有类似的时间轴。请注意，数据写入在逻辑上可以与事务开始和日志内容的写入同时发出，但必须在事务结束发出前发出并完成。</p>
<p>最后要注意的是，时间轴中标记的每次写入的完成时间是任意的。在实际系统中，完成时间由 I/O 子系统决定，它可能会重新安排写入顺序以提高性能。我们对排序的唯一保证是协议正确性所必须执行的（如图中的水平虚线所示）。</p>
<h2 id="解决方案3其他方法" class="heading-element"><span>5 解决方案#3：其他方法</span>
  <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%883%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>到目前为止，我们已经描述了保持文件系统元数据一致性的两种方法：</p>
<ul>
<li>基于 <code>fsck</code> 的惰性方法</li>
<li>日志记录的更主动的方法。</li>
</ul>
<p>然而，这些并不是唯一的两种方法。 Ganger 和 Patt 提出了一种这样的方法，称为<strong>软更新</strong>。这种方法仔细地对文件系统的所有写入进行排序，以确保磁盘上的结构永远不会处于不一致的状态。例如，<font color="red">通过在指向它的inode之前将一个指向的数据块写入磁盘，我们可以确保该inode永远不会指向垃圾</font>；对于文件系统的所有结构都可以导出类似的规则。然而，实施软更新可能是一个挑战；虽然上述日志层可以在对确切文件系统结构相对较少的了解的情况下实现，但软更新需要对每个文件系统数据结构的复杂了解，从而给系统增加了相当多的复杂性。</p>
<p>另一种方法称为<font color="red">写时复制（COW）</font>，并在许多流行的文件系统中使用，包括 Sun 的 ZFS。此技术永远不会覆盖原位的文件或目录；相反，它将新的更新放置到磁盘上以前未使用的位置。完成多次更新后，COW 文件系统会翻转文件系统的根结构以包含指向新更新的结构的指针。</p>
<p>COW 技术的一个重要优点是它使得保持文件系统的一致性变得更加简单。由于原始数据没有被直接修改，因此不需要复杂的同步或回滚机制来维护一致性，而是通过简单地修改指向新数据的指针来实现。</p>
<p>另一种方法是名为基于反向指针的一致性（backpointer-based consistency, BBC）的技术中，写入之间不强制执行任何顺序。为了实现一致性，系统中的每个块都添加了一个额外的反向指针；例如，每个数据块都有对其所属inode的引用。当访问文件时，文件系统可以通过检查前向指针（例如，inode 或直接块中的地址）是否指向引用它的块来确定文件是否一致。如果是这样，则所有内容都必须已安全到达磁盘，因此文件是一致的；如果不是，则文件不一致，并返回错误。通过向文件系统添加反向指针，可以获得一种新形式的惰性崩溃一致性。</p>
<p>最后，还有一种减少日志协议等待磁盘写入完成的次数的技术。这种新方法被称为<strong>乐观崩溃一致性</strong>，通过使用事务校验和的通用形式向磁盘发出尽可能多的写入，并包含一些其他技术来检测出现的不一致情况。对于某些工作负载，这些乐观技术可以将性能提高一个数量级。然而，要真正正常运行，需要稍微不同的磁盘接口。</p>
]]></description></item><item><title>快速文件系统</title><link>https://hezephyr.github.io/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 11 May 2024 21:32:09 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<h2 id="旧unix操作系统的问题" class="heading-element"><span>1 旧Unix操作系统的问题</span>
  <a href="#%e6%97%a7unix%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>UNIX 操作系统问世之初，UNIX奇才Ken Thompson自己编写了第一个文件系统。我们称之为 &ldquo;老 UNIX 文件系统&rdquo;，它非常简单。基本上，它的数据结构在磁盘上看起来是这样的：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=small" data-sub-html="<h2>image-20240418123744706</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png" alt="image-20240418123744706" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Old_Unix_File_System.png?size=large 2x" data-title="image-20240418123744706" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>超级块 (S) 包含有关整个文件系统的信息：卷有多大、有多少 inode、指向空闲块列表头部的指针等等。磁盘的inode区域包含文件系统的所有inodes。最后，大部分磁盘都被数据块占用了。</p>
<p>旧文件系统的好处是它很简单，并且支持文件系统试图提供的基本抽象：文件和目录层次结构。这个易于使用的系统是从过去笨拙的、基于记录的存储系统向前迈出的真正一步，并且目录层次结构相对于早期系统提供的更简单的单级层次结构来说是真正的进步。</p>
<p>问题是：<strong>性能非常糟糕</strong>。根据 Kirk McKusick 和他在伯克利的同事的测量，性能从一开始就很糟糕，而且随着时间的推移越来越差，到后来文件系统只能提供整个磁盘带宽的 2%！</p>
<p>主要问题在于，<strong>旧的 UNIX 文件系统把磁盘当作随机存取存储器来处理</strong>；数据被分散到各个地方，而不考虑保存数据的介质是磁盘这一事实，因此有实际而昂贵的定位成本。例如，一个文件的数据块往往离其 inode 很远，因此每当先读取 inode，然后再读取文件的数据块时，都会产生昂贵的寻道（这是一个相当常见的操作）。</p>
<p>更糟糕的是，由于没有对空闲空间进行仔细管理，文件系统最终会变得相当<strong>碎片化</strong>。空闲列表最终会指向散布在磁盘上的大量区块，当文件被分配时，它们只会占用下一个空闲区块。其结果是，逻辑上连续的文件会在磁盘上来回访问，从而大大降低了性能。例如，假设下面的数据块区域包含四个文件（A、B、C 和 D），每个文件的大小为 2 个数据块：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=small" data-sub-html="<h2>image-20240418125008864</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png" alt="image-20240418125008864" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_1.png?size=large 2x" data-title="image-20240418125008864" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果删除 B 和 D，则结果布局为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=small" data-sub-html="<h2>image-20240418125054288</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png" alt="image-20240418125054288" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_2.png?size=large 2x" data-title="image-20240418125054288" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如你所看到的，空闲空间被分割成两块，每块两个区块，而不是一块连续的四个区块。假设你现在想分配一个四块大小的文件 E：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=small" data-sub-html="<h2>image-20240418125147699</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png" alt="image-20240418125147699" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Example_3.png?size=large 2x" data-title="image-20240418125147699" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>你可以看到发生了什么：E 会被分散到整个磁盘，因此在访问 E 时，磁盘的性能不会达到峰值（顺序）。而是先读取 E1 和 E2，然后寻道，再读取 E3 和 E4。这种碎片问题在旧的 UNIX 文件系统中经常出现，而且会影响性能。顺便提一句：<font color="red"><strong>磁盘碎片整理工具</strong>正是用来解决这个问题的；它们会重组磁盘上的数据，将文件连续放置，并为一个或几个连续区域腾出空间，移动数据，然后重写 inodes 等，以反映变化。</font></p>
<p>还有一个问题：原始块大小太小（512 字节）。因此，从磁盘传输数据的效率本来就不高。块越小越好，因为可以最大限度地减少内部碎片（块内的浪费），但对传输不利，因为每个块都可能需要定位开销才能到达。这就是问题所在：</p>
<blockquote>
<p>如何组织文件系统数据结构以提高性能？在这些数据结构之上，我们需要哪种类型的分配策略？如何让文件系统 &ldquo;感知磁盘&rdquo;？</p>
</blockquote>
<h2 id="ffs磁盘感知是解决方案" class="heading-element"><span>2 FFS：磁盘感知是解决方案</span>
  <a href="#ffs%e7%a3%81%e7%9b%98%e6%84%9f%e7%9f%a5%e6%98%af%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>伯克利大学的一个小组决定建立一个更好、更快的文件系统，他们巧妙地将其称为<strong>快速文件系统（FFS）</strong>。他们的想法是设计 &ldquo;磁盘感知 &ldquo;的文件系统结构和分配策略，从而提高性能，他们正是这样做的。因此，FFS 开启了文件系统研究的新纪元；通过保留文件系统的相同接口（相同的 API，包括 <code>open()</code>、<code>read()</code>、<code>write()</code>、<code>close()</code> 和其他文件系统调用），但改变内部实现，作者为新文件系统的构建铺平了道路，这项工作一直持续到今天。几乎所有现代文件系统都遵循现有的接口（从而保持与应用程序的兼容性），同时出于性能、可靠性或其他原因改变其内部结构。</p>
<h2 id="组织结构柱面组" class="heading-element"><span>3 组织结构：柱面组</span>
  <a href="#%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e6%9f%b1%e9%9d%a2%e7%bb%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>第一步是更改磁盘结构。 FFS 将磁盘划分为<strong>多个柱面组</strong>。<strong>单柱面</strong>是硬盘驱动器不同表面上距驱动器中心距离相同的一组磁道；它被称为柱面是因为它与所谓的几何形状明显相似。 FFS将N个连续的柱面聚合为一组，因此整个磁盘可以被视为柱面组的集合。这是一个简单的示例，显示了具有六个盘片的驱动器的四个最外层磁道，以及由三个柱面组成的柱面组：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=small" data-sub-html="<h2>image-20240418130734316</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png" alt="image-20240418130734316" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Cylinder_Group_Example_1.png?size=large 2x" data-title="image-20240418130734316" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，现代驱动器不会导出足够的信息供文件系统真正理解特定柱面是否正在使用；如前所述，<font color="red">磁盘导出块的逻辑地址空间，并将其几何细节隐藏在客户端之外。</font>因此，现代文件系统（例如Linux ext2、ext3和ext4）将驱动器组织成块组，每个块组只是磁盘地址空间的连续部分。下面的图片说明了一个示例，在该示例中，每8个块被组织到不同的块组中（请注意实际分组将包含更多块）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=small" data-sub-html="<h2>image-20240418130941919</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png" alt="image-20240418130941919" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Block_Group_Example_1.png?size=large 2x" data-title="image-20240418130941919" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>无论您将它们称为柱面组还是块组，这些组都是 FFS 用于提高性能的核心机制。至关重要的是，通过将两个文件放在同一组中，FFS 可以确保依次访问不会导致磁盘上的长时间查找。</p>
<p>为了使用这些组来存储文件和目录，FFS 需要能够将文件和目录放入一个组中，并在其中跟踪有关它们的所有必要信息。为此，FFS 包含您可能期望文件系统在每个组中具有的所有结构，例如 inode 空间、数据块以及一些用于跟踪这些结构是否已分配或空闲的结构。以下是 FFS 在单个柱面组中保留的内容的描述：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=small" data-sub-html="<h2>image-20240418131130383</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png" alt="image-20240418131130383" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Single_Cylinder_Group_Example_1.png?size=large 2x" data-title="image-20240418131130383" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在让我们更详细地检查一下这个单个柱面组的组成部分。出于可靠性原因，FFS 会在每个组中保留一份<strong>超级块 (S) 副本</strong>。挂载文件系统需要超级块；通过保留多个副本，如果其中一个副本损坏，你仍然可以通过工作副本挂载和访问文件系统。</p>
<p>在每个组内，FFS 需要跟踪该组的 inode 和数据块是否已分配。每个组的 <strong>inode 位图 (ib)</strong> 和<strong>数据位图 (db)</strong> 对每个组中的 inode 和数据块起作用。位图是管理文件系统中空闲空间的绝佳方法，因为很容易找到一大块空闲空间并将其分配给文件，或许可以避免旧文件系统中空闲列表的一些碎片问题。</p>
<p>最后，<strong>inode</strong> 和<strong>数据块区域</strong>与以前的 &ldquo;非常简单文件系统&rdquo;（VSFS）一样。像往常一样，每个柱面组的大部分由数据块组成。</p>
<blockquote>
<center>FFS 文件创建
</center>
<p>作为一个例子，想一想创建文件时必须更新哪些数据结构；在这个例子中，假设用户创建了一个新文件 <code>/foo/bar.txt</code>，文件长度为一个块（4KB）。该文件是新文件，因此需要一个新的 inode；因此，inode 位图和新分配的 inode 都将被写入磁盘。</p>
<p>文件中还有数据，因此也必须分配；数据位图和数据块（最终）将被写入磁盘。因此，对当前分区至少要进行四次写入（请注意，这些写入在进行之前可能会在内存中缓冲一段时间）。但这还不是全部！尤其是，在创建新文件时，还必须将文件放到文件系统的层次结构中，即必须更新目录。具体来说，必须更新父目录 <code>foo</code>，以添加 <code>bar.txt</code> 条目；这一更新可能适合 <code>foo</code> 的现有数据块，也可能需要分配一个新块（以及相关的数据位图）。<code>foo</code> 的 inode 也必须更新，以反映目录的新长度并更新时间字段（如最后修改时间）。</p>
<p>总的来说，创建一个新文件的工作量很大！也许下次再创建新文件时，你应该更加感激，或者至少对创建工作如此顺利感到惊讶。</p>
</blockquote>
<h2 id="策略如何分配文件和目录" class="heading-element"><span>4 策略：如何分配文件和目录</span>
  <a href="#%e7%ad%96%e7%95%a5%e5%a6%82%e4%bd%95%e5%88%86%e9%85%8d%e6%96%87%e4%bb%b6%e5%92%8c%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了这个组结构，FFS 现在必须决定如何将文件和目录以及相关元数据放置在磁盘上以提高性能。基本原则很简单：<font color="red">将相关的东西放在一起（其推论就是将不相关的东西分开）</font>。</p>
<p>因此，为了遵守这一原则，FFS 必须决定什么是“相关的”并将其放置在同一个区块组中；相反，不相关的项目应放置在不同的块组中。为了实现这一目标，FFS 使用了一些简单的放置启发式法。</p>
<p>首先是目录的放置。 FFS 采用一种简单的方法：找到分配目录数量较少（以平衡组之间的目录）和空闲 inode 数量较多（以便随后能够分配一堆文件）的柱面组，并将目录数据和inode放在该组中。当然，这里可以使用其他启发式方法（例如，考虑空闲数据块的数量）。</p>
<p>对于文件，FFS 做了两件事。</p>
<ul>
<li>首先，<font color="red">它确保（在一般情况下）将文件的数据块分配在与其 inode 相同的组中</font>，从而防止 inode 和数据之间的长时间查找（如在旧文件系统中）。</li>
<li>其次，<font color="red">它将同一目录中的所有文件放置在它们所在目录的柱面组中</font>。</li>
</ul>
<p>因此，如果用户创建四个文件：<code>/a/b</code>、<code>/a/c</code>、<code>/a/d</code> 和 <code>b/ f</code>，FFS 会尝试将前三个放置在彼此附近（同一组），而第四个放置在远处（在其他组中）。</p>
<p>让我们看一个此类分配的示例。在示例中，假设每组只有 10 个 inode 和 10 个数据块（都小得离谱），并且三个目录（根目录 <code>/</code>、<code>/a</code>、<code>/b</code>）和 4 个文件（<code>/a/ c</code>、<code>/a/d</code>、<code>/a/e</code>、<code>/b/f</code>) 根据 FFS 策略放置在其中。假设常规文件的大小各为两个块，并且目录只有一个数据块。对于该图，我们对每个文件或目录使用明显的符号（即 <code>/</code> 表示根目录，<code>a</code> 表示 <code>/a</code>，<code>f</code> 表示 <code>/b/f</code>，等等）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=small" data-sub-html="<h2>image-20240418201534595</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png" alt="image-20240418201534595" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Placed_Policy_Example.png?size=large 2x" data-title="image-20240418201534595" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，FFS 策略做了两个积极的事情：每个文件的数据块都靠近每个文件的 inode，同一目录中的文件彼此靠近（即 <code>/a/c</code>、<code>/a/d</code> 和 <code>/a/e</code>）都在组 1 中，并且目录 <code>/b</code> 及其文件 <code>/b/f</code> 在组 2 中彼此靠近）。</p>
<p>相比之下，现在让我们看一下 inode 分配策略，它只是将 inode 分布在组之间，试图确保没有组的 inode 表很快被填满。最终的分配可能如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=small" data-sub-html="<h2>image-20240418201925750</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png" alt="image-20240418201925750" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Inode_Placed_Policy_Example.png?size=large 2x" data-title="image-20240418201925750" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从图中可以看出，虽然此策略确实将文件（和目录）数据保留在其各自的 inode 附近，但目录中的文件在磁盘上任意分布，因此不会保留基于名称的局部性。对文件 <code>/a/c</code>、<code>/a/d</code> 和 <code>/a/e</code> 的访问现在跨越三组，而不是按照 FFS 方法跨越一组。</p>
<p>FFS 策略启发式方法并非基于对文件系统流量或任何特别细微的内容的广泛研究；相反，它们基于良好的老式常识。目录中的文件通常一起访问：想象一下编译一堆文件，然后将它们链接到单个可执行文件中。由于存在这种基于命名空间的局部性，FFS 通常会提高性能，确保相关文件之间的查找良好且简短。</p>
<h2 id="文件局部性测量" class="heading-element"><span>5 文件局部性测量</span>
  <a href="#%e6%96%87%e4%bb%b6%e5%b1%80%e9%83%a8%e6%80%a7%e6%b5%8b%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了更好地理解这些启发式方法是否有意义，让我们分析一些文件系统访问的痕迹，看看是否确实存在命名空间局部性。由于某种原因，文献中似乎没有对这个主题进行很好的研究。</p>
<p>具体来说，我们将使用 SEER 跟踪并分析目录树中文件访问彼此之间的“距离”有多远。例如，如果文件 <code>f</code> 被打开，然后在跟踪中下一个重新打开（在打开任何其他文件之前），则目录树中这两个打开之间的距离为零（因为它们是同一文件）。如果打开目录 <code>dir</code>中的文件 <code>f</code>（即 <code>dir/f</code>），然后打开同一目录中的文件 <code>g</code>（即 <code>dir/g</code>），则两个文件访问之间的距离为 1，因为它们共享同一目录但不是同一文件。换句话说，我们的距离度量衡量的是您必须在<strong>目录树上走多远才能找到两个文件的共同祖先</strong>；它们在树中越近，度量越低。</p>
<p>下图显示了在 SEER 集群中所有工作站的 SEER 跟踪中在所有跟踪的整体上观察到的局部性。该图沿 x 轴绘制差异指标，并沿 y 轴显示具有该差异的文件打开的累积百分比。具体来说，对于 SEER 跟踪（图中标记为“Trace”），您可以看到大约 7% 的文件访问是针对先前打开的文件，而近 40% 的文件访问是针对同一文件或到同一目录中的一（即相差零或一）。因此，FFS 局部性假设似乎是有意义的（至少对于这些痕迹而言）。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Locality_For_SEER_Traces.png" alt="image-20240418202721034" style="zoom:50%;" />
<p>有趣的是，另外 25% 左右的文件访问是针对距离为 2 的文件的。当用户以多级方式构建一组相关目录并在它们之间持续跳转时，就会发生这种类型的局部性。例如，如果用户有一个 <code>src</code> 目录并将目标文件（<code>.o</code> 文件）构建到 <code>obj</code> 目录中，并且这两个目录都是主目录 <code>proj</code> 的子目录，则常见的访问模式将是 <code>proj/src/foo .c</code> 后跟 <code>proj/obj/foo.o</code>。这两个访问之间的距离是 2，因为 <code>proj</code> 是共同的祖先。 FFS 不会在其策略中捕获这种类型的局部性，因此在此类访问之间会发生更多的查找。</p>
<p>为了进行比较，该图还显示了“随机”轨迹的局部性。随机跟踪是通过以随机顺序从现有 SEER 跟踪中选择文件并计算这些随机排序的访问之间的距离度量来生成的。正如您所看到的，正如预期的那样，随机跟踪中的命名空间局部性较少。然而，因为最终每个文件共享一个共同的祖先（例如根），所以存在一些局部性，因此随机作为比较点是有用的。</p>
<h2 id="大文件例外" class="heading-element"><span>6 大文件例外</span>
  <a href="#%e5%a4%a7%e6%96%87%e4%bb%b6%e4%be%8b%e5%a4%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在 FFS 中，文件放置的一般策略有一个重要的例外，那就是大文件。如果没有不同的规则，一个大文件就会占满它第一次放置的块组（也许还有其他块组）。以这种方式填满一个块组是不可取的，因为这会阻止后续的 &ldquo;相关 &ldquo;文件被放置在这个块组中，从而可能会损害文件访问的本地性。</p>
<p>因此，对于大文件，FFS 的做法如下。在第一个块组中分配了一定数量的块之后（例如 12 个块，或一个 inode 中可用的直接指针的数量），FFS 会将文件的下一个 &ldquo;大 &ldquo;块（例如第一个间接块指向的那些块）放到另一个块组（可能是为了降低利用率而选择的）中。然后，文件的下一个块被放到另一个不同的块组中，依此类推。</p>
<p>让我们通过一些图表来更好地理解这一策略。如果没有大文件例外情况，单个大文件就会将其所有块放入磁盘的一个部分。我们以一个文件 (<code>/a</code>) 为例进行研究，该文件有 30 个块，FFS 配置为每个组 10 个 inodes 和 40 个数据块。下面是没有大文件例外情况的 FFS 的描述：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=small" data-sub-html="<h2>image-20240418204128184</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png" alt="image-20240418204128184" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example.png?size=large 2x" data-title="image-20240418204128184" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如图所示，<code>/a</code> 填满了group 0 中的大部分数据块，而其他组仍然是空的。如果现在在根目录 (<code>/</code>) 中创建了其他文件，那么组中就没有太多空间来存放它们的数据了。</p>
<p>在大文件例外情况下（此处设置为每个块中包含五个块），FFS 会将文件分散到各个组中，因此任何一个组内的利用率都不会太高：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=small" data-sub-html="<h2>image-20240418204256591</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png" alt="image-20240418204256591" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Big_File_Placed_Example_2.png?size=large 2x" data-title="image-20240418204256591" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>你可能注意到，将文件块分散到磁盘上会降低性能，尤其是在相对常见的顺序文件访问情况下（例如，用户或应用程序按顺序读取 0 到 29 块）。但您可以通过谨慎选择块大小来解决这个问题。</p>
<p>具体来说，如果块的大小足够大，文件系统就会花大部分时间从磁盘传输数据，而只花（相对较少的）时间在块的各块之间查找。<font color="red">这种通过增加每次开销的工作量来减少开销的过程称为摊销，是计算机系统中的一种常用技术</font>。</p>
<p>让我们举个例子：假设磁盘的平均定位时间（即寻道和旋转）为 10 毫秒。再假设磁盘的数据传输速度为 40 MB/s。如果您的目标是将一半时间用于在数据块之间寻道，一半时间用于传输数据（从而达到磁盘峰值性能的 50%），那么每 10 毫秒的定位时间就需要花费 10 毫秒来传输数据。那么问题来了：一个数据块需要多大才能花费 10 毫秒来传输数据？我们来计算一下：
$$
\frac{40\cancel{MB}}{\cancel{sec}}\cdot\frac{1024KB}{1\cancel{MB}}\cdot\frac{1\cancel{sec}}{1000\cancel{ms}}\cdot10\cancel{ms}=409.6KB
$$
基本上，这个等式表示的是：如果您以 40 MB/s 的速度传输数据，则每次查找时只需传输 409.6KB，以便将一半的时间用于查找，一半的时间用于传输。同样，您可以计算实现 90% 峰值带宽（结果约为 3.69MB），甚至 99% 峰值带宽（40.6MB！）所需的块大小。正如您所看到的，您越接近峰值，这些块就越大（有关这些值如下图所示）。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Amortization_How_Big_Do_Chunks_Have_To_Be.png" alt="image-20240418205144894" style="zoom:50%;" />
<p>不过，FFS 并没有使用这种计算方法，以便将大文件分摊到各个组。相反，它根据 inode 本身的结构采取了一种简单的方法。前 12 个直接块与 inode 放在同一个组中；随后的每个间接块及其指向的所有块则放在不同的组中。对于 4KB 的块大小和 32 位磁盘地址，此策略意味着文件的每 1024 个块 (4MB) 被放置在单独的组中，唯一的例外是直接指针指向的文件的第一个 48KB。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=small" data-sub-html="<h2>image-20240418205920172</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png" alt="image-20240418205920172" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Large_File_Placed_Example_3.png?size=large 2x" data-title="image-20240418205920172" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，磁盘驱动器的发展趋势是，传输速率的提高相当快，因为磁盘制造商善于将更多bit压缩到相同的表面，但与寻道有关的驱动器机械方面（磁盘臂速度和旋转速度）的提高却相当缓慢。这意味着，随着时间的推移，机械成本会变得相对更昂贵，因此，为了摊销这些成本，你必须在两次寻道之间传输更多的数据。</p>
<h2 id="关于-ffs-的其他一些事情" class="heading-element"><span>7 关于 FFS 的其他一些事情</span>
  <a href="#%e5%85%b3%e4%ba%8e-ffs-%e7%9a%84%e5%85%b6%e4%bb%96%e4%b8%80%e4%ba%9b%e4%ba%8b%e6%83%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>FFS 还引入了其他一些创新。特别是，设计者们非常担心小文件的容纳问题；事实证明，当时许多文件的大小都在 2KB 左右，使用 4KB 的块虽然有利于传输数据，但空间效率却不高。因此，对于一个典型的文件系统来说，这种<strong>内部碎片</strong>会导致大约一半的磁盘空间被浪费。</p>
<p>FFS 设计者的解决方案很简单，也很好地解决了这个问题。他们决定引入<strong>子块</strong>，即文件系统可以分配给文件的 512 字节的小块。这样，如果你创建了一个小文件（比如 1KB 大小），它将占用两个子块，从而不会浪费整个 4KB 的块。<font color="red">随着文件的增大，文件系统将继续为其分配 512 字节的块，直到获得完整的 4KB 数据。这时，FFS 会找到一个 4KB 的块，将子块复制到其中，然后释放子块以备将来使用。</font></p>
<p>你可能会认为这个过程效率很低，需要文件系统做大量额外的工作（尤其是执行复制时需要大量额外的 I/O）。因此，FFS 通常通过修改 <code>libc</code> 库来避免这种低效行为；<font color="red">该库会对写入内容进行缓冲，然后以 4KB 的分块形式将其发送到文件系统，从而在大多数情况下完全避免了子块特殊化</font>。</p>
<p>FFS 引入的第二项重要功能是优化磁盘布局以提高性能。在那个时代（SCSI 和其他更现代的设备接口出现之前），磁盘的复杂程度要低得多，需要主机 CPU 以更实际的方式控制其运行。当文件被放置在磁盘的连续扇区上时，FFS 就会出现问题，如下图左侧所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=small" data-sub-html="<h2>image-20240418210429044</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png" alt="image-20240418210429044" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/FFS_Standard_Versus_Parameterized_Placement.png?size=large 2x" data-title="image-20240418210429044" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>特别是在顺序读取时出现问题。FFS 会首先发出对 0 号块的读取；当读取完成后，FFS 再发出对 1 号块的读取时，为时已晚：1 号块已经在磁头下方旋转，现在读取 1 号块将会导致完全旋转。</p>
<p>FFS 采用不同的布局解决了这个问题，如上图右侧所示。通过跳过每一个其他块（在示例中），FFS 有足够的时间在下一个块经过磁头之前请求下一个块。事实上，FFS 很聪明，它能计算出特定磁盘在布局时应跳过多少块，以避免额外的旋转；这种技术被称为<strong>参数化</strong>，因为 FFS 会计算出磁盘的特定性能参数，并利用这些参数来决定准确的交错布局方案。</p>
<p>你可能会想：这个方案毕竟没那么好。事实上，使用这种布局，你只能获得峰值带宽的 50%，因为你必须绕每个磁道两次，才能读取每个区块一次。幸运的是，现代磁盘要聪明得多：<font color="red">它们会在内部读入整个磁道，并将其缓冲到内部磁盘缓存中（因此通常称为磁道缓冲区）</font>。这样，在后续读取磁道时，磁盘就会从缓存中返回所需的数据。因此，文件系统不再需要担心这些令人难以置信的低级细节。如果设计得当，抽象和更高级别的接口可能是件好事。</p>
<p>此外，还增加了其他一些可用性改进。FFS 是最早允许使用<strong>长文件名</strong>的文件系统之一，从而使文件系统中的文件名更具表现力，而不是传统的固定大小方法（如 8 个字符）。此外，文件系统还引入了一个新概念，即<strong>符号链接</strong>。硬链接的局限性在于它们不能指向目录（因为担心会在文件系统层次结构中引入循环），而且只能指向同一卷内的文件（即 inode number必须仍然有意义）。<font color="red">符号链接允许用户创建指向系统中任何其他文件或目录的 &ldquo;别名&rdquo;，因此更加灵活</font>。FFS 还引入了用于重命名文件的原子 <code>rename()</code> 操作。除基本技术外，易用性方面的改进也为 FFS 赢得了更多用户。</p>
]]></description></item><item><title>文件系统实现</title><link>https://hezephyr.github.io/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 11 May 2024 21:05:11 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</guid><description><![CDATA[<h2 id="思维模型" class="heading-element"><span>1 思维模型</span>
  <a href="#%e6%80%9d%e7%bb%b4%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>要考虑文件系统，我们通常建议考虑它们的两个不同方面；如果您了解这两个方面，您可能就会了解文件系统的基本工作原理。</p>
<ul>
<li>首先是文件系统的<font color="red">数据结构</font>。换句话说，文件系统使用什么类型的磁盘结构来组织其数据和元数据？我们将看到的第一个文件系统（包括下面的 vsfs）采用简单的结构，如块数组或其他对象，而更复杂的文件系统，如 SGI 的 XFS，使用更复杂的基于树的结构。</li>
<li>文件系统的第二个方面是它的<font color="red">访问方法</font>。它如何将进程发出的调用（例如 <code>open()</code>、<code>read()</code>、<code>write()</code> 等）映射到其结构上？在执行特定系统调用期间会读取哪些结构？写了哪些？所有这些步骤的执行效率如何？</li>
</ul>
<p>如果您了解文件系统的数据结构和访问方法，您就已经开发了一个关于它如何真正工作的良好思维模型，这是系统思维的关键部分。</p>
<blockquote>
<center>文件系统思维模型
</center>
<p>思维模型是你在学习系统时真正想要开发的东西。对于文件系统，您的思维模型最终应该包括以下问题的答案：</p>
<ol>
<li>哪些磁盘结构存储文件系统的数据和元数据？</li>
<li>当进程打开文件时会发生什么？</li>
<li>在读取或写入期间访问哪些磁盘结构？</li>
</ol>
<p>通过研究和改进您的思维模型，您可以对正在发生的事情形成抽象的理解，而不仅仅是试图理解某些文件系统代码的细节。</p>
</blockquote>
<h2 id="vsfs的整体组织" class="heading-element"><span>2 VSFS的整体组织</span>
  <a href="#vsfs%e7%9a%84%e6%95%b4%e4%bd%93%e7%bb%84%e7%bb%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们现在开发 vsfs 文件系统数据结构的整体磁盘组织。我们需要做的第一件事是将磁盘分为块；简单的文件系统仅使用一种块大小，这正是我们在这里要做的。我们选择常用的大小 4 KB。</p>
<p>因此，我们对构建文件系统的磁盘分区的看法很简单：一系列块，每个块大小为 4 KB。在大小为 $N$ 个 4 KB 块的分区中，块的寻址范围为 $0$ 到 $N − 1$。假设我们有一个非常小的磁盘，只有 64 个块：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=small" data-sub-html="<h2>image-20240417111330145</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png" alt="image-20240417111330145" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_Size_Example.png?size=large 2x" data-title="image-20240417111330145" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在让我们考虑一下需要在这些块中存储什么来构建文件系统。当然，首先想到的是用户数据。事实上，任何文件系统中的大部分空间都是（并且应该是）用户数据。我们将用于用户数据的磁盘区域称为<strong>数据区域</strong>，并且为了简单起见，为这些块保留磁盘的固定部分，例如磁盘上 64 个块中的最后 56 个块：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=small" data-sub-html="<h2>image-20240417111520646</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png" alt="image-20240417111520646" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Data_Region_Example.png?size=large 2x" data-title="image-20240417111520646" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>文件系统必须跟踪每个文件的信息。该信息是<strong>元数据</strong>的关键部分，跟踪诸如哪些数据块（在数据区域中）组成文件、文件的大小、其所有者和访问权限、访问和修改时间以及其他类似信息等。为了存储这些信息，文件系统通常有一个称为<code>inode</code>的结构。</p>
<p>为了容纳inodes，我们还需要在磁盘上为它们保留一些空间。我们将磁盘的这一部分称为inode表，它仅保存磁盘上inodes的数组。因此，我们的磁盘映像现在看起来像下图，假设我们使用 64 个块中的 5 个作为inodes（在图中用 I 表示）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=small" data-sub-html="<h2>image-20240417112112851</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png" alt="image-20240417112112851" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VFS_Block_inodes_Example.png?size=large 2x" data-title="image-20240417112112851" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这里我们应该注意，inode 通常不会那么大，例如 128 或 256 字节。假设每个 inode 256 字节，一个 4 KB 的块可以容纳 16 个 inodes，而我们上面的文件系统总共包含 80 个 inodes。在我们的简单文件系统中，构建在一个微小的 64 块分区上，这个数字代表我们的文件系统中可以拥有的最大文件数；但是，请注意，构建在更大磁盘上的相同文件系统可以简单地分配更大的inode表，从而容纳更多文件。</p>
<p>到目前为止，我们的文件系统已经有了数据块（D）和 inodes（I），但仍然缺少一些东西。正如您可能已经猜到的，仍然需要的一个主要组件是<font color="red">某种跟踪inodes或数据块是否空闲或已分配的方法。</font>因此，这种分配结构是任何文件系统中必需的元素。</p>
<p>当然，有许多可行的分配跟踪方法。例如，我们可以使用一个指向第一个空闲块的<strong>空闲列表</strong>，该块再指向下一个空闲块，依此类推。相反，我们选择了一种简单且流行的结构，称为<strong>位图</strong>，其中包括数据区域（<strong>数据位图</strong>）和inode表（inode位图）。位图是一个简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。因此我们新的磁盘布局，带有inode位图 (i) 和数据位图 (d)：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=small" data-sub-html="<h2>image-20240417112825881</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png" alt="image-20240417112825881" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Bit_Map_Example.png?size=large 2x" data-title="image-20240417112825881" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>您可能会注意到，为这些位图使用整个 4 KB 块有点过大；这样的位图可以跟踪是否分配了32K个对象，但我们只有80个inode和56个数据块。然而，为了简单起见，我们还是为每个位图使用整个 4 KB 块。</p>
<p>我们非常简单的文件系统的磁盘结构的设计中还剩下一个块。我们将其保留给<strong>超级块</strong>，在下图中用 S 表示。<font color="red">超级块包含有关此特定文件系统的信息，例如，包括文件系统中有多少个 inodes 和数据块（在本例中分别为 80 和 56）、inode 表开始的位置（块 3）等等</font>。它还可能包含某种幻数来标识文件系统类型（在本例中为 vsfs）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=small" data-sub-html="<h2>image-20240417113149921</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png" alt="image-20240417113149921" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Block_Superblock_Example.png?size=large 2x" data-title="image-20240417113149921" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>因此，<font color="red">在挂载文件系统时，操作系统会首先读取超级块，初始化各种参数，然后将卷附加到文件系统树上。</font>这样，当访问卷内文件时，系统就能准确知道在哪里可以找到所需的磁盘结构。</p>
<h2 id="文件组织inode" class="heading-element"><span>3 文件组织：Inode</span>
  <a href="#%e6%96%87%e4%bb%b6%e7%bb%84%e7%bb%87inode" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>3.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>文件系统最重要的磁盘结构之一是 inode；几乎所有文件系统都有与此类似的结构。名称 inode 是<strong>index node</strong>的缩写，这是 UNIX和可能更早的系统中赋予它的历史名称，使用它是因为这些节点最初排列在数组中，并且在访问特定 inode 时索引到该数组。</p>
<blockquote>
<center>数据结构 — INODE
</center>
<p>inode 是许多文件系统中使用的通用名称，用于描述保存给定文件元数据的结构，例如其长度、权限及其组成块的位置。这个名字至少可以追溯到 UNIX（如果不是更早的系统的话，可能更早可以追溯到 Multics）；它是<code>index node</code>（索引节点）的缩写，因为inode number用于索引磁盘上inodes数组，以便找到该编号的inode。正如我们将看到的，inode的设计是文件系统设计的关键部分之一。大多数现代系统对于它们跟踪的每个文件都有某种类似的结构，但可能将它们称为不同的东西（例如 dnodes、fnodes 等）。</p>
</blockquote>
<p>每个inode都隐式地通过一个数字（称为<code>i-number</code>）引用，我们之前称之为文件的底层名称。在vsfs（以及其他简单的文件系统中），给定一个<code>i-number</code>，您应该能够直接计算出对应<code>inode</code>位于磁盘上的位置。例如，以上述的vsfs inode表为例：：大小为20KB（5个4KB块），因此包含80个inodes（假设每个inode为256字节）；进一步假设inode区域从12KB开始（即超级块从0KB开始，inode位图在地址4KB处，数据位图在8KB处，因此inode表紧随其后）。在vsfs中，我们因此有以下布局来表示文件系统分区开头部分的情况（特写视图）:</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=small" data-sub-html="<h2>image-20240417125143762</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png" alt="image-20240417125143762" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/VSFS_Inode_Table_Example.png?size=large 2x" data-title="image-20240417125143762" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>要读取number为 32 的 inode，文件系统首先要计算 inode 区域的偏移量（$32 \cdot sizeof (inode)$ 或 $8192$），将其与磁盘上 inode 表的起始地址（<code>inodeStartAddr = 12KB</code>）相加，从而得出所需 inode 块的正确字节地址：20KB。回想一下，磁盘不是字节寻址的，而是由大量可寻址扇区（通常为 512 字节）组成。因此，要获取包含 inode 32 的 inode 块，文件系统将向 $\frac{20×1024}{512}$ 扇区或 40 扇区发出读取命令，以获取所需的 inode 块。更一般地说，inode 块的扇区地址<code>sector</code>可按如下方式计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">inumber</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">inode_t</span><span class="p">))</span> <span class="o">/</span> <span class="n">blockSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">sector</span> <span class="o">=</span> <span class="p">((</span><span class="n">blk</span> <span class="o">*</span> <span class="n">blockSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">inodeStartAddr</span><span class="p">)</span> <span class="o">/</span> <span class="n">sectorSize</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>每个 <code>inode</code> 内部实际上包含了文件所需的所有信息：文件类型（例如常规文件、目录等）、大小、分配给它的块数、保护信息（例如谁拥有该文件、以及谁可以访问它）、一些时间信息，包括文件创建、修改或上次访问的时间，以及有关其数据块驻留在磁盘上的位置的信息（例如某种指针）。我们将有关文件的所有此类信息称为<strong>元数据</strong>；事实上，文件系统中除了纯用户数据之外的任何信息通常被称为<strong>元数据</strong>。 ext2中的一个inode示例如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=small" data-sub-html="<h2>image-20240417130232939</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png" alt="image-20240417130232939" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simplified_Ext2_Inode_Example.png?size=large 2x" data-title="image-20240417130232939" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>inode 设计中最重要的决策之一是它如何引用数据块的位置。一种简单的方法是在 inode 内有一个或多个直接指针（磁盘地址）；每个指针指向属于该文件的一个磁盘块。这种方法是有限的：例如，如果您想要一个非常大的文件（例如，<strong>大于</strong>块大小乘以 inode 中的直接指针数量），那么您就不走运了。</p>
<h3 id="多级索引" class="heading-element"><span>3.2 多级索引</span>
  <a href="#%e5%a4%9a%e7%ba%a7%e7%b4%a2%e5%bc%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了支持更大的文件，文件系统设计者不得不在 inodes 中引入不同的结构。一种常见的想法是使用一种被称为<strong>间接指针</strong>的特殊指针。<font color="red">它不指向包含用户数据的块，而是指向包含更多指针的块，每个指针都指向用户数据。</font>因此，一个 inode 可能有一定数量的直接指针（如 12 个）和一个间接指针。如果文件长得足够大，就会分配一个间接块（来自磁盘的数据块区域），并将间接指针的 inode 插槽设置为指向它。假设有 4KB 的数据块和 4 字节的磁盘地址，则又增加了 1024 个指针；文件可以增长到 $(12 + 1024) \cdot 4K$ 或 4144KB。</p>
<p>毫不奇怪，在这种方法中，您可能希望支持更大的文件。要做到这一点，<font color="red">只需向inode添加另一个指针：双间接指针。</font>该指针指向一个包含指向间接块的指针的块，每个间接块都包含对数据块的指针。因此，双间接块增加了通过额外 $1024 × 1024$ 或 100 万个 4KB 块来扩展文件的可能性，换句话说支持超过 4GB 大小的文件。然而您可能需要更多，并且我们打赌您知道这将导致什么：<strong>三重间接指针</strong>。</p>
<p>总体而言，这种不平衡树被称为多级索引方法来定位文件块。让我们以十二个直接指针为例进行研究，并且还有单间接块和双间接块。假设每个块大小为 4 KB，并且每个指针占用 4 字节，则该结构可以容纳略大于 4 GB 大小的文件（即 $(12 +  1024 + 1024^2) × 4 KB）$。您能计算出通过添加三重间接块可以处理多大尺寸的文件吗？（$1024^3$）</p>
<p>许多文件系统使用多级索引，其中包括常用文件系统如 Linux ext2和ext3、NetApp 的WAFL ，以及原始 UNIX 文件系统等等 。其他一些文件系统如 SGI XFS 和 Linux ext4 使用<strong>范围</strong>而不是简单指针（它们类似于虚拟内存讨论中段）。</p>
<blockquote>
<center>考虑基于范围的方法
</center>
<p>另一种方法是使用范围而不是指针。范围只是一个磁盘指针加上一个长度（以块为单位）；因此，不需要为文件的每个块提供一个指针，而只需要一个指针和一个长度来指定文件在磁盘上的位置。只有单个范围是有限的，因为在分配文件时可能很难找到磁盘上连续的可用空间块。因此，基于盘区的文件系统通常允许多个盘区，从而在文件分配期间为文件系统提供了更多的自由度。</p>
<p>比较这两种方法，基于指针的方法最灵活，但每个文件使用大量元数据（特别是对于大文件）。基于范围的方法不太灵活，但更紧凑；特别是，当磁盘上有足够的可用空间并且文件可以连续布置时（这实际上是任何文件分配策略的目标），它们可以很好地工作。</p>
</blockquote>
<p>您可能想知道：为什么要使用这样的不平衡树？为什么不采用其他方法呢？事实证明，许多研究人员研究了文件系统及其使用方式，几乎每次他们都会发现几十年来一直存在的某些“真理”。其中一项发现是大多数文件都很小。这种不平衡的设计反映了这样的现实；如果大多数文件确实很小，那么针对这种情况进行优化是有意义的。因此，使用少量的直接指针（典型数字为 12），一个 inode 可以直接指向 48 KB 的数据，而对于较大的文件则需要一个（或多个）间接块。Agrawal等人 最近的一项研究总结了这些结果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=small" data-sub-html="<h2>image-20240417143438784</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png" alt="image-20240417143438784" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_System_Measurement_Summary.png?size=large 2x" data-title="image-20240417143438784" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当然，在inode设计的空间中，还存在许多其他的可能性；毕竟，inode 只是一种数据结构，任何存储相关信息并能够有效查询的数据结构就足够了。由于文件系统软件很容易更改，因此如果工作负载或技术发生变化，您应该愿意探索不同的设计。</p>
<h2 id="目录组织" class="heading-element"><span>4 目录组织</span>
  <a href="#%e7%9b%ae%e5%bd%95%e7%bb%84%e7%bb%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在 vsfs 中（与许多文件系统一样），目录的组织很简单；目录基本上只包含（条目名称，inode number）对的列表。对于给定目录中的每个文件或目录，目录的数据块中有一个字符串和一个数字。对于每个字符串，也可能有一个长度（假设名称可变）。</p>
<p>例如，假设目录 <code>dir</code>（inode number为 5）中包含三个文件（<code>foo</code>、<code>bar</code> 和 <code>foobar_is_a_pretty_longname</code> ），inode number分别为 12、13 和 24。 <code>dir</code> 的磁盘数据可能如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=small" data-sub-html="<h2>image-20240417150136421</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png" alt="image-20240417150136421" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Dir_Disk_Data_Example.png?size=large 2x" data-title="image-20240417150136421" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，每个条目都有一个 inode number、记录长度（名称的总字节数加上任何剩余空间）、字符串长度（名称的实际长度），最后是条目的名称。请注意，每个目录都有两个额外的条目：<code>.</code>点 &ldquo;和<code>..</code>. &ldquo;点-点&rdquo;；点目录只是当前目录（本例中为 <code>dir</code>），而点-点是父目录（本例中为根目录）。</p>
<p>删除文件（例如调用 <code>unlink()</code>）可能会在目录中间留下一个空位，因此也应该有某种方法来标记这个空位（例如使用保留的 inode number，如 0）。这种删除是使用记录长度的原因之一：新的条目可能会重复使用旧的、更大的条目，因此会有额外的空间。</p>
<blockquote>
<center>基于链接的方法</center>
<p>设计 inode 的另一种更简单的方法是使用链表。因此，在inode内，您不需要多个指针，而只需要一个指针来指向文件的第一个块。要处理更大的文件，请在该数据块的末尾添加另一个指针，依此类推，这样就可以支持大文件。</p>
<p>正如您可能已经猜到的，链接文件分配对于某些工作负载来说表现不佳；例如，考虑读取文件的最后一个块，或者只是进行随机访问。因此，为了使链接分配更好地工作，一些系统将在内存中保留链接信息表，而不是将下一个指针与数据块本身一起存储。该表由数据块D的地址索引；条目的内容只是 D 的下一个指针，即文件中 D 后面的下一个块的地址。空值也可能存在（指示文件结束），或者其他一些标记来指示特定块是空闲的。拥有这样的下一个指针表使得链接分配方案可以有效地进行随机文件访问，只需首先扫描（在内存中）表以找到所需的块，然后直接访问（在磁盘上）它。</p>
<p>这样的表是不是听起来很熟悉？我们所描述的是<strong>文件分配表</strong>或 <strong>FAT</strong> 文件系统的基本结构。是的，这个经典的旧 Windows 文件系统（在 NTFS之前）基于简单的基于链接的分配方案。与标准 UNIX 文件系统还存在其他差异；例如，本身没有inodes，而是存储有关文件的元数据并直接引用该文件的第一个块的目录条目，这使得创建硬链接变得不可能。</p>
</blockquote>
<p>您可能想知道目录到底存储在哪里。通常，文件系统将目录视为一种特殊类型的文件。因此，<font color="red">目录在 inode 表中的某个位置有一个 inode（inode 的 type 字段标记为“目录”而不是“常规文件”）。</font>该目录具有inode指向的数据块（也许还有间接块）；这些数据块位于我们简单文件系统的数据块区域中。因此，我们的磁盘结构保持不变。</p>
<p>我们还应该再次注意，这个简单的线性目录条目列表并不是存储此类信息的唯一方法。和以前一样，任何数据结构都是可能的。例如，XFS以 B 树形式存储目录，使文件创建操作（必须确保文件名在创建之前未使用过）比具有必须在其目录中完整扫描的简单列表的系统更快。</p>
<h2 id="空闲空间管理" class="heading-element"><span>5 空闲空间管理</span>
  <a href="#%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>文件系统必须跟踪哪些 inodes 和数据块是空闲的，哪些不是，以便在分配新文件或目录时能为其找到空间。因此，<strong>空闲空间管理</strong>对所有文件系统都很重要。在 vsfs 中，我们有两个简单的位图可以完成这项任务。</p>
<p>例如，当我们创建一个文件时，必须为该文件分配一个 inode。因此，文件系统将在位图中搜索空闲的 inode，并将其分配给文件；文件系统必须将 inode 标记为已用（用 1 表示），并最终用正确的信息更新磁盘位图。在分配数据块时，也会进行类似的操作。</p>
<p>在为新文件分配数据块时，还可能需要考虑一些其他因素。例如，一些 Linux 文件系统（如 <code>ext2</code> 和 <code>ext3</code>）在创建新文件并需要数据块时，会寻找一连串空闲的块（如 8 个）；通过找到这样一连串空闲的块，然后将它们分配给新创建的文件，文件系统可以保证文件的一部分在磁盘上是连续的，从而提高性能。因此，这种预分配策略是为数据块分配空间时常用的启发式方法。</p>
<blockquote>
<p>管理可用空间的方法有很多种；位图只是一种方式。一些早期的文件系统使用空闲列表，其中超级块中的单个指针被保留指向第一个空闲块；在该块内，保留下一个空闲指针，从而形成系统空闲块的列表。当需要一个块时，使用头块并相应地更新列表。</p>
<p>现代文件系统使用更复杂的数据结构。例如，SGI 的 XFS使用某种形式的 B 树来紧凑地表示磁盘的哪些块是空闲的。与任何数据结构一样，不同的时空权衡都是可能的。</p>
</blockquote>
<h2 id="访问路径读写" class="heading-element"><span>6 访问路径：读写</span>
  <a href="#%e8%ae%bf%e9%97%ae%e8%b7%af%e5%be%84%e8%af%bb%e5%86%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>既然我们对文件和目录在磁盘上的存储方式有了一定的了解，我们就应该能够在读取或写入文件的过程中跟踪操作流程。因此，了解访问路径上发生的事情是理解文件系统如何工作的第二个关键；请注意！</p>
<p>在下面的示例中，我们假设文件系统已经加载，因此超级块已经在内存中。其他一切（即 inodes、目录）仍在磁盘上。</p>
<h3 id="从磁盘读取文件" class="heading-element"><span>6.1 从磁盘读取文件</span>
  <a href="#%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在这个简单的示例中，我们首先假设您只想简单地打开一个文件（例如 <code>/foo/bar</code>），读取它，然后关闭它。对于这个简单的示例，我们假设文件大小仅为 12KB（即 3 个块）。</p>
<p>当发出 <code>open(&quot;/foo/bar&quot;, O RDONLY)</code> 调用时，文件系统首先需要找到文件 <code>bar</code> 的 <code>inode</code>，以获取有关文件的一些基本信息（权限信息、文件大小等） 。为此，文件系统必须能够找到inode，但它现在拥有的只是完整路径名。文件系统必须遍历路径名，从而找到所需的inode。</p>
<p>所有遍历都从文件系统的根目录（简称为 <code>/</code>）开始。因此，FS首先从磁盘读取的是根目录的inode。但是这个索引节点在哪里呢？要找到一个 inode，我们必须知道它的 i-number。通常，我们在其父目录中查找文件或目录的 i-number；根没有父父目录（根据定义）。因此，根 inode number必须是“众所周知的”；当文件系统被挂载时，FS必须知道它是什么。在大多数 UNIX 文件系统中，根 inode number为 2。因此，为了开始该过程，FS 读取包含 inode number为2 的块（第一个 inode 块）。</p>
<p>一旦读入 inode，FS 就可以在其中查找指向数据块的指针，其中包含根目录的内容。因此，FS 将使用这些磁盘上的指针来读取目录，在本例中查找 <code>foo</code> 的条目。通过读入一个或多个目录数据块，它将找到 <code>foo</code> 的条目；一旦找到，FS 也将找到接下来需要的 <code>foo</code> 的 inode number（假设是 44）。</p>
<p>下一步是递归遍历路径名，直到找到所需的 inode。在这个例子中，FS读取包含<code>foo</code>的inode的块，然后读取其目录数据，最后找到<code>bar</code>的inode number。 <code>open()</code> 的最后一步是将 <code>bar</code> 的 inode 读入内存；然后，FS 进行<strong>最终的权限检查</strong>，在每个进程的打开文件表中为此进程分配一个文件描述符，并将其返回给用户。</p>
<p>打开后，程序可以发出 <code>read()</code> 系统调用来读取文件。因此，第一次读取（在偏移量 0 处，除非已调用 <code>lseek()</code>）将读取文件的第一个块，并查询 <code>inode</code> 以查找该块的位置；它还可能用新的上次访问时间更新inode。读取将进一步更新该文件描述符的内存中打开文件表，更新文件偏移量，以便下一次读取将读取第二个文件块等。</p>
<p>在某个时刻，文件将被关闭。这里要做的工作要少得多；显然，文件描述符应该被释放，但现在，这就是 FS 真正需要做的。不发生任何磁盘 I/O。</p>
<p>下图描述了整个过程；时间在图中向下增加。在图中，打开文件会导致发生大量读取，以便最终找到文件的 inode。之后，读取每个块需要文件系统首先查看 inode，然后读取该块，然后通过写入更新 inode 的上次访问时间字段。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=small" data-sub-html="<h2>image-20240417154339356</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png" alt="image-20240417154339356" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Read_Timeline_Example.png?size=large 2x" data-title="image-20240417154339356" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>另请注意，打开操作生成的 I/O 量与路径名的长度成正比。对于路径中的每个附加目录，我们必须读取其inode及其数据。大型目录的存在会使情况变得更糟；在这里，我们只需要读取一个数据块来获取目录的内容，而对于一个大目录，我们可能需要读取许多数据块才能找到所需的条目。</p>
<h3 id="从磁盘写入文件" class="heading-element"><span>6.2 从磁盘写入文件</span>
  <a href="#%e4%bb%8e%e7%a3%81%e7%9b%98%e5%86%99%e5%85%a5%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>写入文件的过程与此类似。首先，必须打开文件（如上所述）。然后，应用程序可以发出 <code>write()</code> 调用，用新内容更新文件。最后，关闭文件。</p>
<p>与读取不同的是，向文件写入也可能<strong>分配</strong>一个数据块（除非该数据块被覆盖等）。在写入一个新文件时，每次写入不仅要向磁盘写入数据，还要首先决定向文件分配哪个块，并相应地更新磁盘的其他结构（如数据位图和 inode）。因此，对文件的每次写入在逻辑上会产生 5 次 I/O：</p>
<ul>
<li>一次读取数据位图（然后更新数据位图，将新分配的块标记为已使用）；</li>
<li>一次写入数据位图（将其新状态反映到磁盘上）；</li>
<li>两次读取并写入 inode（根据新块的位置更新 inode）；</li>
<li>最后一次写入实际块本身。</li>
</ul>
<p>如果考虑到创建文件这种简单而常见的操作，写入流量甚至会更大。要创建一个文件，文件系统不仅要分配一个 inode，还要在包含新文件的目录中分配空间。这样做的 I/O 总流量相当大：</p>
<ul>
<li>一次读取 inode 位图（查找空闲的 inode）；</li>
<li>一次写入 inode 位图（标记已分配）；</li>
<li>一次写入新 inode 本身（初始化）；</li>
<li>一次写入目录数据（将文件的高级名称与其 inode number联系起来）；</li>
<li>以及一次读取和写入目录 inode 以更新它。</li>
</ul>
<p>如果目录需要增长以容纳新的条目，还需要额外的 I/O（即数据位图和新目录块）。所有这些都只是为了创建一个文件！</p>
<p>让我们看一个具体的示例，其中创建了文件 <code>/foo/bar</code>，并向其中写入了三个块。下图显示了 <code>open()</code>（创建文件）期间以及三个 4KB 写入的每一个期间发生的情况。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=small" data-sub-html="<h2>image-20240417160026092</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png" alt="image-20240417160026092" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Creation_Timeline_Example.png?size=large 2x" data-title="image-20240417160026092" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在图中，对磁盘的读取和写入按照引起它们发生的系统调用进行分组，并且它们可能发生的粗略顺序从图的顶部到底部。您可以看到创建文件的工作量：在本例中需要 10 个 I/O，遍历路径名，然后最终创建文件。您还可以看到，每次分配写入都会花费 5 个 I/O：一对读取和更新 inode，另一对读取和更新数据位图，最后写入数据本身。</p>
<p>文件系统如何以合理的效率完成这些任务？即使是最简单的操作，如打开、读取或写入文件，也会产生大量分散在磁盘上的 I/O 操作。文件系统如何才能降低这么多 I/O 操作带来的高昂成本呢？</p>
<h2 id="缓存和缓冲" class="heading-element"><span>7 缓存和缓冲</span>
  <a href="#%e7%bc%93%e5%ad%98%e5%92%8c%e7%bc%93%e5%86%b2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正如上面的例子所示，读写文件的成本很高，需要对（慢速）磁盘进行多次 I/O。大多数文件系统都会积极使用系统内存（DRAM）来缓存重要的数据块，以解决明显存在的巨大性能问题。</p>
<p>想象一下上面的打开示例：如果没有缓存，每次打开文件都需要对目录层次结构中的每一级进行至少两次读取（一次读取相关目录的 inode，至少一次读取其数据）。对于长路径名（例如，<code>/1/2/3/.../100/file.txt</code>），文件系统光是打开文件就需要执行数百次读取！</p>
<p>因此，早期的文件系统引入了<strong>固定大小的缓存</strong>来保存常用数据块。就像我们在讨论虚拟内存时一样，LRU 等策略和不同的变体将决定在缓存中保留哪些区块。这种固定大小的缓存通常在启动时分配，大约占总内存的 10%。</p>
<p>然而，这种<strong>静态的内存分区</strong>可能会造成浪费；如果文件系统在某个时间点不需要 10%的内存怎么办？如果采用上述固定大小的方法，文件缓存中未使用的页面就无法重新用于其他用途，从而造成浪费。</p>
<p>相比之下，现代系统采用的<strong>是动态分区方法</strong>。具体来说，许多现代操作系统<font color="red">将虚拟内存页和文件系统页整合到统一的页面缓存中。</font>这样，内存就可以更灵活地分配给虚拟内存和文件系统，具体取决于哪个系统在特定时间需要更多内存。</p>
<blockquote>
<center>了解静态与静态动态分区
</center>
<p>在不同的客户端/用户之间划分资源时，可以使用<strong>静态分区或动态分区</strong>。静态方法只是将资源一次划分为固定比例；例如，如果有两个可能的内存用户，您可以将一些固定部分的内存分配给一个用户，并将其余部分分配给另一个用户。动态方法更加灵活，随着时间的推移提供不同数量的资源；例如，一个用户可能在一段时间内获得较高百分比的磁盘带宽，但随后，系统可能会切换并决定为不同的用户提供更大比例的可用磁盘带宽。</p>
<p>每种方法都有其优点。静态分区可确保每个用户获得一定的资源份额，通常可以提供更可预测的性能，并且通常更容易实现。动态分区可以实现更好的利用率（通过让资源匮乏的用户消耗原本空闲的资源），但实现起来可能更复杂，并且如果用户的闲置资源被其他用户占用，在需要时需要很长时间才能收回，则会导致性能下降。通常情况下，没有最好的方法；相反，你应该思考手头的问题，然后决定哪种方法最合适。</p>
</blockquote>
<p>现在想象一下带缓存的文件打开示例。第一次打开可能会产生大量的 I/O 流量来读取目录 inode 和数据，但同一文件（或同一目录中的文件）的后续文件打开大部分会在缓存中进行，因此不需要 I/O。</p>
<p>我们还要考虑缓存对写入的影响。如果缓存足够大，就可以完全避免读取 I/O，而写入流量必须进入磁盘才能持久化。因此，缓存对写入流量的过滤器与对读取流量的过滤器不同。也就是说，写缓冲确实具有许多性能优势。</p>
<ul>
<li>首先，<font color="red">通过延迟写入，文件系统可以将一些更新批处理到较小的一组 I/O 中</font>；例如，如果在创建一个文件时更新inode位图，然后在创建另一个文件时更新inode位图，则文件系统会通过在第一次更新后延迟写入来节省 I/O。</li>
<li>其次，<font color="red">通过在内存中缓冲大量写入，系统可以调度后续 I/O，从而提高性能。</font></li>
<li>最后，<font color="red">有些写入可以通过延迟来完全避免。例如，如果应用程序创建了一个文件然后将其删除，则延迟写入以将文件创建反映到磁盘可以完全避免它们。</font>在这种情况下，懒惰（将块写入磁盘）是一种美德。</li>
</ul>
<p>基于上述原因，大多数现代文件系统都会在内存中缓冲写入 5 到 30 秒，这也是另一种权衡：如果系统在更新传播到磁盘之前崩溃，更新就会丢失；但是，如果在内存中保留更长时间，就可以通过批处理、调度甚至避免写入来提高性能。</p>
<blockquote>
<center>了解持久/性能的权衡</center>
<p>存储系统通常会向用户提供持久/性能的权衡。如果用户希望写入的数据立即持久，系统必须全力将新写入的数据提交到磁盘，因此写入速度很慢（但安全）。但是，如果用户可以容忍少量数据的丢失，系统可以在内存中缓冲写入一段时间，然后将其写入磁盘（在后台）。这样做会使写入看起来很快完成，从而提高感知性能；但是，如果发生崩溃，尚未提交到磁盘的写入将会丢失，因此需要进行权衡。要了解如何正确进行这种权衡，最好了解使用存储系统的应用程序需要什么；例如，虽然丢失网络浏览器下载的最后几张图像可能是可以容忍的，但丢失向您的银行帐户添加资金的数据库事务的一部分可能会更难以容忍。</p>
</blockquote>
<p>有些应用程序（如数据库）并不喜欢这种权衡。因此，为了避免因写入缓冲而造成意外数据丢失，它们只需通过调用<code>fsync()</code>、使用绕过缓存的<strong>直接 I/O 接口</strong>或使用<strong>原始磁盘接口</strong>来强制写入磁盘，从而完全避开文件系统。虽然大多数应用程序都能接受文件系统的取舍，但如果默认情况不能令人满意，也有足够的控制措施让系统按照你的意愿行事。</p>
]]></description></item><item><title>文件和目录</title><link>https://hezephyr.github.io/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</link><pubDate>Sat, 11 May 2024 21:04:20 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</guid><description><![CDATA[<h2 id="文件和目录" class="heading-element"><span>1 文件和目录</span>
  <a href="#%e6%96%87%e4%bb%b6%e5%92%8c%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>随着时间的推移，在存储虚拟化过程中形成了两个关键的抽象概念。第一个是文件。文件只是一个由字节组成的线性数组，每个字节都可以读写。每个文件都有某种底层名称，通常是某个数字；通常情况下，用户并不知道这个名称（我们将看到）。由于历史原因，文件的底层名称通常被称为其inode number（索引节点号）。</p>
<p>在大多数系统中，操作系统并不了解文件的结构（例如，它是图片、文本文件还是 C 代码）；相反，<font color="red">文件系统的职责仅仅是将这些数据持久地存储在磁盘上</font>，并确保当你再次请求数据时，你能得到当初放在那里的数据。做到这一点并不像看起来那么简单！</p>
<p>第二个抽象概念是目录。目录和文件一样，也有一个底层名称（即inode number），但其内容却非常具体：它包含一个（用户可读名称、底层名称）对列表。例如，假设有一个底层名称为 &ldquo;10 &ldquo;的文件，用户可读文件名为 &ldquo;foo&rdquo;。因此，&ldquo;foo &ldquo;所在的目录就会有一个条目（&ldquo;foo&rdquo;, &ldquo;10&rdquo;），将用户可读名称映射到底层名称。<font colro="red">目录中的每个条目都指向文件或其他目录</font>。通过将目录放置在其他目录中，用户可以建立一个任意的目录树（或目录层次结构），所有文件和目录都存储在该目录下。</p>
<p>目录层次结构从根目录开始（在基于 UNIX 的系统中，根目录简称为 <code>/</code>），并使用某种分隔符来命名随后的子目录，直到所需的文件或目录被命名为止。例如，如果用户在根目录<code>/</code>中创建了一个目录 <code>foo</code>，然后在目录 <code>foo</code> 中创建了一个文件 <code>bar.txt</code>，我们可以通过其<strong>绝对路径名</strong>来引用该文件，在本例中为 <code>/foo/bar.txt</code> 。更复杂的目录树如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=small" data-sub-html="<h2>image-20240416102432763</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png" alt="image-20240416102432763" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Directory_Tree_Example_1.png?size=large 2x" data-title="image-20240416102432763" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>示例中的有效目录为 <code>/</code>、<code>/foo</code>、<code>/bar</code>、<code>/bar/bar</code>、<code>/bar/foo</code>，有效文件为 <code>/foo/bar.txt</code> 和 <code>/bar/foo/bar.txt</code>。目录和文件可以具有相同的名称，只要它们位于文件系统树中的不同位置即可（例如，图中有两个名为 <code>bar.txt</code> 的文件，<code>/foo/bar.txt</code> 和 <code>/bar/foo/bar.txt</code>）。</p>
<p>您可能还注意到，此示例中的文件名通常由两部分组成：<code>bar</code> 和 <code>txt</code>，以<code>.</code>分隔。第一部分是任意名称（描述文件），而文件名的第二部分通常用于指示文件的类型，例如，它是 C 代码（例如<code>.c</code>）还是图像（例如 <code>.jpg</code>） ，或音乐文件（例如<code>.mp3</code>）。然而，这通常只是一个约定：通常没有强制规定名为 <code>main.c</code> 的文件中包含的数据确实是 C 源代码。</p>
<p>因此，我们可以看到文件系统提供的一件伟大的事情：一种命名我们感兴趣的所有文件的便捷方法。名称在系统中很重要，因为访问任何资源的第一步就是能够命名它。因此，在 UNIX 系统中，文件系统提供了一种统一的方式来访问磁盘、U盘、CD-ROM、许多其他设备以及事实上还有许多其他东西，它们都位于同一个目录树下。</p>
<h2 id="文件系统接口" class="heading-element"><span>2 文件系统接口</span>
  <a href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="文件操作" class="heading-element"><span>2.1 文件操作</span>
  <a href="#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="创建文件" class="heading-element"><span>2.1.1 创建文件</span>
  <a href="#%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们将从最基本的操作开始：创建文件。这可以通过 <code>open</code> 系统调用来实现；调用 <code>open()</code> 并传递 <code>O_CREAT</code> 标志，程序就可以创建一个新文件。下面是一些示例代码，用于在当前工作目录下创建一个名为 &ldquo;foo &ldquo;的文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>例程<code>open()</code> 使用多个不同的标志。在本例中，如果文件不存在，第二个参数会创建文件（<code>O_CREAT</code>），确保该文件只能被写入（<code>O_WRONLY</code>），并且如果文件已经存在，则将其截断为 0 字节大小，从而删除任何现有内容（<code>O_TRUNC</code>）。第三个参数指定权限，在这种情况下，文件所有者可以读写文件。</p>
<p><code>open()</code> 的一个重要方面是它的返回值：<strong>文件描述符</strong>。<font color="red">文件描述符只是一个整数，每个进程都是私有的，在 UNIX 系统中用于访问文件</font>；因此，一旦文件被打开，你就可以使用文件描述符来读取或写入文件，前提是你有这样做的权限。因此，文件描述符是一种能力，即一个不透明的句柄，它赋予你执行某些操作的权力。另一种将文件描述符视为指向文件类型对象的指针的方法是：一旦你有了这样一个对象，你就可以调用其他 &ldquo;方法 &ldquo;来访问文件，如<code>read()</code>和 <code>write()</code>。如上所述，文件描述符由操作系统按进程进行管理。这意味着在 UNIX 系统的 <code>proc</code> 结构中保存了某种简单的结构（如数组）。下面是 xv6 内核中的相关内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">proc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span> <span class="c1">// Open files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一个简单数组（最多包含 <code>NOFILE</code> 打开的文件）可以跟踪每个进程打开了哪些文件。数组的每个条目实际上只是一个指向<code>struct file</code>的指针，它将用于跟踪正在读取或写入的文件信息。</p>
<h4 id="读写文件" class="heading-element"><span>2.1.2 读写文件</span>
  <a href="#%e8%af%bb%e5%86%99%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><h5 id="顺序读写" class="heading-element"><span>2.1.2.1 顺序读写</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e8%af%bb%e5%86%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>有了一些文件后，我们当然会想读取或写入它们，让我们从读取一个现有文件开始。如果我们在命令行中输入，我们可能只使用程序 <code>cat</code> 将文件的内容转储到屏幕上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s1">&#39;Hello, World&#39;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; cat foo
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>在此代码片段中，我们将程序 <code>echo</code> 的输出重定向到文件 <code>foo</code>，然后该文件中包含内容“Hello, World”。然后我们使用 <code>cat</code> 来查看文件的内容。但是<code>cat</code>程序如何访问文件<code>foo</code>呢？</p>
<p>为了找到这一点，我们将使用一个非常有用的工具来跟踪程序进行的系统调用。在 Linux 上，该工具称为 <code>strace</code>；其他系统也有类似的工具（请参阅 Mac 上的 <code>dtruss</code>，或某些较旧的 UNIX 变体上的 <code>truss</code>）。 <code>strace</code> 的作用是跟踪程序运行时所做的每个系统调用，并将跟踪转储到屏幕上供您查看。</p>
<p>下面是一个使用 <code>strace</code> 来确定 <code>cat</code> 正在做什么的示例（为了便于阅读，删除了一些调用）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; strace cat foo
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">openat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;foo&#34;</span>, O_RDONLY<span class="p">|</span>O_LARGEFILE<span class="o">)</span>       <span class="o">=</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">read<span class="o">(</span>3, <span class="s2">&#34;Hello, World\n&#34;</span>, 131072<span class="o">)</span>       <span class="o">=</span> <span class="m">13</span>
</span></span><span class="line"><span class="cl">write<span class="o">(</span>1, <span class="s2">&#34;Hello, World\n&#34;</span>, 13<span class="o">)</span>          <span class="o">=</span> <span class="m">13</span>
</span></span><span class="line"><span class="cl">Hello, World
</span></span><span class="line"><span class="cl">read<span class="o">(</span>3, <span class="s2">&#34;&#34;</span>, 131072<span class="o">)</span>                     <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">close<span class="o">(</span>3<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">+++ exited with <span class="m">0</span> +++</span></span></code></pre></td></tr></table>
</div>
</div><p>cat 做的第一件事是打开文件进行读取。我们应该注意以下几点：</p>
<ol>
<li>首先，该文件仅打开用于读取（而不是写入），如 <code>O_RDONLY 标志</code>所示；</li>
<li>其次，使用 64 位偏移量 (<code>O_LARGEFILE</code>)；</li>
<li>第三，对 <code>openat()</code>（和<code>oepn()</code>一样）的调用成功并返回一个文件描述符，其值为 3。</li>
</ol>
<p>为什么第一次调用 <code>openat()</code> 返回 3，而不是您可能期望的 0 或 1？事实证明，<font color="red">每个正在运行的进程已经打开了三个文件：标准输入（进程可以读取以接收输入）、标准输出（进程可以写入以将信息转储到屏幕）和标准错误（进程可以向其写入错误消息）</font>。它们分别由文件描述符 0、1 和 2 表示。因此，当您第一次打开另一个文件时（如上面的 cat 所做的那样），它几乎肯定是文件描述符 3。</p>
<p>打开成功后，<code>cat</code> 会使用 <code>read()</code> 系统调用从文件中重复读取一些字节。</p>
<ol>
<li><code>read()</code> 的第一个参数是文件描述符，它告诉文件系统要读取哪个文件；当然，一个进程可能同时打开多个文件，因此描述符能让操作系统知道某个特定读取指向哪个文件。</li>
<li>第二个参数指向一个缓冲区，<code>read()</code>的结果将放置在这个缓冲区中；在上面的系统调用跟踪中，<code>strace</code> 在这个位置（&ldquo;Hello, World&rdquo;）显示了读取的结果。</li>
<li>第三个参数是缓冲区的大小，在本例中为 131072 B。对 <code>read()</code> 的调用也成功返回，这里返回的是读取的字节数（13，其中 12 个字节表示 &ldquo;Hello, World&quot;中的字符，1 个字节表示行结束标记）。</li>
</ol>
<p>此时，你会看到 <code>strace</code> 的另一个有趣结果：对 <code>write()</code> 系统调用的一次调用，调用的是文件描述符 1。如上文所述，这个描述符被称为标准输出，因此它被用来将 &ldquo;Hello, World&quot;这个字符串写到屏幕上，就像 <code>cat</code> 程序要做的那样。但它会直接调用 <code>write()</code> 吗？也许会（如果高度优化的话）。但如果没有，<code>cat</code>程序可能会调用库例程 <code>printf()</code>；<code>printf()</code> 会在内部计算出传给它的所有格式细节，并最终写入标准输出，将结果打印到屏幕上。</p>
<p>然后，<code>cat</code> 程序尝试从文件中读取更多信息，但由于文件中已经没有字节了，<code>read()</code> 返回 <code>0</code>，程序知道这意味着它已经读完了整个文件。因此，程序会调用 <code>close()</code> 来表示它已经读完了文件 &ldquo;foo&rdquo;，并传入相应的文件描述符。文件就这样关闭了，文件的读取也就完成了。</p>
<p>写文件的步骤与此类似。首先，打开一个文件进行写入，然后调用 <code>write()</code> 系统调用，对于较大的文件，可能会重复调用，最后关闭 <code>write()</code>。使用 <code>strace</code> 来跟踪对文件的写入，或许是跟踪你自己编写的程序，或许是跟踪 <code>dd</code> 工具，例如 <code>dd if=foo of=bar</code>（从文件<code>foo</code>中读取数据，并将其写入到文件<code>bar</code>中）。</p>
<h5 id="非顺序读写" class="heading-element"><span>2.1.2.2 非顺序读写</span>
  <a href="#%e9%9d%9e%e9%a1%ba%e5%ba%8f%e8%af%bb%e5%86%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>到目前为止，我们已经讨论了如何读取和写入文件，但所有访问都是顺序的；也就是说，我们要么从头到尾读取一个文件，要么从头到尾写出一个文件。</p>
<p>然而，有时能够读取或写入文件中的特定偏移量是很有用的。例如，如果您在文本文档上构建索引，并使用它来查找特定单词，您最终可能会从文档中的一些随机偏移量中读取。为此，我们将使用 <code>lseek()</code> 系统调用。这是函数原型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>第一个参数是<code>filedes</code>的（文件描述符）。</li>
<li>第二个参数是<code>offset</code>，它将文件偏移量定位到文件中的特定位置。</li>
<li>第三个参数由于历史原因被称为 <code>whence</code>，它决定了寻找的具体执行方式。摘自<code>man  page: man lseek</code>：
<ul>
<li>如果<code>whence</code>是<code>SEEK_SET</code>，则偏移量设置为偏移字节。</li>
<li>如果<code>whence</code>是<code>SEEK_CUR</code>，则偏移量设置为其当前位置加上偏移字节。</li>
<li>如果<code>whence</code>是<code>SEEK_END</code>，则偏移量设置为文件的大小加上偏移量字节。</li>
</ul>
</li>
</ul>
<blockquote>
<center>数据结构——打开文件表</center>
<p><font color="red">每个进程都维护一个文件描述符数组，每个文件描述符都引用系统范围的<strong>打开文件表</strong>中的一个条目。</font>该表中的每个条目都会跟踪描述符引用的底层文件、当前偏移量以及其他相关详细信息，例如文件是否可读或可写。</p>
</blockquote>
<p>从上述描述中可以看出，对于进程打开的每个文件，操作系统都会跟踪一个 &ldquo;当前 &ldquo;偏移量，该偏移量决定了下一次读取或写入将从文件的哪个位置开始。因此，<font color="red">打开文件的抽象概念之一就是它有一个当前偏移量，该偏移量通过两种方式之一进行更新</font>。</p>
<ul>
<li>第一种方式是，当读取或写入 $N$ 个字节时，$N$ 会添加到当前偏移量中；<font color="red">因此每次读取或写入都会隐式更新偏移量</font>。</li>
<li>第二种方式是通过 <code>lseek</code> 来显式更新偏移量，如上文所述。</li>
</ul>
<p>正如你可能已经猜到的，偏移量保存在我们之前看到的<code>struct file</code>中，由 <code>struct proc</code> 引用。下面是该结构的 xv6（简化）定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">readable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">writable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正如您在该结构中所看到的，操作系统可以使用它来确定打开的文件是否可读或可写（或两者）、它引用的底层文件（由 <code>struct inode</code> 指针 <code>ip</code> 指向）以及当前偏移量（<code>off</code>）。还有一个引用计数（<code>ref</code>），我们将在下面进一步讨论。</p>
<p>这些文件结构代表了系统中当前打开的所有文件；它们有时一起称为打开文件表。 xv6 内核也将它们保留为数组，每个条目有一个锁，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">file</span> <span class="n">file</span><span class="p">[</span><span class="n">NFILE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">ftable</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们通过几个例子来更清楚地说明这一点。首先，让我们跟踪一个打开文件（大小为 300 字节）并通过重复调用 <code>read()</code> 系统调用来读取该文件的进程，每次读取 100 字节。以下是相关系统调用的跟踪，以及每个系统调用返回的值，以及此文件访问的打开文件表中的当前偏移量的值：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=small" data-sub-html="<h2>image-20240416142836821</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png" alt="image-20240416142836821" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_2.png?size=large 2x" data-title="image-20240416142836821" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>跟踪中有几项值得注意。</p>
<ol>
<li>首先，您可以看到打开文件时当前偏移量如何初始化为零。</li>
<li>接下来，您可以看到它是如何随着进程的每次 <code>read()</code> 递增的；这使得进程可以轻松地继续调用 <code>read()</code> 来获取文件的下一个块。</li>
<li>最后，您可以看到最后尝试的 <code>read()</code> 超过文件末尾如何返回零，从而向进程表明它已完整读取文件。</li>
</ol>
<p>让我们跟踪一个打开同一个文件两次并向每个文件发出读取的进程。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=small" data-sub-html="<h2>image-20240416143511054</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png" alt="image-20240416143511054" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_3.png?size=large 2x" data-title="image-20240416143511054" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在此示例中，分配了两个文件描述符（3 和 4），每个描述符都引用打开文件表中的不同条目（在本示例中，条目 <code>10</code> 和 <code>11</code>，如表标题所示；OFT 代表打开文件表）。如果您跟踪所发生的情况，您可以看到每个当前偏移量是如何独立更新的。</p>
<p>在最后一个示例中，进程在读取之前使用 <code>lseek()</code> 重新定位当前偏移量；在这种情况下，只需要一个打开文件表条目（与第一个示例相同）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=small" data-sub-html="<h2>image-20240416143932186</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png" alt="image-20240416143932186" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Trace_System_Call_Example_4.png?size=large 2x" data-title="image-20240416143932186" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这里，<code>lseek()</code> 调用首先将当前偏移量设置为 200。随后的 <code>read()</code> 读取接下来的 50 个字节，并相应地更新当前偏移量。</p>
<blockquote>
<center>调用 LSEEK()不执行磁盘寻道</center>
<p><code>lseek()</code> 调用只是简单地改变操作系统内存中的一个变量，该变量跟踪了特定进程下一次读取或写入将从哪个偏移开始。当向磁盘发出读取或写入请求时，如果不在与上次读取或写入相同磁道上，则会发生磁头移动，这就是磁盘寻道。更令人困惑的是，通过调用 <code>lseek()</code> 从文件的随机部分进行读取或写入，并且接着对这些随机部分进行读取/写入，确实会导致更多的磁盘寻道。因此，调用<code>lseek()</code> 确实可能导致在即将进行的读取或写入中产生一次寻道，但绝对不会引起任何磁盘 I/O 操作本身发生。</p>
</blockquote>
<h4 id="共享文件表条目" class="heading-element"><span>2.1.3 共享文件表条目</span>
  <a href="#%e5%85%b1%e4%ba%ab%e6%96%87%e4%bb%b6%e8%a1%a8%e6%9d%a1%e7%9b%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在许多情况下（如上面的示例所示），文件描述符到打开文件表中的条目的映射是一对一的映射。例如，当一个进程运行时，它可能决定打开一个文件，读取它，然后关闭它；在此示例中，该文件将在打开的文件表中具有唯一的条目。<font color="red">即使其他进程同时读取同一个文件，每个进程也会在打开的文件表中拥有自己的条目</font>。这样，文件的每次逻辑读取或写入都是独立的，并且每次访问给定文件时都有自己的当前偏移量。</p>
<p>然而，有一些有趣的情况，打开文件表中的条目是共享的。其中一种情况发生在父进程使用 <code>fork()</code> 创建子进程时。下面显示了一个小代码片段，其中父级创建了一个子级，然后等待它完成。子进程通过调用 <code>lseek()</code> 调整当前偏移量，然后退出。最后，父进程在等待子进程后，检查当前偏移量并打印出其值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;file.txt&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">rc</span> <span class="o">=</span> <span class="nf">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child: offset %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: offset %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nf">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当我们运行这个程序时，我们会看到以下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ make fork-seek
</span></span><span class="line"><span class="cl">gcc -c fork-seek.c
</span></span><span class="line"><span class="cl">gcc fork-seek.o -o fork-seek
</span></span><span class="line"><span class="cl">❯ ./fork-seek
</span></span><span class="line"><span class="cl">child: offset <span class="m">10</span>
</span></span><span class="line"><span class="cl">parent: offset <span class="m">10</span></span></span></code></pre></td></tr></table>
</div>
</div><p>下图显示了连接每个进程私有描述符数组、共享打开文件表条目以及从它到底层文件系统 inode 的引用的关系。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Processes_Sharing_An_Open_File_Table_Entry.png" alt="image-20240416145540776" style="zoom:67%;" />
<p>请注意，我们最终在这里使用了<strong>引用计数</strong>。<font color="red">当文件表项被共享时，其引用计数会增加；只有当两个进程都关闭该文件（或退出）时，该条目才会被删除。</font></p>
<p>在父进程和子进程之间共享打开的文件表条目有时很有用。例如，如果您创建多个协作处理某项任务的进程，它们可以写入同一输出文件，而无需任何额外的协调。有关调用 <code>fork()</code> 时进程共享的内容的更多信息，请参阅手册页：<code>man fork</code>。</p>
<p>另一种有趣且可能更有用的共享情况发生在<code>dup()</code> 系统调用（及其非常相似的系统调用<code>dup2()</code> 甚至 <code>dup3()</code>）中。</p>
<p><code>dup()</code>调用允许进程创建一个新的文件描述符，该文件描述符引用与现有描述符相同的底层打开文件。下面这个代码片段展示了如何使用 <code>dup()</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;README&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd2</span> <span class="o">=</span> <span class="nf">dup</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 现在 fd 和 fd2 可以互换使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>dup()</code> 调用（特别是 <code>dup2()</code>）在编写 UNIX shell 和执行输出重定向等操作时非常有用，有以下几点：</p>
<ol>
<li><strong>标准流重定向：</strong> 在 shell 编程中，通常需要将标准输入、标准输出和标准错误流重定向到文件或者其他进程的管道中。通过 <code>dup()</code> 函数，可以复制文件描述符，并将其与标准流相关联，从而实现输出重定向操作。</li>
<li><strong>管道通信：</strong> 在 shell 中，管道用于将一个进程的输出连接到另一个进程的输入，以实现进程之间的通信。<code>dup()</code> 函数可以用于复制文件描述符，从而创建管道的输入和输出端口。</li>
<li><strong>文件描述符管理：</strong> 在大型 shell 脚本中，可能会涉及到大量的文件描述符操作。通过 <code>dup()</code> 函数，可以更方便地管理文件描述符，使得代码更加清晰易读。</li>
</ol>
<h4 id="使用-fsync-立即写入" class="heading-element"><span>2.1.4 使用 <code>fsync()</code> 立即写入</span>
  <a href="#%e4%bd%bf%e7%94%a8-fsync-%e7%ab%8b%e5%8d%b3%e5%86%99%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">大多数时候，当程序调用 <code>write()</code> 时，它只是告诉文件系统：请在将来的某个时刻将此数据写入持久存储</font>。出于性能原因，文件系统会将此类写入在内存中缓冲一段时间（例如 5 秒或 30 秒）；在稍后的时间点，写入实际上将被发送到存储设备。从调用应用程序的角度来看，写入似乎很快完成，并且只有在极少数情况下（例如，在 <code>write()</code> 调用之后但在写入磁盘之前机器崩溃）才会丢失数据。</p>
<p>然而，某些应用程序需要的不仅仅是这个最终保证。例如，在数据库管理系统（DBMS）中，正确的恢复协议的开发需要能够不时地强制写入磁盘。</p>
<p>为了支持这些类型的应用程序，大多数文件系统提供了一些额外的控制 API。在 UNIX 世界中，提供给应用程序的接口称为 <code>int fsync(int fd)</code>。当进程为特定文件描述符调用 <code>fsync()</code> 时，文件系统会通过将指定文件描述符引用的文件的所有<strong>脏（即尚未写入）数据</strong>强制写入磁盘来做出响应。一旦所有这些写入完成，<code>fsync()</code> 例程就会返回。</p>
<blockquote>
<p>flush的软刷新版本，相比于fsync，它更为柔和，因为它不直接将数据写入到磁盘中的持久存储，而是将用户空间级别的缓冲区中的数据刷新到操作系统的缓冲区（例如glibc中的缓冲区）。</p>
<p>具体来说，它的作用是将用户空间（应用程序）中的数据刷新到操作系统的内核缓冲区中，而不是直接写入磁盘。这使得数据在应用程序和操作系统之间进行了一次更柔和的传递，不需要等待数据真正写入磁盘，因此称为“柔和版本”。相比之下，fsync是一个更严格的操作，它要求将数据直接写入到磁盘中，确保数据的持久化，并等待写入完成的确认。</p>
</blockquote>
<p>下面这段代码如何使用 <code>fsync()</code> 的简单示例。该代码打开文件 foo，向其中写入单个数据块，然后调用 <code>fsync()</code> 以确保立即强制写入磁盘。一旦 <code>fsync()</code> 返回，应用程序就可以安全地继续前进，知道数据已被持久化（如果 <code>fsync()</code> 正确实现了）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">ssize_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="nf">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Data written to disk successfully.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有趣的是，这个序列并不能保证你所期望的一切；在某些情况下，你还需要对包含文件 <code>foo</code> 的目录进行 <code>fsync()</code>。添加这一步不仅能确保文件本身在磁盘上，还能确保文件（如果是新创建的）也能持久地成为目录的一部分。不足为奇的是，这类细节经常被忽视，从而导致许多应用程序级的错误&hellip;&hellip;</p>
<h4 id="重命名文件" class="heading-element"><span>2.1.5 重命名文件</span>
  <a href="#%e9%87%8d%e5%91%bd%e5%90%8d%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>一旦我们有了一个文件，有时为文件指定一个不同的名称会很有用。当在命令行中输入时，这是通过 <code>mv</code> 命令完成的；在此示例中，文件 <code>foo</code> 被重命名为 <code>bar</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ mv foo bar
</span></span><span class="line"><span class="cl">$ strace mv foo bar
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">rename<span class="o">(</span><span class="s2">&#34;foo&#34;</span>, <span class="s2">&#34;bar&#34;</span><span class="o">)</span>                    <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>strace</code>，我们可以看到 <code>mv</code> 使用了系统调用 <code>rename(char *old, char *new)</code>，它需要两个参数：文件的原始名称（<code>old</code>）和新名称（<code>new</code>）。</p>
<p><code>rename()</code>调用提供了一个有趣的保证，那就是它（通常）是作为与系统崩溃有关的原子调用实现的；如果系统在重命名过程中崩溃，文件要么被命名为旧名，要么被命名为新名，不会出现奇怪的中间状态。因此，<code>rename()</code> 对于支持某些需要对文件状态进行原子更新的应用程序至关重要。</p>
<p>让我们说得具体一点。想象一下，你正在使用一个文件编辑器（如 <code>emacs</code>），然后在文件中间插入一行。例如，文件名是 <code>foo.txt</code>。编辑器可能会更新文件，以保证新文件的内容与原来的内容一致，并加上插入的一行，具体方法如下（为简单起见，忽略了错误检查）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;foo.txt.tmp&#34;</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// write out new version of file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">rename</span><span class="p">(</span><span class="s">&#34;foo.txt.tmp&#34;</span><span class="p">,</span> <span class="s">&#34;foo.txt&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，编辑器所做的事情很简单：以临时名称 (<code>foo.txt.tmp</code>) 写出文件的新版本，使用 <code>fsync()</code> 将其强制写入磁盘，然后当应用程序确定新文件时元数据和内容都在磁盘上，将临时文件重命名为原始文件的名称。最后一步以原子方式将新文件交换到位，同时删除旧版本的文件，从而实现原子文件更新。</p>
<h4 id="获取文件信息" class="heading-element"><span>2.1.6 获取文件信息</span>
  <a href="#%e8%8e%b7%e5%8f%96%e6%96%87%e4%bb%b6%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>除了文件访问之外，我们期望文件系统保留有关其存储的每个文件的大量信息。通常我们称这些关于文件的数据为<strong>元数据</strong>。要查看特定文件的元数据，我们可以使用 <code>stat()</code> 或 <code>fstat()</code> 系统调用。这些调用接受一个路径名（或文件描述符）到一个文件，并填充一个如下所示的 <code>stat</code> 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">dev_t</span> <span class="n">st_dev</span><span class="p">;</span> <span class="cm">/* ID of device containing file */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ino_t</span> <span class="n">st_ino</span><span class="p">;</span> <span class="cm">/* inode number */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">mode_t</span> <span class="n">st_mode</span><span class="p">;</span> <span class="cm">/* protection */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">nlink_t</span> <span class="n">st_nlink</span><span class="p">;</span> <span class="cm">/* number of hard links */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uid_t</span> <span class="n">st_uid</span><span class="p">;</span> <span class="cm">/* user ID of owner */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">gid_t</span> <span class="n">st_gid</span><span class="p">;</span> <span class="cm">/* group ID of owner */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">dev_t</span> <span class="n">st_rdev</span><span class="p">;</span> <span class="cm">/* device ID (if special file) */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">st_size</span><span class="p">;</span> <span class="cm">/* total size, in bytes */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">blksize_t</span> <span class="n">st_blksize</span><span class="p">;</span> <span class="cm">/* blocksize for filesystem I/O */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">blkcnt_t</span> <span class="n">st_blocks</span><span class="p">;</span> <span class="cm">/* number of blocks allocated */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">st_atime</span><span class="p">;</span> <span class="cm">/* time of last access */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">st_mtime</span><span class="p">;</span> <span class="cm">/* time of last modification */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">st_ctime</span><span class="p">;</span> <span class="cm">/* time of last status change */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，每个文件都保存了大量信息，包括文件大小（以字节为单位）、底层名称（即 inode number）、一些所有权信息、文件被访问或修改的时间等。要查看这些信息，可以使用命令行工具<code>stat</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s1">&#39;Hello, World&#39;</span> &gt; file
</span></span><span class="line"><span class="cl">&gt; stat file
</span></span><span class="line"><span class="cl">  File: file
</span></span><span class="line"><span class="cl">  Size: <span class="m">13</span>        	Blocks: <span class="m">8</span>          IO Block: <span class="m">4096</span>   regular file
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1339196</span>     Links: <span class="m">1</span>
</span></span><span class="line"><span class="cl">Access: <span class="o">(</span>0664/-rw-rw-r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/    zfhe<span class="o">)</span>   Gid: <span class="o">(</span> 1000/    zfhe<span class="o">)</span>
</span></span><span class="line"><span class="cl">Access: 2024-04-16 19:10:20.591807830 +0800
</span></span><span class="line"><span class="cl">Modify: 2024-04-16 19:10:20.591807830 +0800
</span></span><span class="line"><span class="cl">Change: 2024-04-16 19:10:20.591807830 +0800
</span></span><span class="line"><span class="cl"> Birth: 2024-04-16 19:10:20.591807830 +0800</span></span></code></pre></td></tr></table>
</div>
</div><p>事实证明，每个文件系统通常将此类信息保存在称为 <code>inode</code>的结构中。当我们讨论文件系统实现时，我们将了解更多关于 <code>inode</code> 的知识。现在，您应该将<code>inode</code>视为由文件系统保存的持久数据结构，其中包含我们上面看到的信息。所有 <code>inode</code> 都驻留在磁盘上；活动副本通常缓存在内存中以加快访问速度。</p>
<h4 id="删除文件" class="heading-element"><span>2.1.7 删除文件</span>
  <a href="#%e5%88%a0%e9%99%a4%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>至此，我们知道如何创建文件并按顺序或不按顺序访问它们。但是如何删除文件呢？如果您使用过 UNIX，您可能认为您知道：只需运行 <code>rm</code> 程序即可。但是 <code>rm</code> 使用什么系统调用来删除文件呢？让我们再次使用<code>strace</code>来找出答案。这里我们删除文件“file”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; strace rm file
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">unlinkat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;file&#34;</span>, 0<span class="o">)</span>           <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div><p>我们已经从跟踪输出中删除了大量无关紧要的内容，只留下对神秘系统调用 <code>unlinkat()</code> 的一次调用。如你所见，<code>unlinkat()</code> 第一个参数<code>AT_FDCWD</code> 表示使用当前工作目录作为基础目录进行文件操作，第二个参数接受要删除的文件名，第三个是一个标志参数<code>0</code>，通常用于指定操作行为的一些选项，但在这种情况下，它是用来指示删除操作的默认行为，成功后返回 0。但这也给我们带来了一个巨大的谜团：为什么这个系统调用被命名为 &ldquo;unlink&rdquo;？为什么不直接使用 &ldquo;remove &ldquo;或 &ldquo;delete&quot;呢？要了解这个谜题的答案，我们首先必须了解的不仅仅是文件，还有目录。</p>
<blockquote>
<p>在Linux系统中，系统调用 <code>openat</code>、<code>unlinkat</code> 等带有 <code>at</code> 后缀的调用是为了提供更灵活的文件操作方式。这些带有 <code>at</code> 后缀的系统调用允许在指定的目录中执行文件操作，而不是在当前工作目录中。</p>
<p>这种设计的优点在于它允许程序员指定一个基础目录进行文件操作，而不必依赖于当前工作目录。这对于需要跨多个目录操作文件的程序尤其有用。例如，如果程序需要打开不在当前目录下的文件，而是相对于某个固定的基础目录，那么使用 <code>openat</code> 调用就可以轻松实现这一点。</p>
<p>因此，<code>openat</code>、<code>unlinkat</code> 等系统调用提供了更加灵活和安全的文件操作方式，使程序员可以更精确地控制文件操作的上下文。</p>
</blockquote>
<h3 id="目录操作" class="heading-element"><span>2.2 目录操作</span>
  <a href="#%e7%9b%ae%e5%bd%95%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除了文件之外，还可以使用一组与目录相关的系统调用来创建、读取和删除目录。请注意，<font color="red">您永远不能直接写入目录；由于目录的格式被视为文件系统元数据，因此您只能通过在其中创建文件、目录或其他对象类型等方式间接更新目录。</font>通过这种方式，文件系统可以确保目录的内容始终符合预期。</p>
<h4 id="创建目录" class="heading-element"><span>2.2.1 创建目录</span>
  <a href="#%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>要创建目录，可以使用单个系统调用 <code>mkdir()</code>。同名的 <code>mkdir</code> 程序可用于创建这样的目录。让我们看一下当我们运行 <code>mkdir</code> 程序来创建一个名为 <code>foo</code> 的简单目录时会发生什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; strace mkdir foo
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">mkdir<span class="o">(</span><span class="s2">&#34;foo&#34;</span>, 0777<span class="o">)</span>                      <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div><p>当创建这样的目录时，它被视为“empty”，尽管它确实具有最少的内容。具体来说，一个空目录有两个条目：一个条目引用其自身，另一个条目引用其父目录。前者被称为“.” （点）目录，后者为“..”（点-点）。其中根目录是文件系统的顶层目录，因此它没有父目录，在 UNIX 文件系统中，根目录的父目录通常被表示为自身，即指向自己。</p>
<p>您可以通过将标志 (<code>-a</code>) 传递给程序 <code>ls</code> 来查看这些目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -al foo
</span></span><span class="line"><span class="cl">total <span class="m">8</span>
</span></span><span class="line"><span class="cl">drwxrwxr-x <span class="m">2</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 19:48 .
</span></span><span class="line"><span class="cl">drwxrwxr-x <span class="m">3</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 19:48 ..</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="读取目录" class="heading-element"><span>2.2.2 读取目录</span>
  <a href="#%e8%af%bb%e5%8f%96%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>现在我们已经创建了一个目录，我们可能也希望读取一个目录。事实上，这正是程序 <code>ls</code> 所做的。让我们编写自己的小工具（例如 <code>ls</code>），看看它是如何完成的。</p>
<p>我们不只是像打开文件一样打开目录，而是使用一组新的调用。下面是一个打印目录内容的示例程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DIR</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">);</span>                 <span class="c1">// Open current directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">dp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">d</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Read one directory entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Print the inode number and name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%lu %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_ino</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">closedir</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>                       <span class="c1">// Close the directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该程序使用了三个调用：<code>opendir()</code>、<code>readdir()</code> 和 <code>closedir()</code> 来完成工作，您可以看到接口是多么简单；我们只是使用一个简单的循环一次读取一个目录条目，并打印出目录中每个文件的名称和<code>inode number</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ make read_dir
</span></span><span class="line"><span class="cl">gcc -c read_dir.c
</span></span><span class="line"><span class="cl">gcc read_dir.o -o read_dir
</span></span><span class="line"><span class="cl">❯ ./read_dir
</span></span><span class="line"><span class="cl"><span class="m">26212234</span> .
</span></span><span class="line"><span class="cl"><span class="m">22996964</span> ..
</span></span><span class="line"><span class="cl"><span class="m">26257183</span> file.txt
</span></span><span class="line"><span class="cl"><span class="m">26257285</span> fork-seek
</span></span><span class="line"><span class="cl"><span class="m">26256904</span> Makefile
</span></span><span class="line"><span class="cl"><span class="m">26261892</span> fsync.c
</span></span><span class="line"><span class="cl"><span class="m">26257284</span> fork-seek.o
</span></span><span class="line"><span class="cl"><span class="m">26258349</span> dup
</span></span><span class="line"><span class="cl"><span class="m">26261922</span> fsync
</span></span><span class="line"><span class="cl"><span class="m">26258348</span> dup.o
</span></span><span class="line"><span class="cl"><span class="m">26405969</span> read_dir.o
</span></span><span class="line"><span class="cl"><span class="m">26212238</span> README.md
</span></span><span class="line"><span class="cl"><span class="m">26261927</span> foo
</span></span><span class="line"><span class="cl"><span class="m">26405970</span> read_dir
</span></span><span class="line"><span class="cl"><span class="m">26405873</span> read_dir.c
</span></span><span class="line"><span class="cl"><span class="m">26258222</span> dup.c
</span></span><span class="line"><span class="cl"><span class="m">26256864</span> fork-seek.c
</span></span><span class="line"><span class="cl"><span class="m">26261921</span> fsync.o</span></span></code></pre></td></tr></table>
</div>
</div><p>下面的声明显示了 <code>struct dirent</code> 数据结构中每个目录条目中的可用信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">dirent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">d_name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span> <span class="cm">/* filename */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ino_t</span> <span class="n">d_ino</span><span class="p">;</span> <span class="cm">/* inode number */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">d_off</span><span class="p">;</span> <span class="cm">/* offset to the next dirent */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">d_reclen</span><span class="p">;</span> <span class="cm">/* length of this record */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_type</span><span class="p">;</span> <span class="cm">/* type of file */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于目录中的信息很少（基本上只是将名称映射到 <code>inode number</code>，以及其他一些细节），程序可能希望在每个文件上调用 <code>stat()</code> 来获取每个文件的更多信息，如长度或其他详细信息。事实上，当你给 <code>ls</code> 传递 <code>-l</code> 标志时，它就会这么做。</p>
<h4 id="删除目录" class="heading-element"><span>2.2.3 删除目录</span>
  <a href="#%e5%88%a0%e9%99%a4%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>最后，你可以调用 <code>rmdir()</code>（由同名程序 <code>rmdir</code> 使用）删除目录。不过，与删除文件不同，删除目录更加危险，因为一条命令就可能删除大量数据。因此，<code>rmdir()</code> 要求在删除之前目录必须为空（即只有&rdquo;. &ldquo;和&rdquo;.. &ldquo;条目）。如果试图删除非空目录，<code>rmdir()</code> 函数的调用就会失败。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo/foo.txt
</span></span><span class="line"><span class="cl">&gt; rmdir foo
</span></span><span class="line"><span class="cl">rmdir: failed to remove <span class="s1">&#39;foo&#39;</span>: Directory not empty
</span></span><span class="line"><span class="cl">&gt; rm foo/foo.txt
</span></span><span class="line"><span class="cl">&gt; rmdir foo</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="链接" class="heading-element"><span>3 链接</span>
  <a href="#%e9%93%be%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="硬链接" class="heading-element"><span>3.1 硬链接</span>
  <a href="#%e7%a1%ac%e9%93%be%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在，我们通过了解一种在文件系统树中创建条目的新方法，即 <code>link()</code> 系统调用，回到为什么要通过 <code>unlink()</code> 来删除文件的谜题上来。<code>link()</code> 系统调用需要两个参数，一个旧路径名和一个新路径名；当你把一个新文件名 &ldquo;链接 &ldquo;到一个旧文件名时，你基本上就创造了另一种方式来引用同一个文件。在本例中，命令行程序 <code>ln</code> 就是用来实现这一功能的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; cat foo
</span></span><span class="line"><span class="cl">Hello, World
</span></span><span class="line"><span class="cl">&gt; ln foo foo2
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>这里我们创建了一个包含单词“Hello, World”的文件，并将其命名为<code>foo</code>。然后我们使用 <code>ln</code> 程序创建到该文件的硬链接。之后，我们可以通过打开 <code>foo</code> 或 <code>foo2</code> 来检查该文件。</p>
<p>链接的工作原理是，它只是在创建链接的目录中创建另一个名称，并将其指向与原始文件相同的 <code>inode number</code>（即底层名称）。文件并没有以任何方式复制；相反，你现在只有两个名称（<code>foo</code>和 <code>foo2</code>），它们都指向同一个文件。我们甚至可以在目录本身中看到这一点，打印出每个文件的 <code>inode number</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -i foo foo2
</span></span><span class="line"><span class="cl"><span class="m">1339196</span> foo  
</span></span><span class="line"><span class="cl"><span class="m">1339196</span> foo2</span></span></code></pre></td></tr></table>
</div>
</div><p>通过向 <code>ls</code> 传递 <code>-i</code> 标志，它会打印出每个文件的 <code>inode number</code>（以及文件名）。这样，你就能看到 <code>link</code> 到底做了什么：它只是对相同的 <code>inode number</code>（本例中为 1339196）进行了新的引用。</p>
<p>现在，你可能开始明白为什么 <code>unlink()</code> 要叫 <code>unlink()</code>了。当你创建文件时，实际上是在做两件事。</p>
<ul>
<li>首先，你正在创建一个结构（inode），它将跟踪文件的几乎所有相关信息，包括文件大小、块在磁盘上的位置等等。</li>
<li>其次，将一个人类可读的名称链接到该文件，并将该链接放到一个目录中。</li>
</ul>
<p>在文件系统中创建了文件的硬链接后，原始文件名（<code>foo</code>）和新创建的文件名（<code>foo2</code>）就没有什么区别了；事实上，它们都只是指向文件底层元数据的链接，而文件底层元数据就在 <code>inode number</code>1339196中。</p>
<p>因此，要从文件系统中删除文件，我们需要调用 <code>unlink()</code>。在上面的例子中，我们可以删除名为 <code>file</code> 的文件，并且仍然可以顺利访问该文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls
</span></span><span class="line"><span class="cl">foo  foo2
</span></span><span class="line"><span class="cl">&gt; rm foo
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>这样做的原因是，当文件系统取消链接文件时，它会检查 <code>inode number</code>内的引用计数。该<strong>引用计数</strong>（有时称为<strong>链接计数</strong>）允许文件系统跟踪有多少不同的文件名已链接到该特定 <code>inode</code>。当调用 <code>unlink()</code> 时，它会删除文件名（正在删除的文件）与给定 <code>inode number</code>之间的“链接”，并减少引用计数；<font olor="red">只有当引用计数为零时，文件系统才会同时释放inode和相关数据块，从而真正“删除”文件。</font></p>
<p>当然，您可以使用 <code>stat()</code> 查看文件的引用计数。让我们看看当我们创建和删除文件的硬链接时会发生什么。在此示例中，我们将创建指向同一文件的三个链接，然后将其删除。观察链接计数！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">1</span>
</span></span><span class="line"><span class="cl">&gt; ln foo foo2
</span></span><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">2</span>
</span></span><span class="line"><span class="cl">&gt; ln foo2 foo3
</span></span><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">3</span>
</span></span><span class="line"><span class="cl">&gt; rm foo
</span></span><span class="line"><span class="cl">&gt; stat foo2 <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">2</span>
</span></span><span class="line"><span class="cl">&gt; rm foo2
</span></span><span class="line"><span class="cl">&gt; stat foo3 <span class="p">|</span> grep Inode
</span></span><span class="line"><span class="cl">Device: fc03h/64515d	Inode: <span class="m">1338857</span>     Links: <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="符号链接软链接" class="heading-element"><span>3.2 符号链接（软链接）</span>
  <a href="#%e7%ac%a6%e5%8f%b7%e9%93%be%e6%8e%a5%e8%bd%af%e9%93%be%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>还有另一种非常有用的链接类型，它称为<strong>符号链接</strong>，有时也称为<strong>软链接</strong>。事实证明，硬链接有一定的局限性：</p>
<ul>
<li>您不能为目录创建硬链接，因为担心会在目录树中创建循环。例如，假设有两个目录A和B，它们都包含一个硬链接到对方的硬链接。这种情况下，无论你从A开始还是从B开始，都会导致无限的循环，因为通过任一路径进入其中一个目录后，你可以通过硬链接返回到另一个目录，反复无穷地进行。</li>
<li>您不能硬链接到其他磁盘分区中的文件（因为 <code>inode number</code>仅在特定文件系统内唯一，而不是跨文件系统）；</li>
</ul>
<p>因此，创建了一种称为符号链接的新型链接。要创建这样的链接，您可以使用相同的程序 <code>ln</code>，但带有 <code>-s</code> 标志。这是一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; ln -s foo foo2
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World</span></span></code></pre></td></tr></table>
</div>
</div><p>正如您所看到的，创建软链接看起来非常相似，现在可以通过文件名 <code>foo</code> 以及符号链接名 <code>foo2</code> 来访问原始文件。</p>
<p>然而，除了表面上的相似性之外，符号链接实际上与硬链接有很大不同。符号链接实际上本身就是一个不同类型的文件。我们已经讨论过常规文件和目录；<font color="red">符号链接是文件系统所知的第三种类型。</font>符号链接上的统计数据揭示了一切：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; stat foo <span class="p">|</span> grep regular
</span></span><span class="line"><span class="cl">  Size: <span class="m">13</span>        	Blocks: <span class="m">8</span>          IO Block: <span class="m">4096</span>   regular file
</span></span><span class="line"><span class="cl">&gt; stat foo2 <span class="p">|</span> grep symbolic
</span></span><span class="line"><span class="cl">  Size: <span class="m">3</span>         	Blocks: <span class="m">0</span>          IO Block: <span class="m">4096</span>   symbolic link</span></span></code></pre></td></tr></table>
</div>
</div><p>运行 <code>ls</code> 也揭示了这个事实。如果仔细观察 <code>ls</code> 输出的长格式的第一个字符，您会发现最左侧列中的第一个字符是 <code>-</code> 表示常规文件，<code>d</code> 表示目录，<code>l</code> 表示软链接。您还可以查看符号链接的大小（在本例中为 3 个字节），以及链接指向的内容（名为 <code>foo</code> 的文件）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -al
</span></span><span class="line"><span class="cl">total <span class="m">12</span>
</span></span><span class="line"><span class="cl">drwxrwxr-x  <span class="m">2</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 21:02 .
</span></span><span class="line"><span class="cl">drwxr-x--- <span class="m">22</span> zfhe zfhe <span class="m">4096</span> Apr <span class="m">16</span> 21:03 ..
</span></span><span class="line"><span class="cl">-rw-rw-r--  <span class="m">1</span> zfhe zfhe   <span class="m">13</span> Apr <span class="m">16</span> 20:56 foo
</span></span><span class="line"><span class="cl">lrwxrwxrwx  <span class="m">1</span> zfhe zfhe    <span class="m">3</span> Apr <span class="m">16</span> 20:56 foo2 -&gt; foo</span></span></code></pre></td></tr></table>
</div>
</div><p><code>foo2</code> 是 3 个字节的原因是因为符号链接的形成方式是将链接到的文件的路径名作为链接文件的数据。因为我们链接到了一个名为 <code>foo</code> 的文件，所以我们的链接文件 <code>foo2</code> 很小（3 个字节）。如果我们链接到更长的路径名，我们的链接文件会更大：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; a_longer_filename
</span></span><span class="line"><span class="cl">&gt; ln -s a_longer_filename file
</span></span><span class="line"><span class="cl">&gt; ls -al a_longer_filename file
</span></span><span class="line"><span class="cl">-rw-rw-r-- <span class="m">1</span> zfhe zfhe <span class="m">13</span> Apr <span class="m">16</span> 21:04 a_longer_filename
</span></span><span class="line"><span class="cl">lrwxrwxrwx <span class="m">1</span> zfhe zfhe <span class="m">17</span> Apr <span class="m">16</span> 21:05 file -&gt; a_longer_filename</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，由于符号链接的创建方式，它们留下了所谓的悬空引用的可能性，悬空引用可能会导致程序错误，因为它们试图访问不再有效的内存位置或资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; <span class="nb">echo</span> <span class="s2">&#34;Hello, World&#34;</span> &gt; foo
</span></span><span class="line"><span class="cl">&gt; ln -s foo foo2
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">Hello, World
</span></span><span class="line"><span class="cl">&gt; rm foo
</span></span><span class="line"><span class="cl">&gt; cat foo2
</span></span><span class="line"><span class="cl">cat: foo2: No such file or directory</span></span></code></pre></td></tr></table>
</div>
</div><p>正如您在此示例中所看到的，与硬链接完全不同，删除名为 <code>foo</code> 的原始文件会导致链接指向不再存在的路径名。</p>
<h2 id="权限位和访问控制列表" class="heading-element"><span>4 权限位和访问控制列表</span>
  <a href="#%e6%9d%83%e9%99%90%e4%bd%8d%e5%92%8c%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%88%97%e8%a1%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>进程的抽象提供了两个中心虚拟化：CPU和内存。每一种虚拟化都会给进程造成一种错觉，以为它拥有自己的专用 CPU 和专用内存；实际上，操作系统使用了各种技术，以安全可靠的方式在相互竞争的实体之间共享有限的物理资源。</p>
<p>正如本章所述，文件系统也提供了磁盘的虚拟视图，将磁盘从一堆原始块转化为更方便用户使用的文件和目录。然而，文件系统的抽象与 CPU 和内存的抽象明显不同，因为文件通常由不同用户和进程共享，并不总是私有的。因此，文件系统中通常有一套更全面的机制来实现不同程度的共享。</p>
<p>此类机制的第一种形式是经典的 UNIX <strong>权限位</strong>。要查看文件 <code>foo.txt</code> 的权限，只需输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls -l foo.txt
</span></span><span class="line"><span class="cl">-rw-rw-r-- <span class="m">1</span> zfhe zfhe <span class="m">0</span> Apr <span class="m">16</span> 21:12 foo.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>我们只关注该输出的第一部分，即 <code>-rw-r--r--</code>。这里的第一个字符仅显示文件的类型： <code>-</code> 表示常规文件（即 <code>foo.txt</code>），<code>d</code> 表示目录，<code>l</code> 表示符号链接，依此类推；这（大部分）与权限无关，所以我们暂时忽略它。</p>
<p>我们感兴趣的是权限位，它们由接下来的九个字符（<code>rw-r--r--</code>）表示。对于每个常规文件、目录和其他实体，这些位确定谁可以访问它以及如何访问它。</p>
<p>权限由三组组成：</p>
<ol>
<li>文件所有者可以对文件执行哪些操作；</li>
<li>组中的某个人可以对文件执行哪些操作；</li>
<li>最后是任何人（有时称为其他人）都可以执行哪些操作。</li>
</ol>
<p>所有者、组成员或其他人可以拥有的能力包括读取文件、写入文件或执行文件的能力。在上面的示例中，<code>ls</code> 输出的前三个字符表明该文件可由所有者 (<code>rw-</code>) 读取和写入，并且只能由组<code>zfhe</code>成员以及系统中的其他任何人读取 (<code>r --</code> 后面跟着 <code>r--</code>)。</p>
<p>文件的所有者可以轻松更改这些权限，例如通过使用 <code>chmod</code>命令（<strong>更改文件模式</strong>）（还有<code>chown</code>：更改文件或目录的所有者；<code>chgrp</code>：更改文件或目录的所属组）。要删除除所有者之外的任何人访问该文件的能力，您可以输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; chmod <span class="m">600</span> foo.txt
</span></span><span class="line"><span class="cl">&gt; ls -l foo.txt
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> zfhe zfhe <span class="m">0</span> Apr <span class="m">16</span> 21:12 foo.txt</span></span></code></pre></td></tr></table>
</div>
</div><p>这条命令启用了所有者的可读位（4）和可写位（2）（将它们 OR 在一起会产生上面的 6），但将组和其他人的权限位分别设置为 0 和 0，从而将权限设置为 <code>rw-------</code>。</p>
<p>执行位尤其有趣。对于普通文件，它的存在决定了程序是否可以运行。例如，如果我们有一个名为 hello.csh 的简单 shell 脚本，我们可能希望通过输入以下内容来运行它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ./hello.csh
</span></span><span class="line"><span class="cl">hello, from shell world.</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，如果我们没有正确设置该文件的执行位，就会发生以下情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; chmod <span class="m">600</span> hello.csh
</span></span><span class="line"><span class="cl">&gt; ./hello.csh
</span></span><span class="line"><span class="cl">zsh: permission denied: ./hello.csh</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<center>文件系统的超级用户
</center>
<p>允许哪个用户执行特权操作以帮助管理文件系统？例如，如果需要删除一个不活动用户的文件以节省空间，谁有权这样做？</p>
<p>在本地文件系统中，常见的默认设置是存在某种超级用户（即 <code>root</code>），它可以访问所有文件，而不受权限限制。在分布式文件系统（如 AFS，它有访问控制列表）中，一个名为 <code>system:administrators</code> 的组包含受信任的用户。</p>
<p>在这两种情况下，这些受信任的用户都代表着固有的安全风险；如果攻击者能够以某种方式冒充此类用户，攻击者就可以访问系统中的所有信息，从而违反预期的隐私和保护保证。</p>
</blockquote>
<p>对于目录，执行位的行为略有不同。具体来说，它使用户（或组或每个人）能够执行诸如将目录（即 <code>cd</code>）更改为给定目录之类的操作，并结合可写位在其中创建文件。在 UNIX 文件系统中，具体如下：</p>
<ol>
<li><strong>读权限（r）</strong>：允许查看目录中的文件列表（即列出目录中的内容）。</li>
<li><strong>写权限（w）</strong>：允许在目录中创建、删除和重命名文件。</li>
<li><strong>执行权限（x）</strong>：允许进入目录。要进入目录，用户必须拥有目录的执行权限。</li>
</ol>
<p>除了权限位之外，一些文件系统，包括称为 AFS 的分布式文件系统，还包括更复杂的控制。例如，AFS 以每个目录的<strong>访问控制列表</strong> (ACL) 的形式执行此操作。访问控制列表是一种更通用、更强大的方式来准确表示谁可以访问给定资源。在文件系统中，这使用户能够创建一个非常具体的列表，其中列出谁可以读取一组文件，谁不能读取一组文件，这与上述权限位的所有者/组/所有人模型不同。</p>
<p>例如，以下是一位用户的 AFS 帐户中的私有目录的访问控制，如 <code>fs listacl</code> 命令所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; fs listacl private
</span></span><span class="line"><span class="cl">Access list <span class="k">for</span> private is
</span></span><span class="line"><span class="cl">Normal rights:
</span></span><span class="line"><span class="cl">    system:administrators rlidwka
</span></span><span class="line"><span class="cl">    remzi rlidwka</span></span></code></pre></td></tr></table>
</div>
</div><p>该列表显示系统管理员和用户 <code>remzi</code> 都可以查找、插入、删除和管理此目录中的文件，以及读取、写入和锁定这些文件，具体标识符解释如下。</p>
<ul>
<li><code>r</code>: 读取权限 (Read)</li>
<li><code>l</code>: 列出目录权限 (List)</li>
<li><code>i</code>: 插入权限 (Insert)</li>
<li><code>d</code>: 删除权限 (Delete)</li>
<li><code>w</code>: 写入权限 (Write)</li>
<li><code>k</code>: 锁定权限 (Lock)</li>
<li><code>a</code>: 管理权限 (Administer)</li>
</ul>
<p>要允许某人（在本例中为其他用户）访问此目录，用户 <code>remzi</code> 只需输入以下命令即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; fs setacl private/ andrea rl
</span></span><span class="line"><span class="cl">&gt; fs listacl private
</span></span><span class="line"><span class="cl">Access list <span class="k">for</span> private is
</span></span><span class="line"><span class="cl">Normal rights:
</span></span><span class="line"><span class="cl">    system:administrators rlidwka
</span></span><span class="line"><span class="cl">    remzi rlidwka
</span></span><span class="line"><span class="cl">    andrea rl</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<center>警惕TOCTTOC
</center>
<p>TOCTTOU 是 &ldquo;Time of Check to Time of Use&rdquo; 的缩写，指的是在检查某个条件和使用该条件之间可能存在的时间间隔。这个术语通常用于描述安全漏洞，特别是在多线程或并发环境中，由于时间间隔导致的条件竞争问题。</p>
<p>1974 年，McPhee注意到计算机系统存在问题。具体来说，McPhee 指出“&hellip;如果有效性检查和与该有效性检查相关的操作之间存在时间间隔，并且通过多任务处理，可以在该时间间隔期间故意更改有效性检查变量，导致控制程序执行无效操作。”今天，我们将此称为“Time of Check to Time of Use ”(TOCTTOU) 问题，可惜，这种情况仍然可能发生。</p>
<p>Bishop 和 Dilger描述的一个简单示例展示了用户如何欺骗更值得信赖的服务，从而造成麻烦。例如，想象一下，邮件服务以 root 身份运行（因此有权访问系统上的所有文件）。该服务将传入消息附加到用户的收件箱文件中，如下所示。首先，它调用 <code>lstat()</code> 来获取有关该文件的信息，特别是确保它实际上只是目标用户拥有的常规文件，而不是指向邮件服务器不应更新的另一个文件的链接。然后，检查成功后，服务器用新消息更新文件。</p>
<p>不幸的是，检查和更新之间的差距导致了一个问题：攻击者（在本例中，是接收邮件的用户，因此有权访问收件箱）切换收件箱文件（通过调用 <code>rename()</code>) 指向敏感文件，例如 <code>/etc/passwd</code>（其中保存有关用户及其密码的信息）。如果这种切换发生在正确的时间（在检查和访问之间），服务器将用邮件的内容更新敏感文件。攻击者现在可以通过发送电子邮件写入敏感文件，从而提升权限；通过更新<code>/etc/passwd</code>，攻击者可以添加具有root权限的帐户，从而获得系统的控制权。</p>
<p>TOCTTOU 问题没有任何简单而出色的解决方案。<font color="red">一种方法是减少需要 root 权限才能运行的服务数量，这会有所帮助</font>。 <code>O_NOFOLLOW</code> 标志使得如果目标是符号链接，<code>open()</code> 将失败，从而避免需要所述链接的攻击。更激进的方法，例如使用<strong>事务性文件系统</strong>，可以解决问题，但广泛部署的事务性文件系统并不多。因此，通常的建议：编写以高权限运行的代码时要小心！</p>
</blockquote>
<h2 id="制作和挂载文件系统" class="heading-element"><span>5 制作和挂载文件系统</span>
  <a href="#%e5%88%b6%e4%bd%9c%e5%92%8c%e6%8c%82%e8%bd%bd%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们现在已经了解了访问文件、目录和某些特殊类型链接的基本接口。不过，我们还应该讨论一个话题：如何从许多底层文件系统中生成完整的目录树。要完成这项任务，首先要制作文件系统，然后挂载这些文件系统，以便访问其中的内容。</p>
<p>为了创建文件系统，大多数文件系统都提供了一个工具，通常被称为 <code>mkfs</code>（读作 &ldquo;make fs&rdquo;），它可以完成这项任务。其原理如下：输入一个设备（如磁盘分区，如 <code>/dev/sda1</code>）和一个文件系统类型（如 <code>ext3</code>）给该工具，<font color="red">它就会在该磁盘分区中写入一个以根目录为起点的空文件系统。</font>mkfs 说：“那就有一个文件系统吧！”</p>
<p>不过，一旦创建了这样一个文件系统，就需要在统一文件系统树中对其进行访问。这项任务需要通过 <code>mount</code> 程序来完成（它会让底层系统调用 <code>mount()</code> 来完成真正的工作）。<code>mount</code> 程序的作用非常简单，<font color="red">就是将一个现有目录作为目标挂载点，然后在目录树上粘贴一个新的文件系统。</font></p>
<p>这里的一个例子可能很有用。假设我们有一个未挂载的 <code>ext3</code> 文件系统，存储在设备分区 <code>/dev/sda1</code>，其内容如下：一个根目录，其中包含两个子目录 <code>a</code> 和 <code>b</code>，每个子目录又包含一个名为 <code>foo</code> 的文件。假设我们希望将该文件系统挂载到挂载点 <code>/home/users</code>。我们可以这样输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; mount -t ext3 /dev/sda1 /home/users</span></span></code></pre></td></tr></table>
</div>
</div><p>如果挂载成功，这个新文件系统就可用了。不过，请注意现在访问新文件系统的方式。要查看根目录的内容，我们可以这样使用 <code>ls</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; ls /home/users/
</span></span><span class="line"><span class="cl">a b</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，路径名 <code>/home/users/</code> 现在指的是新挂载目录的根目录。同样，我们可以使用 <code>/home/users/a</code> 和 <code>/home/users/b</code> 这两个路径名访问目录 <code>a</code> 和 <code>b</code>。最后，可以通过 <code>/home/users/a/foo</code> 和 <code>/home/users/b/foo</code> 访问名为 <code>foo</code> 的文件。这就是挂载的魅力所在：挂载将所有文件系统统一为一棵树，使命名统一、方便，而不是拥有多个独立的文件系统。要查看系统上挂载了哪些文件，以及挂载在哪些位置，只需运行<code>mount</code>程序即可。你会看到如下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt; mount
</span></span><span class="line"><span class="cl">/dev/sda1 on / <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">proc on /proc <span class="nb">type</span> proc <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">sysfs on /sys <span class="nb">type</span> sysfs <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">/dev/sda5 on /tmp <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">/dev/sda7 on /var/vice/cache <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">tmpfs on /dev/shm <span class="nb">type</span> tmpfs <span class="o">(</span>rw<span class="o">)</span>
</span></span><span class="line"><span class="cl">AFS on /afs <span class="nb">type</span> afs <span class="o">(</span>rw<span class="o">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种疯狂的组合表明有大量不同的文件系统，包括 <code>ext3</code>（基于磁盘的标准文件系统）、<code>proc</code> 文件系统（用于访问当前进程信息的文件系统）、<code>tmpfs</code>（仅用于临时文件的文件系统） ）和 <code>AFS</code>（分布式文件系统）都粘合到这台机器的文件系统树上。</p>
<h2 id="总结" class="heading-element"><span>6 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><strong>文件</strong>是可以创建、读取、写入和删除的字节数组。它有一个唯一引用它的底层名称（即<code>number</code>）。此层名称通常称为<code>inode number</code>。</li>
<li><strong>目录</strong>是元组的集合，每个元组都包含一个人类可读的名称及其映射到的底层名称。每个条目要么引用另一个目录，要么引用一个文件。每个目录本身也有一个底层名称（<code>inode number</code>）。目录总是有两个特殊条目：<code>.</code>条目（引用自身）和 <code>..</code> 条目（引用其父条目）。</li>
<li><strong>目录树</strong>或<strong>目录层次结构</strong>将所有文件和目录组织成一棵大树，从根开始。</li>
<li>要访问文件，进程必须使用系统调用（通常为 <code>open()</code>）来请求操作系统的许可。如果授予权限，操作系统会返回一个文件描述符，然后在权限和意图允许的情况下，该文件描述符可用于读或写访问。</li>
<li>每个文件描述符都是一个私有的、每个进程的实体，它引用打开文件表中的一个条目。其中的条目跟踪这次访问<font color="red">引用了哪个文件、文件的当前偏移量（即下一次读取或写入将访问文件的哪一部分）以及其他相关信息。</font></li>
<li>调用<code>read()</code> 和<code>write()</code> 自然会更新当前偏移量；否则，进程可以使用 <code>lseek()</code> 来更改其值，从而能够随机访问文件的不同部分。</li>
<li>要强制更新持久性存储，进程必须使用<code>fsync()</code> 或相关调用。然而，在保持高性能的同时正确执行此操作具有挑战性，因此在执行此操作时请仔细考虑。</li>
<li>要使文件系统中的多个人类可读名称引用同一基础文件，请使用<strong>硬链接或符号链接</strong>。每种方法在不同的情况下都有用，因此在使用之前请考虑它们的优点和缺点。请记住，<font color="red">删除文件只是从目录层次结构中执行最后一次<code>unlink()</code> 操作</font>。</li>
<li>大多数文件系统都有启用和禁用共享的机制。此类控制的基本形式是由<strong>权限位</strong>提供的；更复杂的访问控制列表（ACL）可以更精确地控制谁可以访问和操作信息。</li>
</ul>
]]></description></item><item><title>廉价磁盘冗余阵列</title><link>https://hezephyr.github.io/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/</link><pubDate>Sat, 11 May 2024 21:03:30 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当我们使用磁盘时，</p>
<ul>
<li>有时我们希望它更快； I/O 操作速度很慢，因此可能成为整个系统的瓶颈。</li>
<li>有时我们希望它更大；越来越多的数据被放到网上，因此我们的磁盘变得越来越满。</li>
<li>有时我们希望它更加可靠；当磁盘发生故障时，如果我们的数据没有备份，所有有价值的数据都会消失。</li>
</ul>
<p>所以关键问题是：我们怎样才能制作大型、快速、可靠的存储系统？有哪些关键技术？不同方法之间的权衡是什么？</p>
<p>在本章中，我们将介绍<font color="red">廉价磁盘冗余阵列，即 RAIDs</font>，这是一种<font color="red">协同使用多个磁盘来构建更快、更大、更可靠的磁盘系统的技术</font>。该术语是由加州大学伯克利分校的一组研究人员（由 David Patterson 和 Randy Katz 教授以及当时的学生 Garth Gibson 领导）于 20 世纪 80 年代末提出的。大约在这个时候，许多不同的研究人员同时得出了使用多个磁盘来构建更好的存储系统的基本思想。</p>
<p>从外部来看，RAIDs 看起来像一个磁盘：一组可以读取或写入的块。在内部，RAID 是一个复杂的系统，由多个磁盘、内存（易失性和非易失性）以及一个或多个用于管理系统的处理器组成。硬件 RAID 非常类似于计算机系统，专门用于管理一组磁盘的任务。</p>
<p>与单个磁盘相比，RAID 具有如下优点。</p>
<ol>
<li><strong>性能</strong>。并行使用多个磁盘可以大大加快 I/O 时间。</li>
<li><strong>容量</strong>。大数据集需要大磁盘。</li>
<li><strong>可靠性</strong>；将数据分布在多个磁盘上（没有 RAID 技术）使得数据容易受到单个磁盘丢失的影响；通过某种形式的冗余，RAID 可以容忍磁盘丢失并继续运行，就像没有发生任何问题一样。</li>
</ol>
<blockquote>
<center>提示：透明性有助于部署</center>
<p>在考虑如何为系统添加新功能时，应始终考虑能否以透明的方式添加这些功能，即不要求更改系统的其他部分。要求完全重写现有软件（或彻底改变硬件）会降低想法产生影响的几率。RAID 就是一个很好的例子，当然，它的透明性也是其成功的原因之一；管理员可以安装一个基于 SCSI 的 RAID 存储阵列，而不是 SCSI 磁盘，系统的其他部分（主机、操作系统等）无需做任何改动即可开始使用。通过解决部署问题，RAID 从一开始就取得了巨大成功。</p>
</blockquote>
<p>令人惊奇的是，RAID 为使用 RAID 的系统提供了透明的优势，也就是说，对于主机系统而言，RAID 就像一个大磁盘。当然，透明性的好处在于，它使人们能够简单地用 RAID 更换磁盘，而无需更改任何软件；操作系统和客户端应用程序无需修改即可继续运行。通过这种方式，透明性大大提高了 RAID 的可部署性，使用户和管理员在使用 RAID 时不必担心软件兼容性问题。</p>
<p>我们现在讨论 RAID 的一些重要方面。我们首先讨论<strong>接口和故障模型</strong>，然后讨论如何从<strong>容量</strong>、<strong>可靠性</strong>和<strong>性能</strong>这三个重要方面评估 RAID 设计。然后，我们将讨论对 RAID 设计和实施很重要的其他一些问题。</p>
<h2 id="接口和-raid-内部结构" class="heading-element"><span>2 接口和 RAID 内部结构</span>
  <a href="#%e6%8e%a5%e5%8f%a3%e5%92%8c-raid-%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于上面的文件系统来说，RAID 看起来就像一个大的、（希望）快速且（希望）可靠的磁盘。就像单个磁盘一样，它表现为块的线性阵列，每个块都可以由文件系统（或其他客户端）读取或写入。</p>
<p>当文件系统向 RAID 发出逻辑 I/O 请求时，RAID 内部必须计算要访问哪个磁盘（或多个磁盘）才能完成请求，然后发出一个或多个物理 I/O 来完成该请求。这些物理 I/O 的确切性质取决于 RAID 级别，我们将在下面详细讨论。然而，作为一个简单的例子，考虑一个 RAID，它保留每个块的两个副本（每个副本位于一个单独的磁盘上）；当写入此类镜像 RAID 系统时，RAID 必须为其发出的每一个逻辑 I/O 执行两次物理 I/O。</p>
<p>RAID 系统通常是一个独立的硬件盒，通过标准连接（如 SCSI 或 SATA）与主机相连。不过，RAID 的内部结构相当复杂，包括一个<strong>运行固件的微控制器</strong>，用于指导 RAID 的运行；<strong>DRAM 等易失性内存</strong>，用于在数据块读写时对其进行缓冲；在某些情况下，非易失性内存用于对写入进行安全缓冲；甚至可能还包括用于执行奇偶校验计算的专用逻辑（在某些 RAID 级别中非常有用，下文将详细介绍）。从高层次来看，RAID 在很大程度上是一种专用计算机系统：它有处理器、内存和磁盘；但它运行的不是应用程序，而是专门用于操作 RAID 的软件。</p>
<h2 id="故障模型" class="heading-element"><span>3 故障模型</span>
  <a href="#%e6%95%85%e9%9a%9c%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了理解 RAID 并比较不同的方法，我们必须有一个故障模型。 RAID 旨在检测某些类型的磁盘故障并从中恢复；因此，准确地了解会出现哪些故障对于实现可行的设计至关重要。</p>
<p>我们假设的第一个故障模型非常简单，被称为<font color="red">故障停止故障模型</font>。在此模型中，磁盘可以恰好处于两种状态之一：工作或故障。使用工作磁盘，所有块都可以读取或写入。相反，当磁盘发生故障时，我们假设它永久丢失。</p>
<p>故障停止模型的一个关键方面是它对故障检测的假设。具体来说，当磁盘出现故障时，我们假设很容易检测到这一点。例如，在 RAID 阵列中，我们假设 RAID 控制器硬件（或软件）可以立即观察到磁盘发生故障。</p>
<p>因此，目前我们不必担心更复杂的“静默”故障，例如磁盘损坏。我们也不必担心单个块在其他工作磁盘上变得无法访问（有时称为潜在扇区错误）。稍后我们将考虑这些更复杂（不幸的是，更现实）的磁盘故障。</p>
<h2 id="如何评估-raid" class="heading-element"><span>4 如何评估 RAID</span>
  <a href="#%e5%a6%82%e4%bd%95%e8%af%84%e4%bc%b0-raid" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>构建 RAID 有多种不同的方法。这些方法中的每一种都有不同的特征，值得评估，以便了解它们的优点和缺点。</p>
<p>具体来说，我们将依据三个指标评估每个 RAID 设计。</p>
<ol>
<li>
<p>第一个指标是<strong>容量</strong>；给定一组 N 个磁盘，每个磁盘有 B 个块，RAID 客户端有多少可用容量？如果没有冗余，答案是$N\cdot B$；相反，如果我们有一个系统保留每个块的两个副本（称为镜像），则我们获得的有用容量为$\frac{N\cdot B}{2}$。不同的方案（例如基于奇偶校验的方案）往往介于两者之间。</p>
</li>
<li>
<p>第二个指标是<strong>可靠性</strong>。给定的设计可以容忍多少个磁盘故障？根据我们的故障模型，我们假设只有整个磁盘可能发生故障；在之后（即数据完整性），我们将考虑如何处理更复杂的故障模式。</p>
</li>
<li>
<p>最后一个指标是<strong>性能</strong>。评估性能有些困难，因为它很大程度上取决于磁盘阵列的工作负载。因此，在评估性能之前，我们将首先介绍一组应该考虑的典型工作负载。</p>
<blockquote>
<p>我们现在考虑三种重要的 RAID 设计：RAID Level 0（条带化）、RAID Level 1（镜像）和 RAID Levels 4/5（基于奇偶校验的冗余）。将这些设计中的每一个命名为“level”源于atterson，Gibson和Katz在伯克利的开创性工作。</p>
</blockquote>
</li>
</ol>
<p>在分析 RAID 性能时，可以考虑两种不同的性能指标。首先是<font color="red">单请求延迟</font>。了解 RAID 的单个 I/O 请求的延迟非常有用，因为它揭示了单个逻辑 I/O 操作期间可以存在多少并行性。第二个是 RAID 的<font color="red">稳态吞吐量</font>，即许多并发请求的总带宽。由于 RAID 通常用于高性能环境，因此稳态带宽至关重要，因此将成为我们分析的主要焦点。</p>
<p>为了更详细地了解吞吐量，我们需要提出一些感兴趣的工作负载。在本次讨论中，我们假设有两种类型的工作负载：顺序工作负载和随机工作负载。对于顺序工作负载，我们假设对数组的请求来自大的连续块；例如，访问 1 MB 数据的请求（或一系列请求），从块 $x$ 开始到块 ($x+1$ MB) 结束，将被视为连续的。顺序工作负载在许多环境中都很常见（想象一下在大文件中搜索关键字），因此被认为很重要。</p>
<p>对于随机工作负载，我们假设每个请求都相当小，并且每个请求都发送到磁盘上不同的随机位置。例如，随机请求流可能首先访问逻辑地址 10 处的 4KB，然后访问逻辑地址 550,000，然后访问 20,100，等等。一些重要的工作负载，例如数据库管理系统 (DBMS) 上的事务工作负载，表现出这种类型的访问模式，因此它被认为是重要的工作负载。</p>
<p>当然，真正的工作负载并不那么简单，并且通常混合了顺序和看似随机的组件以及两者之间的行为。为了简单起见，我们只考虑这两种可能性。</p>
<p>正如您所知，顺序和随机工作负载将导致磁盘的性能特征存在很大差异。通过顺序访问，磁盘以其最有效的模式运行，花费很少的时间寻道和等待旋转，而大部分时间用于传输数据。对于随机访问，情况恰恰相反：大部分时间都花在寻道和等待旋转上，而花在传输数据上的时间相对较少。为了在我们的分析中捕捉到这种差异，我们假设磁盘在顺序工作负载下可以以 $S\text{ MB/s}$ 的速度传输数据，在随机工作负载下可以以$R\text{ MB/s}$的速度传输数据。一般来说，S 远大于 R（即 S ≫ R）。</p>
<p>为了确保我们理解这种差异，让我们做一个简单的练习。具体来说，我们根据以下磁盘特性来计算 S 和 R。假设顺序传输平均大小为 10 MB，随机传输平均大小为 10 KB。</p>
<p>另外，假设以下磁盘特性：</p>
<ul>
<li>平均寻道时间 7 ms</li>
<li>平均旋转延迟 3 ms</li>
<li>磁盘传输速率 50 MB/s</li>
</ul>
<p>为了计算 S，我们需要首先计算出典型的 10 MB 传输所花费的时间。首先，我们花费 7 毫秒进行寻道，然后花费 3 毫秒进行旋转。最后，传输开始；$\frac{10\text{ MB}}{50\text{ MB/s}}$ 导致传输时间为 $\frac{1}{5}s$，即 200 毫秒。因此，对于每个 10 MB 请求，我们花费 210 毫秒完成请求。要计算 S，我们只需：
$$
S=\frac{\text{Amount of Data}}{\text{Time to access}}=\frac{10\text{ MB}}{210ms}=47.62\text{ MB/s}
$$
正如我们所看到的，由于传输数据花费大量时间，S 非常接近磁盘的峰值带宽（寻道和旋转成本已摊销）。我们可以类似地计算 R。寻道和旋转是一样的；然后我们计算传输所花费的时间，即$\frac{10\text{ KB}}{50\text{ MB/s}}$ ，即 0.195 毫秒。
$$
R=\frac{\text{Amount of Data}}{\text{Time to access}}=\frac{10\text{ KB}}{10ms+0.195ms}=0.981\text{ MB/s}
$$
我们可以看到，R 小于 1 MB/s，S/R 接近 50 MB/s</p>
<h2 id="raid-level-0条带化" class="heading-element"><span>5 RAID Level 0：条带化</span>
  <a href="#raid-level-0%e6%9d%a1%e5%b8%a6%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍" class="heading-element"><span>5.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>第一个 RAID Level实际上根本不是 RAID Level，因为没有冗余。不过，RAID Level（或称条带化）是性能和容量的绝佳上限，因此值得了解。</p>
<p>最简单的条带化形式是在系统磁盘上对数据块进行条带化，如下所示（这里假设有 4 个磁盘阵列）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=small" data-sub-html="<h2>image-20240414220046035</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png" alt="image-20240414220046035" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_0_Simple_Striping.png?size=large 2x" data-title="image-20240414220046035" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从上表中，你可以了解到基本概念：将磁盘阵列的数据块以循环方式分布在磁盘上。这种方法的设计目的是在请求连续的磁盘阵列块时，从磁盘阵列中提取最大的并行性（例如，在大的顺序读取中）。我们将同一行中的块称为一个条带；因此，块 0、1、2 和 3 位于上述同一条带中。</p>
<p>在示例中，我们做了一个简化假设，即在移动下一个磁盘之前，每个磁盘上只放置一个块（每个块的大小为 4KB）。然而，这种安排并不一定是必须的。例如，我们可以将块跨越多个磁盘进行排列，如下表所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=small" data-sub-html="<h2>image-20240414220112661</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png" alt="image-20240414220112661" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Striping_With_A_Bigger_Chunk_Size.png?size=large 2x" data-title="image-20240414220112661" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在本例中，我们在每个磁盘上放置两个 4KB 的数据块，然后再移动到下一个磁盘。因此，该 RAID 阵列的数据块大小为 8KB，一个磁条由 4 个数据块或 32KB 的数据组成。</p>
<blockquote>
<center>RAID 映射问题</center>
<p>在研究 RAID 的容量、可靠性和性能特征之前，我们首先介绍一下所谓的映射问题。所有RAID阵列都会出现这个问题；简而言之，给定一个要读取或写入的逻辑块，RAID 如何准确地知道要访问哪个物理磁盘和偏移量？</p>
<p>对于这些简单的 RAID levels，我们不需要太复杂就能将逻辑块正确映射到其物理位置。以上面的第一个条带化示例为例（块大小=1，数据块 = 4KB）。在这种情况下，给定逻辑块地址 A，RAID 可以使用两个简单的方程轻松计算所需的磁盘和偏移量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Disk</span>   <span class="o">=</span> <span class="n">A</span> <span class="o">%</span> <span class="n">number_of_disks</span>
</span></span><span class="line"><span class="cl"><span class="n">Offset</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">number_of_disks</span></span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，这些都是整数运算（例如，4 / 3 = 1 而不是 1.33333&hellip;）。让我们通过一个简单的例子来看看这些方程是如何工作的。想象一下，在上面的第一个 RAID 中，块 14 的请求到达。假设有 4 个磁盘，这意味着我们感兴趣的磁盘是 (14 % 4 = 2)：磁盘 2。确切的块计算公式为： （14 / 4 = 3)：块3。因此，块14应该在第三个磁盘（磁盘2，从0开始）的第四个块（块3，从0开始）上找到，这正是它所在的位置。</p>
</blockquote>
<h3 id="块大小" class="heading-element"><span>5.2 块大小</span>
  <a href="#%e5%9d%97%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>块大小主要影响阵列的性能。例如，较小的块大小意味着许多文件将在许多磁盘上进行条带化，从而提高单个文件读写的并行性；然而，跨多个磁盘访问块的定位时间会增加，因为整个请求的定位时间由跨所有驱动器的请求定位时间的最大值决定。</p>
<p>另一方面，大的块大小会降低这种文件内并行性，从而依赖多个并发请求来实现高吞吐量。然而，大的块大小会减少定位时间；例如，如果单个文件适合一个块并因此被放置在单个磁盘上，则访问它时产生的定位时间将只是单个磁盘的定位时间。</p>
<p>因此，确定“最佳”块大小很难，因为它需要大量有关磁盘系统的工作负载的知识。对于本次讨论的其余部分，我们将假设数组使用单个块 (4KB) 的块大小。大多数数组使用较大的块大小（例如 64 KB），但对于我们下面讨论的问题，确切的块大小并不重要；因此，为了简单起见，我们使用单个块。</p>
<h3 id="评估-条带化" class="heading-element"><span>5.3 评估 条带化</span>
  <a href="#%e8%af%84%e4%bc%b0-%e6%9d%a1%e5%b8%a6%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们来评估条带化的容量、可靠性和性能。从容量的角度来看，条带化是完美的：给定 N 块磁盘，每块磁盘的大小为 B 块，条带化就能提供$N\cdot B$ 个有用容量容量块。从可靠性的角度来看，条带化也是完美的，但也是糟糕的：任何磁盘故障都会导致数据丢失。</p>
<p>最后，性能也非常出色：所有磁盘都能利用，而且往往是并行利用，为用户的 I/O 请求提供服务。例如，从延迟的角度来看，单块请求的延迟应与单个磁盘的延迟基本相同；毕竟 RAID-0 只需将该请求重定向到其中一个磁盘即可。从稳态吞吐量的角度来看，我们希望获得系统的全部带宽。因此，吞吐量等于 N（磁盘数量）乘以 S（单个磁盘的连续带宽）。对于大量随机 I/O，我们可以再次使用所有磁盘，从而获得 $N\cdot R$MB/s。我们将在下文中看到，这些值既是最简单的计算值，也是与其他 RAID levels相比的上限。</p>
<h2 id="raid-level-1镜像" class="heading-element"><span>6 RAID Level 1：镜像</span>
  <a href="#raid-level-1%e9%95%9c%e5%83%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-1" class="heading-element"><span>6.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除条带化之外，我们的第一个 RAID Level称为 RAID Level 1，或镜像。在镜像系统中，我们只需为系统中的每个数据块制作一个以上的副本；当然，每个副本都应放置在单独的磁盘上。通过这种方法，我们可以<font color="red">容忍磁盘故障</font>。</p>
<p>在典型的镜像系统中，我们假设 RAID 会为每个逻辑块保留两个物理副本。下面是一个例子：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=small" data-sub-html="<h2>image-20240414224917155</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png" alt="image-20240414224917155" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Simple_RAID_1_Mirroring.png?size=large 2x" data-title="image-20240414224917155" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在示例中，磁盘 0 和磁盘 1 的内容完全相同，磁盘 2 和磁盘 3 的内容也完全相同；<font color="red">数据在这些镜像对中进行条带化处理</font>。事实上，你可能已经注意到，在磁盘上放置块拷贝有多种不同的方法。上面的排列方式很常见，有时也被称为 <strong>RAID-10</strong> 或（<strong>RAID 1+0</strong>），因为它使用镜像对（RAID-1），然后在其上使用条带（RAID-0）；另一种常见的排列方式是 <strong>RAID-01</strong>（或 <strong>RAID 0+1</strong>），它包含两个大型条带（RAID-0）阵列，然后在其上使用镜像（RAID-1）。现在，我们只讨论假设上述布局的镜像。</p>
<p>从镜像阵列读取数据块时，RAID 有一个选择：可以读取任一副本。例如，如果向 RAID 发出读取逻辑块 5 的命令，RAID 可以自由选择从磁盘 2 或磁盘 3 读取。但在写入逻辑块时，就没有这样的选择了：RAID 必须更新数据的两个副本，以保持可靠性。但请注意，这些写入可以并行进行；例如，对逻辑块 5 的写入可以同时写入磁盘 2 和磁盘 3。</p>
<h3 id="raid-1分析" class="heading-element"><span>6.2 RAID-1分析</span>
  <a href="#raid-1%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>让我们评估一下 RAID-1。</p>
<ul>
<li>从容量的角度来看，RAID-1 是昂贵的；镜像级别 = 2 时，我们只能获得峰值有用容量的一半。在 N 块磁盘上有 B 个数据块时，RAID-1 的有用容量为 $\frac{N\cdot B}{2}$。</li>
<li>从可靠性的角度来看，RAID-1 表现出色。它可以承受任何一块磁盘的故障。如果运气好的话，RAID-1 还能做得更好。想象一下，在上图中，磁盘 0 和磁盘 2 同时发生故障。在这种情况下，数据不会丢失！一般来说，镜像系统（镜像级别为 2）可以承受 1 个磁盘的故障，最多可以承受 $\frac{N}{2}$ 个磁盘的故障，具体取决于哪些磁盘发生故障。在实践中，我们通常不喜欢听天由命，因此大多数人认为镜像可以很好地处理单个故障。</li>
<li>最后，我们分析一下性能。从单个读取请求的延迟角度来看，我们可以看到它与单个磁盘的延迟相同；RAID-1 所做的只是将读取指向其中一个副本。写入则略有不同：它需要两次物理写入才能完成。这两次写入是并行进行的，因此时间与单个写入的时间大致相同；但是，由于逻辑写入必须等待两次物理写入完成，因此会受到两个请求中最坏情况下的寻道和旋转延迟，因此（平均而言）会略高于写入单个磁盘的时间。</li>
</ul>
<blockquote>
<center>RAID 一致性更新问题</center>
<p>在分析 RAID-1 之前，让我们首先讨论任何多磁盘 RAID 系统中都会出现的一个问题，即一致性更新问题 。写入任何必须在单个逻辑操作期间更新多个磁盘的 RAID 时都会出现此问题。在这种情况下，假设我们正在考虑镜像磁盘阵列。</p>
<p>想象一下，向 RAID 发出写操作，然后 RAID 决定必须将其写入两个磁盘，即磁盘 0 和磁盘 1。然后，RAID 向磁盘 0 发出写操作，但就在 RAID 可以向磁盘发出请求之前1、发生断电（或系统崩溃）。在这种不幸的情况下，让我们假设对磁盘 0 的请求已完成（但显然对磁盘 1 的请求没有完成，因为它从未发出）。</p>
<p>这种过早断电的结果是该块的两个副本现在不一致；磁盘 0 上的副本是新版本，磁盘 1 上的副本是旧版本。我们希望发生的是两个磁盘的状态都以原子方式改变，即，要么两个磁盘最终都成为新版本，要么都不成为新版本。</p>
<p>解决这个问题的一般方法是在执行之前使用某种<font color="red">预写日志</font>首先记录 RAID 将要执行的操作（即用某条数据更新两个磁盘）。通过采用这种方法，我们可以确保在发生崩溃时，会发生正确的事情；通过运行将所有待处理事务重播到 RAID 的恢复过程，我们可以确保没有两个镜像副本（在 RAID-1 情况下）不同步。</p>
<p>最后一点：由于每次写入时记录到磁盘的成本非常昂贵，因此大多数 RAID 硬件都包含少量非易失性 RAM（例如，电池供电的 RAM），用于执行此类记录。因此，无需花费高昂的日志记录到磁盘的成本即可提供一致的更新。</p>
</blockquote>
<p>为了分析稳态吞吐量，我们从顺序工作负载开始。当顺序写入磁盘时，每次逻辑写入必须导致两次物理写入；例如，当我们写入逻辑块0（上图）时，RAID内部会将其同时写入磁盘0和磁盘1。因此，我们可以得出镜像阵列顺序写入时获得的最大带宽为（$\frac{N}{2}\cdot S$)，或峰值带宽的一半。</p>
<p>不幸的是，我们在顺序读取期间获得了完全相同的性能。人们可能认为顺序读取可以做得更好，因为它只需要读取数据的一份副本，而不是两者都读取。然而，让我们用一个例子来说明为什么这没有多大帮助。假设我们需要读取块 0、1、2、3、4、5、6 和 7。假设我们将 0 的读取发送到磁盘 0，将 1 的读取发送到磁盘 2，将 2 的读取发送到磁盘 1 ，以及将 3 读取到磁盘 3。我们继续分别向磁盘 0、2、1 和 3 发出对 4、5、6 和 7 的读取。人们可能天真地认为，由于我们利用了所有磁盘，因此我们实现了阵列的全部带宽。</p>
<p>然而，要知道情况并非（必然）如此，请考虑单个磁盘（例如磁盘 0）收到的请求。首先，它收到对块0的请求；然后，它收到对块 4 的请求（跳过块 2）。事实上，每个磁盘都会收到对每个其他块的请求。当它在跳过的块上旋转时，它不会向客户端提供有用的带宽。因此，每个磁盘只能提供其峰值带宽的一半。因此，顺序读取只能获得($\frac{N}{2}\cdot S$)MB/s的带宽。</p>
<p>随机读取是镜像 RAID 的最佳情况。在这种情况下，我们可以将读取分布在所有磁盘上，从而获得全部可能的带宽。因此，对于随机读取，RAID-1 提供 $N\cdot R$ MB/s。</p>
<p>最后，随机写入的性能如您所料：$\frac{N}{2}\cdot R$ MB/s。每个逻辑写入必须转化为两个物理写入，因此当所有磁盘都在使用时，客户端只会将其视为可用带宽的一半。尽管对逻辑块 $x$ 的写入变成了对两个不同物理磁盘的两次并行写入，但许多小请求的带宽仅达到我们在条带化中看到的一半。正如我们很快就会看到的，获得一半的可用带宽实际上非常好！</p>
<h2 id="raid-level-4使用奇偶校验节省空间" class="heading-element"><span>7 RAID Level 4：使用奇偶校验节省空间</span>
  <a href="#raid-level-4%e4%bd%bf%e7%94%a8%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c%e8%8a%82%e7%9c%81%e7%a9%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-2" class="heading-element"><span>7.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们现在介绍一种不同的向磁盘阵列添加冗余的方法，称为<strong>奇偶校验</strong>。基于奇偶校验的方法试图使用更少的容量，从而克服镜像系统所付出的巨大空间代价。然而，这种方法以<strong>性能</strong>为代价。</p>
<p>下面是一个五磁盘 RAID-4 系统示例。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=small" data-sub-html="<h2>image-20240415095640999</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png" alt="image-20240415095640999" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example.png?size=large 2x" data-title="image-20240415095640999" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们为每个数据条带添加了一个奇偶校验块，用于存储该数据块条带的冗余信息。例如，奇偶校验块 P1 具有从块 4、5、6 和 7 计算出的冗余信息。</p>
<p>要计算奇偶校验，我们需要使用一个数学函数，使我们能够承受条带中任何一个块的丢失。事实证明，简单的函数 XOR 就能很好地做到这一点。对于一组给定的bit，如果bit中 1 的个数为偶数，则所有这些bit的 XOR 返回 0；如果 1 的个数为奇数，则返回 1。例如：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=small" data-sub-html="<h2>image-20240415100052993</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png" alt="image-20240415100052993" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_with_Parity_Calculate.png?size=large 2x" data-title="image-20240415100052993" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在第一行（0,0,1,1）中，有两个 1（C2、C3），因此所有这些值的 XOR 将是 0 (P)；同样，在第二行中只有一个 1（C1），因此 XOR 必须是 1 (P)。您可以用一种简单的方法记住这一点：任何一行中 1 的个数必须是偶数（而不是奇数）；这就是 RAID 必须保持的<strong>不变性</strong>，这样奇偶校验才会正确。</p>
<p>从上面的例子中，您或许还能猜到如何使用奇偶校验信息来从故障中恢复。假设标有 C2 的列丢失了。要想知道该列中应该有哪些值，我们只需读入该行中的所有其他值（包括 XOR 的奇偶校验位），然后重建正确的答案。具体来说，假设第一行 C2 列的值丢失了（它是一个 1）；通过读取该行中的其他值（C0 中的 0、C1 中的 0、C3 中的 1 和奇偶校验列 P 中的 0），我们得到了 0、0、1 和 0。因为我们知道 XOR 在每一行中保持偶数个 1，所以我们知道丢失的数据一定是：一个 。请注意我们是如何计算重构值的：我们只需将数据位和奇偶校验位一起 XOR 即可，与最初计算奇偶校验的方法相同。</p>
<p>现在你可能想知道：我们说的是将所有这些bit进行 XOR，但从上面我们知道 RAID 在每个磁盘上放置了 4KB （或更大）的数据块；我们如何对一堆数据块应用 XOR 来计算奇偶校验呢？事实证明这也很简单。只需对数据块的每个位执行逐位 XOR 即可；将每个逐位 XOR 的结果放入奇偶校验块的相应位槽中即可。例如，如果我们有大小为 4 位的数据块，它们可能看起来像这样：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=small" data-sub-html="<h2>image-20240415100519049</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png" alt="image-20240415100519049" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_4_With_Parity_Example_2.png?size=large 2x" data-title="image-20240415100519049" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>从表中可以看出，每个数据块的每个bit都要计算奇偶校验，并将计算结果放入奇偶校验数据块中。</p>
<h3 id="raid-4-分析" class="heading-element"><span>7.2 RAID-4 分析</span>
  <a href="#raid-4-%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在让我们分析一下RAID-4。从容量的角度来看，RAID-4 使用 1 个磁盘来为其保护的每组磁盘提供奇偶校验信息。因此，RAID 组的有用容量为 $(N − 1) · B$。</p>
<p>可靠性也很容易理解：<font color="red">RAID-4 只能容忍 1 个磁盘故障，不能再出现更多故障。</font>如果多个磁盘丢失，则根本无法重建丢失的数据。</p>
<p>最后，还有性能。这次，让我们从分析稳态吞吐量开始。顺序读取性能可以利用除奇偶校验磁盘之外的所有磁盘，从而提供 $(N − 1) · S\text{ MB/s}$ 的峰值有效带宽（一个简单的情况）。</p>
<p>要了解顺序写入的性能，我们必须首先了解它们是如何完成的。将大块数据写入磁盘时，RAID-4 可以执行称为<font color="red">全条带写入的简单优化</font>。例如，想象一下块 0、1、2 和 3 已作为写入请求的一部分发送到 RAID 的情况（如下表所示）。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=small" data-sub-html="<h2>image-20240415101029694</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png" alt="image-20240415101029694" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Full_Stripe_Write_In_RAID_4_Example.png?size=large 2x" data-title="image-20240415101029694" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在这种情况下，RAID可以简单地计算P0的新值（通过对块0、1、2和3执行异或），然后将所有块（包括奇偶校验块）并行写入上面的五个磁盘中（表中以灰色突出显示）。因此，全条带写入是 RAID-4 写入磁盘的最有效方式。</p>
<p>一旦我们了解了全条带写入，计算 RAID-4 上顺序写入的性能就很容易了；有效带宽也是$(N − 1) · S\text{ MB/s}$。即使在操作过程中不断使用奇偶校验磁盘，客户端也无法从中获得性能优势。</p>
<p>现在我们来分析一下随机读取的性能。从上表中还可以看到，一组 1-block 随机读取将分布在系统的数据磁盘上，但不会分布在奇偶校验磁盘上。因此，有效性能为：$(N − 1) · R\text{ MB/s}$。</p>
<p>我们最后保存的随机写入呈现了 RAID-4 最有趣的情况。假设我们希望覆盖上面示例中的块 1。我们可以直接覆盖它，但这会给我们带来一个问题：奇偶校验块 P0 将不再准确地反映条带的正确奇偶校验值；在此示例中，P0 也必须更新。如何才能既正确又高效地更新呢？</p>
<p>事实证明有两种方法。第一个称为<font color="red">加法奇偶校验</font>，要求我们执行以下操作。要计算新奇偶校验块的值，请并行读入条带中的所有其他数据块（在示例中为块 0、2 和 3），并将这些数据块与新块 (1) 进行异或。结果就是新的奇偶校验块。为了完成写入，您可以将新数据和新奇偶校验写入各自的磁盘，同样是并行的。</p>
<p>该技术的问题在于它会随着磁盘数量的增加而扩展，因此在较大的 RAID 中需要大量读取来计算奇偶校验。因此，<font color="red">采用减法奇偶校验法</font>。</p>
<p>例如，想象一下这一串位（4 个数据位，一个奇偶校验）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=small" data-sub-html="<h2>image-20240415101714960</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png" alt="image-20240415101714960" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A_Strpe_RAID_4_Example_1.png?size=large 2x" data-title="image-20240415101714960" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>假设我们希望用一个新值覆盖位 C2，我们将其称为$C2_{new}$ 。减法分三个步骤进行。</p>
<ol>
<li>
<p>首先，我们读入C2处的旧数据（$C2_{old}=1$）和旧奇偶校验（$P_{old}=0$）。</p>
</li>
<li>
<p>然后，我们比较旧数据和新数据；</p>
<ul>
<li>如果它们相同（例如，$C2_{new}=C2_{old}$），那么我们知道奇偶校验位也将保持相同（即，$P_{new}=P_{old}$）。</li>
<li>然而，如果它们不同，那么我们必须将旧奇偶校验位翻转到其当前状态的相反状态，即，如果($P_{old}==1$)，$P_{new}$将被设置为0；如果 ($P_{old}==0$)，$P_{new}$将被设置为 1。我们可以用 XOR 巧妙地表达整个过程（其中 $\oplus$ 是 XOR 运算符）：</li>
</ul>
<p>$$
P_{new}=(C_{old}\oplus C_{new})\oplus P_{old}
$$</p>
</li>
</ol>
<p>由于我们处理的是数据块而不是bit，因此我们对数据块中的所有bit进行计算（例如，每个数据块中的 4096 个字节乘以每个字节的 8 个bit）。因此，在大多数情况下，新的数据块会与旧的数据块不同，因此新的奇偶校验数据块也会不同。现在，你应该能算出何时使用加法奇偶校验计算，何时使用减法奇偶校验计算。想一想，系统中需要有多少磁盘才能使加法计算法的 I/O 次数少于减法计算法；交叉点是多少？</p>
<p>在进行性能分析时，我们假设使用的是减法。因此，每写一次，RAID 必须执行 4 次物理 I/O（两次读和两次写）。现在假设有大量的写操作提交给 RAID，那么 RAID-4 可以并行执行多少次写操作呢？要理解这一点，让我们再看看 RAID-4 布局，如下表所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=small" data-sub-html="<h2>image-20240415102557259</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png" alt="image-20240415102557259" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_To_4_13_And_Parity_Blocks_Example.png?size=large 2x" data-title="image-20240415102557259" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>现在假设大约在同一时间有 2 个小写入提交到 RAID-4，即块 4 和 13（表中用 * 标记）。这些磁盘的数据位于磁盘 0 和 1 上，因此数据的读取和写入可以并行发生，这很好。出现的问题是奇偶校验磁盘；两个请求都必须读取 4 和 13 的相关奇偶校验块、奇偶校验块 P1 和 P3（用 + 标记）。希望问题现在已经清楚了：奇偶校验磁盘是此类工作负载下的瓶颈；因此，我们有时将其称为基于奇偶校验的 RAID 的<strong>小写入问题</strong>。因此，<font color="red">即使数据磁盘可以并行访问，奇偶校验磁盘也会阻止任何并行性的实现；由于奇偶校验磁盘的存在，对系统的所有写入都将被序列化</font>。由于奇偶校验磁盘每个逻辑 I/O 必须执行两次 I/O（一次读，一次写），因此我们可以通过计算奇偶校验磁盘在这两个 I/O 上的性能来计算 RAID-4 中小型随机写入的性能，因此我们达到了 $\frac{R}{2}$ MB/s。随机小写入下的 RAID-4 吞吐量很糟糕；当您向系统添加磁盘时，它不会得到改善。</p>
<p>最后，我们将分析 RAID-4 中的 I/O 延迟。大家现在都知道，单次读取（假设没有故障）只是映射到单个磁盘，因此其延迟相当于单个磁盘请求的延迟。单次写入的延迟需要两次读取，然后两次写入；读取和写入可以并行进行，因此总延迟大约是单个磁盘的两倍（存在一些差异，因为我们必须等待两次读取完成，从而获得最坏情况下的定位时间，但更新不会产生寻道成本，因此可能是比平均定位成本更好的定位时间）。</p>
<h2 id="raid-level-5旋转奇偶校验" class="heading-element"><span>8 RAID Level 5：旋转奇偶校验</span>
  <a href="#raid-level-5%e6%97%8b%e8%bd%ac%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本介绍-3" class="heading-element"><span>8.1 基本介绍</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d-3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了解决（至少部分地）小写入问题，Patterson、Gibson 和 Katz 引入了 RAID-5。 RAID-5 的工作方式几乎与 RAID-4 相同，只是它在驱动器之间旋转奇偶校验块，如下表所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=small" data-sub-html="<h2>image-20240415103321139</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png" alt="image-20240415103321139" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_5_With_Rotated_Parity.png?size=large 2x" data-title="image-20240415103321139" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>正如您所看到的，每个条带的奇偶校验块现在在磁盘上旋转，以消除 RAID-4 的奇偶校验磁盘瓶颈。</p>
<h3 id="raid-5-分析" class="heading-element"><span>8.2 RAID 5 分析</span>
  <a href="#raid-5-%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>RAID-5 的大部分分析与 RAID-4 相同。例如，两个级别的有效容量和容错能力是相同的。顺序读写性能也是如此。单个请求（无论是读还是写）的延迟也与 RAID-4 相同。</p>
<p>随机读取性能好一点，因为我们现在可以利用所有磁盘。最后，随机写入性能比 RAID-4 显着提高，因为它<font color="red">允许跨请求并行</font>。想象一下对块 1 的写入和对块 10 的写入；这将变成对磁盘 1 和磁盘 4 的请求（针对块 1 及其奇偶校验P0）以及对磁盘 0 和磁盘 2 的请求（针对块 10 及其奇偶校验P2）。因此，它们可以并行进行。事实上，我们通常可以假设，给定大量随机请求，我们将能够保持所有磁盘均匀忙碌。如果是这样的话，那么我们小写的总带宽将是 $\frac{N}{4}\cdot R$ MB/s。 4 个丢失的因素是由于每次 RAID-5 写入仍然生成 4 次总 I/O 操作，这只是使用基于奇偶校验的 RAID 的成本。</p>
<p>因为 RAID-5 基本上与 RAID-4 相同，除了在少数情况下更好之外，在市场上几乎完全取代了 RAID-4。唯一没有被取代的地方是那些知道自己永远不会执行大写操作的系统，从而完全避免小写问题；在这些情况下，有时会使用 RAID-4，因为它构建起来稍微简单一些。</p>
<h2 id="raid-比较" class="heading-element"><span>9 RAID 比较</span>
  <a href="#raid-%e6%af%94%e8%be%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现在，如下表所示，我们总结了 RAID Levels的简化比较。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=small" data-sub-html="<h2>image-20240415103909530</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png" alt="image-20240415103909530" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RAID_Capacity_Reliability_And_Performance.png?size=large 2x" data-title="image-20240415103909530" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>请注意，我们省略了许多细节以简化我们的分析。例如，在镜像系统中写入时，平均寻道时间比仅写入单个磁盘时稍长，因为寻道时间是两次寻道（每个磁盘上一次）的最大值。因此，两个磁盘的随机写入性能通常会略低于单个磁盘的随机写入性能。此外，在更新 RAID-4/5 中的奇偶校验磁盘时，第一次读取旧奇偶校验可能会导致完全寻道和旋转，但第二次写入奇偶校验只会导致旋转。</p>
<p>然而，表中的比较确实捕捉到了本质差异，并且对于理解跨 RAID Levels的权衡很有用。对于延迟分析，我们简单地使用 T 来表示对单个磁盘的请求所花费的时间。</p>
<p>总而言之：</p>
<ul>
<li>如果您严格<font color="red">要求性能而不关心可靠性</font>，那么<font color="red">条带化</font>显然是最好的。</li>
<li>然而，如果您想要<font color="red">随机 I/O 性能和可靠性</font>，<font color="red">镜像</font>是最好的；您所付出的成本是损失容量。</li>
<li>如果<font color="red">容量和可靠性</font>是您的主要目标，那么 <font color="red">RAID-5 就是首选</font>；您付出的代价是小写性能。最后，如果您<font color="red">始终执行顺序 I/O 并希望最大化容量</font>，那么 RAID-5 也是最有意义的。</li>
</ul>
]]></description></item></channel></rss>