<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>ZephyrHe</title><link>https://hezephyr.github.io/</link><description>HeZephyr's Note Zephyr He的博客：日拱一卒无有尽，功不唐捐终入海</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Thu, 25 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>【MIT 6.5840(6.824)学习笔记】Raft</title><link>https://hezephyr.github.io/posts/07.raft/</link><pubDate>Thu, 25 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/07.raft/</guid><description><![CDATA[<h2 id="脑裂" class="heading-element"><span>1 脑裂</span>
  <a href="#%e8%84%91%e8%a3%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>许多容错系统使用一个单主节点来决定主副本。</p>
<ul>
<li><strong>MapReduce</strong>：由单主节点控制计算复制。</li>
<li><strong>GFS</strong>：主备复制数据，并由单主节点确定主拷贝的位置。</li>
<li><strong>VMware FT</strong>：主虚机和备份虚机之间复制指令，需要单点的Test-and-Set服务确认主虚机。</li>
</ul>
<p>这三个例子都是一个多副本系统，<font color="red">系统容错的关键点转移到这个主节点上</font>。</p>
<p>使用单主节点，我们则需要避免<strong>脑裂（Split-Brain）问题</strong>。脑裂指的是在多副本系统中，因网络分裂导致多个副本都认为自己是主副本，从而出现数据不一致或功能冲突的问题。</p>
<p>这里有两种<strong>解决方案</strong></p>
<ol>
<li>构建高可靠网络：如果网络完全不出现故障，客户端无法访问的服务器即被认为是关机，这样可以排除脑裂的可能。<font color="red">但需要大量资金和控制物理环境</font>。</li>
<li>人工解决问题：客户端默认等待两个服务器的响应。如果只收到一个响应，需人工检查两个服务器的状态。<font color="red">人工检查虽然能解决问题，但可能不够及时</font>。</li>
</ol>
<h2 id="过半票决" class="heading-element"><span>2 过半票决</span>
  <a href="#%e8%bf%87%e5%8d%8a%e7%a5%a8%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在构建能自动恢复，同时又避免脑裂的多副本系统时，关键点在于<strong>过半票决（Majority Vote）</strong>，这是Raft论文中提出的一个基本概念，<font color="red">即在一个多副本系统中，任何操作必须得到超过一半的服务器同意才能完成</font>。为了有效使用过半票决，服务器数量应该是奇数。这样在出现网络分区时，一个分区无法拥有超过半数的服务器，从而避免脑裂。对于过半票决，可以用下面这个通用方程来描述：</p>
<p>如果系统有$2\times F+1$个服务器，那么系统最多可以接受$F$个服务器出现故障。</p>
<p>Raft协议依赖过半票决来进行Leader选举和日志提交。每个操作需要过半的服务器批准。任何两个操作的过半服务器至少有一个重叠。</p>
<ul>
<li><strong>Leader选举</strong>：新选出的Leader必然获得过半服务器的选票，而这些服务器与旧Leader的服务器有重叠，因此知道旧Leader的任期号。</li>
<li><strong>日志一致性</strong>：新Leader的过半服务器包含了旧Leader的操作，确保日志一致性。</li>
</ul>
<h2 id="raft概述" class="heading-element"><span>3 Raft概述</span>
  <a href="#raft%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft协议作为库（Library）存在于服务中，每个Raft副本包含应用程序代码和Raft库。<font color="red">应用程序代码处理RPC或其他客户端请求，Raft库负责同步多副本之间的操作</font>。</p>
<p><strong>操作流程</strong>如下：</p>
<ol>
<li>
<p><strong>客户端请求</strong>：客户端发送请求（如Put或Get）到Raft集群的Leader节点。</p>
</li>
<li>
<p><strong>请求处理</strong>：</p>
<ul>
<li><strong>Raft层</strong>：Leader节点将请求操作传递给Raft层，要求将操作写入日志。Raft节点之间的交互确保操作被过半节点复制。当Leader节点确认过半副本都有操作的拷贝后，通知应用程序层执行操作。</li>
</ul>
<ul>
<li><strong>应用程序层</strong>：仅在收到Raft层的确认后才执行操作（更新数据库或读取值）。</li>
</ul>
</li>
<li>
<p><strong>操作提交</strong>：</p>
<ul>
<li><strong>Raft层</strong>：通知应用程序层，操作已在过半副本中复制完成，可以执行。</li>
<li><strong>应用程序层</strong>：执行操作并最终返回结果给客户端。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>为何不需要拷贝到所有节点？</strong></p>
<p>为了容错，系统只需过半的副本即可完成操作，这样即使部分服务器故障，系统仍能继续工作。</p>
<p><strong>除了Leader节点，其他节点的应用程序层会有什么样的动作？</strong></p>
<p>在操作在Leader节点提交后，其他副本的Raft层将操作传递给本地应用程序层，确保所有副本的操作序列一致，状态最终保持一致。</p>
</blockquote>
<h2 id="日志" class="heading-element"><span>4 日志</span>
  <a href="#%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如下图所示，展示了Raft协议在处理客户端请求时的消息交互流程，AE代表<code>AppendEntries</code> RPC。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=small" data-sub-html="<h2>image-20240724224709014</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png" alt="image-20240724224709014" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240724224709014.png?size=large 2x" data-title="image-20240724224709014" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li><strong>客户端请求</strong>：客户端发送一个Put请求到当前Raft集群的Leader节点（S1）。</li>
<li><strong>Leader节点处理</strong>：S1的Raft层发送AppendEntries RPC到其他两个副本节点（S2、S3）。S1等待至少一个Follower节点（S2或S3）的响应以达到过半节点的响应。</li>
<li><strong>Follower节点响应</strong>：S2、S3接收AppendEntries RPC并返回响应给Leader（S1）。S1只需等待一个Follower节点的正确响应即可。</li>
<li><strong>操作提交</strong>：一旦S1收到过半节点的正确响应（包括自己），S1执行客户端请求并返回结果给客户端。</li>
<li><strong>通知其他副本</strong>：S2、S3在收到AppendEntries后不确定请求是否被Leader提交。Leader需要在下一次AppendEntries或心跳消息中通知其他副本请求已被commit。其他副本收到此消息后，更新本地状态，执行已提交的请求。</li>
</ol>
<p>Raft系统对Log的关注有几个关键原因：</p>
<ol>
<li><strong>操作排序</strong>：所有副本不仅要执行相同的操作，还要以相同的顺序执行这些操作。Log由编号的槽位（类似一个数组）组成，槽位的数字表示了Leader选择的顺序。</li>
<li><strong>临时存储</strong>：Follower收到操作但还未执行时，需要将操作存放在某处，直到收到Leader发送的commit号。Log就是这个临时存储的地方。Follower在操作commit前不确定这些操作是否会被执行，有时这些操作可能会被丢弃。</li>
<li><strong>重传机制</strong>：Leader记录操作在其Log中，因为这些操作可能需要重传给Follower。如果Follower短时间离线或丢失了一些消息，Leader需要能够向Follower重传丢失的Log消息。即使是已commit的请求，为了向丢失相应操作的副本重传，Leader也需要在Log中存储这些操作。</li>
<li><strong>状态恢复</strong>：Log帮助重启的服务器恢复状态。故障重启后的服务器使用存储在磁盘中的Log，从头执行其中的操作，重建故障前的状态并继续运行。每个Raft节点都需要将Log写入磁盘，确保故障重启后Log能保留，帮助服务器恢复状态。</li>
</ol>
<h2 id="应用层接口" class="heading-element"><span>5 应用层接口</span>
  <a href="#%e5%ba%94%e7%94%a8%e5%b1%82%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在Raft集群中，每一个副本上，应用层（如key-value数据库）和Raft层之间主要有两个接口。这两个接口分别用于转发客户端请求给Raft层，以及Raft层通知应用层请求已被commit。</p>
<p>第一个接口是key-value层用来转发客户端请求的接口—Start函数。当客户端发送请求给key-value层时，key-value层会将请求转发给Raft层，并告诉Raft层将请求存放在Log中。Start函数只接收一个参数，即客户端请求。Start函数的返回值包括：</p>
<ul>
<li>请求在Log中的位置（index）</li>
<li>当前的任期号（term number）</li>
<li>其他信息</li>
</ul>
<p>第二个接口是<code>applyCh</code> channel，<font color="red">以Go <code>channel</code>中的一条消息形式存在</font>。Raft层会通过发送ApplyMsg消息给applyCh来通知key-value层哪些请求已经commit，key-value层读取这些消息。ApplyMsg包含：</p>
<ul>
<li>请求（command）</li>
<li>对应的Log位置（index）</li>
</ul>
<p>所有的副本都会收到ApplyMsg消息，知道应该执行请求并应用在本地状态中。Leader需要知道ApplyMsg中的请求对应哪个客户端请求，以便响应客户端请求。</p>
<h2 id="leader-选举" class="heading-element"><span>6 Leader 选举</span>
  <a href="#leader-%e9%80%89%e4%b8%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>引入Leader的原因：</p>
<ul>
<li>
<p>有Leader系统效率更高，因为请求只需一轮消息即可获得过半认可。</p>
</li>
<li>
<p>无Leader系统需要一轮消息确认临时Leader，再一轮确认请求，效率较低。</p>
</li>
</ul>
<p>Raft使用任期号（term number）区分不同的Leader。每个任期最多有一个Leader。Followers只需知道当前的任期号。</p>
<p>Leader选举过程如下：</p>
<ol>
<li>如果Follower在选举定时器时间内未收到Leader消息，会认为Leader下线，开始选举。</li>
<li>当前节点增加任期号，发起选举。</li>
<li>节点发送<code>RequestVote</code> RPC给其他节点，自己投票给自己。</li>
<li>节点需要获得过半服务器的认可投票才能成为Leader。</li>
</ol>
<p>任期内每个节点只投一次票，就不可能有两个候选人同时获得过半的选票，确保每个任期最多一个Leader。成功当选后，Leader立即发送<code>AppendEntries</code>消息（心跳）通知其他节点自己当选。</p>
<p>如果Leader在网络分区中少数服务器内，无法获得过半认可，不能commit请求。旧Leader在小分区内运行，但不能执行客户端请求，只能发送心跳。</p>
<blockquote>
<p><strong>有没有可能出现极端的情况，导致单向的网络出现故障，进而使得Raft系统不能工作？</strong></p>
<p>如果当前Leader的网络单边出现故障，Leader可以发出心跳，但是又不能收到任何客户端请求。它发出的心跳被送达了，因为它的出方向网络是正常的，那么它的心跳会抑制其他服务器开始一次新的选举。但是它的入方向网络是故障的，这会阻止它接收或者执行任何客户端请求。这个场景是Raft并没有考虑的众多极端的网络故障场景之一。</p>
<p>可以通过一个双向的心跳机制来解决。即Leader发送心跳，Follower要响应这个心跳，如果Leader没有收到响应，则会决定卸任。</p>
</blockquote>
<p>所有Raft节点收到任何一条AppendEntries消息都会重置其选举定时器。只要Leader以合理的速率发送心跳或其他AppendEntries消息，Followers就会重置选举定时器，阻止其他节点成为候选人。在没有网络故障或丢包的情况下，<font color="red">连续的心跳消息会防止新的选举发生</font>。</p>
<p>如果出现<strong>服务器故障或网络问题</strong>或者<strong>分割选票（多个候选人几乎同时竞选，选票分散）</strong>，可能导致无法凑齐过半服务器，无法选出Leader，这次选举就失败了。</p>
<p>Raft不能完全避免分割选票问题，但可以大大降低发生概率。通过随机选择选举定时器的超时时间，减少同步超时的概率。</p>
<p><strong>超时时间设置</strong>：</p>
<ul>
<li><strong>下限</strong>：至少大于Leader的心跳间隔，多次心跳间隔更好（例如3次心跳间隔）。</li>
<li><strong>上限</strong>：远小于服务器两次故障之间的平均时间。</li>
<li><strong>时间差</strong>：足够大以确保第一个超时节点能够完成一轮选举，至少需要大于发送一条RPC的往返时间。</li>
</ul>
<blockquote>
<center>lab tip
</center>
<p><font color="red">每一次一个节点重置自己的选举定时器时，都需要重新选择一个随机的超时时间。</font>避免服务器会以极小的概率选择相同的随机超时时间，那么会永远处于分割选票的场景中</p>
</blockquote>
<h2 id="日志恢复" class="heading-element"><span>7 日志恢复</span>
  <a href="#%e6%97%a5%e5%bf%97%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><strong>Leader正常运行时</strong>，Follower必须同意并接收Leader的日志。但<strong>Leader故障后</strong>，新Leader需要整理各副本可能不一致的日志。</p>
<p>新Leader会发送包含<code>prevLogIndex</code>和<code>prevLogTerm</code>的AppendEntries RPC。</p>
<p>Follower检查本地日志是否匹配：</p>
<ul>
<li><strong>不匹配</strong>：拒绝AppendEntries，Leader减少nextIndex并重试。</li>
<li><strong>匹配</strong>：接受AppendEntries，更新本地日志。</li>
</ul>
<blockquote>
<p><strong>为什么Raft系统可以安全的删除不一致的日志？</strong></p>
<p>如果日志条目未存在于过半服务器中，旧Leader不可能commit该条目，也就不可能将它应用到应用程序的状态中，安全删除无影响。<font color="red">并且如果客户端未收到回复，将重发请求，确保请求最终被处理</font>。</p>
<p><strong>为什么总是删除Followers的Log的结尾部分？</strong></p>
<p>Leader具有完整的Log记录，可以在任何需要的时候填充Followers的日志。如果系统刚启动，或发生反常情况，Leader能够从第一条记录开始恢复Followers的日志，因为它有所有必要的信息。</p>
</blockquote>
<h2 id="选举约束" class="heading-element"><span>8 选举约束</span>
  <a href="#%e9%80%89%e4%b8%be%e7%ba%a6%e6%9d%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>为了保证系统的正确性，并非任意节点都可以成为Leader。不是说第一个选举定时器超时了并触发选举的节点，就一定是Leader。Raft对于谁可以成为Leader，存在一些限制。限制条件如下：</p>
<ul>
<li>候选人最后一条Log条目的任期号<strong>大于</strong>本地最后一条Log条目的任期号；</li>
<li>或者，候选人最后一条Log条目的任期号<strong>等于</strong>本地最后一条Log条目的任期号，且候选人的Log记录长度<strong>大于等于</strong>本地Log记录长度。</li>
</ul>
<p>所以Raft更倾向于选择拥有更高任期号记录的候选人，确保系统一致性。</p>
<h2 id="快速恢复" class="heading-element"><span>9 快速恢复</span>
  <a href="#%e5%bf%ab%e9%80%9f%e6%81%a2%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>基于上述介绍，Leader<strong>现行机制</strong>是每次回退一条Log条目来解决日志冲突。如果Follower长时间关机，错过大量AppendEntries消息。Leader重启后需逐条RPC回退Log条目，耗时较长。</p>
<p>Raft论文中提供了一个快速恢复方法。<font color="red">Follower返回足够信息给Leader，使Leader能按任期（Term）为单位回退，而非逐条回退</font>。Follower拒绝AppendEntries消息时，返回以下3个信息：</p>
<ul>
<li><strong>XTerm</strong>：Follower中与Leader冲突的Log条目的任期号。</li>
<li><strong>XIndex</strong>：Follower中，任期号为XTerm的第一条Log条目的槽位号。</li>
<li><strong>XLen</strong>：Follower中空白Log槽位数。</li>
</ul>
<blockquote>
<p>可以使用二分查找等更高效的方法进一步加速。</p>
</blockquote>
<h2 id="持久化" class="heading-element"><span>10 持久化</span>
  <a href="#%e6%8c%81%e4%b9%85%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在Raft协议中，持久化存储（persistence）和非持久化存储（volatile）的区别在于服务器重启时的状态保持。持久化存储确保服务器重启后能够恢复到之前的状态，从而保证服务的连续性和数据的一致性。持久化存储通常使用磁盘或电池供电的RAM来保存数据。</p>
<p>根据Raft论文图2，以下三个数据需要持久化存储：</p>
<ul>
<li><strong>Log</strong>：保存所有的日志条目，是唯一记录应用程序状态的地方。</li>
<li><strong>currentTerm</strong>：当前的任期号，用于确保每个任期只有一个Leader。</li>
<li><strong>votedFor</strong>：记录当前任期投票给了哪个服务器，用于确保每个任期内只有一个Leader被选举出来。</li>
</ul>
<p>每当Log、currentTerm或votedFor发生变化时，服务器必须将这些数据写入磁盘以确保其持久化。这可以通过调用系统的<code>write</code>和<code>fsync</code>函数来实现，其中<code>fsync</code>确保数据在磁盘上安全存储。</p>
<p>为了提高性能，可以采用批量操作的方法。例如，当Leader接收到多个客户端请求时，可以累积这些请求，然后一次性持久化存储多个Log条目，减少持久化存储的次数。</p>
<h2 id="日志快照" class="heading-element"><span>11 日志快照</span>
  <a href="#%e6%97%a5%e5%bf%97%e5%bf%ab%e7%85%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在Raft一致性算法中，日志条目（Log entries）会随着系统运行时间的延长而不断增加。这会带来两个问题：</p>
<ol>
<li><strong>存储空间</strong>：日志条目数量过多，会占用大量的内存和磁盘空间。</li>
<li><strong>系统重启</strong>：如果服务器重启，需要重放所有日志条目来恢复状态，耗时较长。</li>
</ol>
<p>为了应对上述问题，Raft引入了快照机制。快照是对应用程序状态的压缩表示。通过创建快照，可以丢弃部分已应用的日志条目，减少存储空间，并加快重启时的恢复过程。</p>
<p>Raft会将应用程序创建的快照存储在磁盘上，确保数据的持久性。服务器重启时，Raft会从磁盘读取最近的快照，并将其传递给应用程序，恢复到快照对应的状态。然后，从快照之后的日志条目开始继续恢复。</p>
<p>如果某个Follower的日志比Leader的短，且短于Leader快照的起始位置，那么Leader无法通过发送日志条目来同步Follower的日志。Raft引入了<code>InstallSnapshot</code> RPC。当Follower的日志长度不够时，Leader会发送快照给Follower，然后继续通过<code>AppendEntries</code> RPC发送后续的日志条目。</p>
<p>快照的生成和恢复需要应用程序与Raft组件之间的紧密协同。应用程序负责生成和吸纳快照，Raft负责管理快照和日志条目的持久化存储。Leader可能并发发送多个RPC消息，包括<code>AppendEntries</code>和<code>InstallSnapshot</code>，需要处理可能的乱序和冗余消息。</p>
<blockquote>
<p><strong>快照生成是否依赖应用程序</strong></p>
<p>是的，快照生成函数是应用程序的一部分，应用程序负责生成和恢复快照。只有应用程序自己才知道自己的状态（进而能生成快照）。而通过快照反向生成应用程序状态的函数，同样也是依赖应用程序的。</p>
</blockquote>
<h2 id="课程qa" class="heading-element"><span>12 课程QA</span>
  <a href="#%e8%af%be%e7%a8%8bqa" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li><strong>Raft 通常用于什么？是否用于实际软件中？</strong></li>
</ol>
<p>Raft（以及 Paxos）主要用于构建容错的“配置服务”，跟踪在大型部署中的服务器职责分配。这种服务对复制部署尤为重要，可以避免脑裂问题。Raft 还被一些数据库（如 Spanner、CockroachDB）用于数据复制。</p>
<p>有多个实际应用使用 Raft，如 Docker、etcd 和 MongoDB。许多基于 Paxos 的系统（如 Chubby、ZooKeeper）也在实际生产环境中使用。</p>
<ol start="2">
<li><strong>Raft 如何与 VMware FT 比较？</strong></li>
</ol>
<p>Raft 更具容错性，没有单点故障，而 VMware FT 存在一个测试和设置服务器作为单点故障。Raft 用作库集成在应用软件中，而 VMware FT 可用于任何虚拟机。</p>
<ol start="3">
<li><strong>Raft 如何防止恶意攻击？</strong></li>
</ol>
<p>Raft 默认没有防御恶意攻击的机制。实际部署中需要通过防火墙保护，或使用加密验证 Raft 数据包。</p>
<ol start="4">
<li><strong>Raft 的“非拜占庭”条件是什么？</strong></li>
</ol>
<p>Raft 假设服务器要么按协议运行，要么停止运行。拜占庭故障指计算机执行错误操作，这可能导致 Raft 发送不正确的结果。</p>
<ol start="5">
<li><strong>Raft 可以在地理分布的数据中心中使用吗？</strong></li>
</ol>
<p>通常，Raft 部署在单一数据中心。<font color="red">跨数据中心的系统（如 Spanner）更适合无领导协议，以便客户可以与本地副本通信</font>。</p>
<ol start="6">
<li><strong>Raft 的日志为何是从 1 开始编号的？</strong></li>
</ol>
<p>日志从零编号，但第一个条目（索引为 0）具有Term 0，使得初始 AppendEntries RPC 可以包含有效的 PrevLogIndex。</p>
<ol start="7">
<li><strong>Raft 的副本优化是什么？</strong></li>
</ol>
<p>副本优化通过在服务快照时使用 fork()，实现了“写时复制”。操作系统会延迟实际的内存复制，优化了性能。</p>
<ol start="8">
<li><strong>为什么新领导在其任期开始时需要提交一个无操作（no-op）日志条目？</strong></li>
</ol>
<p>新领导提交无操作日志条目可以确保其日志中所有之前的条目都是已提交的。这是为了防止新领导在自己失败时，前一个领导的日志条目未被提交，从而保持系统一致性。</p>
<ol start="9">
<li><strong>使用心跳机制提供租约（leases）进行只读操作是如何工作的？为什么需要时间同步？</strong></li>
</ol>
<p>领导者通过在心跳消息中暗示下一段时间内不能选举新领导，从而提供只读操作的租约。为了保证安全，服务器的时钟需要保持同步，确保租约时间的准确性。</p>
<ol start="10">
<li><strong>在 Raft 的配置变更过程中，如何理解旧配置（$C_\text{old}$）到新配置（$C_\text{new}$）的过渡？</strong></li>
</ol>
<p>在联合共识阶段（$C_\text{old,new}$），领导者需要获得旧配置和新配置的多数支持。配置变更日志条目需要同时被旧配置和新配置的多数服务器确认。</p>
<ol start="11">
<li><strong>快照（snapshot）的创建和恢复过程中的数据是否需要压缩？</strong></li>
</ol>
<p>快照通常会对数据进行压缩，以减少传输和存储成本。压缩方案应根据具体应用的数据类型来选择，如使用 JPEG 压缩图像数据，或使用通用压缩算法如 ZIP。</p>
<ol start="12">
<li><strong>领导者如何决定什么时候向跟随者发送快照？</strong></li>
</ol>
<p>领导者会在跟随者的 <code>matchIndex</code> 小于其日志开始索引时发送快照，以确保跟随者能够赶上最新的日志状态。</p>
<ol start="13">
<li><strong>在 Raft 中，添加日志条目是否算作执行操作？</strong></li>
</ol>
<p>不算。仅当领导者将日志条目标记为已提交后，服务器才会执行日志条目中的操作。执行操作指的是将日志条目交给实际服务进行处理。</p>
</blockquote>
]]></description></item><item><title>【论文阅读笔记】 SkexGen: Autoregressive Generation of CAD Construction Sequences with Disentangled Codebooks</title><link>https://hezephyr.github.io/posts/06.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0skexgen/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/06.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0skexgen/</guid><description><![CDATA[<h2 id="摘要" class="heading-element"><span>1 摘要</span>
  <a href="#%e6%91%98%e8%a6%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>SkexGen是一种新颖的<font color="red">自回归生成模型</font>，用于创建CAD构造序列，其中包含<font color="red">草图和拉伸建模操作</font>。这个模型利用不同的Transformer架构将构造序列中的<strong>拓扑、几何和拉伸变化</strong>编码到<strong>解耦的码本</strong>中。<strong>自回归</strong>Transformer解码器根据码本向量生成具有特定属性的CAD构造序列。广泛的实验表明，我们的解耦码本表示可以生成多样且高质量的CAD模型，增强了用户的控制能力，并能够有效探索设计空间。</p>
<p><a href="https://github.com/samxuxiang/SkexGen"target="_blank" rel="external nofollow noopener noreferrer">【code】<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="引言" class="heading-element"><span>2 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>SkexGen是一种新颖的自回归生成模型，使用离散码本进行CAD模型生成。作者采用草图和拉伸建模语言来描述CAD构造序列，其中草图操作创建二维原语，拉伸操作将它们提升并组合成三维。<font color="red">Transformer编码器学习到解耦的潜在表示，作为三个码本，分别捕捉构造序列的拓扑、几何和拉伸变化</font>。给定码本向量，自回归Transformer解码器生成草图和拉伸构造序列，进而处理成CAD模型。</p>
<p>作者在一个大规模草图和拉伸数据集（<a href="https://drive.google.com/drive/folders/1mSJBZjKC-Z5I7pLPTgb4b5ZP-Y6itvGG"target="_blank" rel="external nofollow noopener noreferrer">DeepCAD数据集，需要将其转换为SkexGen格式<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>）上评估了SkexGen。与多个baseline和最先进方法进行的定性和定量评估表明，SkexGen生成了更真实和多样的CAD模型，同时实现了有效的控制和高效的设计空间探索，这是以往方法无法实现的。作者做出了以下贡献：</p>
<ul>
<li><strong>SkexGen架构</strong>，自回归生成高质量和多样化的CAD构造序列。</li>
<li><strong>解耦的码本</strong>，编码构造序列的拓扑、几何和拉伸变化，实现了设计的有效控制和探索。</li>
<li>在<strong>公共基准</strong>上的广泛定性和定量评估，展示了最先进的性能。</li>
</ul>
<h2 id="相关工作" class="heading-element"><span>3 相关工作</span>
  <a href="#%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>构造性实体几何（CSG）</strong></p>
<p>3D形状由参数化基元通过布尔运算组成的CSG树表达。这种轻量级表示已广泛用于与程序合成、神经引导程序合成、无监督学习和专用参数化基元结合的重建任务中。<font color="red">但参数化CAD仍主导机械设计，并且广泛使用草图和拉伸建模操作</font>。</p>
</li>
<li>
<p><strong>构造序列生成</strong></p>
<ul>
<li>PolyGen开创：使用Transformer和指针网络预测n-gon网格顶点和面。</li>
<li>数据集推动：大规模CAD建模操作数据集促进直接学习用户建模操作。</li>
<li>拉伸操作预测：预测拉伸操作序列以部分恢复构造序列，但没有底层草图信息。<font color="red">预测线、弧、圆等草图基元的序列是形成CAD二维基础的关键构造块，可通过添加拉伸操作轻松扩展到3D</font>。</li>
<li>Transformer架构的应用：应用于草图和拉伸序列生成，<font color="red">但在用户控制方面存在局限</font>。</li>
</ul>
<p>现有的方法通常将<font color="red">网络条件设置为用户提供的图像、点云或手绘草图</font>，只是将现有设计转换为CAD构造序列表示，<font color="red">而没有提供对拓扑和几何的单独控制</font>来探索相关设计的空间。作者的方法则提供对拓扑和几何的单独控制。</p>
</li>
<li>
<p><strong>码本架构</strong></p>
<p>自引入以来，码本已在许多图像和音频生成任务中证明有效，提高了生成图像的多样性并提供了额外的用户控制。由于其高结构规律性，它们特别适合于编码CAD建模序列。</p>
</li>
</ul>
<h2 id="草图和拉伸构造序列" class="heading-element"><span>4 草图和拉伸构造序列</span>
  <a href="#%e8%8d%89%e5%9b%be%e5%92%8c%e6%8b%89%e4%bc%b8%e6%9e%84%e9%80%a0%e5%ba%8f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>作者定义了一个草图和拉伸构造序列表示法，作为基元的层次结构，这一构造基于TurtleGen和DeepCAD的基础，并进行了若干修改，使表示法更具表现力和学习适应性，如下图所示，该示例模型由两个草图组成，这些草图由面、环和曲线构成。序列以拓扑token（$T_1$）开始，表示曲线的起点（类型为弧线），接着两个几何token（$G_1,G_2$），每个token存储一个二维点坐标，。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SkexGen_Construction_Seq_Example.png" alt="image-20240709221547861" style="zoom: 50%;" />
<p><strong>基元层次结构：</strong></p>
<ul>
<li><strong>曲线</strong>：最低级别的基元，包括直线、弧线或圆。</li>
<li><strong>环</strong>：一个闭合路径，由一个（例如圆）或多个曲线（例如直线-弧线-直线）组成。</li>
<li><strong>面</strong>：<font color="red">一个由环限定的二维区域</font>，这是我们的表示法中新增加的。具体来说，<font color="red">一个面由一个外环和若干内环（洞）构成</font>，这在许多CAD系统中是一个惯例。</li>
<li><strong>草图</strong>：由一个或多个面组成。</li>
<li><strong>拉伸草图</strong>：通过拉伸草图形成的三维体积。</li>
<li><strong>草图和拉伸模型</strong>：通过布尔操作（例如交集、并集和差集）由多个拉伸草图组成。<font color="red">注意，DeepCAD的表示法没有面基元，无法表示具有多个面的草图（例如Figure 1中的ES1）</font>。</li>
</ul>
<h2 id="skexgen架构" class="heading-element"><span>5 SkexGen架构</span>
  <a href="#skexgen%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>SkexGen 是一种自回归生成模型，通过两个网络分支中的三个解耦码本学习草图和拉伸模型的变体。图2展示了SkexGen的架构。“草图”分支学习二维草图的拓扑和几何变体，“拉伸”分支学习三维拉伸的变体（如方向）。两个分支架构类似，本节重点介绍草图分支，包含两个编码器和一个解码器。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SkexGen_Architecture.png" alt="image-20240709221648006" style="zoom:50%;" />
<h3 id="拓扑编码器" class="heading-element"><span>5.1 拓扑编码器</span>
  <a href="#%e6%8b%93%e6%89%91%e7%bc%96%e7%a0%81%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>拓扑编码器接收输入的子序列，token为：</p>
<ol>
<li>
<p><strong>拓扑token（T）</strong>：表示三种曲线类型之一（直线/弧线/圆）。</p>
</li>
<li>
<p><strong>结束基元token（E）</strong>：表示三种基元类型之一（环/面/草图）的结束。</p>
</li>
<li>
<p><strong>结束序列token（End）</strong>：表示序列的结束。</p>
</li>
</ol>
<p>因此，token初始化为一个7维（= 3+3+1）的独热向量</p>
<ul>
<li>
<p><strong>嵌入</strong></p>
<p>独热向量转换为256维嵌入。作者考虑拓扑token $T$，其中$h_{T} ^{tp}$是7维独热向量，$i_T$表示其在输入子序列中的索引，其嵌入向量计算公式为：</p>
<p>$$
T \leftarrow \mathbf{W}^\text{tp} h_{T} ^{tp} + \mathbf{p}^{(i_T)}
$$</p>
<p>其中$\mathbf{W}^\text{tp}\in \mathbb{R}^{d_E\times 7}$表示可学习矩阵，$\mathbf{p}^{(i_T)}$表示拓扑子序列索引$i_T$处的可学习位置编码。</p>
</li>
<li>
<p><strong>架构</strong></p>
<p>编码器基于Transformer（<font color="red">四层，每层包含八头自注意层、层规范化和前馈层</font>）。根据Vision Transformer，<strong>输入的拓扑信息编码为一个“码token”</strong>，预先加入到输入中，并初始化为一个可学习的嵌入$Z_{tp}$。令$Z_{tp}^e$为编码器输出的码token嵌入。嵌入$Z_{tp}^e$被量化为大小为$N({\mathbf{b}_{tp}\text{ | }i=1,2\cdots N})$的<strong>码本最近码</strong>。</p>
<p>编码和量化后的最终码token $Z_{tp}^Q$被传递给解码器。</p>
<p>$$
Z^Q_{tp} \leftarrow \mathbf{b}^{(k)}_{tp}, \text{where }
k = \text{argmin}_{j} | Z^e_{_{tp}} - b^{(j)}_{tp} |^2
$$</p>
<p>f这里为了简单起见，只假设了一个码token，拓扑编码器实际上由四个码token，并产生四个输出码token（$Z^{Q_{(1)}}_{tp},Z^{Q_{(2)}}_{tp},Z^{Q_{(3)}}_{tp},Z^{Q_{(4)}}_{tp}$）。作者尝试了不同的码本大小，发现 $N = 500$ 可以取得良好效果。</p>
</li>
</ul>
<h3 id="几何编码器" class="heading-element"><span>5.2 几何编码器</span>
  <a href="#%e5%87%a0%e4%bd%95%e7%bc%96%e7%a0%81%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>输入token</strong></p>
<ul>
<li>
<p>几何token（G）：包含一个二维点坐标</p>
</li>
<li>
<p>结束基元token（E）：表示四种基元类型之一（曲线/面/环/草图）的结束</p>
</li>
<li>
<p>结束序列token（End）</p>
</li>
</ul>
<p>几何token G 指定沿曲线的一个二维点坐标。由于坐标是数值型的，作者将<font color="red">草图离散化</font>为$64\times 64$（6位）像素，并考虑$64^2$个可能的像素位置。因此，一个$4101(=64^2+4+1)$维的独热向量唯一确定了token信息。</p>
</li>
<li>
<p><strong>嵌入</strong></p>
<p>我们按照4.1中的嵌入公式并使用$\mathbf{W^{ge}}\in\mathbb{R}^{d_E\times 4101}$和位置编码来初始化输入token嵌入。token E和End类似于拓扑Token的初始化，通过将它们的独热向量$h^{ge}_G\in \mathbb{R}^{4101}$乘以$\mathbf{W^{ge}}$并加上位置编码。几何Token G的初始化不同：</p>
<p>$$
G \leftarrow \mathbf{W^{ge}} h^{ge}_G + \mathbf{W}^xh^x_G +
\mathbf{W}^y h^y_G + \mathbf{p}^{(i_G)}.
$$</p>
<p>几何token $G$具有附加的坐标嵌入，$h^x_G,h^y_G\in \mathbb{R}^{64}$是指示像素的$x,y$坐标的独热向量。坐标嵌入是可选的，但可以进一步提高实验结果。</p>
</li>
<li>
<p><strong>架构</strong></p>
<ul>
<li>类似于拓扑编码器，基于Transformer。</li>
<li>生成嵌入 $Z^{{e_{(i)}}}_{ge}$ 和量化后的码token $Z^{Q_{(i)}}_{ge}$ 。</li>
<li>使用两个码token，码本大小 $N = 1000$。</li>
</ul>
</li>
</ul>
<h3 id="草图解码器" class="heading-element"><span>5.3 草图解码器</span>
  <a href="#%e8%8d%89%e5%9b%be%e8%a7%a3%e7%a0%81%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>草图解码器以拓扑和几何码本为输入，生成几何token $G$和结束基元token $E$（用于曲线/环/面/草图），以恢复草图子序列。</p>
<blockquote>
<p>注意，不生成拓扑标记T，因为它们可以根据每条曲线内的几何标记数量推断出来（即，直线/弧线/圆分别有1/2/4个G标记）。这意味着几何编码器和草图解码器有相似的子序列（Figure 2）。</p>
</blockquote>
<ul>
<li>
<p><strong>输入</strong></p>
<p>给定前$k-1$个token，自回归解码器预测第$k$个token的条件概率。训练输入序列向右移一位，前面添加“start”符号（由位置编码初始化）。由于解码器中可能的token类型与几何编码器相同，我们使用相同的$4101$维独热编码方案，并使用带有位置编码的可学习矩阵（大小为 $d_E \times 4101$）初始化嵌入向量。</p>
</li>
<li>
<p><strong>输出</strong></p>
<p>解码器生成“向左移一位”的子序列，即预测输入中的原始$k$个标记（见Figure 2）。令$K$为草图解码器输出中的一个标记，其具有 $d_E$ 维嵌入。我们使用可学习矩阵 $\mathbf{W^{out}} \in \mathbb{R}^{4101 \times d_E}$ 来预测4101个类别的概率：$h^\text{out}_K \leftarrow \text{softmax} (\mathbf{W^\text{out}} K)$</p>
</li>
<li>
<p><strong>交叉注意力</strong></p>
<p><font color="red">Transformer架构通过交叉注意力从拓扑和几何码本中分别取四个和两个量化码本向量</font>。为了区分两个不同的码本，我们借鉴位置编码的思想，分别向拓扑码 ${ Z^{Q_{(i)}}_{tp} }$ 和几何码 ${ Z^{Q_{(i)}}_{ge} }$ 添加可学习嵌入向量 $\mathbf{p}^{(q_{tp})} \in \mathbb{R}^{4 \times d_E}$和 $\mathbf{p}^{(q_{ge})} \in \mathbb{R}^{2 \times d_E}$ ：</p>
<p>$$
Z^{{Q_{(i)}}}_{tp} + p^{(q_{tp})} \quad \text{or} \quad
Z^{Q_{(i)}}_{ge}+ p^{(q_{ge})}.
$$</p>
<p>基础网络设置与编码器相同（即四层，每层八头），<font color="red">但它是带掩码的自回归（仅关注先前的标记）</font>。</p>
</li>
</ul>
<h3 id="训练" class="heading-element"><span>5.4 训练</span>
  <a href="#%e8%ae%ad%e7%bb%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>拓扑编码器、几何编码器和草图解码器通过三种损失函数联合训练：</p>
<p>$$
\sum_K \text{CrossEntropy}(h^\text{out}_K, h^\text{gt}_K) + \
| \text{sg} (Z^{e}_{tp}) - \mathbf{b}_{tp} |_2^2 + \beta
| Z^{e}_{tp} - \text{sg} (\mathbf{b}_{tp}) |_2^2 + \
| \text{sg} (Z^{e}_{ge}) - \mathbf{b}_{ge}
|_2^2 + \beta | Z^{e}_{ge} - \text{sg} (b_{ge}) |_2^2.
$$</p>
<ul>
<li>
<p>第一行计算序列重建损失，其中 $h^\text{out}_K$ 是草图解码器预测的概率， $h^\text{gt}_K$ 是真实的独热向量，<font color="red">利用交叉熵损失衡量准确度</font>。</p>
</li>
<li>
<p>第二行和第三行是VQ-VAE使用的标准码本和承诺损失。 $\text{sg}$ 表示<strong>停止梯度操作</strong>，在前向传播中是恒等函数，但在后向传播中阻止梯度。 $\beta$ <strong>缩放承诺损失</strong>，设为$0.25$，用于调整承诺损失的权重，这确保编码器输出绑定一个码向量。</p>
</li>
</ul>
<p>为了简化，我们省略了每个编码器中多个码本标记的明确写出。<font color="red">给定一个真实子序列，我们运行两个编码器并自回归地运行解码器，直到生成相同数量的标记</font>。训练采用教师强制的方式，即将真实token而非预测token输入解码器，保证每次迭代解码器仅专注于单步训练，从而简化训练流程并提升效率</p>
<h3 id="生成" class="heading-element"><span>5.5 生成</span>
  <a href="#%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>SkexGen 生成 CAD 模型分两步：</p>
<ol>
<li>从三个码本生成码。
<ul>
<li>
<p>采用训练完成的编码器（拓扑、几何、拉伸）从样本中提取码。</p>
</li>
<li>
<p>Transformer解码器被训练来生成这些<font color="red">非正态分布的量化码，即从码本中挑选码索引</font>。</p>
</li>
<li>
<p>允许架构微小修改以支持条件码生成，如“拓扑条件码选择器”，它基于给定拓扑码来挑选相应的几何和拉伸码。</p>
</li>
</ul>
</li>
<li>给定码生成草图和拉伸构造序列。
<ul>
<li>
<p>给定码，草图和拉伸解码器便通过核采样，自回归方式生成构造子序列。</p>
</li>
<li>
<p>这些子序列整合成完整的草图和拉伸序列，最终由CAD软件解析为边界表示。</p>
</li>
</ul>
</li>
</ol>
<h2 id="实验" class="heading-element"><span>6 实验</span>
  <a href="#%e5%ae%9e%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>实验验证目标：</p>
<ul>
<li>
<p>SkexGen生成高质量和多样化结果的能力</p>
</li>
<li>
<p>码本对生成过程控制的程度</p>
</li>
<li>
<p>SkexGen在设计探索和插值应用中的表现</p>
</li>
</ul>
<h3 id="实验设置" class="heading-element"><span>6.1 实验设置</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%ae%be%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>数据集</strong>：使用DeepCAD数据集，包含178,238个序列，经去重和无效操作剔除，最终训练集含<strong>74,584个草图子序列</strong>与<strong>86,417个拉伸子序列</strong>。针对单一草图实验，经过从构造序列的步骤中提取草图并去重后，<strong>最终收集到114,985个训练样本</strong>。</p>
</li>
<li>
<p><strong>实现细节</strong>：SkexGen基于PyTorch开发，在RTX A5000上训练。采用与DeepCAD一致的设置，四层Transformer结构，每层含八个注意力头，层规范化，前馈维度512，输入嵌入256维，Dropout率0.1。使用Adam优化器，学习率0.001。线性预热和梯度裁剪与 DeepCAD 一致。<font color="red">我们在前25个epoch中跳过代码量化，发现这有助于稳定码本训练。对于数据增强，我们向几何标记的坐标添加小的随机噪声</font>。训练300个epoch，批量大小128。草图与拉伸子序列最大长度分别为200与100。在测试时，我们使用核采样方法以自回归方式采样码选择器和解码器。</p>
</li>
<li>
<p><strong>指标</strong>：</p>
<ul>
<li>
<p><strong>Fréchet Inception Distance (FID)</strong>：比较真实和生成数据分布的均值和协方差来衡量生成的保真度。</p>
</li>
<li>
<p><strong>覆盖率（COV）</strong>：基于表面上2,000个均匀采样点的最小 Chamfer 距离来衡量真实数据与生成数据的匹配百分比。</p>
</li>
<li>
<p><strong>最小匹配距离 (MMD)</strong>：生成样本与其在真实数据集中最近邻的平均最小匹配距离。</p>
</li>
<li>
<p><strong>Jensen-Shannon散度 (JSD)</strong>：基于边缘点分布衡量真实和生成分布的相似性。</p>
</li>
<li>
<p><strong>Novel Score</strong>：生成数据中未出现在训练集中的百分比。</p>
</li>
<li>
<p><strong>Unique Score</strong>：生成样本中仅出现一次的数据百分比，如果序列中的所有token在6位量化后相同，我们认为两个数据样本是相同的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="随机生成" class="heading-element"><span>6.2 随机生成</span>
  <a href="#%e9%9a%8f%e6%9c%ba%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了评估 SkexGen 生成高质量和多样化结果的能力，我们随机生成每种类型的20,000个样本，并将 SkexGen 与四个其他基线进行比较：</p>
<ul>
<li>
<p>CurveGen</p>
</li>
<li>
<p>DeepCAD</p>
</li>
<li>
<p>单一码本的 SkexGen</p>
</li>
<li>
<p>带 VAE 的 SkexGen。</p>
</li>
</ul>
<blockquote>
<p>由于其他来自同时研究的草图生成模型依赖于草图约束标签，并且理想情况下需要草图约束求解器，这使得它们无法直接比较。</p>
</blockquote>
<p><strong>草图生成评估</strong>：结果如下表所示。SkexGen<strong>FID分数</strong>表现最优，证明其生成的草图质量最高。SkexGen在<strong>Novel</strong>上虽不及DeepCAD，但在<strong>Unique</strong>上与CurveGen相当或更优。且定性分析显示，DeepCAD虽然<strong>Novel</strong>得分高，但存在大量无效结果，如自相交曲线和未闭合几何，影响了FID评分。总体而言：</p>
<ul>
<li>
<p>SkexGen 生成的草图在<strong>质量上更好，形状更复杂，自相交更少，对称性更强</strong>。</p>
</li>
<li>
<p>CurveGen 也生成了质量不错的结果，<strong>但矩形和圆的复杂排列较少</strong>。</p>
</li>
<li>
<p>DeepCAD 可以生成比 CurveGen 更复杂的形状，<strong>但噪音很多</strong>。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240709222143401.png" alt="image-20240709222143401" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240709222229350.png" alt="image-20240709222229350" style="zoom:33%;" />
<p><strong>CAD模型生成评估</strong>：结果如下表所示，SkexGen在所有评估指标上领先，尤其在形状复杂度、对称性以及频繁使用弧线方面表现出色。<font color="red">SkexGen能生成涉及多步骤草图和拉伸序列的CAD模型，而DeepCAD则主要生成单步模型</font>。表中间两行展示了多个解耦码本的有效性。减少到单个码本后，生成质量下降，SkexGen 类似于 VQ-VAE。当不使用码本时，结果最差，SkexGen 实际上变成了 VAE。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240709222201905.png" alt="image-20240709222201905" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240709222300874.png" alt="image-20240709222300874" style="zoom: 33%;" />
<p><strong>运行时间评估</strong>：尽管SkexGen的自回归采样过程使其比DeepCAD慢，但比CurveGen（具有两个依赖的自回归解码器）快，显示出采样效率的优化空间。</p>
<h3 id="可控生成" class="heading-element"><span>6.3 可控生成</span>
  <a href="#%e5%8f%af%e6%8e%a7%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>解耦码本实现了设计控制与探索，如下图所示：左侧“拓扑条件”：固定拓扑码，其他码通过核采样获得，展示相同结构的不同变体。右侧“几何条件”：固定几何码，改变其他码，体现一致几何下的多样形态。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240709222419490.png" alt="image-20240709222419490" style="zoom: 33%;" />
<p>为了定量衡量三个码本之间的解耦程度，作者参考了$\beta\text{-VAE}$的评估方法。通过保持一个拓扑、几何或拉伸标记相同，并对其他部分进行采样，生成一对草图和拉伸序列。然后训练一个小型基于Transformer的分类器，通过编码潜在空间中所有数据对的平均成对差异来识别固定的码。SkexGen的分类准确率为99.8 ± 0.1%，证实码本间解耦效果显著。</p>
<h3 id="应用" class="heading-element"><span>6.4 应用</span>
  <a href="#%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>插值应用</strong></p>
<p>利用线性插值技术在模型的码之间探索，生成过渡模型。过程包括：编码模型提取关键码、线性插值这些码，再量化及生成插值模型。插值结果示例如Figure所示，线条演化为圆，矩形实体转为圆形空心盘，显示拓扑和几何动态变化。插值效果可能不平滑，因涉及复杂的离散拓扑变换。</p>
</li>
<li>
<p><strong>码混合应用</strong></p>
<p>通过混合不同数据的拓扑、几何和拉伸码，创造新颖设计组合。图8示例：保持拓扑形状，调整几何位置，如多个圆柱按方形布局排列。这些混合结果体现了系统的创新设计能力，超越了传统方法的局限。</p>
</li>
</ul>
<h2 id="总结" class="heading-element"><span>7 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>SkexGen是一种新颖的自回归生成模型，专为CAD构造序列设计。它利用不同的Transformer架构将CAD构造序列中的拓扑、几何和拉伸变化编码为解耦码本。这些解码器可以生成具有特定属性的CAD构造序列。SkexGen的优势在于其能够生成多样且高质量的CAD模型，同时提高用户的控制能力和设计空间的探索效率。</p>
<p>模型的评估在一个大规模的CAD数据集上进行，结果表明，SkexGen相比多个基准和最新方法，生成的CAD模型更为真实和多样。此外，SkexGen的架构也增强了用户在设计过程中的控制能力，使其能够更有效地探索不同设计空间。</p>
<h4 id="限制" class="heading-element"><span>7.0.1 限制</span>
  <a href="#%e9%99%90%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ol>
<li><strong>数据依赖</strong>：SkexGen依赖于大量的已标注CAD数据集，这些数据集的质量和多样性直接影响模型的表现。</li>
<li><strong>模型复杂性</strong>：该模型使用多个Transformer编码器和解码器来处理复杂的CAD构建序列，这增加了模型的复杂性和计算成本。</li>
<li><strong>拓扑和几何的分离</strong>：虽然这种分离有助于提高控制和生成多样性，但在实际应用中可能会导致模型难以学习到拓扑和几何之间的复杂关系。</li>
<li><strong>有限的建模操作</strong>：SkexGen主要关注草图和拉伸操作，未涉及其他的CAD建模操作，如旋转、扫掠、布尔运算等，限制了其应用范围（<font color="red">但可以通过导入CAD工具后编辑实现其他CAD建模操作</font>）。</li>
</ol>
<h4 id="创新点" class="heading-element"><span>7.0.2 创新点</span>
  <a href="#%e5%88%9b%e6%96%b0%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ol>
<li><strong>自回归生成模型</strong>：SkexGen是一个自回归生成模型，能够生成高质量和多样化的CAD构建序列。</li>
<li><strong>解耦码本</strong>：使用了解耦码本架构，分别编码CAD构建序列中的拓扑、几何和拉伸变化，提高了用户控制和设计空间的探索效率。</li>
</ol>
]]></description></item><item><title>【论文阅读笔记】Hierarchical Neural Coding for Controllable CAD Model Generation</title><link>https://hezephyr.github.io/posts/07.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0hierarchical-neural-coding-for-controllable-cad-model-generation/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/07.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0hierarchical-neural-coding-for-controllable-cad-model-generation/</guid><description><![CDATA[<h2 id="摘要" class="heading-element"><span>1 摘要</span>
  <a href="#%e6%91%98%e8%a6%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>作者提出了一种CAD的创新生成模型，该模型将CAD模型的高级设计概念表示为从全局部件排列到局部曲线几何的三层神经代码的层级树，并且通过指定目标设计的代码树来控制CAD模型的生成或完成。具体而言，<font color="red">一种带有“掩码跳过连接”的向量量化变分自编码器(VAE)的新变体在三个层次上提取设计变化作为神经码本。两阶段的级联自回归Transformer学习从不完整的CAD模型生成代码树，然后根据预期设计完成CAD模型</font>。广泛的实验表明，在<strong>无条件生成等传统任务</strong>上表现出优越性能，同时在<strong>条件生成任务</strong>中实现了新颖的交互能力。</p>
<p><a href="https://github.com/samxuxiang/hnc-cad"target="_blank" rel="external nofollow noopener noreferrer">【code】<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="引言" class="heading-element"><span>2 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>大多数现代CAD设计工具采用“草图和拉伸”风格的工作流程，<font color="red">以这种方式创建的CAD模型具有自然的树结构，支持局部编辑</font>。树叶处的曲线可以调整并重新生成拉伸以更新最终形状。对于设计师来说，重要的是编辑要保留“设计意图”。而设计意图定义也有不同：</p>
<ul>
<li>
<p>Otey等人将设计意图定义为“在修改时CAD模型的预期行为”</p>
</li>
<li>
<p>Martin描述为“对象之间的关系，使得对一个对象的更改可以自动传播到其他对象”。</p>
</li>
</ul>
<p>虽然“草图和拉伸”允许局部更改，但它不提供在编辑模型时给出预期行为所需的关系。一个能理解设计意图的计算系统将彻底改变CAD的实践。这种系统可以帮助设计师在：</p>
<ol>
<li>
<p>根据高级设计概念生成多样化的CAD模型；</p>
</li>
<li>
<p>在约束某些模型属性的情况下修改现有的CAD模型；</p>
</li>
<li>
<p>交互式地自动完成设计（如下图）。</p>
 <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example_For_User_Editing" alt="image-20240710195839501" style="zoom:33%;" />
</li>
</ol>
<p>但目前还没有这样的系统，当前行业标准通过手动指定参数和方程，以定义轮廓的位置和尺寸，以及用于对齐几何的约束，这种称为<font color="red">参数化CAD</font>的过程需要<font color="red">专业技能，并且在意外编辑时很容易出错</font>。下图展示了编辑约束不良的CAD模型的几何形状时原始设计意图被破坏的示例。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example_failures_of_parametric_CAD.png" alt="image-20240710195948645" style="zoom:50%;" />
<p><strong>现有的工作并未利用CAD设计的层次性来提供有效的设计控制</strong>。作者提出了一种新颖的生成网络，将CAD模型的设计意图捕获为从局部几何特征到全局部件排列的三层神经代码树，并根据编码树或不完整的CAD模型指定的设计意图控制CAD模型的生成或完成。CAD模型以建模操作的序列形式生成，然后转换为工业标准的边界表示（B-Rep）格式，以便在CAD软件中进行编辑。</p>
<p>具体来说，作者提出了一种带有“掩码跳过连接”的矢量量化VAE变体，从大规模草图和拉伸CAD数据集（<a href="https://drive.google.com/drive/folders/1mSJBZjKC-Z5I7pLPTgb4b5ZP-Y6itvGG"target="_blank" rel="external nofollow noopener noreferrer">DeepCAD数据集<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>）中学习设计变化形成三个神经码本。掩码跳过连接简单但有效，可以提取高度抽象的码本，使代码与生成的几何形状之间的关系变得直观。然后，两阶段级联自回归Transformer学习生成：</p>
<ol>
<li>
<p>给定不完整CAD模型的三层代码树</p>
</li>
<li>
<p>给定编码树和不完整数据的完整CAD模型</p>
</li>
</ol>
<p>设计师还可以直接提供编码树以生成模型。</p>
<p>与其他生成baseline的定性和定量评估表明，在随机生成任务中，该系统生成了更逼真和复杂的模型。在用户控制的条件生成任务中，系统展示了灵活和优越的几何控制，这得益于层次编码树表示，优于当前最先进的基于深度学习的生成模型（例如SkexGen，DeepCAD）。总之，我们的贡献包括：</p>
<ul>
<li>编码层次设计概念的神经代码树表示，支持高质量和复杂模型的生成、设计意图感知的用户编辑和设计自动完成。</li>
<li>带有掩码跳过连接的新型向量量化变分自编码器，用于增强代码簿学习。</li>
<li>在CAD模型生成方面相对于之前的最先进方法的性能提升。</li>
</ul>
<h2 id="相关工作" class="heading-element"><span>3 相关工作</span>
  <a href="#%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>构造性实体几何（CSG）</strong></p>
<p>3D形状由参数化基元通过布尔运算组成的CSG树表达。这种轻量级表示通过程序合成和无监督学习重建CAD形状。但参数化CAD仍主导机械设计，并且广泛使用草图和拉伸建模操作。</p>
</li>
<li>
<p><strong>直接CAD生成</strong></p>
<p>最近一些工作专注于<font color="red">在没有任何CAD建模序列监督的情况下直接生成CAD模型</font>。作者更专注于以草图和拉伸序列形式进行的参数化CAD的可控生成。</p>
</li>
<li>
<p><strong>草图和拉伸CAD生成</strong></p>
<p>最近大规模参数化CAD数据集的可用性使基于学习的方法能够利用CAD建模序列历史和草图约束生成工程草图和实体模型。生成的序列可以用实体建模内核解析，以获得包含2D工程草图或3D CAD形状的可编辑参数化CAD文件。此外，生成可以受目标B-rep、草图、图像、体素网格或点云的影响。<font color="red">但这种控制是全局级别的，而作者旨在支持设计保持编辑和自动完成等应用程序的全局和局部级别的层次控制</font>。</p>
</li>
<li>
<p><strong>用户控制的CAD生成</strong></p>
<p>提供用户对生成过程的控制，同时保持设计意图，是生成模型在实际CAD软件中采用的关键。尽管以前的方法可以基于高级指导生成多样化的形状，但使用户能够控制生成过程更具挑战性。Sketch2CAD和Free2CAD专注于设计过程的局部控制，并且需要大量的输入。最近的一些工作还利用文本提示和用户指定的指导。SkexGen允许用户通过解耦全局控制CAD形状的拓扑和几何来探索设计变化。然而，其方法仅有助于从零开始创建新设计，<strong>无法轻易修改以提供用户期望的智能编辑CAD模型或自动完成下一步操作的交互体验</strong>。<font color="red">与现有工作不同，作者的方法利用CAD模型内部存在的自然层次结构，提供对生成过程的全局和局部控制。</font></p>
</li>
</ul>
<h2 id="层次cad属性" class="heading-element"><span>4 层次CAD属性</span>
  <a href="#%e5%b1%82%e6%ac%a1cad%e5%b1%9e%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>草图和拉伸的CAD模型具有自然的层次结构，如下图所示。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Model_for_CAD.png" alt="image-20240710200053395" style="zoom: 33%;" />
<p>其中一个环定义了一条封闭的曲线路径，一个轮廓在草图平面内由一个外环和一些内环限定了一个封闭区域，而一个实体则表示一组拉伸的轮廓组合成整个模型。我们的目标是实现在生成CAD模型时的局部和全局控制，即用户可以编辑任何一个实体，并期望其余部分自动进行合理的更新。为了实现这一目标，我们在神经网络的潜在空间中捕捉这种层次结构。<font color="red">在层次结构的较高层上，网络学习较低层次几何实体的相对位置，即构成模型的轮廓和拉伸的边界框</font>。具体来说，我们将CAD模型视为一个实心（S）—轮廓（P）—环（L）树：</p>
<ul>
<li>
<p><strong>环（L）</strong> ：在树的叶子上，我们有环。每个环由一组线和弧或一个圆组成。环（L）的属性定义为一系列由特殊$\text{&lt;SEP&gt;}$ token分隔的x-y坐标：
$$
L = {(x_1, y_1), (x_2, y_2), \text{&lt;SEP&gt;}, (x_3, y_3), \ldots}.
$$</p>
<p>线由两个点（起点和终点）的xy坐标表示；弧由三个点表示，包括起点、中点和终点；圆由曲线上四个均匀分布的点表示。使用这种表示法，<strong>可以通过点的数量识别曲线类型</strong>。我们对环中的曲线进行排序，使得初始曲线是起点坐标最小的曲线，下一条是与其逆时针方向相连的曲线。</p>
</li>
<li>
<p><strong>轮廓（P）</strong>：轮廓位于叶子层之上。由于环的几何结构在叶子层捕捉，轮廓节点的属性定义为草图平面内环的二维边界框参数系列：</p>
<p>$$
P = {(x_i, y_i, w_i, h_i)}_{i=1}^{N^{\text{loop}}_i}.
$$</p>
<p>其中$i$是轮廓内$N^{\text{loop}}_i$个环的索引。$(x_i, y_i)$是边界框的左下角，$(w_i, h_i)$是宽度和高度。<font color="red">我们通过对所有二维边界框的左下角进行升序排序来确定轮廓$P$中边界框参数的顺序</font>。</p>
</li>
<li>
<p><strong>实体（S）</strong>：在轮廓层之上，我们有通过拉伸一个或多个轮廓形成的三维实体模型。实体节点的属性捕获拉伸轮廓的排列，使用一系列三维边界框参数：</p>
<p>$$
S = {(x_j, y_j, z_j, w_j, h_j, d_j)}_{j=1}^{N^{\text{profile}}_j}.
$$</p>
<p>其中$j$是模型中$N^{\text{profile}}_j$个拉伸轮廓的索引。$(x_j, y_j, z_j)$是边界框的左下角，$(w_j, h_j, d_j)$是其尺寸。同样，$S$中的参数按所有拉伸的三维边界框的左下角进行升序排序。</p>
</li>
</ul>
<h2 id="三层码本学习" class="heading-element"><span>5 三层码本学习</span>
  <a href="#%e4%b8%89%e5%b1%82%e7%a0%81%e6%9c%ac%e5%ad%a6%e4%b9%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>给定一个以S-P-L树格式表示的草图和拉伸CAD模型数据集，一种新的向量量化VAE（VQ-VAE）变体学习它们的潜在模式，作为三个离散的码本，这些码本将CAD模型编码为一棵神经码树，用于下游应用。</p>
<p>遵循SkexGen，我们用于学习码本的架构基础是一个VQ-VAE，由一个Transformer编码器$E$和解码器$D$组成，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Architecture_CAD?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Architecture_CAD?size=small" data-sub-html="<h2>image-20240710200229628</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Architecture_CAD" alt="image-20240710200229628" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Architecture_CAD?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Architecture_CAD?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Architecture_CAD?size=large 2x" data-title="image-20240710200229628" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们独立学习L、P和S的码本。与SkexGen和之前的掩码学习工作不同，我们在从编码器输入到解码器输入的跳过连接上应用掩码。直观来说，一个标准的VQ-VAE（即没有跳过连接）被训练用来恢复实例特定的输入细节，这对于正在学习实例无关设计模式的量化码来说是一个挑战。一个天真的跳过连接允许解码器通过直接复制输入来作弊。<font color="red">掩码跳过连接迫使解码器从未掩码元素中关联部分细节和填补缺失部分，其中关系由编码在码中的设计模式引导</font>。</p>
<ul>
<li>
<p><strong>编码器：</strong> 考虑一个$L$（方程1），包含一系列的x-y坐标和特殊的$\text{&lt;SEP&gt;}$ token。我们使用65维的独热向量来表示一个token，其中一个坐标被量化为6位（即64维），$\text{&lt;SEP&gt;}$需要一个额外的维度。设$T^E_t$表示Transformer编码器的第$t$个token的256维嵌入。嵌入初始化为：</p>
<p>$$
T_t^E\leftarrow\begin{cases}\text{MLP}(W_\text{emb}x_t\parallel
W_\text{emb}y_t)+\gamma_t\quad\text{(for x-y)},\\text{MLP}
(W_\text{emb}&lt;\text{SEP}&gt;\parallel W_\text{emb}&lt;\text{SEP}&gt;)+
\gamma_t.\end{cases}
$$</p>
<p>$W_\text{emb}$是一个$65\times 32$的token嵌入矩阵。$\parallel$是拼接运算符。$\text{MLP}$是一个两层的多层感知器。$\gamma_t$是一个可学习的256维位置嵌入。第二种情况是对于$\text{&lt;SEP&gt;}$，其值重复两次。对于P和S，我们处理每个二维或三维边界框参数的方式与$x_t, y_t$坐标相同，但没有$\text{&lt;SEP&gt;}$ token。</p>
</li>
<li>
<p><strong>向量量化：</strong> 编码器$E$的输出，序列长度为$T$，首先进行平均池化，形成$\overline{E}(T^E)$。然后应用标准的向量量化程序来获得一个256维的码本向量$c$。更具体地说，我们比较码本向量$\mathbf{b}$和编码的$\overline{E}(T^E)$之间的欧几里得距离，并执行最近邻查找。
$$
\mathbf{c}\leftarrow\mathbf{b}_k,\quad\text{where}\quad
k=\mathrm{argmin}_i\left|\left|\overline{E}(T^E)-\mathbf{b}_i\right|\right|^2.
$$</p>
</li>
<li>
<p><strong>带掩码跳过连接的解码器：</strong> 解码器接收量化码$c$和掩码的x-y坐标和$\text{&lt;SEP&gt;}$ token序列，并预测被掩码的token。例如，在一个环节点的情况下，任何$x_t, y_t$和$\text{&lt;SEP&gt;}$ token都可以被掩码（具体来说，每个模型随机掩码30%到70%的token）。设$T^D_t$表示为解码器输入的第$t$个token的嵌入。每个token的嵌入方式与编码器嵌入方程完全相同，只是被掩码的token的嵌入被一个可学习的共享32维掩码token嵌入$m$取代。来自编码器的256维码本向量$c$与${T^D_t}$拼接在一起并传递给解码器$D$，解码器有四个自注意力层。这里的思想是迫使编码器学习有用的潜在特征，可以帮助解码器预测被掩码的token。最后，在解码器后对每个token嵌入（除了码本向量）应用一个MLP，以生成(2 × 65)维的logits，即一对在65类标签上的概率值，分别用于预测xy坐标或$\text{&lt;SEP&gt;}$ token。</p>
</li>
<li>
<p><strong>损失函数：</strong> 训练损失由三项组成：</p>
<p>$$
\begin{aligned}&amp;\sum_{t}\mathrm{EMD}\Big(D(\mathbf{c},{T_{t}^{D}})
, \mathbb{1}_{T_{t}}\Big)+\&amp;\left|\left|sg[\overline{E}(T^{E})]-\mathbf{c}\right|\right|_{2}^{2}+\beta\left|\left|\overline{E}(T^{E})-sg[\mathbf{c}]\right|\right|_{2}^{2}.\end{aligned}
$$</p>
<p>第一项是解码器输出概率和相应数据属性的独热编码$\mathbb{1}_{T_t}$之间的平方EMD损失。损失仅应用于被掩码的token。我们使用的EMD损失函数，该函数假设有序的类标签，并对接近真实值的预测进行较少的惩罚。这比交叉熵损失更好，因为x-y坐标携带距离关系，使得损失可以集中在远离真实值的预测上。注意，我们对环数据属性中的$\text{&lt;SEP&gt;}$ token处理不同，应用标准的交叉熵损失，因为这不是一个有序类标签。</p>
<p>第二和第三项是VQ-VAE中使用的码本和承诺损失。$sg$表示停止梯度操作，在前向传播中是恒等函数，但在后向传播中阻止梯度。$\beta$缩放承诺损失，设为$0.25$。我们使用衰减率为$0.99$的指数移动平均更新。</p>
</li>
</ul>
<h2 id="可控cad生成" class="heading-element"><span>6 可控CAD生成</span>
  <a href="#%e5%8f%af%e6%8e%a7cad%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>环、轮廓和实体码本使我们能够将CAD模型的设计概念表达为层次化的神经代码，从而实现多样化和高质量的生成、新颖的用户控制以指定设计意图，以及自动完成不完整的CAD模型。具体来说，给定一个不完整的CAD模型作为草图和拉伸构建序列：</p>
<ol>
<li>模型编码器将输入序列转换为潜在嵌入；</li>
<li>自回归Transformer<strong>根据嵌入的输入序列</strong>生成代码树；</li>
<li>第二个自回归Transformer<font color="red">根据嵌入的输入序列和代码树</font>生成完整的CAD模型。</li>
</ol>
<ul>
<li>
<p><strong>模型编码器：</strong> 模型编码器的主体是标准的Transformer编码器模块，具有6个自注意力层。我们借用了SkexGen中使用的格式，并将模型表示为一个token序列，每个token是一个独热向量，唯一确定一个曲线类型、量化曲线参数和量化拉伸参数。编码器将独热向量转换为一系列256维的潜在嵌入${T^E_t}$。</p>
</li>
<li>
<p><strong>编码树生成器：</strong> $G_\text{code}$是一个自回归解码器，它生成代码的层次结构${T^C_t}$。每个实体、轮廓或环从相应的码本中分配一个代码，条件是编码的嵌入${T^E_t}$。类似于层次属性表示，层次代码表示为一系列特征向量，指示代码或分隔token。具体来说，一个特征是一个独热向量，其大小是三个码本中代码的总数加上一个分隔符。例如，考虑上图示例中的代码树，包含一个实体、两个轮廓和两个或四个环。这个树的特征表示为$[S, \text{&lt;SEP&gt;}, P, L, L, \text{&lt;SEP&gt;}, P, L, L, L, L]$。这里我们执行神经代码树的深度优先遍历，边界命令$\text{&lt;SEP&gt;}$用于指示轮廓和环代码的新分组。</p>
<p>$G_\text{code}$有6个自注意力（SA）层与6个交叉注意力（CA）层交替。第一个SA层是在查询token${T^{\bar{C}}_t}$上，每个查询token由位置编码$\gamma_t$初始化并自回归估计。每个CA层的输入是${T^E_t}$。每个SA或CA层都有8个头的注意力，随后是一个Add-Norm层。一个查询token ${T^{\bar{c}}_t}$将有一个生成的代码索引，该索引转换为一个代码${T^C_t}$。分隔符被一个可学习的嵌入取代。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240729230535954.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240729230535954.png?size=small" data-sub-html="<h2>image-20240729230535954</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240729230535954.png" alt="image-20240729230535954" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240729230535954.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240729230535954.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240729230535954.png?size=large 2x" data-title="image-20240729230535954" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>Codebook表示从代码索引到代码的映射。我们使用标准的交叉熵损失训练$G_\text{code}$。注意，对于无条件生成，我们删除部分CAD模型编码器，并仅使用查询token ${T^{\bar{C}}_t}$训练SA层，没有交叉注意力层和${T^E_t}$。</p>
</li>
<li>
<p><strong>模型生成器：</strong> 模型生成器是第二个自回归解码器$G_\text{cad}$，生成一个草图和拉伸的CAD模型。$G_\text{cad}$与SkexGen解码器相同，不同的是部分CAD模型嵌入${T^E_t}$和层次神经代码${T^C_t}$通过交叉注意力层控制生成，而SkexGen仅允许全局代码的指定。架构规格与第一个解码器相同。查询token ($T^\text{out}_t$)包含生成的CAD命令序列作为独热向量，我们使用相同的标准交叉熵损失。</p>
</li>
</ul>
<h2 id="实验" class="heading-element"><span>7 实验</span>
  <a href="#%e5%ae%9e%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>本节展示了无条件和有条件生成的结果，证明了以下几点：</p>
<ol>
<li>相较于当前最先进的技术，生成的质量更高、种类更多、复杂性更强；</li>
<li>通过层次化神经代码实现可控生成；</li>
<li>两个重要应用，用户编辑和自动补全。</li>
</ol>
<h3 id="实验设置" class="heading-element"><span>7.1 实验设置</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%ae%be%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>数据集</strong>: 使用大规模DeepCAD数据集，包含178,238个草图及拉伸模型，按90%训练、5%验证、5%测试划分。去除重复模型和属性，并限制训练模型的复杂度（最多5个实体、20个环/轮廓、60条曲线/环、200个命令/序列），最终训练集包含102,114个实体、60,584个轮廓、150,158个环和124,451个草图和拉伸序列用于CAD模型训练。对于CAD工程图，我们遵循SkexGen并从DeepCAD中提取草图。在移除重复后，共有99,650个草图用于训练。</p>
</li>
<li>
<p><strong>实施细节</strong>: 在Nvidia RTX A6000 GPU上训练，批次大小256。码本模块和生成模块分别训练250和350轮。采用改进的Transformer主干，输入嵌入维度256，前馈维度512，Dropout率0.1，各含6层、每层8头注意力。码本学习网络有4层。使用AdamW优化器，学习率0.001，线性预热2000步。测试时采用核采样，对输入曲线坐标添加随机噪声减少过拟合，针对码本坍塌问题采取重新初始化策略。最优代码本大小约为轮廓和实体3,500，环2,500，压缩比约60x、17x和29x。</p>
</li>
</ul>
<h3 id="指标" class="heading-element"><span>7.2 指标</span>
  <a href="#%e6%8c%87%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>五个已建立的指标定量评估随机生成</p>
<ul>
<li>
<p><strong>点云指标</strong>：基于模型表面采样的2000点比较生成和真实数据的点云集，评估多样性与质量。</p>
<ul>
<li>覆盖率（COV）：至少匹配一个生成样本的真实模型百分比，反映生成形状的多样性。</li>
<li>最小匹配距离（MMD）：平均最小匹配距离，衡量两组之间的接近程度。</li>
<li>Jensen-Shannon散度（JSD）：两个概率分布间的相似性，计算占用相同空间位置的频率。</li>
</ul>
</li>
<li>
<p><strong>token指标</strong>：衡量唯一性。数值字段量化为6位。</p>
<ul>
<li>新颖性（Novel）：未出现在训练集中的生成CAD序列比例。</li>
<li>唯一性（Unique）：在生成集中仅出现一次的数据比例。</li>
</ul>
</li>
</ul>
<h3 id="无条件生成" class="heading-element"><span>7.3 无条件生成</span>
  <a href="#%e6%97%a0%e6%9d%a1%e4%bb%b6%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对比DeepCAD与SkexGen，所有方法生成10,000个CAD模型，与测试集随机选取的2,500个真实模型比较。</p>
<ul>
<li>
<p>**定量评估：**如下表所示，我们的方法在所有三个点云评估指标上超越baseline，展现显著的质量和多样性提升。在Unique指标上，我们的方法与SkexGen相当，远超DeepCAD。Novel指标上略逊于SkexGen，但明显优于DeepCAD；此差距源于较小且多样性不足的训练集，且仅包含少量复杂形状所致。SkexGen因无法生成非常复杂的模型而受此影响较小。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240710200626544.png" alt="image-20240710200626544" style="zoom:50%;" />
</li>
<li>
<p><strong>定性评估：</strong> 下图显示我们的方法能生成结构良好、几何形状复杂、部件布局精细的CAD模型，与真实世界实例相似。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Quanlitative_Evaluation" alt="image-20240710200812020" style="zoom: 33%;" />
</li>
<li>
<p><strong>人工评估：</strong> 通过亚马逊众包平台进行人类感知质量评估，针对具有三个或更多拉伸的模型。在与真实模型并列展示的情况下，我们的方法在“真实感”评分上表现突出，分布对称，表明生成模型难以被区分。比较之下，DeepCAD和SkexGen的分布偏向“较不真实”，表明易被识别为简单或不规范的模型。我们的方法中有49.2%的生成模型被认定为比训练数据更“真实”，SkexGen为46.9%，DeepCAD为38.7%。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/human_evaluation" alt="image-20240710200951339" style="zoom:50%;" />
</li>
</ul>
<h3 id="可控生成" class="heading-element"><span>7.4 可控生成</span>
  <a href="#%e5%8f%af%e6%8e%a7%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们在两种“编辑”和一种“自动补全”应用场景中展示了可控生成。</p>
<ul>
<li>
<p><strong>代码树编辑：</strong> 用户可编辑不同层次的代码节点，实现局部到全局的CAD层次修改，这是以往方法所不具备的。编辑结果多样化且控制精确，如下图所示。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240710201053164.png" alt="image-20240710201053164" style="zoom:50%;" />
</li>
<li>
<p><strong>保持设计的编辑：</strong> 在固定代码树的基础上，用户可迭代地调整模型参数以细化设计，同时保持当前设计不变。如下图所示，局部尺寸调整后，相关部分会自动调整以适应更改。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240710201145516.png" alt="image-20240710201145516" style="zoom: 33%;" />
</li>
<li>
<p><strong>从用户输入的自动补全：</strong> 根据用户提供的部分轮廓或环，预测可能的代码集以完成CAD模型。图9和图10展示了从部分轮廓和拉伸轮廓开始的自动补全结果，每行展示不同生成代码的结果。相比最近邻搜索baseline，我们的方法在多样性和精确匹配用户输入方面表现更优，如图11所示。</p>
  <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/image-20240710201749115.png" alt="image-20240710201749115" style="zoom: 33%;" />
</li>
</ul>
<h2 id="总结" class="heading-element"><span>8 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>作者引入了一种新颖的可控CAD生成模型。方法的关键是三层神经编码，它在建模层次结构的不同层次上捕获设计模式和意图。本文在包含用户反馈的智能生成设计方向上又迈出了重要一步。广泛的评估显示，生成质量有了显著提升，并展示了作者的分层神经编码在意图感知编辑和自动补全等应用中的巨大潜力。其主要创新点和限制如下：</p>
<p><strong>创新点：</strong></p>
<ol>
<li><strong>分层神经编码</strong>：提出了一种三层次的神经编码方法，将CAD模型的高级设计概念表示为从全局部件布局到局部曲线几何的树状结构。</li>
<li><strong>设计意图的捕捉与控制</strong>：通过指定目标设计来生成或完成CAD模型，使用代码树来控制生成过程。</li>
<li><strong>新型变分自编码器（VAE）</strong>：提出了一种新型的向量量化VAE变体，具有“掩蔽跳跃连接”，用于从大规模草图和挤出CAD数据集中提取设计变化作为神经代码本。</li>
<li><strong>两阶段级联自回归变换器</strong>：用于从不完整的CAD模型生成代码树，然后根据预期设计完成CAD模型。</li>
</ol>
<p><strong>限制：</strong></p>
<ol>
<li><strong>有效性问题</strong>：当前系统在生成具有自相交边或实体的CAD模型时可能存在有效性问题，因为损失函数没有明确地惩罚无效的几何形状。<font color="red">未来的工作是增加一个损失函数，利用领域知识明确对 CAD 模型的无效性进行惩罚</font>。</li>
<li><strong>恢复失败的能力</strong>：系统在面对失败情况时，缺乏从错误中恢复的能力，这主要是因为缺乏“无效CAD模型数据集”来训练这种恢复机制。</li>
<li><strong>模型格式限制</strong>：该方法使用的是草图和拉伸CAD格式，这可能排除了其他流行的建模操作，如旋转、镜像和扫掠等。</li>
</ol>
]]></description></item><item><title>【论文阅读笔记】In Search of an Understandable Consensus Algorithm (Extended Version)</title><link>https://hezephyr.github.io/posts/03.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0in-search-of-an-understandable-consensus-algorithm-extended-version/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0in-search-of-an-understandable-consensus-algorithm-extended-version/</guid><description><![CDATA[<h2 id="介绍" class="heading-element"><span>1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式一致性共识算法指的是在分布式系统中，使得所有节点对同一份数据的认知能够达成共识的算法。且算法允许所有节点像一个整体一样工作，即使其中一些节点出现故障也能够继续工作。之前的大部分一致性算法实现都是基于Paxos，但Paxos难以理解和实现，为此作者开始寻找一种新的易于理解的一致性算法，Raft则是作者工作的产出。</p>
<p>在设计Raft的过程中，作者采用了一系列策略来增强其可理解性，包括：</p>
<ul>
<li><strong>算法分解</strong>：Raft将核心功能模块化，<font color="red">分离出领导人选举、日志复制和安全性三个关键部分</font>，使每个部分的逻辑更加清晰。</li>
<li><strong>状态空间缩减</strong>：相比于Paxos，Raft减少了不确定性和服务器间的不一致性状态，简化了状态机模型，从而降低了理解和实现的难度。</li>
</ul>
<p>Raft 算法在许多方面和现有的一致性算法都很相似，但是它也有一些特性：</p>
<ul>
<li><strong>强领导人机制</strong>：Raft采用了更强的领导人角色，<font color="red">所有日志条目仅由领导人发送给其他服务器</font>，这种集中控制方式简化了日志管理，增强了算法的直观性。</li>
<li><strong>领导人选举</strong>：<font color="red">Raft使用随机计时器来触发领导人选举</font>，这种机制在心跳机制的基础上增加了少许复杂性，<strong>但有效地解决了选举冲突，实现了快速而简单的决策过程</strong>。</li>
<li><strong>成员关系调整</strong>：Raft 使用一种<strong>联合共识</strong>的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li>
</ul>
<h2 id="复制状态机" class="heading-element"><span>2 复制状态机</span>
  <a href="#%e5%a4%8d%e5%88%b6%e7%8a%b6%e6%80%81%e6%9c%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>复制状态机是共识算法的核心应用背景，它是指一组服务器上的状态机生成相同状态的副本，即使部分服务器宕机也能持续运行。这种架构在大规模分布式系统中尤其重要，因为它能够解决一系列容错问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是<font color="red">一个独立的复制状态机去管理领导人选举和存储配置信息并且在领导人宕机的情况下也要存活下来</font>。比如 Chubby 和 ZooKeeper。</p>
<p>复制状态机通常都是基于复制日志实现的，如图 1。每个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。所有日志都包含相同的指令序列，确保状态机一致，因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be1.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图1.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">一致性算法的任务是保证复制日志的一致</font>性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p>
<p>实际系统中使用的一致性算法主要有以下特性：</p>
<ul>
<li>安全性保证（绝对不会返回一个错误的结果）。</li>
<li>即使部分服务器失败，只要多数服务器运行，系统依然可用。</li>
<li>不依赖于时序，能够应对时钟错误和消息延迟。</li>
<li>大多数情况下，指令可以在一轮远程过程调用后完成，不受少数慢节点影响。</li>
</ul>
<h2 id="paxos的问题" class="heading-element"><span>3 Paxos的问题</span>
  <a href="#paxos%e7%9a%84%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ol>
<li>
<p>Paxos极其难以理解。</p>
</li>
<li>
<p>没有为构建实际系统实现提供良好的基础。</p>
</li>
</ol>
<h2 id="为了可理解性的设计" class="heading-element"><span>4 为了可理解性的设计</span>
  <a href="#%e4%b8%ba%e4%ba%86%e5%8f%af%e7%90%86%e8%a7%a3%e6%80%a7%e7%9a%84%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>设计Raft算法的初衷：</p>
<ol>
<li>
<p>必须提供一个完整的实际的系统实现基础，减少开发者工作量；</p>
</li>
<li>
<p>必须在任何情况下都是安全的并且在大多数的情况下都是可用的；</p>
</li>
<li>
<p>它的大部分操作必须是高效的；</p>
</li>
<li>
<p>可理解性，它必须保证对于普遍的人群都可以十分容易的去理解；</p>
</li>
<li>
<p>便于系统构建者形成直观理解，便于实际应用和扩展；</p>
</li>
</ol>
<p>Raft设计原则：</p>
<ol>
<li>
<p><strong>问题分解</strong>：将复杂问题拆解为独立、易于理解和解决的子问题。例如，Raft 的领导人选举、日志复制、安全性和成员变更。</p>
</li>
<li>
<p><strong>状态空间简化</strong>：减少状态数量，降低系统复杂性并在可能的时候消除不确定性。确保日志无空洞，限制日志不一致的可能性。</p>
</li>
<li>
<p><strong>随机化应用</strong>：在领导人选举中使用随机化，简化机制，快速解决冲突。</p>
</li>
</ol>
<h2 id="raft一致性算法" class="heading-element"><span>5 Raft一致性算法</span>
  <a href="#raft%e4%b8%80%e8%87%b4%e6%80%a7%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 是一种管理复制日志的一致性算法，通过选举领导人并由其管理日志来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。这一决策过程无需与其他服务器进行商议，从而简化了整个复制日志的管理流程，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。</p>
<p>Raft算法的一致性问题被巧妙地分解为三个关键子问题：</p>
<ul>
<li><strong>领导选举</strong>：当领导人发生故障的时候, 一个新的领导人需要被选举出来，确保系统的连续性和稳定性（5.2）</li>
<li><strong>日志复制</strong>：领导人必须从客户端接收日志条目然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。</li>
<li><strong>安全性</strong>：Raft通过特定的机制（5.4）确保一旦日志条目被应用到某个服务器的状态机中，其他服务器不会在同一日志索引位置应用不同的指令，从而保障了系统状态的一致性和安全性。</li>
</ul>
<h3 id="raft基础" class="heading-element"><span>5.1 Raft基础</span>
  <a href="#raft%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 Raft 集群由若干个服务器节点构成，如常见的 5 节点配置，能容忍最多 2 个节点失效。节点有以下三种状态：</p>
<ul>
<li>
<p>领导人：唯一决策者，处理所有客户端请求，并且管理复制日志。</p>
</li>
<li>
<p>跟随者：被动角色，仅响应领导人和候选人的请求。</p>
</li>
<li>
<p>候选人：竞选状态，用于选举新领导人</p>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图4.jpeg?size=small" data-sub-html="<h2>server_state</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg" alt="server_state" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be4.jpeg?size=large 2x" data-title="server_state" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">跟随者在收不到消息时，升级为候选人，启动选举；获得多数票的候选人成为领导人；领导人宕机或发现任期过期，降级为跟随者。</font></p>
<p>Raft 通过任期来划分时间，每个任期都始于一次选举。任期用整数标记，每段任期有其选举过程。如果选举成功，选出的领导人将负责管理集群，直到该任期结束。任期在Raft中充当逻辑时钟的作用，帮助节点检测过期信息，如过期的领导人。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图5.jpeg?size=small" data-sub-html="<h2>Term_Figure</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg" alt="Term_Figure" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be5.jpeg?size=large 2x" data-title="Term_Figure" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>每个节点维护一个当前任期号，通信时交换任期号，节点自动更新至较大值，领导人或候选人如果发现任期号过期，会恢复为跟随者；节点拒绝过期任期请求。</p>
<p>在 Raft 算法中，节点间的通信依赖于RPC。基本的一致性算法主要使用两种类型的 RPCs：</p>
<ul>
<li>
<p><strong>请求投票RPC</strong>：候选人发起，用于选举。</p>
</li>
<li>
<p><strong>附加条目RPC</strong>：领导人发起，复制日志和提供心跳机制。</p>
</li>
<li>
<p><strong>安装快照PRC</strong>：领导人发起，安装快照。为了提高性能，服务器在未及时收到响应时会重试 RPC，并且能够并行发起 RPC。</p>
</li>
</ul>
<h3 id="领导人选举" class="heading-element"><span>5.2 领导人选举</span>
  <a href="#%e9%a2%86%e5%af%bc%e4%ba%ba%e9%80%89%e4%b8%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Raft 算法采用心跳机制来触发领导人选举过程。服务器启动时，<strong>默认处于跟随者状态</strong>，仅当接收到来自领导人或候选人的有效 RPC 时才保持这一状态。领导人定期向所有跟随者发送心跳包，即不含日志项的附加条目RPC，以此维护其领导地位。若跟随者<font color="red">在设定的选举超时时间内未收到任何消息</font>，它将假定无有效领导人并发起选举，以选出新的领导人。</p>
<p>选举流程开始时，跟随者增加自己的当前任期号并转换为候选人状态，然后向集群中其他服务器节点发送请求投票RPC来给自己投票。候选人保持该状态，直至出现以下三种情况之一：</p>
<ul>
<li>
<p>赢得选举。</p>
</li>
<li>
<p>其他服务器成为领导人。</p>
</li>
<li>
<p>在一定时间内无明确获胜者。</p>
</li>
</ul>
<p>赢得选举的条件是获得集群大多数服务器节点的选票，<font color="red">每台服务器对同一任期号的投票遵循先来先服务原则</font>，并有额外限制（5.4）以确保选举安全性，避免了脑裂（同一人气，集群出现两个领导人）。一旦当选，候选人即刻转变为领导人，通过发送心跳消息确立领导地位并阻止发起新选举。</p>
<p>在等待投票的过程中，候选人可能接收到领导人发送的附加条目RPC，如果该领导人任期号不低于候选人的任期号，候选人将认可其合法性，回归跟随者状态；反之，候选人将拒绝RPC，继续竞选。<font color="red">若多个候选人同时发起选举，选票分散可能导致无人胜出，所有候选人均会因超时而重新开始选举，但任期号会递增。</font></p>
<p>为防止选票分散，Raft算法引入了<font color="red">随机化选举超时时间策略</font>。各服务器在固定时间范围内（例如$[150,200]$）随机选取超时值，使得通常情况下仅有一台服务器超时，进而顺利赢得选举并在其他服务器超时前发送心跳。即使发生选票分散，随机化的超时机制也降低了下一轮选举中再次分散的可能性。</p>
<p>作者最初设计考虑过引入排名系统以决定优先级，但发现这可能导致高排名服务器故障时的可用性问题，且算法调整复杂，难以确保没有副作用。经过多次调整，最终确定随机重试方法更为直观易懂，且避免了排名系统带来的复杂性和潜在问题。</p>
<h3 id="日志复制" class="heading-element"><span>5.3 日志复制</span>
  <a href="#%e6%97%a5%e5%bf%97%e5%a4%8d%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一旦选举产生领导人，它便开始处理客户端请求，每个请求携带一条被复制状态机执行的指令。领导人将此指令作为新日志条目追加至日志中，并并行发起附加条目RPC给其他服务器复制，日志条目在被安全复制后，领导人将其应用到状态机并将执行结果返回给客户端，即使面对跟随者崩溃、延迟或网络丢包，领导人也会持续重试RPC（<font color="red">尽管已经回复了客户端</font>）直至所有跟随者存储所有日志条目。</p>
<p>日志结构如图6所示，条目按序编号，包含创建时的任期号及待执行指令。日志条目在满足一定条件时变为可提交状态，即安全地应用到状态机中。<font color="red">领导人决定何时提交日志条目，Raft算法保证所有提交条目持久化并最终被执行</font>。日志条目在被复制到多数服务器时即被提交，包括前任领导人创建的条目。领导人追踪最大已提交条目索引，并在附加条目RPC中包含该索引，使跟随者同步应用已提交条目。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be6-20240719213332262.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图6-20240719213332262.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>Raft的日志机制维持不同服务器日志之间的高层次一致性，简化系统行为并增强可预测性，是安全性的重要组成部分。关键特性是<font color="red">若两日志条目索引和任期号相同，则它们存储相同指令，并且前序条目也相同。</font>。这是因为日志匹配特性，领导人最多在一个任期内特定索引创建日志条目，且日志条目位置固定不变。<font color="red">附加条目RPC包含前一条目的索引和任期号，若跟随者找不到匹配条目则拒绝，确保日志匹配特性</font>。</p>
<p>正常运行时，领导人与跟随者日志一致，但在领导人崩溃后可能出现不一致，如图7所示。领导人通过强制跟随者复制自己的日志解决不一致，覆盖冲突条目。领导人维护<code>nextIndex</code>记录每个跟随者下一个待发送条目索引，初始化为自身最后条目索引+1。<font color="red">当一致性检查失败，领导人就会减小<code>nextIndex</code>直至找到共同点，删除跟随者冲突条目并发送自身条目</font>。成功后，跟随者日志与领导人保持一直。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be7.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图7.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<blockquote>
<p>算法可优化减少拒绝次数，跟随者可返回冲突条目任期号及对应最小索引，领导人据此一次性跳过冲突任期所有条目。但实践中，这种优化可能非必需，因不一致性罕见且涉及条目不多。</p>
</blockquote>
<p>通过日志复制机制，领导人无需特殊操作即可恢复一致性，只需执行常规流程，日志在响应一致性检查失败时自动对齐。领导人从不覆盖或删除自身日志，确保一致性。日志复制机制体现了高可用性、快速复制及对慢跟随者的容忍度。</p>
<h3 id="安全性" class="heading-element"><span>5.4 安全性</span>
  <a href="#%e5%ae%89%e5%85%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 Raft 算法中，尽管已经描述了领导人的选举和日志的复制过程，但这些机制本身并不足以保证所有状态机按照相同的顺序执行相同的指令。存在一种情况，即一个跟随者在领导人提交了若干日志条目后变得不可用，之后这个跟随者可能被选举为新的领导人，并可能覆盖这些已提交的日志条目，导致不同状态机可能执行不同的指令序列。</p>
<p>为了解决这个问题，Raft 算法在领导选举时增加了限制，确保任何给定任期的领导人都拥有之前任期的所有已提交的日志条目（即<strong>领导人完整特性</strong>）。这一限制简化了提交规则，并为复制状态机的正确行为提供了证明。</p>
<h4 id="选举限制" class="heading-element"><span>5.4.1 选举限制</span>
  <a href="#%e9%80%89%e4%b8%be%e9%99%90%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在基于领导人的一致性算法中，领导人都必须存储所有已提交的日志条目。Raft 算法通过简单的方法确保新选举的领导人拥有之前任期中所有已提交的日志条目，避免了额外的日志传输机制和复杂性。</p>
<p>Raft 使用投票机制来阻止未包含所有已提交日志条目的候选人赢得选举。<font color="red">候选人必须获得集群中大多数节点的同意，这确保了所有已提交的日志条目至少存在于一个节点上</font>。如果候选人的日志至少和大多数的服务器节点一样新，那么他一定持有了所有已经提交的日志条目。请求投票RPC 实现了这样的限制：<font color="red">RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求</font>。</p>
<p>Raft通过比较日志中最后一条条目的任期号和索引来判断哪个日志更“新”。</p>
<ul>
<li>如果任期号不同，任期号更大的日志更“新”。</li>
<li>如果任期号相同，则条目更多（索引值更大）的日志更“新”。</li>
</ul>
<h4 id="提交之前任期内的日志条目" class="heading-element"><span>5.4.2 提交之前任期内的日志条目</span>
  <a href="#%e6%8f%90%e4%ba%a4%e4%b9%8b%e5%89%8d%e4%bb%bb%e6%9c%9f%e5%86%85%e7%9a%84%e6%97%a5%e5%bf%97%e6%9d%a1%e7%9b%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>领导人在当前任期内创建的日志条目，当被复制到大多数服务器上时，则可认为是可提交的。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，<font color="red">对于之前任期中的日志条目，即使它们已经被复制到大多数服务器上，也不能简单地通过副本数量来确定它们是否已提交</font>，如图8所示。这是因为在领导人崩溃和重新选举的过程中，可能会出现新的领导人并不包含所有之前任期的日志条目，这可能导致已复制的日志被覆盖。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be8.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图8.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了避免这种情况，<font color="red">Raft不会通过副本数目去提交一个之前任期内的日志条目，只有当前任期的日志条目才能通过复制到大多数服务器来提交</font>。一旦当前任期的日志条目被提交，根据日志匹配特性，之前任期的日志条目也会被间接的提交。</p>
<p><font color="red">Raft 在处理日志时保留了原始的任期号</font>，这虽然增加了提交规则的复杂性，但简化了日志的识别和管理。与其它算法不同，Raft 在复制之前任期日志不需要使用新的任期号，在提交前不用发送冗余的日志条目来重新编号，</p>
<h4 id="安全性论证" class="heading-element"><span>5.4.3 安全性论证</span>
  <a href="#%e5%ae%89%e5%85%a8%e6%80%a7%e8%ae%ba%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在 Raft 算法中，领导人完整性特性是确保一致性的关键。这一特性保证了在任期 T 的领导人提交的日志条目，必须被存储在未来任期的领导人日志中。</p>
<p>设任期U（&gt;T）的领导人U缺失该条目，如下图所示，在U的选举中，至少存在一个节点（如S3）同时持有T任期的日志并投票给U。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be9.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图9.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ul>
<li><strong>关键点</strong>：此节点在投票前接受T任期已提交日志，且在投票时仍保存该条目。</li>
<li><strong>矛盾一</strong>：此节点把自己选票投给领导人 U 时，<strong>说明领导人 U 的日志必须和投票者自己一样新</strong>。但假设U不包含T任期提交的日志。</li>
<li><strong>矛盾二</strong>：若U最后日志任期大于此节点，<strong>则前领导人必含提交日志，由日志匹配特性知U亦应含该日志</strong>，产生矛盾。</li>
</ul>
<p>故所有大于T任期的领导人必定包含T任期中所有已提交日志条目。<strong>日志匹配原则</strong>确保未来领导人同样包含间接提交的条目。<font color="red">领导人完整性特性支撑状态机安全特性，防止不同日志在相同索引值上被应用</font>。</p>
<h3 id="追随者和候选人崩溃" class="heading-element"><span>5.5 追随者和候选人崩溃</span>
  <a href="#%e8%bf%bd%e9%9a%8f%e8%80%85%e5%92%8c%e5%80%99%e9%80%89%e4%ba%ba%e5%b4%a9%e6%ba%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>崩溃影响</strong>：崩溃导致后续RPC失败，影响通信和一致性。</li>
<li><strong>处理机制</strong>：
<ul>
<li><strong>无限重试</strong>：系统通过持续重试RPC来处理这类失败。</li>
<li><strong>重启恢复</strong>：当崩溃服务器重启，未完成的RPC能够继续执行至成功。</li>
</ul>
</li>
<li><strong>RPC幂等性保障</strong>：<font color="red">指多次执行相同操作产生的效果等同于一次执行</font>，故重复执行RPC也不会引起不一致或错误状态。</li>
</ul>
<h3 id="时间和可用性" class="heading-element"><span>5.6 时间和可用性</span>
  <a href="#%e6%97%b6%e9%97%b4%e5%92%8c%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Raft 算法的一个核心要求是安全性不应依赖于时间，即系统不应因为事件的快慢而产生错误的结果。然而，系统的可用性，即及时响应客户端的能力，不可避免地依赖于时间因素。特别是在领导人选举过程中，时间要求尤为关键。</p>
<p>关键的时间因素有：</p>
<ul>
<li><strong>广播时间 (Broadcast Time)</strong>：服务器向集群成员并行发送RPC并接收响应的平均时间。</li>
<li><strong>选举超时时间 (Election Timeout)</strong>：跟随者等待领导人心跳的最长时限，过期则发起选举。</li>
<li><strong>平均故障间隔时间 (Mean Time Between Failures, MTBF)</strong>：服务器两次故障之间的平均时间。</li>
</ul>
<p>Raft 要求满足以下时间不等式以保证系统正常运行：</p>
<p>$\text{Broadcast Time}\ll\text{Election Timeout}\ll\text{MTBF}$</p>
<p><font color="red">广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的</font>。广播时间受存储技术影响，范围约为$[0.5,20]\text{ ms}$，选举超时时间基于广播时间设置，要比广播时间大几个数量级，一般在$[10,500]\text{ ms}$，而MTBF通常数月以上，远大于选举超时时间，满足系统稳定运行需求。</p>
<h2 id="集群成员变化" class="heading-element"><span>6 集群成员变化</span>
  <a href="#%e9%9b%86%e7%be%a4%e6%88%90%e5%91%98%e5%8f%98%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 算法在设计时假设集群配置是固定的，但在实际应用中，集群配置需要动态调整，如替换宕机的机器或改变复制级别。直接更改集群配置存在风险，可能导致同一任期内两个领导人同时存在，因此需要一种安全的配置变更机制。为了确保配置变更的安全性，必须采用两阶段方法。在Raft中，集群切换到一个过渡配置，称为联合共识，结合了新旧配置：</p>
<ul>
<li>日志条目被复制给新旧配置的所有服务器。</li>
<li>新旧配置的服务器都可以成为领导人。</li>
<li>达成一致（选举和提交）需要分别在新旧配置上获得大多数支持。</li>
</ul>
<p><font color="red">联合共识允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程</font>。此外，联合共识可以让集群在配置转换的过程中依然响应客户端的请求。配置变更过程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be11.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图11.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li><strong>请求接收</strong>：领导人接收到从 $C_\text{old}$ 到 $C_\text{new}$ 的配置变更请求。</li>
<li><strong>联合共识日志条目</strong>：领导人创建 $C_\text{old,new}$ 配置条目并将其作为日志条目存储和复制。</li>
<li><strong>提交联合共识</strong>：一旦 $C_\text{old,new}$ 被提交，<font color="red">新旧配置都不能单方面做出决定</font>，只有拥有 $C_\text{old,new}$ 日志条目的服务器才能成为领导人。</li>
<li><strong>新配置日志条目</strong>：这个时候，领导人创建 $C_\text{new}$ 配置条目并复制给集群，最终在 $C_\text{new}$ 规则下提交，旧的配置变得无关紧要。</li>
</ol>
<h2 id="日志压缩" class="heading-element"><span>7 日志压缩</span>
  <a href="#%e6%97%a5%e5%bf%97%e5%8e%8b%e7%bc%a9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 算法通过复制日志来维护一致性，但随着时间的推移，日志会不断增长，占用大量空间并影响性能。为了解决这个问题，Raft 使用<strong>快照技术</strong>压缩日志，通过存储系统状态至持久化存储，随后丢弃先前日志。</p>
<p>下图展示了快照的基本思想，<strong>每个服务器独立创建快照，只包含已提交的日志条目，主要的工作包括将状态机的状态写入快照中</strong>。Raft也包含一些少量元数据到快照中：最后索引和任期号。保留这些数据是为了支持一致性检查，允许服务器清除过期日志。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-%e5%9b%be12.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/raft-图12.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>领导人偶尔也需要通过安装快照RPC将快照分块发送给一些落后的追随者，追随者收到快照后，他必须自己决定对于已经存在的日志该如何处理，一般来说是覆盖冲突日志，保留后续未冲突日志。</p>
<p>在快照时，有两个性能相关的因素需要考虑：</p>
<ul>
<li><strong>创建时机</strong>：服务器需要决定何时创建快照，以避免频繁写入或存储空间耗尽。Raft 的策略是当日志大小达到一个阈值之后，就开始快照。</li>
<li><strong>写入时间</strong>：写入快照可能需要显著时间，为了不影响正常的操作，应通过写时复制技术避免影响正常操作。</li>
</ul>
<h2 id="客户端交互" class="heading-element"><span>8 客户端交互</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%ba%a4%e4%ba%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft中的客户端发送所有请求给领导人。客户端初始化时随机选择服务器，非领导人服务器会拒绝客户端请求并提供最近接收到的领导人信息。如果领导人崩溃后，客户端请求超时，重启随机选择过程直至找到新领导人。</p>
<p>Raft目标是要实现线性化语义，由于Raft是可能同时执行同一条命令多次的，为了解决这个问题，<strong>客户端为每条指令分配唯一序列号，状态机跟踪每个客户端的最新序列号和相应响应。如果接收到的指令序列号已经被执行，状态机直接返回结果而不重新执行</strong>。</p>
<p>只读操作可以不写入日志直接处理。但不记录日志可能导致返回脏数据，即领导人在不知情的情况下被新领导人取代。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。</p>
<ol>
<li>
<p><strong>最新提交日志信息</strong>：<font color="red">领导人需要知道任期内所有被提交的日志条目</font>。Raft 通过让领导人在任期开始时提交一个空白日志条目来实现。</p>
</li>
<li>
<p><strong>领导人状态检查</strong>：在处理只读请求前，领导人必须检查自己是否已被废黜。Raft 通过让领导人在响应只读请求前与集群大多数节点交换心跳信息来处理这个问题。</p>
</li>
</ol>
<h2 id="总结" class="heading-element"><span>9 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Raft 是一种用于管理复制日志的一致性算法，旨在解决分布式系统中的一致性问题。它通过领导人选举、日志复制和安全性保证来实现系统的高可用性和一致性。</p>
<p><strong>Raft 的五大保证</strong>：</p>
<ol>
<li>
<p><strong>选举安全性</strong>：在任一给定任期内，最多只能有一个领导人被选举出来。</p>
</li>
<li>
<p><strong>领导人只追加</strong>：领导人不会覆盖或删除其日志中的条目；它只追加新的条目。</p>
</li>
<li>
<p><strong>日志匹配</strong>：如果两个日志在相同索引和任期号处含有相同的条目，则在该索引之前的所有条目都是相同的。</p>
</li>
<li>
<p><strong>领导人完整性</strong>：如果一个日志条目在给定任期被提交，那么该条目将出现在所有更高编号任期的领导人的日志中。</p>
</li>
<li>
<p><strong>状态机安全性</strong>：如果一个服务器将某个索引的日志条目应用到其状态机中，其他服务器不会对该索引应用不同的日志条目。</p>
</li>
</ol>
]]></description></item><item><title>【论文阅读笔记】DeepCAD: A Deep Generative Network for Computer-Aided Design Models</title><link>https://hezephyr.github.io/posts/05.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0deepcad/</link><pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/05.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0deepcad/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>现有3D生成模型：</p>
<ul>
<li>
<p><strong>3D点云</strong>：大量离散的3D点组成的数据表示形式；</p>
</li>
<li>
<p><strong>多边形网格</strong>：一系列相连的多边形组成的3D模型；</p>
</li>
<li>
<p><strong>水平集场</strong>：使用数值函数来表示物体的边界，并根据函数值的正负来确定物体内部和外部的区域；</p>
</li>
</ul>
<p>仅能创建3D形状的离散表示，都缺少生成3D形状设计本质的能力—绘制过程。</p>
<p>作者提出了一个深度生成网络DeepCAD，能够输出CAD工具（如AutoCAD）中用于构建3D形状的操作序列，这是CAD模型的“绘制”过程。</p>
<p>这是CAD设计的生成模型的<strong>第一个工作</strong>，挑战在于<font color="red">CAD设计的顺序和参数化性质</font>。CAD模型由一系列几何操作（例如，曲线草图、拉伸、圆角、布尔、倒角）组成，每个操作由某些不规则的参数（<strong>离散或连续</strong>）控制。故以前开发的3D生成模型不适合CAD模型生成。</p>
<p>为了克服这些挑战，需要寻求一种能够协调CAD模型中的不规则性的表示，作者考虑最常用的CAD操作（命令），并将它们统一在一个公共结构中，该结构对其命令类型、参数和序列顺序进行编码，通过<font color="red">类比CAD命令序列和自然语言</font>，作者提出了一种<font color="red">基于Transformer网络的自编码器，它将CAD模型嵌入到潜在空间中，然后将潜在向量解码成CAD模型</font>。<a href="https://github.com/ChrisWu1997/DeepCAD"target="_blank" rel="external nofollow noopener noreferrer">【code】<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>为了训练这个自编码器，作者还创建了一个新的CAD命令序列数据集，以促进未来基于学习的CAD设计的研究。<a href="https://drive.google.com/drive/folders/1mSJBZjKC-Z5I7pLPTgb4b5ZP-Y6itvGG"target="_blank" rel="external nofollow noopener noreferrer">【dataset】<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>下图是DeepCAD的生成演示。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DeepCAD_Generation" alt="image-20240708205521814" style="zoom:50%;" />
<h2 id="相关工作" class="heading-element"><span>2 相关工作</span>
  <a href="#%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>参数化形状推断</strong></p>
<p>深度学习的进步使得神经网络模型能够分析几何数据，推断出参数化形状。具体工作如下：</p>
<ul>
<li><strong>ParSeNet</strong>：将3D点云分解为一组参数化的表面补丁。</li>
<li><strong>PIE-NET</strong>：从3D点云中提取参数化的边界曲线。</li>
<li><strong>UV-Net 和 BrepNet</strong>：专注于编码参数化模型的边界曲线和表面。</li>
<li><strong>Li等人</strong>：训练了一种神经网络，在合成数据上将2D用户草图转换为CAD操作。</li>
<li><strong>Xu等人</strong>：应用神经引导搜索，从参数化实心形状中推断出CAD建模序列。</li>
</ul>
</li>
<li>
<p><strong>3D形状生成模型</strong></p>
<p>大多数现有方法生成离散形式的3D形状，如体素化形状、点云、多边形网格、隐式签名距离场。<font color="red">生成的形状可能存在噪声，缺乏锐利的几何特征，不便于用户编辑</font>。新方法使用神经网络模型生成3D形状作为一系列几何操作。</p>
<ul>
<li><strong>CSGNet</strong>：基于体素化形状输入推断CSG操作序列。</li>
<li><strong>UCSG-Net</strong>：无监督情况下推断CSG树。</li>
<li><strong>领域特定语言（DSLs）</strong>：通过DSLs合成3D形状，如ShapeAssembly。</li>
<li><strong>作者工作</strong>：<font color="red">自编码器网络输出一系列CAD操作指定的CAD模型</font>。CAD模型成为工业生产标准形状表示，可以直接<strong>导入CAD工具</strong>进行用户编辑，也可转换为<strong>点云和多边形网格</strong>。<font color="red">这是第一个直接生成CAD设计的生成模型</font>。</li>
</ul>
</li>
<li>
<p><strong>基于Transformer的模型</strong></p>
<p>Transformer网络作为基于注意力的构建模块，成功应用于自然语言处理、图像处理和其他类型数据。并行工作在约束的CAD草图生成上也依赖于Transformer网络。</p>
<p>与作者工作相关的还有DeepSVG-用于生成可缩放矢量图（SVG）图像的Transformer网络。SVG图像由参数化原语（如直线和曲线）描述，原语无特定顺序或依赖关系。</p>
<p>与SVG不同，<font color="red">CAD命令在3D中描述，可以是相互依赖的，必须遵循特定顺序</font>。所以需要寻求一种新的方法在基于Transformer的自编码器中编码CAD命令及其顺序。</p>
</li>
</ul>
<h2 id="方法" class="heading-element"><span>3 方法</span>
  <a href="#%e6%96%b9%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>DeepCAD围绕对CAD命令序列的新表示方法（3.1.2），这种CAD表示方法特别适合于输入到神经网络中。此外，这种表示法还引导出一个自然的训练目标函数（3.4）。为了训练DeepCAD，作者创建了一个新数据集，其规模远远大于同类数据集（3.3）。</p>
<h3 id="神经网络的cad表示" class="heading-element"><span>3.1 神经网络的CAD表示</span>
  <a href="#%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e7%9a%84cad%e8%a1%a8%e7%a4%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CAD 模型提供了两个层次的表示。</p>
<ul>
<li>
<p>在用户交互层面，CAD 模型被描述为用户在 CAD 软件中创建实心形状时执行的一系列操作，例如用户在二维平面上绘制一个闭合曲线轮廓，然后将其拉伸成三维实心形状，再通过布尔运算等进行处理。我们将这种规范称为 <strong>CAD 命令序列</strong>。</p>
</li>
<li>
<p>在命令序列背后，是 <font color="red">CAD 模型的内核表示</font>，广为人知的是边界表示（B-rep）。给定一个命令序列，其 B-rep 会自动计算出来，通常通过行业标准库 Parasolid。它由拓扑组件及其连接组成，以形成一个实心形状。</p>
</li>
</ul>
<p>我们的目标是生成 CAD 命令序列的模型，而不是 B-rep。<font color="red">这是因为 B-rep 是命令序列的抽象：命令序列可以很容易地转换为 B-rep，但反之则很难，因为不同的命令序列可能会生成相同的 B-rep</font>。此外，命令序列是人类可理解的，便于编辑和应用于各种下游任务。</p>
<h4 id="cad命令的规范" class="heading-element"><span>3.1.1 CAD命令的规范</span>
  <a href="#cad%e5%91%bd%e4%bb%a4%e7%9a%84%e8%a7%84%e8%8c%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>CAD 工具支持丰富的命令集，作者仅考虑了一组常用的命令，这些命令分为两类：草图和拉伸。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DeepCAD_Command_Type" alt="image-20240708205620579" style="zoom: 33%;" />
<p>尽管概念上简单，但它们足够表达生成各种形状。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CAD_Construction_Process" alt="image-20240708205725122" style="zoom:50%;" />
<ul>
<li>
<p>草图命令用于在三维空间中的二维平面上指定闭合曲线，每个闭合曲线称为<strong>一个环</strong>，多个环形成一个闭合区域，称为<strong>轮廓</strong>。我们的表示方法中，一个轮廓由其边界上的环列表描述（如Figure 2中的“Sketch 1”）；<font color="red">一个环总是以指示命令开始，后跟一系列曲线命令。我们列出环上的所有曲线，并按逆时针顺序排列，开始点为最左下角的曲线</font>。实际中，我们考虑三种最常用的曲线命令：<strong>画直线、弧线和圆</strong>。这些命令占了我们大规模现实数据集中 <strong>92%</strong> 的比例。</p>
<p>每个曲线命令由其曲线类型（$t_i\in {\langle\text{SQL}\rangle,\text{L,A,R}}$）和参数（Table 1）描述，曲线参数指定了曲线在草图平面的局部参考框架中的二维位置。由于每个环中的曲线是一个接一个连接的，为了简洁，我们从参数列表中排除了曲线的起始位置；<font color="red">第一条曲线总是从草图平面的原点开始，原点的世界空间坐标在拉伸命令中指定</font>。简言之，一个草图轮廓由一个环列表描述（$S=[Q_1,\dots,Q_N]$），每个环$Q_i$由一系列从指示命令开始的曲线组成，例如$Q_i=[\langle\text{SQL}\rangle, C_1,\dots,C_{n_i}]$，每个曲线命令$C_j=(t_j,p_j)$指定曲线类型$t_j$及其形状参数$p_j$。</p>
</li>
<li>
<p>拉伸命令有两个目的。</p>
<ul>
<li>
<p>它将草图轮廓从二维平面拉伸成三维实体，拉伸类型可以是<strong>单向、对称或双向</strong>。</p>
</li>
<li>
<p>它通过布尔运算指定如何将新拉伸的三维实体与先前创建的形状合并：<strong>创建新实体，或者与现有实体连接、切割或相交</strong>。</p>
</li>
</ul>
<p>拉伸命令还需要定义草图平面的三维方向和其二维局部参考框架，这是通过旋转矩阵（Table 1中$(\theta,\gamma,\phi)$参数确定）定义的（<font color="red">为了跟平面局部参考系对齐，并将$z$轴与平面的法线方向对齐</font>）。命令参数包括一个拉伸轮廓的比例因子$s$。</p>
</li>
</ul>
<p>通过这些命令，我们将一个 CAD 模型$M$描述为交替出现的曲线命令和拉伸命令序列。换句话说$M=[C_1,\dots,C_{N_c}]$，其中每个$C_i=(c_i,p_i)$指定命令类型和参数。</p>
<h4 id="网络友好的表示" class="heading-element"><span>3.1.2 网络友好的表示</span>
  <a href="#%e7%bd%91%e7%bb%9c%e5%8f%8b%e5%a5%bd%e7%9a%84%e8%a1%a8%e7%a4%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们的 CAD 模型 M 的规范类似于自然语言，<font color="red">词汇表由一系列 CAD 命令组成，形成句子</font>。句子的主语是草图轮廓；谓语是拉伸。这种类比表明我们可以利用在自然语言处理中成功的网络结构（如 <strong>Transformer 网络</strong>，<font color="red">LLMs</font>）来实现我们的目标。</p>
<p>然而，CAD 命令在几个方面与自然语言不同。每个命令有不同数量的参数。在某些命令（例如拉伸）中，<font color="red">参数是连续值和离散值的混合</font>，参数值跨越不同范围。这些特性使得命令序列不适合直接用于神经网络。</p>
<p>为了克服这一挑战，我们对命令序列的维度进行<strong>正则化</strong>。</p>
<ul>
<li>
<p>首先，对于每个命令，其参数堆叠成一个 $16×1$ 的向量，其元素对应于Table 1中所有命令的集合参数（例如$p_i=[x,y,\alpha,f,r,\theta,\phi,\gamma,p_x,p_y,p_z,s,e_1,e_2,b,u]$）。<font color="red">每个命令的未使用参数设置为 -1</font>。</p>
</li>
<li>
<p>接着，我们<strong>固定</strong>每个 CAD 模型 $M$ 的命令总数 $N_c$，<font color="red">并通过添加空命令来填充 CAD 模型的命令序列</font>，直到序列长度达到 $N_c$。我们选择 $N_c = 60$，这是训练数据集中出现的最大命令序列长度。</p>
</li>
<li>
<p>此外，我们通过<font color="red">量化连续参数来统一连续和离散参数</font>。为此，我们将每个 CAD 模型规范化到一个 $2×2×2$ 的立方体内；我们还将<strong>每个草图轮廓规范化到其边界框内</strong>，并在拉伸命令中包括一个比例因子$s$来恢复规范化轮廓到其原始大小。这种规范化限制了连续参数的范围，使我们能够将其值量化为 $256$ 个级别，并使用 $8$ 位整数表示。结果是，所有命令参数都只有离散值集合。<font color="red">参数量化不仅是训练基于 Transformer 网络的常见实践，对于 CAD 模型来说，它对于提高生成质量尤为重要</font>。在 CAD 设计中，必须遵循某些几何关系，例如平行和垂直的草图线条。然而，如果生成模型直接生成连续参数，通过参数回归获得的值容易产生错误，破坏这些严格的关系。相反，参数量化使网络能够将参数“分类”到特定级别，从而更好地遵循学习到的几何关系。</p>
</li>
</ul>
<p>作者在 4.1 中通过消融研究实验证明对 CAD 命令表示选择的正确性。</p>
<h3 id="cad模型的自编码器" class="heading-element"><span>3.2 CAD模型的自编码器</span>
  <a href="#cad%e6%a8%a1%e5%9e%8b%e7%9a%84%e8%87%aa%e7%bc%96%e7%a0%81%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DeepCAD的网络架构如下：</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DeepCAD_Network_Architecture" alt="image-20240708205823395" style="zoom:33%;" />
<p>一旦训练完成，网络的解码器部分将自然地作为 CAD 生成模型。我们的自编码器基于 Transformer 网络，受其在处理序列数据方面成功的启发。自编码器输入一个 CAD 命令序列$M = [C1,\dots , C_{N_c}]$，其中 $N_c$ 是固定数量。</p>
<p>首先，每个命令 $C_i$ 被分别投射到维度为 $d_E = 256$ 的连续嵌入空间。然后，将所有嵌入组合起来输入编码器 $E$，输出一个潜在向量 $z\in \mathbb{R}^{256}$。解码器以潜在向量 $z$ 作为输入，输出生成的 CAD 命令序列 $\hat{M}$。</p>
<ul>
<li>
<p>嵌入部分</p>
<p>与自然语言处理的方法类似，我们首先将每个命令 $C_i$ 投射到一个公共嵌入空间。然而，不同于自然语言中的词语，一个 CAD 命令 $C_i = (t_i, p_i)$ 有两个部分：命令类型 $t_i$ 和参数 $p_i$。因此，我们将 $C_i$ 的嵌入计算为三个嵌入的总和，即</p>
<p>$$
e(C_i) = e^\text{cmd}_i + e^{\text{param}}_i + e^\text{pos}_i\in \R^{d_E},
$$</p>
<ul>
<li>
<p>第一个嵌入 $e^{\text{cmd}}_i$ 表示<strong>命令类型 $t_i$</strong>，由 $e^\text{cmd}_i=W_\text{cmd} \delta_i^c$ 给出。这里 $W_\text{cmd}\in\R^{d_E\times 6}$ 是一个可学习矩阵，$\delta_i^c\in \R^6$ 是一个指示命令类型 $t_i$ 的独热向量。</p>
</li>
<li>
<p>第二个嵌入$e^{\text{param}}_i$ 考虑<strong>命令参数</strong>。每个命令有 $16$ 个参数，每个参数被量化为一个 $8$ 位整数。我们将这些整数转换为维度为 $2^8+1=257$ 的独热向量$\delta^p_{i,j}(j=1\dots16)$，<strong>并将所有独热向量堆叠成矩阵</strong>$\delta^p_i\in\R^{257\times16}$。然后使用另一个可学习矩阵 $W_\text{param}^b\in\R^{d_E\times 257}$ 单独嵌入每个参数，并通过线性层 $W_\text{param}^a\in\R^{d_E\times 16d_E}$组合这些单独的嵌入，即</p>
<p>$$
e^{\text{param}}_i=W_\text{param}^a\text{flat}(W_\text{param}^b\delta^p_i),
$$</p>
<p>其中$\text{flat}(\cdot)$将输入矩阵展平为向量</p>
</li>
<li>
<p>最后，位置嵌入 $e^\text{pos}_i$ 表示命令 $C_i$ <strong>在整个命令序列中的索引</strong>，由 $e^\text{pos}_i = W_\text{pos}\delta_i$ 定义，其中 $W_\text{pos}\delta_i\in\R^{d_E\times N_c}$ 是一个可学习矩阵，$\delta_i\in\R^{N_c}$ 是一个在索引 $i$ 处填充 $1$ 其他位置填充$0$的独热向量。</p>
</li>
</ul>
</li>
<li>
<p>编码器</p>
<p>编码器 $E$ 由四层 Transformer 块组成，<strong>每层有八个注意力头和 $512$ 的前馈维度</strong>。编码器将嵌入序列 $[e_1, \dots, e_{N_c}]$ 作为输入，输出向量 $[e&rsquo;_1,\dots, e&rsquo;_{N_c}]$，每个向量的维度为 $d_E = 256$。输出向量最终<font color="red">被平均</font>以生成一个 $d_E$ 维的潜在向量 $z$。</p>
</li>
<li>
<p>解码器</p>
<p>解码器 $D$ 也建立在 Transformer 块上，具有与编码器相同的超参数设置。它以学习到的常量嵌入为输入，同时关注潜在向量 $z$。最后一个 Transformer 块的输出被送入线性层，以预测 CAD 命令序列 $\hat{M} = [ \hat{C}_1,\dots, \hat{C}_{N_c}]$，包括每个命令的命令类型 $\hat{t}_i$ 和参数 $\hat{t}_i$。与自然语言处理中常用的自回归策略不同，我们采用<font color="red">前馈策略</font>，模型的预测可以分解为</p>
<p>$$
p(\hat{M}|z,\Theta)=\prod_{i=1}^{N_c}p(\hat{t}_i,\hat{p}_i|z,\Theta),
$$</p>
<p>其中$\Theta$表示解码器的网络参数。</p>
</li>
</ul>
<h3 id="cad数据集的创建" class="heading-element"><span>3.3 CAD数据集的创建</span>
  <a href="#cad%e6%95%b0%e6%8d%ae%e9%9b%86%e7%9a%84%e5%88%9b%e5%bb%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现有数据集：</p>
<ul>
<li>
<p><strong>ABC数据集</strong>：虽包含百万级别的CAD设计，但这些设计采用B-rep格式，缺乏如何通过CAD操作构建设计的具体信息；</p>
</li>
<li>
<p><strong>Fusion 360 Gallery数据集</strong>：虽然提供了CAD设计及其构建指令序列，但规模仅有约8000个设计，不足以训练出泛化能力强大的生成模型。</p>
</li>
</ul>
<p>鉴于此，作者决定创建一个全新的、大规模的数据集，该数据集不仅数量庞大，还提供了CAD命令序列，旨在满足训练自动编码网络的需求，并为未来的研究提供资源。</p>
<p>新数据集构建过程始于ABC数据集：</p>
<ol>
<li>
<p>利用其中每个CAD模型链接至Onshape的原始设计。</p>
</li>
<li>
<p>接着，通过Onshape的FeatureScript语言（一种专门用于解析CAD操作与参数的领域特定语言），作者筛选出仅使用“草图”和“拉伸”操作的模型，舍弃了那些采用更复杂操作的模型。</p>
</li>
<li>
<p>对于符合条件的模型，作者编写了一段FeatureScript程序来提取其草图轮廓和拉伸操作，并将其转化为Table 1中列出的命令格式。</p>
</li>
</ol>
<p>最终，作者收集到了总计<strong>178,238</strong>个以CAD命令序列形式描述的CAD设计，这个数量级远超现有同类型数据集。数据集进一步被随机划分为90%的训练集、5%的验证集以及5%的测试集，以备训练和测试之用。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DeepCAD_Dataset" alt="image-20240708210100248" style="zoom:33%;" />
<h3 id="训练和运行时生成" class="heading-element"><span>3.4 训练和运行时生成</span>
  <a href="#%e8%ae%ad%e7%bb%83%e5%92%8c%e8%bf%90%e8%a1%8c%e6%97%b6%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="训练阶段" class="heading-element"><span>3.4.1 训练阶段</span>
  <a href="#%e8%ae%ad%e7%bb%83%e9%98%b6%e6%ae%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们利用构建的数据集对自编码器网络进行训练，采用标准的交叉熵损失函数作为优化目标。具体而言，定义预测的CAD模型$\hat{M}$与真实模型$M$之间的损失函数为：</p>
<p>$$
\mathcal{L} = \sum_{i=1}^{N_c} \ell(\hat{t}_i,t_i) + \beta \sum_{i=1}^{N_c} \sum_{j=1}^{N_p} \ell(\hat{p}_{i,j},p_{i,j}),
$$</p>
<p>其中，$\mathcal{L}(·, ·)$表示标准的交叉熵损失，$N_p$每个命令的参数数量（在我们的示例中，$N_p = 16$），而$\beta$是一个权重项，用于平衡两项损失（在我们的示例中，$\beta = 2$）。值得注意的是，在真实的命令序列中，有些命令是空的（即填充命令$\langle \text{EOS} \rangle$），而有些命令参数未使用（标记为$-1$）。在这种情况下，这些元素对上述损失函数中的求和部分不做贡献。</p>
<p>训练过程中，我们使用<font color="red">Adam优化器</font>，初始学习率为$0.001$，并设置线性预热期为前$2000$步。所有Transformer模块的Dropout率设定为$0.1$，并在反向传播中应用梯度裁剪值为$1.0$。我们以批处理大小$512$对网络进行$1000$轮的训练。</p>
<h4 id="cad生成阶段" class="heading-element"><span>3.4.2 CAD生成阶段</span>
  <a href="#cad%e7%94%9f%e6%88%90%e9%98%b6%e6%ae%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当自编码器训练完成后，我们可以使用一个$256$维的潜在向量$z$来表示一个CAD模型。为了自动生成CAD模型，我们运用latent-GAN技术于已学得的潜在空间上。生成器和判别器都是简单的多层感知机（MLP）网络，各自包含四层隐藏层，它们的训练采用带有梯度惩罚的Wasserstein-GAN策略。最后，生成CAD模型时，我们从多元高斯分布中采样一个随机向量，并将其输入GAN的生成器中。GAN的输出是一个潜在向量$z$，随后将其输入基于Transformer的解码器，从而生成CAD模型。</p>
<h2 id="实验" class="heading-element"><span>4 实验</span>
  <a href="#%e5%ae%9e%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们从两个角度评估我们的自编码器网络：<strong>CAD模型的自编码性能</strong>（4.1）和<strong>潜在空间形状生成</strong>（4.2）。我们还讨论了可以受益于CAD生成模型的潜在应用（4.3）。由于之前没有针对CAD设计的生成模型，因此无法<strong>直接进行比较</strong>。我们的目标是通过一系列消融实验理解模型在不同指标下的性能，并验证我们的算法选择。</p>
<h4 id="cad模型的自编码" class="heading-element"><span>4.0.3 CAD模型的自编码</span>
  <a href="#cad%e6%a8%a1%e5%9e%8b%e7%9a%84%e8%87%aa%e7%bc%96%e7%a0%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">自编码性能通常用于指示生成模型表达目标数据分布的程度</font>。我们使用自编码器网络对训练数据集中不存在的CAD模型$M$进行编码，然后将所得的潜在向量解码成CAD模型$\hat{M}$。通过比较$M$和$\hat{M}$的差异来评估自编码器的性能。</p>
<ul>
<li>
<p><strong>指标</strong></p>
<ul>
<li>
<p><strong>命令准确率</strong>（$\text{ACC}_{\text{cmd}}$）：衡量预测的CAD命令类型的正确性；</p>
<p>$$
\text{ACC}_{\text{cmd}}=\frac{1}{N_c} \sum_{t=1}^{N_c}\mathbb{I}[t_i=\hat{t_i}]
,
$$</p>
</li>
<li>
<p><strong>参数准确率</strong>（$\text{ACC}_\text{param}$）：衡量命令参数的正确性；</p>
<p>$$
\text{ACC}_\text{param} = \frac{1}{K} \sum_{i=1}^{N_c} \sum_{j=1}^{\left| \hat{p}_i \right|} \mathbb{I}[|p_{i,j} - \hat{p}_{i,j}| &lt; \eta]\mathbb{I}[t_i = \hat{t}_i],
$$</p>
<p>其中$K=\sum_{i=1}^{N_c}\mathbb{I}[t_i=\hat{t}_i]|p_i|$是所有正确恢复命令中的参数总数。注意$p_{i,j}$和$\hat{p}_{i,j}$都被量化为$8$位整数，选择$\eta$是作为考虑参数量化的容差阈值，在实践中，我们选择了$\eta=3$（256个级别）</p>
</li>
<li>
<p>此外，我们使用Chamfer距离（CD）来评估3D几何体的质量，通过均匀采样2000个点来计算参考形状和生成形状之间的CD。另外，我们还报告无效率，即无法转换为点云的输出CAD模型的百分比。</p>
</li>
</ul>
</li>
<li>
<p><strong>比较方法</strong></p>
<p>由于缺乏现有的CAD生成模型，我们比较了几种模型变体以验证我们的数据表示和训练策略。具体包括以下几种变体：Alt-Rel、Alt-Trans、Alt-ArcMid、Alt-Regr和Ours+Aug。每种变体在数据表示或训练策略上有所不同。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Quantitative_evaluation_of_autoencoding" alt="image-20240708210209763" style="zoom: 50%;" />
<p>总体而言，Ours+Aug（即使用合成数据增强训练）<strong>表现最佳</strong>，表明<font color="red">随机组合数据可以提高网络的泛化能力</font>。Alt-ArcMid的性能与Ours相似，说明中点表示法是表示弧的可行替代方法。Alt-Trans在CD方面略逊于Ours。虽然Alt-Rel的参数准确率（ACCparam）高于Ours，但其CD分数较大且有时会出现无效拓扑，例如在Figure 4中第二行中的黄色模型有两个三角形环路相互相交，导致拓扑无效，这是由于预测曲线位置的误差累积导致的。Alt-Regr由于不量化连续参数，误差较大，可能破坏关键的几何关系，如平行边和垂直边，例如Figure 4中的第一行。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Comparison_of_autoencoding_results" alt="image-20240708210312512" style="zoom:33%;" />
<p>我们还验证了我们自编码器的泛化，在其他更小的数据集（来自Autodesk Fusion 360）上评估它表现出良好的泛化能力，实现了可比较的定量性能。</p>
<h3 id="形状生成" class="heading-element"><span>4.1 形状生成</span>
  <a href="#%e5%bd%a2%e7%8a%b6%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于CAD设计没有现成的生成模型，我们选择将我们的模型与l-GAN进行比较，l-GAN是一种被广泛研究的点云三维形状生成模型。我们注意到，我们的目标并不是要显示出孰优孰劣，因为这两种生成模型有不同的应用领域。相反，我们证明了我们的模型即使在点云生成模型的度量下也能产生可比的形状质量。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Randomly_Generated_3D_Shapes" alt="image-20240708210552910" style="zoom: 33%;" />
<p>此外，如Figure 5所示，我们模型中的形状具有更清晰的几何细节，并且可以轻松地进行用户编辑(Figure 7)。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/User_Editing_Friendly" alt="image-20240708210641303" style="zoom: 50%;" />
<p>为了与点云生成模型进行定量比较，我们遵循l-GAN中使用的指标。这些度量标准用于衡量两组3D点云形状之间的差异，即真实形状集合$S$和生成形状集合$G$。</p>
<ul>
<li>
<p><strong>覆盖率（COV）</strong>：衡量$S$中的形状有多少可以很好地近似为G中的形状；</p>
</li>
<li>
<p><strong>最小匹配距离（MMD）</strong>：表示$S$和$G$中两个点云之间的最小匹配距离来衡量$G$的保真度；</p>
</li>
<li>
<p><strong>Jensen-Shannon散度(JSD)</strong>：衡量$S$和$G$的点云分布的相似性</p>
</li>
</ul>
<p>然后，我们将真实和生成的CAD模型转换为点云，并评估这些度量标准。结果如下：</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Shape_Generation_measured_under_point_cloud_metrics" alt="image-20240708210452316" style="zoom:50%;" />
<p>表明我们的方法在点云度量标准方面与l-GAN具有可比性的性能。然而，由于其参数化表示，CAD模型具有比点云更平滑的表面和更锐利的几何特征。</p>
<h3 id="未来应用" class="heading-element"><span>4.2 未来应用</span>
  <a href="#%e6%9c%aa%e6%9d%a5%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p>借助CAD生成模型，可以将点云（例如通过3D扫描获取的）重建为CAD模型，例如作者这里使用自编码器将CAD模型$M$编码为潜在向量$c$。然后，利用PointNet++编码器训练它将$M$的点云表示编码为相同的潜在向量$c$。在推断时，给定一个点云，我们使用PointNet++编码器将其映射到潜在向量，然后使用我们的自编码器解码为CAD模型。</p>
 <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2024-07-08-16-40-21-1720428018357.png" title="" alt="" data-align="center">
</li>
<li>
<p>生成的CAD模型可以直接导入CAD工具进行用户编辑。</p>
</li>
</ol>
<h2 id="总结" class="heading-element"><span>5 总结</span>
  <a href="#%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>作者提出了DeepCAD，第一个一个用于CAD设计的深度生成模型。几乎所有以前的3D生成模型都产生离散的3D形状，如体素、点云和网格。为此，作者还引入了一个大型CAD模型数据集，每个模型都表示为一个CAD命令序列。</p>
<p>在构建CAD生成模型的过程中，作者的方法存在以下几个主要限制：</p>
<ol>
<li>
<p><strong>曲线命令类型有限</strong>：目前，作者仅考虑了三种最常用的曲线命令类型（直线、弧线和圆）。然而，其他曲线命令也可以轻松添加，例如可以通过三个控制点以及起点来指定的三次贝塞尔曲线，其参数结构可以按照3.1中描述的方式进行。</p>
</li>
<li>
<p><strong>操作命令的局限性</strong>：虽然像旋转草图这样的操作可以类似于拉伸命令进行编码，但某些CAD操作（如倒角）作用于形状边界的部分，因此需要参考模型的B-rep（边界表示），而不仅仅是其他命令。<font color="red">将这些命令纳入生成模型仍需进一步研究</font>。</p>
</li>
<li>
<p><strong>拓扑有效性无法保证</strong>：并非每个CAD命令序列都能生成拓扑上有效的形状。作者的生成网络不能保证其输出的CAD序列的拓扑一致性。在实践中，生成的CAD命令序列很少失败，但随着命令序列变长，失败的可能性增加。</p>
 <img title="" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2024-07-08-16-45-09-1720428305187.png" alt="" data-align="center" width="396"></li>
</ol>
]]></description></item><item><title>【论文阅读笔记】Attention Is All You Need</title><link>https://hezephyr.github.io/posts/04.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0transformer/</link><pubDate>Sun, 07 Jul 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0transformer/</guid><description><![CDATA[<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>循环神经网络(RNN)，特别是长短期记忆和门控循环神经网络（<strong>编码器-解码器</strong>架构），已成为序列建模和转换问题（如语言建模和机器翻译）的先进方法，众多研究在不断推动其发展。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RNN?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RNN?size=small" data-sub-html="<h2>RNN做机器翻译</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RNN" alt="RNN做机器翻译" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RNN?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RNN?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/RNN?size=large 2x" data-title="RNN做机器翻译" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>但RNN通常<font color="red">沿输入和输出序列的符号位置</font>进行计算，其固有的顺序性导致训练示例内难以并行化，在序列长度较长时，由于内存限制跨示例的批处理，这一问题更加突出。尽管近期通过一些技术改进了计算效率，<font color="red">但顺序计算的基本限制仍未改变</font>。</p>
<p>且RNN使用共享权值矩阵，在面临较长序列时，会有梯度消失的问题(也可以说是后面词的梯度会覆盖前面的梯度)。即使后序的LSTM和GRU对这一部分做了改进，但也无法完全解决该问题。</p>
<p><font color="red">注意力机制</font>已成为各种序列建模和转换模型的重要组成部分，能在不考虑输入或输出序列距离的情况下对依赖关系进行建模，但在大多数情况下与循环网络结合使用。</p>
<p>作者提出了 Transformer 模型，该模型摒弃了循环单元和卷积单元，完全依赖注意力机制来建立输入和输出之间的全局依赖关系，允许更多的并行化。</p>
<h2 id="背景" class="heading-element"><span>2 背景</span>
  <a href="#%e8%83%8c%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">减少序列计算量和加速计算</font>是序列处理模型中的基本思想。ByteNet和ConvS2S通过使用卷积神经网络并行计算，计算量和序列中位置的距离相关。ConvS2S是线性关系，而ByteNet是对数关系，使得长距离关系学习困难。Transformer将这个过程减少到常数规模，尽管降低了有效分辨率，但<strong>多头注意力机制</strong>弥补了这一点。</p>
<p>自注意力机制（内部注意力机制）为<font color="red">序列的不同位置分配权重，并学习表示向量</font>，已在阅读理解、文本摘要等任务中表现出色。</p>
<p>端到端记忆网络通常基于循环注意力机制，已用于简单语言翻译等任务。而Transformer 是<font color="red">第一个完全依赖自注意力</font>来计算其输入和输出表示的转换模型。</p>
<h2 id="模型架构" class="heading-element"><span>3 模型架构</span>
  <a href="#%e6%a8%a1%e5%9e%8b%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Transformer中沿用了非常经典的编码器-解码器架构，编码器将输入的序列$(x_1,\dots,x_n)$转化成一个表示向量$\boldsymbol{z}=(z_1,\dots,z_n)$，而编码器依据向量$\boldsymbol{z}$逐步生成输出序列$(y_1,\dots,y_m)$，并且模型在每个步骤中都是<strong>自回归</strong>的，会将先前生成的符号作为生成下一个的额外输入，例如这一步要生成$y_t$，要将$(y_1,\dots,y_{t-1})$都拿到也作为输入。</p>
<p>同时Transformer模型在编码器和解码器中都使用堆叠自注意力机制和逐点全连接层，如下图的左半部分和右半部分所示。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Transformer_Architecture" alt="image-20240707194838925" style="zoom: 33%;" />
<h3 id="编码器堆叠和解码器堆叠" class="heading-element"><span>3.1 编码器堆叠和解码器堆叠</span>
  <a href="#%e7%bc%96%e7%a0%81%e5%99%a8%e5%a0%86%e5%8f%a0%e5%92%8c%e8%a7%a3%e7%a0%81%e5%99%a8%e5%a0%86%e5%8f%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>编码器由 $6$ 个相同的层堆叠而成。每个层包含两个子层：<font color="red">多头自注意力机制和逐位置全连接前馈神经网络</font>。每个子层都使用了残差连接，然后进行层规范化（<strong>防止模型过拟合</strong>）。假设每一层的输入是$x$，那么每一层的输出结果可以表示为：
$$
\text{LayerNorm}(x+\text{Sublayer(x)})
$$
其中</p>
<ul>
<li>$\text{SubLayer}$是当前子层本身实现的运算函数，比如注意力运算和全连接运算；</li>
<li>模型中的所有子层以及嵌入层的输出维度均为 $d_{\text{model}} = 512$（便于残差连接）。</li>
</ul>
<p>解码器同样由 6 个层组成。其结构与编码器类似，但多了一个<strong>对编码器输出进行关注的多头注意力子层</strong>。并且在<strong>自注意力子层中进行了修改</strong>，以防止信息左向流动。这种掩码机制，结合输出嵌入向量向后偏移一个位置，确保位置 $i$ 的预测仅依赖于位置小于 $i$ 的已知输出。</p>
<h3 id="注意力机制" class="heading-element"><span>3.2 注意力机制</span>
  <a href="#%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>注意力机制就是对一系列的query和一系列的key-value对，我们需要确定对于每个query而言不同 value 的重要程度，而这个权重是根据 query 和key 的相关度计算得到的。</p>
<h4 id="缩放的点积注意力机制" class="heading-element"><span>3.2.1 缩放的点积注意力机制</span>
  <a href="#%e7%bc%a9%e6%94%be%e7%9a%84%e7%82%b9%e7%a7%af%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>Transformer模型中使用的是缩放的点积注意力机制。在这种机制中，注意力计算涉及query和key的维度为  $d_k$ )，以及value的维度为 $d_v$ 。通过引入一个<strong>缩放因子</strong>$\sqrt{d_k}$，可以控制注意力分布的稳定性和计算效率。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Scaled_Dot_Product_Attention" alt="image-20240707205349089" style="zoom:33%;" />
<p>我们用向量化的方式可以将这种注意力机制的计算过程表示成：
$$
\text{Attention}(Q,K,V)=\text{softmax}(\frac{QK^T}{\sqrt{d_k}})V
$$
与传统的注意力机制相比，缩放的点积注意力计算速度更快。缩放参数用于调节注意力计算的规模，以确保对于不同大小的输入，注意力权重的计算结果都能保持在合理的范围内。特别是在$\text{softmax}$函数的应用中，由于指数函数的快速增长特性，<font color="red">缩放可以有效防止某些权重过大</font>，而其他权重接近零的情况，确保了计算结果的平稳性和有效性。</p>
<h4 id="多头注意力机制" class="heading-element"><span>3.2.2 多头注意力机制</span>
  <a href="#%e5%a4%9a%e5%a4%b4%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><h4 id="heading" class="heading-element"><span>3.2.3 </span>
  <a href="#heading" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>Transformer采用了多头注意力机制，将query、key和value进行$h$次投影，然后对$h$个投影并行计算注意力，再将这些结果组合并线性投影生成最终的多头注意力输出。多头注意力使模型能够共同关注不同表示子空间和不同位置的信息。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Multi_Head_Attention" alt="image-20240707214205509" style="zoom:50%;" />
<p>多头注意力机制的计算公式为：
$$
\operatorname{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \ldots, \text{head}_h) W^O
$$
其中每个头的计算方式为：</p>
<p>$$
\text{head}_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)
$$
参数的维度如下：</p>
<ul>
<li>$( Q, K, V)$ 的输入维度为 $( d_{model} )$（通常为$512$）</li>
<li>$W_i^Q \in \mathbb{R}^{d_{model} \times d_k},  W_i^K \in \mathbb{R}^{d_{model} \times d_k}, W_i^V \in \mathbb{R}^{d_{model} \times d_v}, W^O \in \mathbb{R}^{hd_v \times d_{model}}$</li>
</ul>
<p>作者在Transformer中设置 $h = 8$  个头，每个头的维度为 $d_k = d_v = \frac{d_{model}}{h} = 64$。</p>
<h4 id="transformer中注意力机制的应用" class="heading-element"><span>3.2.4 Transformer中注意力机制的应用</span>
  <a href="#transformer%e4%b8%ad%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6%e7%9a%84%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li>在解码器的“编码器-解码器注意力层”中，query 来自上一个解码器层，而 key 和值 value 来自编码器的输出。这使得解码器中的每个位置都可以参与到输入序列所有位置的注意力计算中。</li>
</ul>
<ol>
<li><strong>编码器-解码器注意力层</strong>： 在这一层中，query 来自上一个解码器，而记忆 key 和 value 来自编码器的输出。这使得解码器中的每个位置都可以关注输入序列中的所有位置。</li>
<li><strong>编码器中的自注意力层</strong>： 编码器包含自注意力层。在这种自注意力机制中，<font color="red">query, key 和 value 都来自同一位置，即编码器前一层的输出</font>。这样，编码器中的每个位置都可以关注编码器前一层中的所有位置，从而捕捉输入序列中不同位置之间的全局依赖关系。</li>
<li><strong>解码器中的自注意力层</strong>： 解码器中的自注意力层的key，value和query也是同源的。但为了保持自回归属性，防止序列中前面的内容被后面的内容所影响，解码器在自注意力计算中加入了掩码机制。具体来说，通过在缩放的点积注意力中，将$\operatorname{softmax}$输入中对应非法连接的值设置为$-\infin$，来屏蔽这些连接。</li>
</ol>
<h3 id="逐位置全连接前馈神经网络" class="heading-element"><span>3.3 逐位置全连接前馈神经网络</span>
  <a href="#%e9%80%90%e4%bd%8d%e7%bd%ae%e5%85%a8%e8%bf%9e%e6%8e%a5%e5%89%8d%e9%a6%88%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="transformer中的逐位置全连接前馈神经网络" class="heading-element"><span>3.4 Transformer中的逐位置全连接前馈神经网络</span>
  <a href="#transformer%e4%b8%ad%e7%9a%84%e9%80%90%e4%bd%8d%e7%bd%ae%e5%85%a8%e8%bf%9e%e6%8e%a5%e5%89%8d%e9%a6%88%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Transformer中，逐位置全连接前馈神经网络用于增强模型对序列中每个位置信息的处理能力，这种网络结构包含两个线性变换层和$\operatorname{ReLU}$激活函数，用于每个位置独立地进行相同的操作。其数学表示如下：</p>
<p>$$
\text{FFN}(x) = \max(0, x W_1 + b_1) W_2 + b_2
$$</p>
<p>虽然不同位置的线性变换相同，但各层使用的参数不同。其中，$x$ 是输入向量，维度为 $d_{\text{model}} = 512$ ，而内层的维度为$d_{ff}=2048$，$W_1$ 和 $W_2$ 是两个线性变换的权重矩阵，$b_1$ 和 $b_2$ 是相应的偏置向量。这个结构类似于<code>kernel size</code>为1的卷积操作。</p>
<h3 id="嵌入和softmax" class="heading-element"><span>3.5 嵌入和Softmax</span>
  <a href="#%e5%b5%8c%e5%85%a5%e5%92%8csoftmax" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>和其他序列转换模型类似，Transformer 使用学习得到的嵌入将输入的token和输出的token转换为维度为 $ d_{\text{model}} $ 的向量。Transformer 还使用学习得到的线性变换和$\text{softmax}$函数将解码器的输出转换为预测的下一个token的概率。在Transformer中两个嵌入层和$\text{softmax}$之前的线性变换层之间共享相同的权重矩阵（<strong>减少模型的参数数量，降低过拟合的风险</strong>），同时在嵌入层中，我们将这些权重乘以  $\sqrt{d_{\text{model}}}$（<strong>缩放嵌入权重，防止梯度消失</strong>）。</p>
<h3 id="位置编码" class="heading-element"><span>3.6 位置编码</span>
  <a href="#%e4%bd%8d%e7%bd%ae%e7%bc%96%e7%a0%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Transformer模型中，由于没有循环和卷积单元，为了处理序列数据的位置信息，引入了位置编码。位置编码是为序列中的每个位置添加特定的向量表示，以便模型能够区分不同位置的token。在Transformer中的位置编码使用了sin函数和cos函数，这种方法不同于传统的学习得到的位置嵌入，而是采用固定的函数形式，即</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240729215814533.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240729215814533.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240729215814533.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240729215814533.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240729215814533.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/test.image.latex-20240729215814533.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这里的$\text{pos}$表示位置而$i$表示维度，也就是对于位于$\text{pos}$位置的token的嵌入向量第$i$维加上这样一个值。</p>
<h2 id="为什么使用自注意力机制" class="heading-element"><span>4 为什么使用自注意力机制</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e8%87%aa%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在处理序列数据时，长距离依赖关系的学习是一个关键挑战。论文中对比了使用自注意力、循环单元和卷积单元等不同模型结构时的计算量、时间复杂度和最大依赖路径长度。其中，最大依赖路径长度指的是任意两个输入输出位置之间信息传递的最长路径。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Maximum_Path_Lengths?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Maximum_Path_Lengths?size=small" data-sub-html="<h2>image-20240707224337637</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Maximum_Path_Lengths" alt="image-20240707224337637" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Maximum_Path_Lengths?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Maximum_Path_Lengths?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Maximum_Path_Lengths?size=large 2x" data-title="image-20240707224337637" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>在传统的循环神经网络（RNN）中，信息是逐步传递的，因此全局视角下，任意两个位置之间的最长信息传递路径往往是以序列长度 $n$ 为量级的。这种逐步传递导致了RNN在捕捉长距离依赖时可能面临的挑战，尤其是在处理长序列时效果不佳。</p>
<p>相比之下，<font color="red">Transformer利用自注意力机制直接将每个位置与所有其他位置进行关联，避免了逐步传递的过程</font>，使得任意两个位置之间的信息传递路径变得极为直接和高效。这种直接的路径传递方式使得Transformer能够更有效地捕捉到长距离的依赖关系，而不受序列长度的限制。</p>
<p>因此，Transformer凭借其独特的注意力机制，实现了“Attention is all you need”的理念，强调了在序列建模中注意力机制的重要性和效果。它不仅仅是一种模型结构的创新，更是在解决长距离依赖问题上的一次重大突破。Transformer的成功不仅在于其高效的信息传递路径，还在于其能够在更大范围内捕捉和利用序列中的关联信息，从而提升了序列建模任务的性能和效果。</p>
<h2 id="训练" class="heading-element"><span>5 训练</span>
  <a href="#%e8%ae%ad%e7%bb%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在论文中，训练Transformer模型涉及到几个关键的优化和正则化策略。</p>
<h3 id="优化器" class="heading-element"><span>5.1 优化器</span>
  <a href="#%e4%bc%98%e5%8c%96%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>模型的训练使用了Adam优化器，并采用了一种自适应的学习率。学习率 $\text{lr}$ 的计算方式如下所示：
<a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/lr_learn_compute?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/lr_learn_compute?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/lr_learn_compute" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/lr_learn_compute?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/lr_learn_compute?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/lr_learn_compute?size=large 2x" data-title="img" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这种自适应学习率的设计有助于在训练初期快速提升学习率，以加速模型收敛，而在训练后期逐渐降低学习率，以更细致地调整模型参数，提升训练的稳定性和效果。</p>
<h3 id="正则化" class="heading-element"><span>5.2 正则化</span>
  <a href="#%e6%ad%a3%e5%88%99%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Transformer模型采用了多种正则化方法，以提升泛化能力和训练稳定性：</p>
<ol>
<li>
<p><strong>残差连接</strong>：在每个子层之间都使用了残差连接，这种连接方式有助于减少梯度消失问题，并简化了模型的训练和优化过程。</p>
</li>
<li>
<p><strong>Dropout</strong>：在输入嵌入向量和位置编码相加后的层中使用了Dropout，选择的Dropout概率为0.1。Dropout通过随机地将部分神经元的输出置为零，有助于防止模型过拟合，并增强泛化能力。</p>
</li>
<li>
<p><strong>标签平滑处理</strong>：这是一种用于改善模型训练和提高评价指标（如BLEU分数）的技术。标签平滑处理通过将真实标签替换为一个分布更平滑的目标分布，从而减少模型对训练数据中特定标签的过度自信，提升泛化能力和性能评估的一致性。</p>
</li>
</ol>
]]></description></item><item><title>Shell 23道例题实战</title><link>https://hezephyr.github.io/posts/07.shell%E5%AE%9E%E6%88%98/</link><pubDate>Sun, 09 Jun 2024 09:39:47 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/07.shell%E5%AE%9E%E6%88%98/</guid><description><![CDATA[<h2 id="统计文件的行数" class="heading-element"><span>1 统计文件的行数</span>
  <a href="#%e7%bb%9f%e8%ae%a1%e6%96%87%e4%bb%b6%e7%9a%84%e8%a1%8c%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中的行数</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 方法1：使用 wc -l 和 awk</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 统计行数并使用 awk 提取第一个字段，即行数</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>wc -l nowcoder.txt <span class="p">|</span> awk <span class="s1">&#39;{print $1}&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;使用 wc -l 和 awk：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法2：通过输入流传递文件内容给 wc -l</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 &lt; 操作符</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>wc -l &lt; nowcoder.txt<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;通过输入流：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法3：使用 cat 和管道传递给 wc -l</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 cat 命令和管道</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>cat nowcoder.txt <span class="p">|</span> wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;通过管道：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法4：使用 sed 统计行数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed 的 -n &#39;$=&#39; 选项</span>
</span></span><span class="line"><span class="cl"><span class="nv">lines</span><span class="o">=</span><span class="k">$(</span>sed -n <span class="s1">&#39;$=&#39;</span> nowcoder.txt<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;使用 sed：</span><span class="nv">$lines</span><span class="s2"> 行&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印文件的最后5行" class="heading-element"><span>2 打印文件的最后5行</span>
  <a href="#%e6%89%93%e5%8d%b0%e6%96%87%e4%bb%b6%e7%9a%84%e6%9c%80%e5%90%8e5%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>查看日志的时候，经常会从文件的末尾往前查看，请你写一个<code>bash shell</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中的最后5行。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 查看文件的前5行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;前5行：&#34;</span>
</span></span><span class="line"><span class="cl">head -5 nowcoder.txt
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看文件的后5行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;后5行：&#34;</span>
</span></span><span class="line"><span class="cl">tail -5 nowcoder.txt
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看文件的第5行到第20行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;第5行到第20行：&#34;</span>
</span></span><span class="line"><span class="cl">sed -n <span class="s1">&#39;5,20p&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="输出-0-到-500-中-7-的倍数" class="heading-element"><span>3 输出 0 到 500 中 7 的倍数</span>
  <a href="#%e8%be%93%e5%87%ba-0-%e5%88%b0-500-%e4%b8%ad-7-%e7%9a%84%e5%80%8d%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个 <code>bash</code>脚本以输出数字 $0$ 到 $500$ 中 $7$ 的倍数$(0 7 14 21&hellip;)$的命令</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 方法1：使用 Bash 的扩展语法的 for 循环</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;方法1：使用 Bash 的扩展语法的 for 循环&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> item in <span class="o">{</span>0..500..7<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> 
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$item</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span> <span class="c1"># 分隔行</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法2：使用 seq 命令 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># seq [选项]... 首部 增量 尾部</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;方法2：使用 seq 命令&#34;</span>
</span></span><span class="line"><span class="cl">seq <span class="m">0</span> <span class="m">7</span> <span class="m">500</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;&#34;</span> <span class="c1"># 分隔行</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 方法3：使用 while 循环</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;方法3：使用 while 循环&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 初始化变量</span>
</span></span><span class="line"><span class="cl"><span class="nv">i</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 while 循环</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le <span class="m">500</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 输出当前的 7 的倍数</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$i</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 增加 7</span>
</span></span><span class="line"><span class="cl">    <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i <span class="o">+</span> <span class="m">7</span><span class="k">))</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="输出第5行的内容" class="heading-element"><span>4 输出第5行的内容</span>
  <a href="#%e8%be%93%e5%87%ba%e7%ac%ac5%e8%a1%8c%e7%9a%84%e5%86%85%e5%ae%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>bash</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中第$5$行的内容。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># head 命令拿到前五行，再通过通道，通过tail取出来最后一行，即第五行</span>
</span></span><span class="line"><span class="cl">head -n <span class="m">5</span> nowcoder.txt <span class="p">|</span> tail -n <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用sed 命令中的 p选项，打印第五行</span>
</span></span><span class="line"><span class="cl">sed -n 5p nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印空行的行号" class="heading-element"><span>5 打印空行的行号</span>
  <a href="#%e6%89%93%e5%8d%b0%e7%a9%ba%e8%a1%8c%e7%9a%84%e8%a1%8c%e5%8f%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本以输出一个文本文件<code>nowcoder.txt</code>中空行的行号（空行可能连续，从1开始输出）</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep 命令匹配所有空行，并且输出匹配的行号。-n 选项表示输出匹配行的行号，&#39;^$&#39; 匹配空行。使用 cut 命令以 : 作为分隔符，提取每行的第一个字段，即行号。</span>
</span></span><span class="line"><span class="cl">grep -n <span class="s1">&#39;^$&#39;</span> nowcoder.txt <span class="p">|</span> cut -d<span class="s1">&#39;:&#39;</span> -f1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令，NF 表示当前行的字段数，NR 表示当前行号。当字段数为0时，即当前行为空行，{ print NR } 输出当前行的行号。</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;NF == 0 { print NR }&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed 命令匹配所有空行，并输出匹配行的行号。-n 选项表示只输出指定的行，/^$/ 匹配空行，=表示输出匹配行的行号。</span>
</span></span><span class="line"><span class="cl">sed -n <span class="s1">&#39;/^$/=&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="去掉空行" class="heading-element"><span>6 去掉空行</span>
  <a href="#%e5%8e%bb%e6%8e%89%e7%a9%ba%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个 <code>bash</code>脚本以去掉一个文本文件<code>nowcoder.txt</code>中的空行</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep 命令匹配所有非空行。-v 选项表示反转匹配，&#39;^$&#39; 匹配空行。</span>
</span></span><span class="line"><span class="cl">grep -v <span class="s1">&#39;^$&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed 命令删除匹配空行的行。/^$/ 匹配空行，d 命令删除匹配的行</span>
</span></span><span class="line"><span class="cl">sed <span class="s1">&#39;/^$/d&#39;</span> nowcoder.txt &gt; nowcoder_no_empty_lines.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令，NF 表示字段数，NF 为真时表示非空行。</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;NF&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印字母数小于8的单词" class="heading-element"><span>7 打印字母数小于8的单词</span>
  <a href="#%e6%89%93%e5%8d%b0%e5%ad%97%e6%af%8d%e6%95%b0%e5%b0%8f%e4%ba%8e8%e7%9a%84%e5%8d%95%e8%af%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以统计一个文本文件<code>nowcoder.txt</code>中字母数小于8的单词。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令遍历每个单词，NF 表示当前行的单词数，length($i) 表示当前单词的字母数，如果字母数小于8，则打印当前单词。</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ for (i=1; i&lt;=NF; i++) if (length($i)&lt;8) print $i }&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep 命令匹配字母数小于8的单词。-o 选项表示只输出匹配的内容，\b 表示单词边界，\w\{1,7\} 匹配字母数在1到7之间的单词。</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s1">&#39;\b\w\{1,7\}\b&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="统计所有进程占用内存百分比的和" class="heading-element"><span>8 统计所有进程占用内存百分比的和</span>
  <a href="#%e7%bb%9f%e8%ae%a1%e6%89%80%e6%9c%89%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8%e5%86%85%e5%ad%98%e7%99%be%e5%88%86%e6%af%94%e7%9a%84%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设 <code>nowcoder.txt</code> 内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">USER</span>       <span class="n">PID</span> <span class="o">%</span><span class="n">CPU</span> <span class="o">%</span><span class="n">MEM</span>    <span class="n">VSZ</span>   <span class="n">RSS</span> <span class="n">TTY</span>      <span class="n">STAT</span> <span class="n">START</span>   <span class="n">TIME</span> <span class="n">COMMAND</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>         <span class="mi">1</span>  <span class="mf">0.0</span>  <span class="mf">0.4</span>  <span class="mi">77744</span>  <span class="mi">8332</span> <span class="o">?</span>        <span class="n">Ss</span>    <span class="mi">2021</span>   <span class="mi">1</span><span class="o">:</span><span class="mi">15</span> <span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">init</span> <span class="n">noibrs</span> <span class="n">splash</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>         <span class="mi">2</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>      <span class="mi">0</span>     <span class="mi">0</span> <span class="o">?</span>        <span class="n">S</span>     <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="p">[</span><span class="n">kthreadd</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>         <span class="mi">4</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>      <span class="mi">0</span>     <span class="mi">0</span> <span class="o">?</span>        <span class="n">I</span><span class="o">&lt;</span>    <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="p">[</span><span class="n">kworker</span><span class="o">/</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="n">H</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">daemon</span>     <span class="mi">486</span>  <span class="mf">0.0</span>  <span class="mf">0.1</span>  <span class="mi">28340</span>  <span class="mi">2372</span> <span class="o">?</span>        <span class="n">Ss</span>    <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">atd</span> <span class="o">-</span><span class="n">f</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>       <span class="mi">586</span>  <span class="mf">0.0</span>  <span class="mf">0.3</span>  <span class="mi">72308</span>  <span class="mi">6244</span> <span class="o">?</span>        <span class="n">Ss</span>    <span class="mi">2021</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">01</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sshd</span> <span class="o">-</span><span class="n">D</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">12847</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>   <span class="mi">4528</span>    <span class="mi">68</span> <span class="o">?</span>        <span class="n">S</span><span class="o">&lt;</span>   <span class="n">Jan03</span>   <span class="mi">0</span><span class="o">:</span><span class="mi">13</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">atopacctd</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">16306</span>  <span class="mf">1.7</span>  <span class="mf">1.2</span> <span class="mi">151964</span> <span class="mi">26132</span> <span class="o">?</span>        <span class="n">S</span><span class="o">&lt;</span><span class="n">sl</span> <span class="n">Apr15</span> <span class="mi">512</span><span class="o">:</span><span class="mo">03</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">aegis</span><span class="o">/</span><span class="n">aegis_client</span><span class="o">/</span><span class="n">aegis_11_25</span><span class="o">/</span><span class="n">AliYunDun</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24143</span>  <span class="mf">0.0</span>  <span class="mf">0.4</span>  <span class="mi">25608</span>  <span class="mi">8652</span> <span class="o">?</span>        <span class="n">S</span><span class="o">&lt;</span><span class="n">Ls</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">03</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">atop</span> <span class="o">-</span><span class="n">R</span> <span class="o">-</span><span class="n">w</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">log</span><span class="o">/</span><span class="n">atop</span><span class="o">/</span><span class="n">atop_20220505</span> <span class="mi">600</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24901</span>  <span class="mf">0.0</span>  <span class="mf">0.3</span> <span class="mi">107792</span>  <span class="mi">7008</span> <span class="o">?</span>        <span class="n">Ss</span>   <span class="mi">15</span><span class="o">:</span><span class="mi">37</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="nl">sshd</span><span class="p">:</span> <span class="n">root</span><span class="err">@</span><span class="n">pts</span><span class="o">/</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24903</span>  <span class="mf">0.0</span>  <span class="mf">0.3</span>  <span class="mi">76532</span>  <span class="mi">7580</span> <span class="o">?</span>        <span class="n">Ss</span>   <span class="mi">15</span><span class="o">:</span><span class="mi">37</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">systemd</span><span class="o">/</span><span class="n">systemd</span> <span class="o">--</span><span class="n">user</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span>     <span class="mi">24904</span>  <span class="mf">0.0</span>  <span class="mf">0.1</span> <span class="mi">111520</span>  <span class="mi">2392</span> <span class="o">?</span>        <span class="n">S</span>    <span class="mi">15</span><span class="o">:</span><span class="mi">37</span>   <span class="mi">0</span><span class="o">:</span><span class="mo">00</span> <span class="p">(</span><span class="n">sd</span><span class="o">-</span><span class="n">pam</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以上内容是通过<code>ps aux</code>命令输出到<code>nowcoder.txt</code>文件中的，请你写一个脚本计算一下所有进程占用内存大小的和。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用awk命令过滤到第一行并累加$4</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;BEGIN { sum=0 } NR &gt; 1 { sum+=$4 } END { print sum }&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用while循环读取，并用if跳过第一行，使用bc进行浮点数加法运算</span>
</span></span><span class="line"><span class="cl"><span class="nv">sum</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="nv">cnt</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nb">read</span> -r line<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="nv">$cnt</span> -gt <span class="m">1</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nv">mem</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $4 }&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">sum</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$sum</span><span class="s2">+</span><span class="nv">$mem</span><span class="s2">&#34;</span> <span class="p">|</span> bc<span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cnt</span><span class="o">=</span><span class="k">$((</span>cnt+1<span class="k">))</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$sum</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nv">sum</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">tail -n +2 nowcoder.txt <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> -r line<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="nv">mem</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> <span class="p">|</span> awk <span class="s1">&#39;{ print $4 }&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">sum</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$sum</span><span class="s2">+</span><span class="nv">$mem</span><span class="s2">&#34;</span> <span class="p">|</span> bc<span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="nv">$sum</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$sum</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>Bash</code> 中，<font color="red">管道中的命令会在子 shell 中执行，因此变量修改不会影响主 shell 中的变量</font>。这就是为什么看到 <code>sum</code> 在循环内部被正确更新，但在循环外部仍然是初始值 <code>0</code>。</p>
</blockquote>
<h2 id="统计每个单词出现的个数" class="heading-element"><span>9 统计每个单词出现的个数</span>
  <a href="#%e7%bb%9f%e8%ae%a1%e6%af%8f%e4%b8%aa%e5%8d%95%e8%af%8d%e5%87%ba%e7%8e%b0%e7%9a%84%e4%b8%aa%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以统计一个文本文件<code>nowcoder.txt</code> 中每个单词出现的个数。</p>
<p>为了简单起见，你可以假设：
<code>nowcoder.txt</code>只包括小写字母和空格，每个单词只由小写字母组成，单词间由一个或多个空格字符分隔。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将空格转换为换行符，以便每个单词占一行</span>
</span></span><span class="line"><span class="cl">tr -s <span class="s1">&#39; &#39;</span> <span class="s1">&#39;\n&#39;</span> &lt;nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 对单词进行排序</span>
</span></span><span class="line"><span class="cl">	sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 统计每个单词的出现次数</span>
</span></span><span class="line"><span class="cl">	uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 调整输出格式为&#34;单词 词频&#34;</span>
</span></span><span class="line"><span class="cl">	awk <span class="s1">&#39;{ print $2, $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># 按词频升序排序，-k2,2 意味着只使用第二列进行排序，表示按数值进行排序（默认情况按字典序排序）</span>
</span></span><span class="line"><span class="cl">	sort -k2,2n 
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 统计每个单词的出现次数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># NF 表示当前行的字段数，即单词数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用一个关联数组 cnt 存储每个单词出现的次数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i=1; i&lt;=NF; i++)  # 遍历当前行的每个单词
</span></span></span><span class="line"><span class="cl"><span class="s1">        cnt[$i] += 1        # 将单词加入关联数组 cnt，统计出现次数
</span></span></span><span class="line"><span class="cl"><span class="s1">}
</span></span></span><span class="line"><span class="cl"><span class="s1">END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (x in cnt)           # 遍历关联数组 cnt
</span></span></span><span class="line"><span class="cl"><span class="s1">        print x, cnt[x]       # 输出单词和对应的出现次数
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt <span class="p">|</span> sort -k2,2n</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="第二列是否有重复" class="heading-element"><span>10 第二列是否有重复</span>
  <a href="#%e7%ac%ac%e4%ba%8c%e5%88%97%e6%98%af%e5%90%a6%e6%9c%89%e9%87%8d%e5%a4%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>给定一个<code>nowcoder.txt</code>文件，其中有3列信息，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">20201001 python 99
</span></span><span class="line"><span class="cl">20201002 go 80
</span></span><span class="line"><span class="cl">20201002 c++ 88
</span></span><span class="line"><span class="cl">20201003 php 77
</span></span><span class="line"><span class="cl">20201001 go 88
</span></span><span class="line"><span class="cl">20201005 shell 89
</span></span><span class="line"><span class="cl">20201006 java 70
</span></span><span class="line"><span class="cl">20201008 c 100
</span></span><span class="line"><span class="cl">20201007 java 88
</span></span><span class="line"><span class="cl">20201006 go 97</span></span></code></pre></td></tr></table>
</div>
</div><p>编写一个<code>shell</code>脚本来检查文件第二列是否有重复，且有几个重复，并提取出重复的行的第二列信息（先按次数排序，如果次数相同，按照单词字母顺序排序），输入如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">2 java
</span></span><span class="line"><span class="cl">3 go</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">cat nowcoder.txt <span class="p">|</span> 
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $2 }&#39;</span> <span class="p">|</span> 
</span></span><span class="line"><span class="cl">sort <span class="p">|</span> uniq -c <span class="p">|</span> 
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span> <span class="p">|</span> <span class="c1"># 重新格式化输出</span>
</span></span><span class="line"><span class="cl">sort -k1,1n -k2,2 <span class="p">|</span> <span class="c1"># 按照出现次数和字母顺序排序</span>
</span></span><span class="line"><span class="cl">grep -v <span class="s1">&#39;1&#39;</span>	<span class="c1"># 过滤出现次数不为 1 的行</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="转置文件的内容" class="heading-element"><span>11 转置文件的内容</span>
  <a href="#%e8%bd%ac%e7%bd%ae%e6%96%87%e4%bb%b6%e7%9a%84%e5%86%85%e5%ae%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本来转置文本文件<code>nowcoder.txt</code>中的文件内容。
文件中每行列数相同，并且每个字段由空格分隔</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 读取文件并使用 awk 转置文件内容</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">{
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 遍历当前行的每一个字段
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        a[NR, i] = $i  # 将每个字段存储在一个二维数组中，a[行号, 列号] = 值
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}
</span></span></span><span class="line"><span class="cl"><span class="s1">NF &gt; p { p = NF }  # 如果当前行的字段数大于 p，则更新 p 为当前行的字段数
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 遍历每一列（由最大字段数 p 确定）
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= p; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        # 遍历每一行（由总行数 NR 确定）
</span></span></span><span class="line"><span class="cl"><span class="s1">        for (j = 1; j &lt;= NR; j++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">            printf(&#34;%s%s&#34;, a[j,i], (j==NR ? &#34;&#34; : &#34; &#34;))  # 输出数组中对应的字段值，并在每个字段后添加空格，除非是最后一个字段
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf(&#34;\n&#34;)  # 每一列输出完之后换行
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印每一行出现的数字个数" class="heading-element"><span>12 打印每一行出现的数字个数</span>
  <a href="#%e6%89%93%e5%8d%b0%e6%af%8f%e4%b8%80%e8%a1%8c%e5%87%ba%e7%8e%b0%e7%9a%84%e6%95%b0%e5%ad%97%e4%b8%aa%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本，统计一个文本文件<code>nowcoder.txt</code>中每一行出现的<code>1~5</code>数字的个数，并且计算一下整个文档中一共出现了几个<code>1~5</code>数字的总数。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 读取文件并统计每行中包含的特定数字（1, 2, 3, 4, 5）的数量</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;[1,2,3,4,5]&#34;</span> <span class="s1">&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">BEGIN { 
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum = 0  # 初始化 sum 变量，用于存储总和
</span></span></span><span class="line"><span class="cl"><span class="s1">} {
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 打印当前行号 NR 以及当前行中包含的特定数字的数量 (NF - 1)
</span></span></span><span class="line"><span class="cl"><span class="s1">    print(&#34;line&#34; NR &#34; number: &#34; (NF - 1))
</span></span></span><span class="line"><span class="cl"><span class="s1">    
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 将当前行中包含的特定数字的数量累加到 sum
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum += (NF - 1)
</span></span></span><span class="line"><span class="cl"><span class="s1">} END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    # 打印总和
</span></span></span><span class="line"><span class="cl"><span class="s1">    print(&#34;sum is &#34; sum)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="去掉所有包含this的句子" class="heading-element"><span>13 去掉所有包含this的句子</span>
  <a href="#%e5%8e%bb%e6%8e%89%e6%89%80%e6%9c%89%e5%8c%85%e5%90%abthis%e7%9a%84%e5%8f%a5%e5%ad%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本以实现如下功能：去掉输入中含有<code>this</code>的语句，把不含<code>this</code>的语句输出</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># -v 反转匹配</span>
</span></span><span class="line"><span class="cl">grep -v <span class="s2">&#34;this&#34;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># sed 命令 -&gt; d 删除 -&gt; // 包含要搜索的字符串</span>
</span></span><span class="line"><span class="cl">sed <span class="s1">&#39;/this/d&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># awk 命令，$0为当前行的所有内容，!~ 是 awk 的模式匹配运算符，表示模式不匹配</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;$0!~/this/ {print $0}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="求平均值" class="heading-element"><span>14 求平均值</span>
  <a href="#%e6%b1%82%e5%b9%b3%e5%9d%87%e5%80%bc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以实现一个需求，求输入的一个数组的平均值</p>
<p>第<code>1</code>行为输入的数组长度<code>N</code></p>
<p>第<code>2~N</code>行为数组的元素，如以下为:
数组长度为<code>4</code>，数组元素为<code>1 2 9 8</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;BEGIN {
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum = 0
</span></span></span><span class="line"><span class="cl"><span class="s1">}{
</span></span></span><span class="line"><span class="cl"><span class="s1">    if (NR == 1) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        N = $1  # 将第一行的数字数量保存到变量 N 中
</span></span></span><span class="line"><span class="cl"><span class="s1">    } else {
</span></span></span><span class="line"><span class="cl"><span class="s1">        sum += $1  # 对随后的数字进行累加求和
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">} END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf(&#34;%.3f&#34;, sum / N)  # 输出平均值，保留三位小数
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="去掉不需要的单词" class="heading-element"><span>15 去掉不需要的单词</span>
  <a href="#%e5%8e%bb%e6%8e%89%e4%b8%8d%e9%9c%80%e8%a6%81%e7%9a%84%e5%8d%95%e8%af%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个<code>bash</code>脚本以实现一个需求，去掉输入中含有<code>B</code>和<code>b</code>的单词。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 sed -n 命令打印不包含 &#39;B&#39; 和 &#39;b&#39; 的行</span>
</span></span><span class="line"><span class="cl"><span class="c1"># /^[^bB]*$/ 表示匹配不包含 &#39;B&#39; 和 &#39;b&#39; 的行，^ 表示行开头，[^bB] 表示不包含 &#39;B&#39; 和 &#39;b&#39; 的任何字符，* 表示零次或多次重复，$ 表示行结尾</span>
</span></span><span class="line"><span class="cl">sed -n <span class="s1">&#39;/^[^bB]*$/p&#39;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 grep -E -v 命令排除包含 &#39;B&#39; 和 &#39;b&#39; 的行</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -E 选项启用扩展的正则表达式，-v 选项表示反转匹配</span>
</span></span><span class="line"><span class="cl">grep -E -v <span class="s2">&#34;[bB]&#34;</span> nowcoder.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 awk 命令，遍历每个单词，如果不包含 &#39;B&#39; 和 &#39;b&#39;，则输出该单词</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1;i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        if ($i !~ /b|B/) {  # 使用正则表达式匹配单词中不包含 &#39;</span>B<span class="s1">&#39; 和 &#39;</span>b<span class="s1">&#39; 的部分
</span></span></span><span class="line"><span class="cl"><span class="s1">            printf(&#34;%s &#34;, $i)  # 输出不包含 &#39;</span>B<span class="s1">&#39; 和 &#39;</span>b<span class="s1">&#39; 的单词
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="判断输入的是否为ip地址" class="heading-element"><span>16 判断输入的是否为IP地址</span>
  <a href="#%e5%88%a4%e6%96%ad%e8%be%93%e5%85%a5%e7%9a%84%e6%98%af%e5%90%a6%e4%b8%baip%e5%9c%b0%e5%9d%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>写一个脚本统计文件<code>nowcoder.txt</code>中的每一行是否是正确的<code>IP</code>地址。</p>
<p>如果是正确的<code>IP</code>地址输出：<code>yes</code></p>
<p>如果是错误的<code>IP</code>地址，且是四段号码的话输出：<code>no</code>，否则的话输出：<code>error</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;.&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    flag = &#34;error&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">    if (NF == 4) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        flag = &#34;yes&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">        for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">            if ($i &gt; 255) {
</span></span></span><span class="line"><span class="cl"><span class="s1">                flag = &#34;no&#34;;
</span></span></span><span class="line"><span class="cl"><span class="s1">                break;
</span></span></span><span class="line"><span class="cl"><span class="s1">            }
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf(flag&#34;\n&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="将字段逆序输出文件的每行" class="heading-element"><span>17 将字段逆序输出文件的每行</span>
  <a href="#%e5%b0%86%e5%ad%97%e6%ae%b5%e9%80%86%e5%ba%8f%e8%be%93%e5%87%ba%e6%96%87%e4%bb%b6%e7%9a%84%e6%af%8f%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本，将文件<code>nowcoder.txt</code>中每一行的字段逆序输出，其中字段之间使用英文冒号<code>:</code>相分隔。</p>
<p>假设<code>nowcoder.txt</code>内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
</span></span><span class="line"><span class="cl">root:*:0:0:System Administrator:/var/root:/bin/sh</span></span></code></pre></td></tr></table>
</div>
</div><p>你的脚本应当输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">/usr/bin/false:/var/empty:Unprivileged User:-2:-2:*:nobody
</span></span><span class="line"><span class="cl">/bin/sh:/var/root:System Administrator:0:0:*:root</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        temp[i] = $i
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = NF; i &gt;= 1; i--) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf(&#34;%s%s&#34;, temp[i], (i == 1 ? &#34;\n&#34; : &#34;:&#34;))
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="域名进行计数排序处理" class="heading-element"><span>18 域名进行计数排序处理</span>
  <a href="#%e5%9f%9f%e5%90%8d%e8%bf%9b%e8%a1%8c%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f%e5%a4%84%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设有一些域名，存储在<code>nowcoder.txt</code>里，现在需要写一个<code>shell</code>脚本，将域名取出并根据域名进行计数排序处理（降序）。</p>
<p>假设<code>nowcoder.txt</code>内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">http://www.nowcoder.com/index.html
</span></span><span class="line"><span class="cl">http://www.nowcoder.com/1.html
</span></span><span class="line"><span class="cl">http://m.nowcoder.com/index.html</span></span></code></pre></td></tr></table>
</div>
</div><p>你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">2 www.nowcoder.com
</span></span><span class="line"><span class="cl">1 m.nowcoder.com</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s1">&#39;/&#39;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    print($3)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    print($1&#34; &#34;$2)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印等腰三角形" class="heading-element"><span>19 打印等腰三角形</span>
  <a href="#%e6%89%93%e5%8d%b0%e7%ad%89%e8%85%b0%e4%b8%89%e8%a7%92%e5%bd%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>编写一个<code>shell</code>脚本，输入正整数<code>n</code>，打印边长为<code>n</code>的等腰三角形。</p>
<p>示例：</p>
<p>输入：<code>5</code></p>
<p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">    *
</span></span><span class="line"><span class="cl">   * *
</span></span><span class="line"><span class="cl">  * * *
</span></span><span class="line"><span class="cl"> * * * *
</span></span><span class="line"><span class="cl">* * * * *</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="nb">read</span> n
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> 1<span class="p">;</span> i &lt;<span class="o">=</span> n<span class="p">;</span> i++<span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">((</span><span class="nv">j</span> <span class="o">=</span> 1<span class="p">;</span> j &lt;<span class="o">=</span> n - i<span class="p">;</span> j++<span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span>
</span></span><span class="line"><span class="cl">        <span class="nb">printf</span> <span class="s2">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">done</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">((</span><span class="nv">j</span> <span class="o">=</span> 1<span class="p">;</span> j &lt;<span class="o">=</span> i<span class="p">;</span> j++<span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$j</span> -eq <span class="nv">$i</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="nb">printf</span> <span class="s2">&#34;*&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="nb">printf</span> <span class="s2">&#34;* &#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="k">done</span>
</span></span><span class="line"><span class="cl">    <span class="nb">printf</span> <span class="s2">&#34;\n&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="打印只有一个数字的行" class="heading-element"><span>20 打印只有一个数字的行</span>
  <a href="#%e6%89%93%e5%8d%b0%e5%8f%aa%e6%9c%89%e4%b8%80%e4%b8%aa%e6%95%b0%e5%ad%97%e7%9a%84%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设有一个<code>nowcoder.txt</code>，编写脚本，打印只有一个数字的行。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;[0-9]&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    if (NF == 2) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        print($0)
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="格式化输出" class="heading-element"><span>21 格式化输出</span>
  <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>有一个文件<code>nowcoder.txt</code>，里面的每一行都是一个数字串，编写一个<code>shell</code>脚本对文件中每一行的数字串进行格式化：每$3$个数字加入一个逗号（,）。</p>
<p>例如：数字串为“123456789”，那么需要格式化为123,456,789。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用-F分割数字串</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i = 1; i &lt;= NF; i++) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf($i)
</span></span></span><span class="line"><span class="cl"><span class="s1">        if ((NF - i) % 3 == 0 &amp;&amp; i != NF) {
</span></span></span><span class="line"><span class="cl"><span class="s1">            printf(&#34;,&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">        }
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf(&#34;\n&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="处理文本" class="heading-element"><span>22 处理文本</span>
  <a href="#%e5%a4%84%e7%90%86%e6%96%87%e6%9c%ac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>有一个文本文件<code>nowcoder.txt</code>，假设内容格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">111:13443
</span></span><span class="line"><span class="cl">222:13211
</span></span><span class="line"><span class="cl">111:13643
</span></span><span class="line"><span class="cl">333:12341
</span></span><span class="line"><span class="cl">222:12123</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写一个<code>shell</code>脚本，按照以下的格式输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">[111]
</span></span><span class="line"><span class="cl">13443
</span></span><span class="line"><span class="cl">13643
</span></span><span class="line"><span class="cl">[222]
</span></span><span class="line"><span class="cl">13211
</span></span><span class="line"><span class="cl">12123
</span></span><span class="line"><span class="cl">[333]
</span></span><span class="line"><span class="cl">12341</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    cnt[$1] = cnt[$1] $2 &#34;\n&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">} END {
</span></span></span><span class="line"><span class="cl"><span class="s1">    for (i in cnt) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf(&#34;[%s]\n%s&#34;, i, cnt[i])
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> nowcoder.txt</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析1-ip访问次数统计" class="heading-element"><span>23 Nginx日志分析1-IP访问次数统计</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%901-ip%e8%ae%bf%e9%97%ae%e6%ac%a1%e6%95%b0%e7%bb%9f%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设 <code>Nginx</code> 的日志存储在 <code>nowcoder.txt</code> 里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.23</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">21</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">22</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.24</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">22</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.25</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">22</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">26</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">08</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.25</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">16</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.24</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /2/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.25</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /3/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.20</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.22</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mf">192.168.1.21</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">23</span><span class="o">/</span><span class="n">Apr</span><span class="o">/</span><span class="mi">2020</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">27</span><span class="o">:</span><span class="mi">49</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s">&#34;GET /1/index.php HTTP/1.1&#34;</span> <span class="mi">404</span> <span class="mi">490</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写 Shell 脚本统计出 2020 年 4 月 23 号访问 IP 的对应次数，并且按照次数降序排序。你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">5</span> <span class="mf">192.168.1.22</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mf">192.168.1.21</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="mf">192.168.1.20</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mf">192.168.1.25</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mf">192.168.1.24</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 通过grep过滤，再统计排序</span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;23/Apr/2020&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析2-统计某个时间段的ip访问量" class="heading-element"><span>24 Nginx日志分析2-统计某个时间段的IP访问量</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%902-%e7%bb%9f%e8%ae%a1%e6%9f%90%e4%b8%aa%e6%97%b6%e9%97%b4%e6%ae%b5%e7%9a%84ip%e8%ae%bf%e9%97%ae%e9%87%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设 <code>Nginx</code> 的日志存储在 <code>nowcoder.txt</code> 里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写 <code>Shell</code> 脚本统计 2020年04月23日20点至23点去重后的 IP 访问量，你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">5</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出说明：2020年04月23日20点至23点，共有 192.168.1.24、192.168.1.25、192.168.1.20、192.168.1.21、192.168.1.22 共 5 个 IP 访问了。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;23/Apr/2020:2[0-3]&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq <span class="p">|</span>
</span></span><span class="line"><span class="cl">wc -l</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析3-统计访问3次以上的ip" class="heading-element"><span>25 nginx日志分析3-统计访问3次以上的IP</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%903-%e7%bb%9f%e8%ae%a1%e8%ae%bf%e9%97%ae3%e6%ac%a1%e4%bb%a5%e4%b8%8a%e7%9a%84ip" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>nginx</code>的日志我们存储在nowcoder.txt里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>shell</code>脚本统计访问3次以上的IP，你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">6 192.168.1.22
</span></span><span class="line"><span class="cl">5 192.168.1.21
</span></span><span class="line"><span class="cl">4 192.168.1.20</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1 }&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    if ($1 &gt; 3) {
</span></span></span><span class="line"><span class="cl"><span class="s1">        print $1, $2
</span></span></span><span class="line"><span class="cl"><span class="s1">    }
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析4-查询某个ip的详细访问情况" class="heading-element"><span>26 Nginx日志分析4-查询某个IP的详细访问情况</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%904-%e6%9f%a5%e8%af%a2%e6%9f%90%e4%b8%aaip%e7%9a%84%e8%af%a6%e7%bb%86%e8%ae%bf%e9%97%ae%e6%83%85%e5%86%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>Nginx</code>的日志存储在<code>nowcoder.txt</code>里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>shell</code>脚本查询192.168.1.22的详细访问次数情况，按访问频率降序排序。你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">/</span><span class="mi">1</span><span class="o">/</span><span class="n">index</span><span class="p">.</span><span class="n">php</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">/</span><span class="mi">3</span><span class="o">/</span><span class="n">index</span><span class="p">.</span><span class="n">php</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;192.168.1.22&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $7 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析5-统计爬虫抓取404的次数" class="heading-element"><span>27 nginx日志分析5-统计爬虫抓取404的次数</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%905-%e7%bb%9f%e8%ae%a1%e7%88%ac%e8%99%ab%e6%8a%93%e5%8f%96404%e7%9a%84%e6%ac%a1%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>nginx</code>的日志存储在<code>nowcoder.txt</code>里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 301 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 500 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:21:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:05:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 200 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 300 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 500 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:59:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>shell</code>脚本统计百度爬虫抓取404的次数，你的脚本应该输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">2</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;404&#34;</span> <span class="p">|</span> grep <span class="s2">&#34;www.baidu.com&#34;</span> <span class="p">|</span> wc -l</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nginx日志分析6-统计每分钟的请求数" class="heading-element"><span>28 Nginx日志分析6-统计每分钟的请求数</span>
  <a href="#nginx%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%906-%e7%bb%9f%e8%ae%a1%e6%af%8f%e5%88%86%e9%92%9f%e7%9a%84%e8%af%b7%e6%b1%82%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>Nginx</code>的日志存储在nowcoder.txt里，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">192.168.1.20 - - [21/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [21/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [21/Apr/2020:21:21:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.23 - - [21/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [22/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [22/Apr/2020:15:26:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:08:05:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Baiduspider&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:09:20:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:10:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:14:12:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:15:00:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Baiduspider&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:16:15:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.24 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /2/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.25 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /3/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.20 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:20:27:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.22 - - [23/Apr/2020:22:10:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;
</span></span><span class="line"><span class="cl">192.168.1.21 - - [23/Apr/2020:23:59:49 +0800] &#34;GET /1/index.php HTTP/1.1&#34; 404 490 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写<code>Shell</code>脚本统计每分钟的请求数，并且按照请求数降序排序。你的脚本应该输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">5</span> <span class="mi">20</span><span class="o">:</span><span class="mi">27</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">15</span><span class="o">:</span><span class="mo">00</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">22</span><span class="o">:</span><span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">14</span><span class="o">:</span><span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">10</span><span class="o">:</span><span class="mi">27</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">23</span><span class="o">:</span><span class="mi">59</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">21</span><span class="o">:</span><span class="mi">21</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">16</span><span class="o">:</span><span class="mi">15</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">15</span><span class="o">:</span><span class="mi">26</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">09</span><span class="o">:</span><span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">08</span><span class="o">:</span><span class="mo">05</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{ print $2&#34;:&#34;$3 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -r <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习1-查看各个状态的连接数" class="heading-element"><span>29 netstat练习1-查看各个状态的连接数</span>
  <a href="#netstat%e7%bb%83%e4%b9%a01-%e6%9f%a5%e7%9c%8b%e5%90%84%e4%b8%aa%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9e%e6%8e%a5%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设netstat命令运行的结果我们存储在nowcoder.txt里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要编写shell脚本查看系统tcp连接中各个状态的连接数，并且按照连接数降序输出。你的脚本应该输出如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">ESTABLISHED 22
</span></span><span class="line"><span class="cl">TIME_WAIT 9
</span></span><span class="line"><span class="cl">LISTEN 3</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;tcp&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $6 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -nr <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $2, $1 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习2-查看和3306端口建立的连接" class="heading-element"><span>30 netstat练习2-查看和3306端口建立的连接</span>
  <a href="#netstat%e7%bb%83%e4%b9%a02-%e6%9f%a5%e7%9c%8b%e5%92%8c3306%e7%ab%af%e5%8f%a3%e5%bb%ba%e7%ab%8b%e7%9a%84%e8%bf%9e%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设netstat命令运行的结果我们存储在nowcoder.txt里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.143:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你查看和本机3306端口建立连接并且状态是<code>established</code>的所有IP，按照连接数降序排序。你的脚本应该输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">10 172.16.0.24
</span></span><span class="line"><span class="cl">9 172.16.34.144
</span></span><span class="line"><span class="cl">1 172.16.34.143</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;tcp.*ESTABLISHED&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $5 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;$2 == 3306 { print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -nr <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $1, $2 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习3-输出每个ip的连接数" class="heading-element"><span>31 netstat练习3-输出每个IP的连接数</span>
  <a href="#netstat%e7%bb%83%e4%b9%a03-%e8%be%93%e5%87%ba%e6%af%8f%e4%b8%aaip%e7%9a%84%e8%bf%9e%e6%8e%a5%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>netstat</code>命令运行的结果我们存储在<code>nowcoder.txt</code>里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.143:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你输出每个IP的连接数，按照连接数降序排序。你的脚本应该输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">172.16.0.24 10
</span></span><span class="line"><span class="cl">172.16.34.144 9
</span></span><span class="line"><span class="cl">100.100.142.4 3
</span></span><span class="line"><span class="cl">0.0.0.0 3
</span></span><span class="line"><span class="cl">172.16.34.143 1
</span></span><span class="line"><span class="cl">172.16.240.74 1
</span></span><span class="line"><span class="cl">120.55.222.235 1
</span></span><span class="line"><span class="cl">100.100.54.133 1
</span></span><span class="line"><span class="cl">100.100.45.106 1
</span></span><span class="line"><span class="cl">100.100.32.118 1
</span></span><span class="line"><span class="cl">100.100.30.25 1
</span></span><span class="line"><span class="cl">100.100.142.5 1
</span></span><span class="line"><span class="cl">100.100.142.1 1</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep <span class="s2">&#34;tcp&#34;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $5 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{ print $1 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">uniq -c <span class="p">|</span>
</span></span><span class="line"><span class="cl">sort -nr <span class="p">|</span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{ print $2, $1 }&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="netstat练习4-输出和3306端口建立连接总的各个状态的数目" class="heading-element"><span>32 netstat练习4-输出和3306端口建立连接总的各个状态的数目</span>
  <a href="#netstat%e7%bb%83%e4%b9%a04-%e8%be%93%e5%87%ba%e5%92%8c3306%e7%ab%af%e5%8f%a3%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e6%80%bb%e7%9a%84%e5%90%84%e4%b8%aa%e7%8a%b6%e6%80%81%e7%9a%84%e6%95%b0%e7%9b%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设<code>netstat</code>命令运行的结果我们存储在<code>nowcoder.txt</code>里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:6160            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41856     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49822     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49674     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:42316     172.16.34.143:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:44076     172.16.240.74:6379      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49656     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58248     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50108     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41944     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:35548     100.100.32.118:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:39024     100.100.45.106:443      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41788     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58260     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41812     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41854     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:58252     100.100.142.4:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49586     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41754     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50466     120.55.222.235:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:38514     100.100.142.5:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49832     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:52162     100.100.30.25:80        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50372     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:50306     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49600     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41908     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:60292     100.100.142.1:80        TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:37650     100.100.54.133:80       TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41938     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:49736     172.16.0.24:3306        ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 172.16.56.200:41890     172.16.34.144:3306      ESTABLISHED
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.1:323           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 0.0.0.0:45881           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 127.0.0.53:53           0.0.0.0:*
</span></span><span class="line"><span class="cl">udp        0      0 172.16.56.200:68        0.0.0.0:*
</span></span><span class="line"><span class="cl">udp6       0      0 ::1:323                 :::*
</span></span><span class="line"><span class="cl">raw6       0      0 :::58                   :::*                    7</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你输出和本机3306端口建立连接的各个状态的数目，按照以下格式输出
<code>TOTAL_IP</code>表示建立连接的ip数目</p>
<p><code>TOTAL_LINK</code>表示建立连接的总数目</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">TOTAL_IP 3
</span></span><span class="line"><span class="cl">ESTABLISHED 20
</span></span><span class="line"><span class="cl">TOTAL_LINK 20</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 统计包含3306且协议为tcp的总IP数量</span>
</span></span><span class="line"><span class="cl"><span class="nv">TOTAL_IP</span><span class="o">=</span><span class="k">$(</span>grep <span class="s2">&#34;tcp&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk <span class="s1">&#39;{ print $5 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F: <span class="s1">&#39;$2 == 3306 {print $1, $2 }&#39;</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">	sort <span class="p">|</span>
</span></span><span class="line"><span class="cl">	uniq <span class="p">|</span>
</span></span><span class="line"><span class="cl">	wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;TOTAL_IP </span><span class="nv">$TOTAL_IP</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 统计包含3306且状态为ESTABLISHED且协议为tcp的数量</span>
</span></span><span class="line"><span class="cl"><span class="nv">ESTABLISHED</span><span class="o">=</span><span class="k">$(</span>awk <span class="s1">&#39;/3306/ { if ($6 == &#34;ESTABLISHED&#34; &amp;&amp; $1 == &#34;tcp&#34;) print $5 }&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;ESTABLISHED </span><span class="nv">$ESTABLISHED</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 统计包含3306且协议为tcp的连接数量</span>
</span></span><span class="line"><span class="cl"><span class="nv">TOTAL_LINK</span><span class="o">=</span><span class="k">$(</span>awk <span class="s1">&#39;/3306/ { if ($1 == &#34;tcp&#34;) print $5 }&#39;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;TOTAL_LINK </span><span class="nv">$TOTAL_LINK</span><span class="s2">&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="业务分析-提取值" class="heading-element"><span>33 业务分析-提取值</span>
  <a href="#%e4%b8%9a%e5%8a%a1%e5%88%86%e6%9e%90-%e6%8f%90%e5%8f%96%e5%80%bc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设我们的日志<code>nowcoder.txt</code>里，内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">12-May-2017 10:02:22.789 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server version:Apache Tomcat/8.5.15
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.813 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:May 5 2017 11:03:04 UTC
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.813 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Server number:8.5.15.0
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.814 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:Windows, OS Version:10
</span></span><span class="line"><span class="cl">12-May-2017 10:02:22.814 信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:x86_64</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你提取出对应的值，输出内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">serverVersion:Apache Tomcat/8.5.15
</span></span><span class="line"><span class="cl">serverName:8.5.15.0
</span></span><span class="line"><span class="cl">osName:Windows
</span></span><span class="line"><span class="cl">osVersion:10</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;Server version:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print &#34;serverVersion:&#34; $2}&#39;</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;Server number:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print &#34;serverName:&#34; $2}&#39;</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;OS Name:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;[:,]&#34;</span> <span class="s1">&#39;{print &#34;osName:&#34; $2}&#39;</span>
</span></span><span class="line"><span class="cl">grep -o <span class="s2">&#34;OS Version:.*&#34;</span> nowcoder.txt <span class="p">|</span>
</span></span><span class="line"><span class="cl">	awk -F <span class="s2">&#34;:&#34;</span> <span class="s1">&#39;{print &#34;osVersion:&#34; $2}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ps分析-统计vszrss各自总和" class="heading-element"><span>34 ps分析-统计VSZ,RSS各自总和</span>
  <a href="#ps%e5%88%86%e6%9e%90-%e7%bb%9f%e8%ae%a1vszrss%e5%90%84%e8%87%aa%e6%80%bb%e5%92%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>假设命令运行的结果我们存储在<code>nowcoder.txt</code>里，格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span class="line"><span class="cl">root         1  0.0  0.1  37344  4604 ?        Ss    2020   2:13 /sbin/init
</span></span><span class="line"><span class="cl">root       231  0.0  1.5 166576 62740 ?        Ss    2020  15:15 /lib/systemd/systemd-journald
</span></span><span class="line"><span class="cl">root       237  0.0  0.0      0     0 ?        S&lt;    2020   2:06 [kworker/0:1H]
</span></span><span class="line"><span class="cl">root       259  0.0  0.0  45004  3416 ?        Ss    2020   0:25 /lib/systemd/systemd-udevd
</span></span><span class="line"><span class="cl">root       476  0.0  0.0      0     0 ?        S&lt;    2020   0:00 [edac-poller]
</span></span><span class="line"><span class="cl">root       588  0.0  0.0 276244  2072 ?        Ssl   2020   9:49 /usr/lib/accountsservice/accounts-daemon
</span></span><span class="line"><span class="cl">message+   592  0.0  0.0  42904  3032 ?        Ss    2020   0:01 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation
</span></span><span class="line"><span class="cl">root       636  0.0  0.0  65532  3200 ?        Ss    2020   1:51 /usr/sbin/sshd -D
</span></span><span class="line"><span class="cl">daemon     637  0.0  0.0  26044  2076 ?        Ss    2020   0:00 /usr/sbin/atd -f
</span></span><span class="line"><span class="cl">root       639  0.0  0.0  29476  2696 ?        Ss    2020   3:29 /usr/sbin/cron -f
</span></span><span class="line"><span class="cl">root       643  0.0  0.0  20748  1992 ?        Ss    2020   0:26 /lib/systemd/systemd-logind
</span></span><span class="line"><span class="cl">syslog     645  0.0  0.0 260636  3024 ?        Ssl   2020   3:17 /usr/sbin/rsyslogd -n
</span></span><span class="line"><span class="cl">root       686  0.0  0.0 773124  2836 ?        Ssl   2020  26:45 /usr/sbin/nscd
</span></span><span class="line"><span class="cl">root       690  0.0  0.0  19472   252 ?        Ss    2020  14:39 /usr/sbin/irqbalance --pid=/var/run/irqbalance.pid
</span></span><span class="line"><span class="cl">ntp        692  0.0  0.0  98204   776 ?        Ss    2020  25:18 /usr/sbin/ntpd -p /var/run/ntpd.pid -g -u 108:114
</span></span><span class="line"><span class="cl">uuidd      767  0.0  0.0  28624   192 ?        Ss    2020   0:00 /usr/sbin/uuidd --socket-activation
</span></span><span class="line"><span class="cl">root       793  0.0  0.0 128812  3148 ?        Ss    2020   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;
</span></span><span class="line"><span class="cl">www-data   794  0.0  0.2 133376  9120 ?        S     2020 630:57 nginx: worker process
</span></span><span class="line"><span class="cl">www-data   795  0.0  0.2 133208  8968 ?        S     2020 633:02 nginx: worker process
</span></span><span class="line"><span class="cl">www-data   796  0.0  0.2 133216  9120 ?        S     2020 634:24 nginx: worker process
</span></span><span class="line"><span class="cl">www-data   797  0.0  0.2 133228  9148 ?        S     2020 632:56 nginx: worker process
</span></span><span class="line"><span class="cl">web        955  0.0  0.0  36856  2112 ?        Ss    2020   0:00 /lib/systemd/systemd --user
</span></span><span class="line"><span class="cl">web        956  0.0  0.0  67456  1684 ?        S     2020   0:00 (sd-pam)
</span></span><span class="line"><span class="cl">root      1354  0.0  0.0   8172   440 tty1     Ss+   2020   0:00 /sbin/agetty --noclear tty1 linux
</span></span><span class="line"><span class="cl">root      1355  0.0  0.0   7988   344 ttyS0    Ss+   2020   0:00 /sbin/agetty --keep-baud 115200 38400 9600 ttyS0 vt220
</span></span><span class="line"><span class="cl">root      2513  0.0  0.0      0     0 ?        S    13:07   0:00 [kworker/u4:1]
</span></span><span class="line"><span class="cl">root      2587  0.0  0.0      0     0 ?        S    13:13   0:00 [kworker/u4:2]
</span></span><span class="line"><span class="cl">root      2642  0.0  0.0      0     0 ?        S    13:17   0:00 [kworker/1:0]
</span></span><span class="line"><span class="cl">root      2679  0.0  0.0      0     0 ?        S    13:19   0:00 [kworker/u4:0]
</span></span><span class="line"><span class="cl">root      2735  0.0  0.1 102256  7252 ?        Ss   13:24   0:00 sshd: web [priv]
</span></span><span class="line"><span class="cl">web       2752  0.0  0.0 102256  3452 ?        R    13:24   0:00 sshd: web@pts/0
</span></span><span class="line"><span class="cl">web       2753  0.5  0.1  14716  4708 pts/0    Ss   13:24   0:00 -bash
</span></span><span class="line"><span class="cl">web       2767  0.0  0.0  29596  1456 pts/0    R+   13:24   0:00 ps aux
</span></span><span class="line"><span class="cl">root     10634  0.0  0.0      0     0 ?        S    Nov16   0:00 [kworker/0:0]
</span></span><span class="line"><span class="cl">root     16585  0.0  0.0      0     0 ?        S&lt;    2020   0:00 [bioset]
</span></span><span class="line"><span class="cl">root     19526  0.0  0.0      0     0 ?        S    Nov16   0:00 [kworker/1:1]
</span></span><span class="line"><span class="cl">root     28460  0.0  0.0      0     0 ?        S    Nov15   0:03 [kworker/0:2]
</span></span><span class="line"><span class="cl">root     30685  0.0  0.0  36644  2760 ?        Ss    2020   0:00 /lib/systemd/systemd --user
</span></span><span class="line"><span class="cl">root     30692  0.0  0.0  67224  1664 ?        S     2020   0:00 (sd-pam)
</span></span><span class="line"><span class="cl">root     32689  0.0  0.0  47740  2100 ?        Ss    2020   0:00 /usr/local/ilogtail/ilogtail
</span></span><span class="line"><span class="cl">root     32691  0.2  0.5 256144 23708 ?        Sl    2020 1151:31 /usr/local/ilogtail/ilogtail</span></span></code></pre></td></tr></table>
</div>
</div><p>现在需要你统计<code>VSZ</code>，<code>RSS</code>各自的总和（以M兆为统计），输出格式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">MEM TOTAL
</span></span><span class="line"><span class="cl">VSZ_SUM:3250.8M,RSS_SUM:179.777M</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">awk <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum_vsz = sum_vsz + $5
</span></span></span><span class="line"><span class="cl"><span class="s1">    sum_rss = sum_rss + $6
</span></span></span><span class="line"><span class="cl"><span class="s1">}END{
</span></span></span><span class="line"><span class="cl"><span class="s1">    print(&#34;MEM TOTAL \n&#34; &#34;VSZ_SUM:&#34; sum_vsz/1024 &#34;M,&#34; &#34;RSS_SUM:&#34; sum_rss/1024 &#34;M&#34;)}&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>计算机网络 面试题目总结</title><link>https://hezephyr.github.io/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</link><pubDate>Sun, 02 Jun 2024 19:45:50 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="基础" class="heading-element"><span>1 基础</span>
  <a href="#%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="计算机网络体系结构" class="heading-element"><span>1.1 计算机网络体系结构</span>
  <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 OSI 七层模型、TCP/IP 四层模型和五层体系结构。<font color="red">OSI 是理论上的网络通信模型，TCP/IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。</font></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/计算机网络体系结构.png?size=small" data-sub-html="<h2>image-20240601203255272</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png" alt="image-20240601203255272" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=large 2x" data-title="image-20240601203255272" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="说说-osi-七层模型" class="heading-element"><span>1.2 说说 OSI 七层模型？</span>
  <a href="#%e8%af%b4%e8%af%b4-osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>OSI七层模型是一个用来描述计算机网络体系结构的标准模型。它将网络通信划分为七个抽象层，每一层都负责特定的功能，从物理连接到应用程序。这些层从下到上分别是：</p>
<ol>
<li>物理层（Physical Layer）：负责传输比特流，并管理物理介质。</li>
<li>数据链路层（Data Link Layer）：处理帧的传输，通过物理地址进行寻址。</li>
<li>网络层（Network Layer）：负责数据包的路由和转发，实现不同网络之间的通信。</li>
<li>传输层（Transport Layer）：提供端到端的可靠数据传输，包括错误检测、流量控制和分段重组。</li>
<li>会话层（Session Layer）：负责建立、管理和终止会话连接，以及数据的同步和恢复。</li>
<li>表示层（Presentation Layer）：处理数据的格式化和表示，确保不同系统的数据格式能够互相理解。</li>
<li>应用层（Application Layer）：提供用户与网络服务的接口，包括各种应用程序和协议，如HTTP、FTP和SMTP。</li>
</ol>
<h3 id="说说-tcpip-四层模型" class="heading-element"><span>1.3 说说 TCP/IP 四层模型？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcpip-%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP/IP 合并了 OSI 的部分层次，专注于高效的网络通信实践，更具实用性。</p>
<ol>
<li>网络接口层（Network Interface Layer）：对应于 OSI 模型的物理层和数据链路层。负责数据帧的物理传输，包括硬件地址寻址（MAC 地址），数据封装和解封装，错误检测和纠正等。</li>
<li>网际层（Internet Layer）对应于 OSI 模型的网络层。主要协议是 IP，负责数据包的寻址和路由。这一层还包括 ICMP 协议。</li>
<li>传输层（Transport Layer）：对应于 OSI 模型的传输层。负责提供端到端的数据传输服务，包括数据分割、流量控制、错误恢复等。主要的协议有 TCP 和 UDP</li>
<li>应用层（Application Layer）：对应于 OSI 模型的会话层、表示层和应用层。包括所有与网络有关的高级协议，如 HTTP、FTP、SMTP 等。</li>
</ol>
<h3 id="说说五层体系结构" class="heading-element"><span>1.4 说说五层体系结构？</span>
  <a href="#%e8%af%b4%e8%af%b4%e4%ba%94%e5%b1%82%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>是对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p>
<ul>
<li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li>
<li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li>
<li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li>
<li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li>
<li>物理层：电缆、光纤、无线电频谱、网络适配器等。</li>
</ul>
<h3 id="说一下每一层对应的网络协议有哪些" class="heading-element"><span>1.5 说一下每一层对应的网络协议有哪些？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e6%af%8f%e4%b8%80%e5%b1%82%e5%af%b9%e5%ba%94%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center">OSI七层网络模型</th>
<th style="text-align:center">TCP/IP四层模型</th>
<th style="text-align:center">对应的网络协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">HTTP、DNS、FTP、NFS、WAIS、SMIP、Telnet、SNMP</td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">TIFF、GIF、JPEG、PICT</td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">RPC、SQL、NFS、NetBIOS、names、AppleTalk</td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">传输层</td>
<td style="text-align:center">TCP、UDP</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center">IP、ICMP、ARP、RAPP、RIP、IPX</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">网络接口层</td>
<td style="text-align:center">FDDI、Frame Relay、HDLC、PPP</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">网络接口层</td>
<td style="text-align:center">EIA/TIA-232、EIA/TIA-499</td>
</tr>
</tbody>
</table>
<h3 id="数据在各层之间是怎么传输的呢" class="heading-element"><span>1.6 数据在各层之间是怎么传输的呢？</span>
  <a href="#%e6%95%b0%e6%8d%ae%e5%9c%a8%e5%90%84%e5%b1%82%e4%b9%8b%e9%97%b4%e6%98%af%e6%80%8e%e4%b9%88%e4%bc%a0%e8%be%93%e7%9a%84%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。</p>
<ul>
<li>发送方的应用进程向接收方的应用进程传送数据</li>
<li>AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li>
<li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li>
<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>
<li>最后的物理层，进行比特流的传输</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=small" data-sub-html="<h2>数据在各层之间的传输</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg" alt="数据在各层之间的传输" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=large 2x" data-title="数据在各层之间的传输" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</font></p>
<h2 id="网络综合" class="heading-element"><span>2 网络综合</span>
  <a href="#%e7%bd%91%e7%bb%9c%e7%bb%bc%e5%90%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="从浏览器地址栏输入-url-到显示主页的过程" class="heading-element"><span>2.1 从浏览器地址栏输入 URL 到显示主页的过程</span>
  <a href="#%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%9c%b0%e5%9d%80%e6%a0%8f%e8%be%93%e5%85%a5-url-%e5%88%b0%e6%98%be%e7%a4%ba%e4%b8%bb%e9%a1%b5%e7%9a%84%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>从在浏览器地址栏输入 URL 到显示主页的过程包括多个步骤，涵盖了 DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 响应、浏览器处理响应并渲染页面等多个环节。</p>
<ol>
<li><strong>DNS 解析</strong>：浏览器发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址。</li>
<li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接（通常是通过 443 端口进行 SSL 加密的 HTTPS 连接）。这一步涉及到 TCP 的三次握手过程，确保双方都准备好进行数据传输。</li>
<li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求消息，包括请求行（如 GET / HTTP/1.1）、请求头（包含用户代理、接受的内容类型等信息）和请求体（如果有）；将请求发送到服务器。</li>
<li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理（可能包括数据库查询等），生成 HTTP 响应消息；响应消息包括状态行（如 HTTP/1.1 200 OK）、响应头（内容类型、缓存控制等信息）和响应体（请求的资源内容）。</li>
<li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li>
<li><strong>断开连接</strong>：TCP 四次挥手，连接结束</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=small" data-sub-html="<h2>image-20240601205448054</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png" alt="image-20240601205448054" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=large 2x" data-title="image-20240601205448054" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="各个过程都使用了哪些协议" class="heading-element"><span>2.2 各个过程都使用了哪些协议？</span>
  <a href="#%e5%90%84%e4%b8%aa%e8%bf%87%e7%a8%8b%e9%83%bd%e4%bd%bf%e7%94%a8%e4%ba%86%e5%93%aa%e4%ba%9b%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>DNS:获取域名对应的IP</li>
<li>TCP:与服务器建立连接和断开连接</li>
<li>IP：使用TCP协议时，网络层需要使用IP协议。</li>
<li>OPSF：IP数据包在路由器之间，路由选择使用OPSF协议</li>
<li>ARP：路由器再与服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议</li>
<li>HTTP：TCP连接建立完成之后，使用HTTP协议传递HTTP报文</li>
</ul>
<h3 id="说说-dns-的解析过程" class="heading-element"><span>2.3 说说 DNS 的解析过程？</span>
  <a href="#%e8%af%b4%e8%af%b4-dns-%e7%9a%84%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DNS 的全称是 <strong>Domain Name System</strong>，也就是域名解析系统，它可以将域名映射到对应的 IP 地址上，比如说我们访问 <code>www.google.com</code>，实际上访问的是谷歌的一台服务器，它的 IP 地址是 <code>xxx.xxx.xxx.xxx</code>。可以通过 IP 地址直接访问服务器，但不方便记忆，所以就有了域名系统。域名到 IP 之间的映射，就需要 DNS 来完成。</p>
<p>假设我们在浏览器地址栏里键入了<code>www.google.com</code>：</p>
<ol>
<li>浏览器会首先检查自己的缓存中是否有这个域名对应的 IP 地址，如果有，直接返回；如果没有，进入下一步。</li>
<li>检查本地 DNS 缓存是否有该域名的记录。</li>
<li>如果没有，向<strong>根域名服务器</strong>发送请求，根域名服务器将请求指向更具体的服务，如 <code>com</code> 顶级域名服务器。</li>
<li>顶级域名服务器再将请求指向权限域名服务器，通常由域名注册机构直接管理，所以机构会提供对应的 DNS 解析服务，将域名和谷歌服务器绑定起来。</li>
<li>最终，浏览器使用获得的 IP 地址发起一个 HTTP 请求到目标服务器，然后该服务器返回所请求的网页内容。</li>
</ol>
<h3 id="说说-websocket-与-socket-的区别" class="heading-element"><span>2.4 说说 WebSocket 与 Socket 的区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-websocket-%e4%b8%8e-socket-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>
</li>
<li>
<p><strong>WebSocket</strong>: 是一种网络协议，属于应用层协议。它是在单个 TCP 连接上进行全双工通信的协议，设计用于浏览器和服务器之间的通信，用来解决 <strong>http 不支持持久化连接</strong>的问题。</p>
</li>
<li>
<p>Socket 一个是<strong>网络编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</p>
</li>
<li>
<p><strong>Socket</strong>工作在传输层，可以基于 TCP 或 UDP 协议。它需要开发者自己处理数据的发送和接收、连接的建立和断开等低层次的细节。</p>
</li>
<li>
<p><strong>WebSocket</strong>工作在应用层，<strong>依赖于 TCP 协议</strong>。<font color="red">WebSocket 在初次连接时通过 HTTP 请求进行握手，一旦连接建立，后续的数据传输都在 WebSocket 协议上进行</font>，浏览器和服务器都可以主动向对方发送数据，保持连接直到显式断开。</p>
</li>
<li>
<p><strong>Socket</strong>传输的是字节流，需要开发者自行定义数据的格式和协议。<strong>WebSocket</strong>传输的是文本帧或二进制帧，协议本身定义了消息的格式，能够直接发送 JSON 或二进制数据，方便开发者使用。</p>
</li>
</ul>
<h3 id="说一下你了解的端口及对应的服务" class="heading-element"><span>2.5 说一下你了解的端口及对应的服务？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e4%bd%a0%e4%ba%86%e8%a7%a3%e7%9a%84%e7%ab%af%e5%8f%a3%e5%8f%8a%e5%af%b9%e5%ba%94%e7%9a%84%e6%9c%8d%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th>端口</th>
<th style="text-align:center">服务</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td style="text-align:center">FTP(文件传输协议)</td>
<td style="text-align:center">用于在计算机之间传输文件</td>
</tr>
<tr>
<td>22</td>
<td style="text-align:center">SSH</td>
<td style="text-align:center">用于远程登录、文件传输和命令行界面交互</td>
</tr>
<tr>
<td>23</td>
<td style="text-align:center">Telnet(远程登录服务)</td>
<td style="text-align:center">允许用户从一台计算机登录到另一台计算机</td>
</tr>
<tr>
<td>53</td>
<td style="text-align:center">DNS域名解析服务</td>
<td style="text-align:center">将域名转换为IP地址以便访问网站</td>
</tr>
<tr>
<td>80</td>
<td style="text-align:center">HTTP超文本传输协议</td>
<td style="text-align:center">用于在万维网上交换信息</td>
</tr>
<tr>
<td>443</td>
<td style="text-align:center">HTTPS</td>
<td style="text-align:center">提供安全的HTTP通信</td>
</tr>
<tr>
<td>1080</td>
<td style="text-align:center">SOCKS</td>
<td style="text-align:center">用于在计算机之间安全地传输数据。它通过代理服务器来隐藏原始的IP地址和端口号，从而提供匿名性和安全性</td>
</tr>
<tr>
<td>3306</td>
<td style="text-align:center">MySQL默认端口号</td>
<td style="text-align:center">用于MySQL数据库服务器上的数据访问</td>
</tr>
</tbody>
</table>
<h2 id="http" class="heading-element"><span>3 HTTP</span>
  <a href="#http" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说-http-常用的状态码及其含义" class="heading-element"><span>3.1 说说 HTTP 常用的状态码及其含义？</span>
  <a href="#%e8%af%b4%e8%af%b4-http-%e5%b8%b8%e7%94%a8%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81%e5%8f%8a%e5%85%b6%e5%90%ab%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 响应状态码是由服务器返回给客户端，用于表示对请求的响应结果。</p>
<p>这些状态码分为五个不同的类别，每个类别用一个数字开头，共有三位数：</p>
<ul>
<li>1XX：<strong>信息性状态码</strong>，临时的响应，客户端应继续请求。</li>
<li>2XX：<strong>成功状态码</strong>，请求已成功被服务器接收。</li>
<li>3XX：<strong>重定向状态码</strong>，用来重定向。</li>
<li>4XX：<strong>客户端错误状态码</strong>，请求可能出错。</li>
<li>5XX：<strong>服务器错误状态码</strong>，服务器在尝试处理请求时发生了错误。</li>
</ul>
<p>常见HTTP状态码如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">101 <strong>Switching Protocols</strong></td>
<td style="text-align:center">切换请求协议</td>
</tr>
<tr>
<td style="text-align:center">200 <strong>OK</strong></td>
<td style="text-align:center">请求成功</td>
</tr>
<tr>
<td style="text-align:center">301 <strong>Moved Permanently</strong></td>
<td style="text-align:center">请求资源永久移动，返回新URI</td>
</tr>
<tr>
<td style="text-align:center">302 <strong>Found</strong></td>
<td style="text-align:center">请求资源临时移动，继续使用原有URI</td>
</tr>
<tr>
<td style="text-align:center">400 <strong>Bad Request</strong></td>
<td style="text-align:center">客户端请求的语法错误，服务端无法理解</td>
</tr>
<tr>
<td style="text-align:center">401 <strong>Unauthorized</strong></td>
<td style="text-align:center">当前请求需要认证</td>
</tr>
<tr>
<td style="text-align:center">403 <strong>Forbidden</strong></td>
<td style="text-align:center">服务器拒绝请求，客户端无权访问该资源</td>
</tr>
<tr>
<td style="text-align:center">404 <strong>Not Found</strong></td>
<td style="text-align:center">请求的资源在服务器上不存在</td>
</tr>
<tr>
<td style="text-align:center">500 <strong>Internal Server Error</strong></td>
<td style="text-align:center">服务器内部错误</td>
</tr>
</tbody>
</table>
<h3 id="http-有哪些请求方式" class="heading-element"><span>3.2 HTTP 有哪些请求方式？</span>
  <a href="#http-%e6%9c%89%e5%93%aa%e4%ba%9b%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 协议定义了多种请求方式，用以指示请求的目的。常见的请求方式有 GET、POST、DELETE、PUT。<font color="red">在正确实现的条件下，GET、HEAD、PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是</font>（每次发送 POST 请求，服务器可能会生成新的资源 ID 或处理生成的唯一值（如订单号、事务 ID）。因此，重复发送 POST 请求会导致创建多个不同的资源或多次执行某个操作）。</p>
<ul>
<li><strong>GET</strong>：请求检索指定的资源。应该只用于获取数据，并且是幂等的，即多次执行相同的 GET 请求应该返回相同的结果，并且不会改变资源的状态。</li>
<li><strong>POST</strong>：向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。可能会创建新的资源或修改现有资源。</li>
<li><strong>DELETE</strong>：删除指定的资源。</li>
<li><strong>PUT</strong>：用于替换指定的资源。如果指定的资源不存在，创建一个新资源。</li>
<li><strong>HEAD</strong>：类似于 GET 请求，但只请求响应头信息，不会返回响应体。常用于检查资源是否存在以及资源的元数据（如检查链接是否有效）。</li>
<li><strong>OPTIONS</strong>：请求服务器返回该资源所支持的所有 HTTP 方法。常用于检查服务器的功能或资源的通信选项。</li>
<li><strong>PATCH</strong>：用于对资源进行部分修改，而不是完全替代资源。</li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试和诊断。</li>
<li><strong>CONNECT</strong>：用于将请求连接转换为透明的 TCP/IP 隧道，通常用于 HTTPS 通过代理服务器的请求。</li>
</ul>
<h3 id="http-的-get-方法可以实现写操作吗" class="heading-element"><span>3.3 HTTP 的 GET 方法可以实现写操作吗?</span>
  <a href="#http-%e7%9a%84-get-%e6%96%b9%e6%b3%95%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e5%86%99%e6%93%8d%e4%bd%9c%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>严格来说，HTTP 的 GET 方法不应该用于实现写操作，因为它设计为一种安全的、幂等的读取操作。GET 请求的主要作用是从服务器获取资源，而不应对服务器上的数据进行任何修改。</p>
<p>但是，实际上，有些 Web 应用可能会滥用 GET 请求进行写操作，例如通过在 URL 中传递参数来修改服务器上的数据。这种做法是不推荐的，主要有以下几个原因：</p>
<ol>
<li><strong>安全性</strong>：GET 请求会将参数包含在 URL 中，这使得敏感数据容易暴露，且容易受到攻击（如 CSRF 攻击）。</li>
<li><strong>缓存问题</strong>：GET 请求通常会被缓存，而缓存的 GET 请求不应引发服务器状态的变化。如果 GET 请求用于写操作，可能会导致缓存的副作用。</li>
<li><strong>幂等性和安全性</strong>：HTTP 标准要求 GET 请求是幂等的（多次相同的请求应产生相同的结果）和安全的（不应对服务器状态产生副作用）。使用 GET 实现写操作违背了这些原则。</li>
</ol>
<h3 id="说一下-get-和-post-的区别" class="heading-element"><span>3.4 说一下 GET 和 POST 的区别？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b-get-%e5%92%8c-post-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p>从 HTTP 报文层面：</p>
<ul>
<li>
<p>GET 请求：将请求参数放在 URL 中，因此 URL 的长度有限制。数据在 URL 中传输，不安全，容易被窃取。</p>
</li>
<li>
<p>POST 请求：将请求参数放在请求体中，没有长度限制。数据在报文体中传输，相对更安全。</p>
</li>
</ul>
</li>
<li>
<p>从幂等性和安全性：</p>
<ul>
<li>
<p>GET 请求：</p>
<ul>
<li>幂等性：多次请求不会改变服务器状态，每次结果相同。</li>
<li>安全性：不会对服务器资源进行修改。</li>
</ul>
</li>
<li>
<p>POST 请求：</p>
<ul>
<li>
<p>不幂等：每次请求可能导致服务器状态变化（如创建资源）。</p>
</li>
<li>
<p>不安全：请求会对服务器资源进行修改。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>从其他层面：</p>
<ul>
<li>GET 请求：能够被缓存，减轻服务器负担。能够保存在浏览器的浏览记录里。URL 可以保存为浏览器书签。</li>
<li>POST 请求：<font color="red">不能被缓存，不保存在浏览器历史记录里</font>。URL 不便于保存为书签。</li>
</ul>
</li>
</ol>
<h3 id="get-的长度限制是多少" class="heading-element"><span>3.5 GET 的长度限制是多少？</span>
  <a href="#get-%e7%9a%84%e9%95%bf%e5%ba%a6%e9%99%90%e5%88%b6%e6%98%af%e5%a4%9a%e5%b0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 中的 GET 方法是通过 URL 传递数据的，<font color="red">但是 URL 本身其实并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器</font>。</p>
<p>例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。</p>
<p>这个长度限制也不是针对数据部分，而是针对整个 URL。</p>
<h3 id="http-请求的过程与原理" class="heading-element"><span>3.6 HTTP 请求的过程与原理？</span>
  <a href="#http-%e8%af%b7%e6%b1%82%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%8e%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 全称是超文本传输协议（HyperText Transfer Protocol），是一个基于请求与响应模式的应用层协议，基于 TCP/IP 协议传输数据。</p>
<p>HTTP 遵循标准的客户端-服务器模型，客户端打开连接以发出请求，然后等待它收到服务器端响应。</p>
<ul>
<li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li>
<li>服务器收到请求后，会根据请求的信息处理请求。</li>
<li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li>
<li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li>
</ul>
<p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。<font color="red">这个过程是同步的</font>，也就是说，客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</p>
<h3 id="说一下-http-的报文结构" class="heading-element"><span>3.7 说一下 HTTP 的报文结构？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b-http-%e7%9a%84%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 的报文结构可以分为两类：请求报文和响应报文。两者在结构上相似，都包含了<strong>起始行</strong>、<strong>头部</strong>和<strong>消息正文</strong>。</p>
<ul>
<li>
<p><strong>请求报文结构</strong></p>
<ol>
<li>
<p><strong>请求行 (Request Line)</strong></p>
<ul>
<li><strong>方法 (Method)</strong>：如 GET、POST、PUT、DELETE 等。</li>
<li><strong>请求目标 (Request-URI)</strong>：即请求的资源路径。</li>
<li><strong>HTTP 版本 (HTTP-Version)</strong>：如 HTTP/1.1。</li>
</ul>
</li>
<li>
<p><strong>请求头部 (Request Headers)</strong></p>
<ul>
<li>包含多个首部字段，每个字段由字段名和字段值组成。</li>
<li>用于提供客户端信息、请求的资源信息等。</li>
</ul>
<p><strong>常见请求头</strong>：</p>
<ul>
<li><code>Host</code>：请求的主机名和端口。</li>
<li><code>User-Agent</code>：发起请求的客户端信息。</li>
<li><code>Accept</code>：客户端可接受的响应内容类型。</li>
<li><code>Content-Type</code>：请求体的媒体类型。</li>
<li><code>Authorization</code>：认证信息。</li>
</ul>
</li>
<li>
<p><strong>空行</strong>：用于分隔请求头部和请求主体。</p>
</li>
<li>
<p><strong>请求主体 (Request Body)</strong>：包含实际要发送给服务器的数据，仅在 POST、PUT 等方法中存在。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="err">GET</span> <span class="err">/index.html</span> <span class="err">HTTP/1.1</span>
</span></span><span class="line"><span class="cl"><span class="nf">Host</span><span class="o">:</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
</span></span><span class="line"><span class="cl"><span class="nf">User-Agent</span><span class="o">:</span> <span class="n">Mozilla</span>/5.0
</span></span><span class="line"><span class="cl"><span class="nf">Accept</span><span class="o">:</span> <span class="n">text</span>/<span class="n">html</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>响应报文结构</strong></p>
<ol>
<li>
<p><strong>状态行 (Status Line)</strong></p>
<ul>
<li>
<p><strong>HTTP 版本 (HTTP-Version)</strong>：如 HTTP/1.1。</p>
</li>
<li>
<p><strong>状态码 (Status Code)</strong>：如 200、404、500 等。</p>
</li>
<li>
<p><strong>原因短语 (Reason-Phrase)</strong>：对状态码的简短描述。</p>
</li>
</ul>
</li>
<li>
<p><strong>响应头部 (Response Headers)</strong></p>
<ul>
<li>包含多个首部字段，每个字段由字段名和字段值组成。</li>
<li>用于提供服务器信息、响应的资源信息等。</li>
</ul>
<p><strong>常见响应头</strong>：</p>
<ul>
<li><code>Date</code>：响应生成的日期和时间。</li>
<li><code>Content-Type</code>：响应体的媒体类型。</li>
<li><code>Content-Length</code>：响应体的长度。</li>
<li><code>Set-Cookie</code>：设置 HTTP Cookie。</li>
</ul>
</li>
<li>
<p><strong>空行</strong>：用于分隔响应头部和响应主体。</p>
</li>
<li>
<p><strong>响应主体 (Response Body)</strong>：包含实际要返回给客户端的数据。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="err">HTTP/1.1</span> <span class="err">200</span> <span class="err">OK</span>
</span></span><span class="line"><span class="cl"><span class="nf">Date</span><span class="o">:</span> <span class="n">Mon</span><span class="p">,</span> 27 <span class="n">Jul</span> 2009 12:28:53 <span class="n">GMT</span>
</span></span><span class="line"><span class="cl"><span class="nf">Content-Type</span><span class="o">:</span> <span class="n">text</span>/<span class="n">html</span>
</span></span><span class="line"><span class="cl"><span class="nf">Content-Length</span><span class="o">:</span> 138
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">&lt;html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;body&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;h1&gt;Hello,</span> <span class="err">World!&lt;/h1&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;/body&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;/html&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="uri-和-url-有什么区别" class="heading-element"><span>3.8 URI 和 URL 有什么区别?</span>
  <a href="#uri-%e5%92%8c-url-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center"><strong>属性</strong></th>
<th style="text-align:center"><strong>URI</strong></th>
<th style="text-align:center"><strong>URL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>定义</strong></td>
<td style="text-align:center">统一资源标识符，用于标识一个资源</td>
<td style="text-align:center">统一资源定位符，提供资源的定位方法</td>
</tr>
<tr>
<td style="text-align:center"><strong>组成部分</strong></td>
<td style="text-align:center"><code>[scheme:][//authority][path][?query][#fragment]</code></td>
<td style="text-align:center"><code>scheme://authority/path[?query][#fragment]</code>（必须包含scheme（协议），authority（域名/IP），路径）</td>
</tr>
<tr>
<td style="text-align:center"><strong>例子</strong></td>
<td style="text-align:center"><code>urn:isbn:0451450523</code>（为URN，不是URL，但是URI）</td>
<td style="text-align:center"><code>https://www.example.com/index.html</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>子集</strong></td>
<td style="text-align:center">可以是 URL 或 URN</td>
<td style="text-align:center">是 URI 的子集</td>
</tr>
</tbody>
</table>
<h3 id="说下-http101120-的区别" class="heading-element"><span>3.9 说下 HTTP1.0，1.1，2.0 的区别？</span>
  <a href="#%e8%af%b4%e4%b8%8b-http101120-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><strong>HTTP1.0</strong> 默认短连接，HTTP 1.1 默认长连接，HTTP 2.0 采用<strong>多路复用</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>特性</strong></th>
<th style="text-align:center"><strong>HTTP/1.0</strong></th>
<th style="text-align:center"><strong>HTTP/1.1</strong></th>
<th style="text-align:center"><strong>HTTP/2.0</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>连接管理</strong></td>
<td style="text-align:center">短连接（默认每个请求/响应对后都关闭连接）</td>
<td style="text-align:center">长连接（默认 keep-alive）</td>
<td style="text-align:center">多路复用（同一连接多请求）</td>
</tr>
<tr>
<td style="text-align:center"><strong>Host 头部</strong></td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>缓存控制</strong></td>
<td style="text-align:center">简单的 Expires 头部</td>
<td style="text-align:center">复杂的 Cache-Control 头部</td>
<td style="text-align:center">同 HTTP/1.1</td>
</tr>
<tr>
<td style="text-align:center"><strong>传输编码</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">支持分块传输编码</td>
<td style="text-align:center">二进制分帧</td>
</tr>
<tr>
<td style="text-align:center"><strong>请求方法</strong></td>
<td style="text-align:center">GET, POST</td>
<td style="text-align:center">GET, POST, PUT, DELETE, OPTIONS 等</td>
<td style="text-align:center">同 HTTP/1.1</td>
</tr>
<tr>
<td style="text-align:center"><strong>头部压缩</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">HPACK 压缩（减少了冗余头部信息的带宽消耗）</td>
</tr>
<tr>
<td style="text-align:center"><strong>服务器推送</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center"><strong>流优先级</strong></td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">支持</td>
</tr>
</tbody>
</table>
<h3 id="http3-了解吗" class="heading-element"><span>3.10 HTTP/3 了解吗？</span>
  <a href="#http3-%e4%ba%86%e8%a7%a3%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP/2.0 基于 TCP 协议，而 HTTP/3.0 则基于 QUIC 协议，Quick UDP Connections，直译为快速 UDP 网络连接。</p>
<p>基于 TCP 的 HTTP/2.0，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输的过程中，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据。</p>
<p>而基于 UDP 的 QUIC 协议可以更彻底解决了 HTTP/2 中的队头阻塞问题，让不同的流之间真正的实现相互独立传输，互不干扰。同时，QUIC 协议在传输的过程中就完成了 TLS 加密握手，更直接了。</p>
<p>目前使用最广泛的是哪个HTTP版本还是是 HTTP/2，在 2022 年 1 月达到峰值，占所有网站的 46.9%。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=small" data-sub-html="<h2>w3techs：使用趋势</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png" alt="w3techs：使用趋势" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=large 2x" data-title="w3techs：使用趋势" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="http-如何实现长连接在什么时候会超时" class="heading-element"><span>3.11 HTTP 如何实现长连接？在什么时候会超时？</span>
  <a href="#http-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e8%b6%85%e6%97%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>什么是 HTTP 的长连接？</strong></p>
<ul>
<li>HTTP 分为长连接和短连接，<strong>本质上说的是 TCP 的长短连接</strong>。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法。</li>
<li>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</li>
</ul>
</blockquote>
<p>通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<code>keep-alive</code>，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p>
<p>在什么时候会超时呢？</p>
<ul>
<li>
<p>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，<strong>也可以在 HTTP 的 header 里面设置超时时间</strong></p>
</li>
<li>
<p>TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">tcp_keepalive_intvl = 15
</span></span><span class="line"><span class="cl">tcp_keepalive_probes = 5
</span></span><span class="line"><span class="cl">tcp_keepalive_time = 1800</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="说说-http-与-https-有哪些区别" class="heading-element"><span>3.12 说说 HTTP 与 HTTPS 有哪些区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-http-%e4%b8%8e-https-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>HTTPS 是 HTTP 的增强版，<font color="red">在 HTTP 的基础上加入了 SSL/TLS 协议，确保数据在传输过程中是加密的</font>。SSL/TLS 需要向 CA（证书权威机构）申请数字证书，用于验证服务器的身份。</li>
<li>HTTP 的默认端⼝号是 <strong>80</strong>，URL 以<code>http://</code>开头；HTTPS 的默认端⼝号是 <strong>443</strong>，URL 以<code>https://</code>开头。</li>
</ol>
<h3 id="为什么要用-https解决了哪些问题" class="heading-element"><span>3.13 为什么要用 HTTPS？解决了哪些问题？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-https%e8%a7%a3%e5%86%b3%e4%ba%86%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用 HTTPS 主要是为了解决 HTTP 传输过程中的一些安全问题，<font color="red">因为 HTTP 是明文传输，所以 HTTPS 在 HTTP 的基础上加入了 SSL/TLS 协议</font>。</p>
<p>HTTPS 主要解决了以下几个问题：</p>
<ul>
<li><strong>窃听风险</strong>：第三方可以截获传输的数据包，获取敏感信息。</li>
<li><strong>篡改风险</strong>：第三方可以在传输过程中篡改数据包，修改数据。</li>
<li><strong>冒充风险</strong>：第三方可以冒充服务器，与客户端通信。</li>
</ul>
<h3 id="https-工作流程是怎样的" class="heading-element"><span>3.14 HTTPS 工作流程是怎样的？</span>
  <a href="#https-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTPS 的连接建立在 SSL/TLS 握手之上，工作流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=small" data-sub-html="<h2>image-20240601233926542</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png" alt="image-20240601233926542" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=large 2x" data-title="image-20240601233926542" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。</p>
<p>HTTPS 在不同阶段会使用不同的加密方式：</p>
<ul>
<li>非对称加密：在握手阶段使用，特别是在密钥交换过程中。非对称加密使用公钥和私钥，其中公钥可以公开，私钥保密。客户端使用公钥加密信息，服务器使用私钥解密。</li>
<li>对称加密：在完成握手后，所有的数据传输都使用对称加密。对称加密使用相同的密钥进行加密和解密，这种加密方式比非对称加密更快。</li>
</ul>
<h3 id="https-会加密-url-吗" class="heading-element"><span>3.15 HTTPS 会加密 URL 吗？</span>
  <a href="#https-%e4%bc%9a%e5%8a%a0%e5%af%86-url-%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTPS 通过 SSL/TLS 协议确保了客户端与服务器之间交换的数据被加密，这包括 HTTP 头部和正文。而 URL 是 HTTP 头部的一部分，因此这部分信息也是加密的。但因为涉及到 SSL 握手的过程，所以域名信息会被暴露出来，需要注意。</p>
<h3 id="客户端怎么去校验证书的合法性" class="heading-element"><span>3.16 客户端怎么去校验证书的合法性？</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e6%80%8e%e4%b9%88%e5%8e%bb%e6%a0%a1%e9%aa%8c%e8%af%81%e4%b9%a6%e7%9a%84%e5%90%88%e6%b3%95%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>首先，所有的证书都是由 CA 机构签发的，CA 机构是一个受信任的第三方机构，它会对证书的申请者进行身份验证，然后签发证书，它具有极高的可信度。</p>
<p>客户端（通常是浏览器，通常会集成 CA 的公钥信息）在校验证书的合法性时，主要通过以下步骤来校验证书的合法性。</p>
<ul>
<li>浏览器会读取证书的所有者、有效期、颁发者等信息，先校验网站域名是否一致，然后校验证书的有效期是否过期；</li>
<li>浏览器开始查找内置的 CA，与服务器返回证书中的颁发者进行对比，确认是否为合法机构；</li>
<li>如果是，从内部植入的 CA 公钥解密 Certificate 的 Signature 内容，得到⼀个 Hash 值 H2；</li>
<li>使⽤同样的 Hash 算法获取证书的 Hash 值 H1，⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则告警。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=small" data-sub-html="<h2>三分恶面渣逆袭：证书签名和客户端校验-来源参考</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png" alt="三分恶面渣逆袭：证书签名和客户端校验-来源参考" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=large 2x" data-title="三分恶面渣逆袭：证书签名和客户端校验-来源参考" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="如何理解-http-协议是无状态的" class="heading-element"><span>3.17 如何理解 HTTP 协议是无状态的？</span>
  <a href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-http-%e5%8d%8f%e8%ae%ae%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这个<code>无状态</code>的的<code>状态</code>值的是什么？是客户端的状态，所以字面意思，就是 HTTP 协议中服务端不会保存客户端的任何信息。</p>
<p>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p>
<blockquote>
<p><strong>那有什么办法记录状态呢？</strong></p>
<p>主要有两个办法，Session 和 Cookie。</p>
</blockquote>
<h3 id="说说-session-和-cookie-有什么联系和区别" class="heading-element"><span>3.18 说说 Session 和 Cookie 有什么联系和区别?</span>
  <a href="#%e8%af%b4%e8%af%b4-session-%e5%92%8c-cookie-%e6%9c%89%e4%bb%80%e4%b9%88%e8%81%94%e7%b3%bb%e5%92%8c%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器（<font color="red">通过 HTTP 请求头的 <code>Cookie</code> 字段在客户端和服务器之间传递</font>）。服务端可以根据这个 Cookie 判断用户的身份和状态。Cookie可以设置过期时间。如果不设置过期时间，则 Cookie 在会话结束（浏览器关闭）时失效。可以通过设置 <code>Expires</code> 或 <code>Max-Age</code> 属性来定义 Cookie 的持久性。</li>
<li>Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。<font color="red">不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上（客户端只保存 Session ID）</font>。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。Session一般在用户会话结束时（例如关闭浏览器、超时）失效。服务器端可以配置 Session 的过期时间。</li>
</ul>
<p>Session 和 Cookie 联系：依赖于 Cookie 来传递 Session ID（通常是服务器在创建 Session 时设置一个 Cookie 来存储 Session ID）。</p>
<p>Session 和 Cookie 的使用场景也不同：</p>
<ul>
<li><strong>Cookie</strong>：适用于存储用户偏好、登录状态等较小的数据，可以跨页面持久化数据。<font color="red">常用于记录用户信息、跟踪用户行为等</font>。</li>
<li><strong>Session</strong>：适用于存储用户会话中的临时信息，如购物车、登录状态等。<font color="red">更适合需要较高安全性的场景，因为数据存储在服务器端</font>。</li>
</ul>
<blockquote>
<p><strong>分布式环境下 Session 怎么处理呢？</strong></p>
<p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。</p>
<p>可以使用 Redis 等分布式缓存来存储 Session，在多台服务器之间共享。</p>
</blockquote>
<blockquote>
<p><strong>客户端无法使用 Cookie 怎么办？</strong></p>
<p>有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。</p>
<p>这时候怎么办？SessionID 怎么存？怎么传给服务端呢？首先是 SessionID 的存储，可以使用客户端的本地存储，比如浏览器的 sessionStorage。</p>
<p>接下来怎么传呢？</p>
<ul>
<li>拼接到 URL 里：直接把 SessionID 作为 URL 的请求参数</li>
<li>放到请求头里：把 SessionID 放到请求的 Header 里，比较常用。</li>
</ul>
</blockquote>
<h2 id="tcp" class="heading-element"><span>4 TCP</span>
  <a href="#tcp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="详细说一下-tcp-的三次握手机制" class="heading-element"><span>4.1 详细说一下 TCP 的三次握手机制？</span>
  <a href="#%e8%af%a6%e7%bb%86%e8%af%b4%e4%b8%80%e4%b8%8b-tcp-%e7%9a%84%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP（Transmission Control Protocol）是一个<font color="red">面向连接的、可靠的、基于字节流的传输层协议</font>。TCP 通过三次握手机制来建立连接，确保双方准备就绪并能可靠地进行通信。以下是三次握手的详细过程：</p>
<ol start="11">
<li>
<p>第一次握手</p>
<ul>
<li><strong>客户端</strong>：发送一个带有 SYN 标志的 TCP 报文段（称为 SYN 报文段），并选择一个初始序列号 <code>seq = x</code>。</li>
<li><strong>服务器</strong>：收到这个 SYN 报文段后，服务器处于 “SYN_RCVD” 状态。</li>
<li><strong>目的</strong>：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。</li>
</ul>
<p><strong>报文内容</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">客户端 --&gt; 服务器: SYN, <span class="nv">seq</span> <span class="o">=</span> x</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第二次握手</p>
<ul>
<li><strong>服务器</strong>：服务器收到 SYN 报文段后，回复一个带有 SYN 和 ACK 标志的 TCP 报文段（称为 SYN-ACK 报文段）。该报文段中包含服务器选择的初始序列号 <code>seq = y</code>，以及对客户端序列号 <code>x</code> 的确认 <code>ack = x + 1</code>。</li>
<li><strong>客户端</strong>：收到这个 SYN-ACK 报文段后，客户端处于 “ESTABLISHED” 状态。</li>
<li><strong>目的</strong>：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。</li>
</ul>
<p>报文内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">服务器 --&gt; 客户端: SYN, ACK, <span class="nv">seq</span> <span class="o">=</span> y, <span class="nv">ack</span> <span class="o">=</span> x + <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第三次握手</p>
<ul>
<li><strong>客户端</strong>：客户端收到 SYN-ACK 报文段后，回复一个带有 ACK 标志的 TCP 报文段（称为 ACK 报文段）。该报文段中包含对服务器序列号 <code>y</code> 的确认 <code>ack = y + 1</code>。</li>
<li><strong>服务器</strong>：收到这个 ACK 报文段后，服务器处于 “ESTABLISHED” 状态，连接建立完成。</li>
<li><strong>目的</strong>：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。</li>
</ul>
<p><strong>报文内容</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">客户端 --&gt; 服务器: ACK, <span class="nv">seq</span> <span class="o">=</span> x + 1, <span class="nv">ack</span> <span class="o">=</span> y + <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP三次握手.png" alt="image-20240602101211701" style="zoom: 33%;" />
<h3 id="tcp-握手为什么是三次为什么不能是两次不能是四次" class="heading-element"><span>4.2 TCP 握手为什么是三次，为什么不能是两次？不能是四次？</span>
  <a href="#tcp-%e6%8f%a1%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e6%ac%a1%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e6%98%af%e4%b8%a4%e6%ac%a1%e4%b8%8d%e8%83%bd%e6%98%af%e5%9b%9b%e6%ac%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用三次握手可以建立一个可靠的连接。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。</p>
<p>两次握手无法确保连接的可靠性。具体原因如下：</p>
<ol>
<li><strong>旧的重复报文干扰</strong>：在两次握手情况下，旧的 SYN 报文可能会被错误地当作新的连接请求。如果服务器发送 SYN-ACK 报文后客户端没有响应，服务器会认为连接失败，但实际上客户端可能已经收到了 SYN-ACK 报文，这样就会导致服务器资源浪费和连接不一致。</li>
<li><strong>确认机制不完整</strong>：两次握手不能保证双方都能正确接收到对方的确认报文。服务器无法确认客户端是否收到了自己的 SYN-ACK 报文，而客户端也无法确认服务器是否收到了自己的 SYN 报文。</li>
</ol>
<p>四次握手在正常情况下是多余的，会增加连接建立的复杂性和开销。三次握手已经足够保证连接的可靠性和正确性：</p>
<ol>
<li><strong>增加复杂性和开销</strong>：四次握手会增加额外的一个报文传输，使得连接建立的过程变得复杂，不必要地增加了传输的延迟和开销。</li>
<li><strong>三次握手足够可靠</strong>：三次握手已经可以确保双方都能确认连接的建立，并且可以避免旧的重复报文的干扰，再增加一次握手并不会带来额外的安全性或可靠性提升。</li>
</ol>
<h3 id="三次握手中每一次没收到报文会发生什么情况" class="heading-element"><span>4.3 三次握手中每一次没收到报文会发生什么情况？</span>
  <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%ad%e6%af%8f%e4%b8%80%e6%ac%a1%e6%b2%a1%e6%94%b6%e5%88%b0%e6%8a%a5%e6%96%87%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在TCP三次握手的过程中，每一次没收到报文都会触发重传机制，并最终导致连接建立失败。具体情况如下：</p>
<ol>
<li>
<p>第一次握手：客户端发送 SYN 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果客户端发送的 SYN 报文没有收到服务器的 SYN-ACK 报文（比如报文丢失或服务器没有响应）。</p>
</li>
<li>
<p><strong>处理</strong>：客户端会进行超时重传。客户端在发送 SYN 报文后会启动一个定时器，如果在一定时间内没有收到服务器的响应（SYN-ACK 报文），客户端会重传 SYN 报文。</p>
</li>
<li>
<p><strong>结果</strong>：重传次数达到一定次数（通常是三次）后，客户端会放弃连接，报错并关闭连接请求。</p>
</li>
</ul>
</li>
<li>
<p>第二次握手：服务器发送 SYN-ACK 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果服务器发送的 SYN-ACK 报文没有收到客户端的 ACK 报文（比如报文丢失或客户端没有响应）。</p>
</li>
<li>
<p><strong>处理</strong>：服务器会进行超时重传。服务器在发送 SYN-ACK 报文后也会启动一个定时器，如果在一定时间内没有收到客户端的 ACK 报文，服务器会重传 SYN-ACK 报文。</p>
</li>
<li>
<p><strong>结果</strong>：重传次数达到一定次数后，服务器会放弃连接，报错并关闭连接请求。</p>
</li>
</ul>
</li>
<li>
<p>第三次握手：客户端发送 ACK 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果客户端发送的 ACK 报文没有收到服务器的确认（ACK 报文本身一般不会单独确认，但此处假设服务器未能进入 ESTABLISHED 状态）。</p>
</li>
<li>
<p><strong>处理</strong>：服务器会因为没有收到 ACK 报文而保持在 SYN-RECEIVED 状态，并可能最终超时并关闭连接。</p>
</li>
<li>
<p><strong>结果</strong>：客户端会认为连接已经建立，并进入 ESTABLISHED 状态，但如果服务器超时关闭连接，客户端在尝试发送数据时会发现连接无法使用，从而报错并关闭连接。</p>
</li>
</ul>
</li>
</ol>
<h3 id="第二次握手传回了-ack为什么还要传回-syn" class="heading-element"><span>4.4 第二次握手传回了 ACK，为什么还要传回 SYN？</span>
  <a href="#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bc%a0%e5%9b%9e%e4%ba%86-ack%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%a6%81%e4%bc%a0%e5%9b%9e-syn" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ACK 标志是为了告诉客户端，它发送的 SYN 报文已经被服务器正确接收。</p>
<p>而传回 SYN 是为了告诉客户端，服务器也希望建立连接，并且响应的确实是客户端发送的报文。</p>
<h3 id="第-3-次握手可以携带数据吗" class="heading-element"><span>4.5 第 3 次握手可以携带数据吗？</span>
  <a href="#%e7%ac%ac-3-%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%8f%af%e4%bb%a5%e6%90%ba%e5%b8%a6%e6%95%b0%e6%8d%ae%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>第 3 次握手是可以携带数据的。此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>
<p>但实际应用中通常不会携带数据，因为在第三次握手中发送数据可能会引发安全和可靠性问题。此时连接还未完全建立，发送数据可能导致数据丢失或安全漏洞。</p>
<p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p>
<h3 id="说说半连接队列和-syn-flood-攻击的关系" class="heading-element"><span>4.6 说说半连接队列和 SYN Flood 攻击的关系？</span>
  <a href="#%e8%af%b4%e8%af%b4%e5%8d%8a%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97%e5%92%8c-syn-flood-%e6%94%bb%e5%87%bb%e7%9a%84%e5%85%b3%e7%b3%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p>半连接队列（Half-Open Connection Queue）是指在 TCP 三次握手过程中，服务器在收到客户端的 SYN 报文后，返回 SYN-ACK 报文并等待客户端的 ACK 报文确认连接的这段时间内，服务器为每个未完成的连接分配的资源队列。</p>
<p><font color="red">SYN Flood 攻击是指攻击者发送大量的 SYN 报文请求与服务器建立连接，但在服务器返回 SYN-ACK 报文后，攻击者不发送最终的 ACK 报文完成握手</font>。这样，服务器的半连接队列会被大量未完成的连接占满，导致服务器资源耗尽，无法处理正常的连接请求，进而造成拒绝服务（Denial of Service，DoS）。</p>
<p>因此，SYN Flood 攻击的核心在于利用半连接队列的有限资源，通过大量伪造的连接请求使服务器无法处理合法用户的连接。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SYN_Flood_Example.png" alt="2fad1ef85054585e10ddeed7a3346a26" style="zoom:50%;" />
<blockquote>
<p><strong>那有什么应对方案呢？</strong></p>
<p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p>
<ul>
<li><strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li>
<li><strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li>
<li><strong>缩短 SYN-ACK 超时时间</strong>：调整系统的 SYN-ACK 超时时间，使未完成的连接请求能够更快地被清理出队列。</li>
<li><strong>分布式拒绝服务防护（DDoS Protection Services）</strong>：使用专业的 DDoS 防护服务，如 Cloudflare、Akamai 等，这些服务可以在网络边缘过滤恶意流量，减轻服务器的压力。</li>
</ul>
</blockquote>
<h3 id="说说-tcp-四次挥手的过程" class="heading-element"><span>4.7 说说 TCP 四次挥手的过程？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e7%9a%84%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 四次挥手是指 TCP 连接终止时所进行的四个步骤，数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起（通常是客户端），具体过程如下：</p>
<ol>
<li><strong>第一次挥手：FIN 报文</strong>：
<ul>
<li>客户端发送一个 FIN 报文段，表明它已经完成了数据发送，请求关闭连接。客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>报文段格式：<code>FIN=1, seq=x</code>。</li>
</ul>
</li>
<li><strong>第二次挥手：ACK 报文</strong>：
<ul>
<li>服务器接收到 FIN 报文后，返回一个 ACK 报文段，确认收到了关闭请求。发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li>报文段格式：<code>ACK=1, ack=x+1</code>。</li>
<li>此时，服务器可能还需要继续发送数据，因此连接处于半关闭状态。</li>
</ul>
</li>
<li><strong>第三次挥手：FIN 报文</strong>：
<ul>
<li>服务端在完成数据发送后，发送一个 FIN 报文段，表明它也已经完成了数据发送，请求关闭连接。发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li>
<li>报文段格式：<code>FIN=1, seq=y</code>。</li>
</ul>
</li>
<li><strong>第四次挥手：ACK 报文</strong>：
<ul>
<li>客户端接收到 FIN 报文后，返回一个 ACK 报文段，确认收到了关闭请求，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
<li>报文段格式：<code>ACK=1, ack=y+1</code>。</li>
<li>此时，连接正式关闭，双方都完成了连接的释放。</li>
</ul>
</li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP_Close_Example.png" alt="image-20240602130755941" style="zoom: 67%;" />
<h3 id="tcp-挥手为什么需要四次呢" class="heading-element"><span>4.8 TCP 挥手为什么需要四次呢？。</span>
  <a href="#tcp-%e6%8c%a5%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%9b%9b%e6%ac%a1%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h3 id="tcp-四次挥手过程中为什么需要等待-2msl-才进入-closed-关闭状态" class="heading-element"><span>4.9 TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</span>
  <a href="#tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%ad%89%e5%be%85-2msl-%e6%89%8d%e8%bf%9b%e5%85%a5-closed-%e5%85%b3%e9%97%ad%e7%8a%b6%e6%80%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN</strong> 报文段的确认。服务端会超时重传这个 <strong>FIN</strong> 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<blockquote>
<p><strong>为什么等待的时间是 2MSL？</strong></p>
<p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>
</blockquote>
<h3 id="保活计时器有什么用" class="heading-element"><span>4.10 保活计时器有什么用？</span>
  <a href="#%e4%bf%9d%e6%b4%bb%e8%ae%a1%e6%97%b6%e5%99%a8%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer），用于在长时间闲置的 TCP 连接中检测对端是否仍然存活，<strong>并防止连接因为长时间没有活动而被认为是不活跃的而被关闭</strong>。</p>
<p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="close-wait-和-time-wait-的状态和意义" class="heading-element"><span>4.11 <code>CLOSE-WAIT</code> 和 <code>TIME-WAIT</code> 的状态和意义？</span>
  <a href="#close-wait-%e5%92%8c-time-wait-%e7%9a%84%e7%8a%b6%e6%80%81%e5%92%8c%e6%84%8f%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>CLOSE-WAIT 状态有什么意义？</strong></p>
</blockquote>
<p>服务端收到客户端关闭连接的请求并确认之后，就会进入 CLOSE-WAIT 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而<font color="red"> CLOSE-WAIT 状态就是为了保证服务端在关闭连接之前将待发送的数据处理完</font>。</p>
<blockquote>
<p><strong>TIME-WAIT 有什么意义？</strong></p>
</blockquote>
<p>TIME-WAIT 状态发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入 TIME-WAIT 状态。</p>
<ul>
<li><strong>防⽌旧连接的数据包</strong></li>
<li><strong>保证连接正确关闭</strong></li>
</ul>
<h3 id="time_wait-状态过多会导致什么问题怎么解决" class="heading-element"><span>4.12 <code>TIME_WAIT</code> 状态过多会导致什么问题？怎么解决？</span>
  <a href="#time_wait-%e7%8a%b6%e6%80%81%e8%bf%87%e5%a4%9a%e4%bc%9a%e5%af%bc%e8%87%b4%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>TIME_WAIT 状态过多会导致什么问题?</strong></p>
</blockquote>
<p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p>
<blockquote>
<p><strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>HTTP 没有使用长连接</li>
<li>HTTP 长连接超时</li>
<li>HTTP 长连接的请求数量达到上限</li>
</ul>
</blockquote>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ol>
<li><strong>端口资源耗尽</strong>：每个处于 <code>TIME_WAIT</code> 状态的连接都会占用一个本地端口。如果 <code>TIME_WAIT</code> 状态的连接过多，可能会导致可用的本地端口资源耗尽，新的连接请求无法分配端口，从而导致服务不可用。</li>
<li><strong>内存和资源占用</strong>：<code>TIME_WAIT</code> 状态的连接会占用一定的系统内存和资源。如果连接过多，会导致系统资源被大量占用，影响服务器的性能和其他应用的运行。</li>
</ol>
<blockquote>
<p><strong>怎么解决 TIME_WAIT 状态过多？</strong></p>
</blockquote>
<ul>
<li>服务器可以设置 <code>SO_REUSEADDR</code> 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li>
<li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li>
</ul>
<h3 id="说说-tcp-报文头部的格式" class="heading-element"><span>4.13 说说 TCP 报文头部的格式？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e6%8a%a5%e6%96%87%e5%a4%b4%e9%83%a8%e7%9a%84%e6%a0%bc%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 TCP 报文段主要由报文段头部（Header）和数据两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mathematica" data-lang="mathematica"><span class="line"><span class="cl"><span class="w">  </span><span class="mi">0</span><span class="w">                   </span><span class="mi">1</span><span class="w">                   </span><span class="mi">2</span><span class="w">                   </span><span class="mi">3</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">          </span><span class="n">Source</span><span class="w"> </span><span class="n">Port</span><span class="w">          </span><span class="o">|</span><span class="w">       </span><span class="n">Destination</span><span class="w"> </span><span class="n">Port</span><span class="w">        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                        </span><span class="n">Sequence</span><span class="w"> </span><span class="n">Number</span><span class="w">                        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                    </span><span class="n">Acknowledgment</span><span class="w"> </span><span class="n">Number</span><span class="w">                      </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">Data</span><span class="w"> </span><span class="o">|</span><span class="n">Reser</span><span class="o">-|</span><span class="w">       </span><span class="n">Flags</span><span class="w">     </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Offset</span><span class="o">|</span><span class="n">ved</span><span class="w">   </span><span class="o">|</span><span class="w">       </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="o">|</span><span class="w">        </span><span class="n">Window</span><span class="w">                </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="p">(</span><span class="mi">4</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w">   </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">bits</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">       </span><span class="n">Checksum</span><span class="w">                </span><span class="o">|</span><span class="w">     </span><span class="n">Urgent</span><span class="w"> </span><span class="n">Pointer</span><span class="w">            </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                       </span><span class="n">Options</span><span class="w"> </span><span class="p">(</span><span class="n">if</span><span class="w"> </span><span class="n">any</span><span class="p">)</span><span class="w">                        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                                                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                        </span><span class="n">data</span><span class="w">                                   </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                                                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>源端口号</strong>（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。</li>
<li><strong>目标端口号</strong>（Destination Port）：也是 16 位，用于标识接收端的应用程序。</li>
<li><strong>序列号</strong>（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。</li>
<li><strong>确认号</strong>（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。</li>
<li><strong>数据偏移</strong>（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。</li>
<li><strong>保留</strong>（Reserved）：6 位，为将来使用预留，目前必须置为 0。</li>
<li><strong>控制位</strong>（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。</li>
<li><strong>窗口大小</strong>（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。</li>
<li><strong>校验和</strong>（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。</li>
<li><strong>紧急指针</strong>（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP_Data_Format_Example.png" alt="1f7ade5afa610376a72553a7d32f622c" style="zoom:50%;" />
<h3 id="tcp-是如何保证可靠性的" class="heading-element"><span>4.14 TCP 是如何保证可靠性的？</span>
  <a href="#tcp-%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e6%80%a7%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP（传输控制协议）通过多种机制来确保数据传输的可靠性。以下是TCP保证可靠性的主要方法：</p>
<ol>
<li><strong>连接管理（Connection Management）</strong>：TCP 使用三次握手（Three-Way Handshake）建立连接和四次挥手（Four-Way Handshake）关闭连接，确保连接的建立和释放过程可靠、无误。</li>
<li><strong>校验和（Checksum）</strong>：TCP 报文段包含一个校验和字段，用于验证报文段在传输过程中是否被损坏。发送方计算并填充校验和，接收方根据接收到的数据重新计算校验和并进行验证，确保数据的完整性。</li>
<li><strong>序列号（Sequence Numbers）</strong>：TCP 为每个字节分配一个序列号。发送方和接收方使用序列号来确保数据按照正确的顺序接收并重组，防止数据丢失或重复。</li>
<li><strong>确认应答（Acknowledgments, ACKs）</strong>：TCP 使用确认应答机制来确认数据的接收。接收方在收到数据后，会发送一个带有确认号的ACK报文段，告知发送方已成功接收到的数据。<strong>这种机制确保了数据的传递和确认</strong>。</li>
<li><strong>拥塞控制（Congestion Control）</strong>：TCP 通过慢启动、拥塞避免、快重传和快恢复等算法来防止网络拥塞，保证数据传输的稳定性和可靠性。</li>
<li><strong>流量控制（Flow Control）</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</li>
<li><strong>重传机制（Retransmission）</strong>：发送方在发送数据后会启动一个计时器。如果在指定时间内未收到对应的ACK报文段，发送方会认为该数据包丢失并进行重传。TCP还使用快速重传机制，当收到三个重复的ACK时，立即重传相应的数据包。</li>
<li><strong>最大消息长度（Maximum Message Length）</strong>：在建立 TCP 连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</li>
</ol>
<h3 id="说说-tcp-的流量控制" class="heading-element"><span>4.15 说说 TCP 的流量控制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，以确保接收方能够及时处理数据而不会因为数据过多而溢出缓冲区，这就是<strong>流量控制</strong>。</p>
<p>TCP 的流量控制主要通过滑动窗口（Sliding Window）机制来实现。示例如下：</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Flow_Control_Example_1.png" alt="97365f7a32a87ad913ceca13f1325e10_720" style="zoom:50%;" />
<h3 id="详细说说-tcp-的滑动窗口" class="heading-element"><span>4.16 详细说说 TCP 的滑动窗口？</span>
  <a href="#%e8%af%a6%e7%bb%86%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。而滑动窗口允许发送方在未接收到 ACK 确认之前可以发送多个数据段，以提高网络的利用率和传输效率，同时避免了发送方过度发送导致接收方缓冲区溢出。</p>
<p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>
<ul>
<li>已发送且已收到 ACK 确认</li>
<li>已发送但未收到 ACK 确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=small" data-sub-html="<h2>18481a6fdea7f130edac0e46840cc015_720</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png" alt="18481a6fdea7f130edac0e46840cc015_720" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=large 2x" data-title="18481a6fdea7f130edac0e46840cc015_720" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>蓝色框里就是发送窗口。SND.WND 表示发送窗口的大小，SND.NXT表示下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号；SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</p>
<p>接收方的滑动窗口包含三大部分，如下：</p>
<ul>
<li>已成功接收并确认</li>
<li>未收到数据但可以接收</li>
<li>未收到数据并不可以接收的数据</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=small" data-sub-html="<h2>154b2bfeb394bbae15f76d48be668ca6_720</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png" alt="154b2bfeb394bbae15f76d48be668ca6_720" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=large 2x" data-title="154b2bfeb394bbae15f76d48be668ca6_720" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>蓝色框内，就是接收窗口。REV.WND 表示接收窗口的大小；REV.NXT表示下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</p>
<p>发送方和接收方通过 ACK 确认报文段来协商窗口大小。发送方根据接收方的接收窗口大小来调整自己的发送窗口大小，以确保不会发送超出接收方能力的数据量。</p>
<h3 id="了解-nagle-算法和延迟确认吗" class="heading-element"><span>4.17 了解 Nagle 算法和延迟确认吗？</span>
  <a href="#%e4%ba%86%e8%a7%a3-nagle-%e7%ae%97%e6%b3%95%e5%92%8c%e5%bb%b6%e8%bf%9f%e7%a1%ae%e8%ae%a4%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>Nagle 算法和延迟确认是干什么的？</strong></p>
</blockquote>
<p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p>
<p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p>
<ul>
<li><strong>Nagle 算法</strong>：当应用程序发送数据时，Nagle 算法会先将数据放入缓冲区，并等待一定的时间（称为 Nagle 算法定时器），<strong>以便将多个小数据包合并成一个大数据包一起发送</strong>。只有当缓冲区中的数据量达到一定阈值（Nagle 算法的最小传输单元）或者定时器超时时，才会触发数据的发送。<font color="red">Nagle 算法主要用于避免发送大量小数据包的情况，从而减少网络的拥塞，提高网络的性能和效率</font>。</li>
<li><strong>延迟确认</strong>：当接收方收到数据时，不会立即发送 ACK 确认报文，而是等待一段时间（一般是等待 200 毫秒左右），以便将多个 ACK 合并成一个 ACK 一起发送。如果在延迟时间内收到新的数据包，则会立即发送 ACK 报文，以确认收到的数据。<font color="red">延迟确认主要用于减少确认报文的数量，避免网络中出现过多的 ACK 报文，从而减少网络的负载和提高网络的吞吐量</font>。</li>
</ul>
<p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p>
<h3 id="说说-tcp-的拥塞控制" class="heading-element"><span>4.18 说说 TCP 的拥塞控制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>什么是拥塞控制？不是有了流量控制吗？</strong></p>
</blockquote>
<p>前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。</p>
<p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤&hellip;.</p>
<p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p>
<p>于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p>
<p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，调节所要发送数据的量。</p>
<blockquote>
<p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong></p>
</blockquote>
<p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p>
<p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
<p>拥塞窗⼝ cwnd 变化的规则：</p>
<ul>
<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>但⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<blockquote>
<p><strong>拥塞控制有哪些常用算法？</strong></p>
</blockquote>
<p>拥塞控制主要有这几种常用算法：</p>
<ul>
<li><strong>慢启动</strong>：先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据）</li>
<li><strong>拥塞避免</strong>：在拥塞避免阶段，TCP的拥塞窗口以线性增长的方式增加，而不是指数级增长</li>
<li><strong>快重传</strong>：发送方不必等待超时计时器的到期，而是立即进行快速重传，重传丢失的数据包</li>
<li><strong>快恢复</strong>：快恢复算法用于在收到重复ACK时，迅速调整拥塞窗口大小以恢复传输速度</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Congestion_Control_Example_1.png" alt="f2bf90ccdfa385562fd6f475cc4f692f_720" style="zoom:50%;" />
<h3 id="说说-tcp-的重传机制" class="heading-element"><span>4.19 说说 TCP 的重传机制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 的重传机制是确保数据传输可靠性的重要部分之一。它通过在发送方定时器超时或者接收到连续的重复确认时触发，重新发送丢失或者未确认的数据段，以确保数据能够在网络中正确传输。以下是 TCP 的重传机制的主要原理：</p>
<ol>
<li><strong>超时重传</strong>：当发送方发送数据后，在等待一定时间内未收到确认 ACK 报文时，触发超时重传机制，重新发送未确认的数据段。超时时间通常根据网络往返时间（RTT）动态调整，以适应网络延迟的变化。</li>
<li><strong>快速重传</strong>：当发送方接收到连续的重复 ACK 报文时，表明接收方已经成功接收了一些数据，但有一个或多个数据段丢失。<font color="red">为了尽快重传丢失的数据段，发送方立即触发快速重传机制，重新发送丢失的数据段，而不必等待超时定时器的到期</font>。</li>
<li><strong>带选择确认的重传（SACK）</strong>：选择确认（SACK）为了解决应该重传多少个包的问题，允许接收方在确认报文中指示出连续的数据段中哪些已经成功接收，哪些丢失了。发送方可以根据 SACK 报文中指示的丢失数据段信息，选择性地进行重传，而不是重传整个窗口内的所有未确认数据段。</li>
<li><strong>重复 SACK</strong>：是在 SACK 的基础上做了一些扩展，在接收方收到连续的重复数据段时，会生成多个相同的 SACK 报文，用于指示哪些数据段已经成功接收。主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</li>
</ol>
<h3 id="说说-tcp-的粘包和拆包" class="heading-element"><span>4.20 说说 TCP 的粘包和拆包？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e7%b2%98%e5%8c%85%e5%92%8c%e6%8b%86%e5%8c%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分。</p>
<p><strong>粘包</strong>指的是在 TCP 连接中，发送方发送的多个数据包在接收方接收时被合并成一个数据包。这种情况通常发生在以下几种场景中：</p>
<ol>
<li>发送方发送数据过于频繁，发送的数据量较小，多个小数据包在发送时被合并成一个数据包。Nagle 算法的作用使得发送方在网络未确认前将小数据包合并发送。</li>
<li>接收方读取数据不及时，一次性读取多个数据包。</li>
</ol>
<p><strong>拆包</strong>指的是一个完整的数据包在接收方接收时被拆分成了多个数据包。这种情况通常发生在以下几种场景中：</p>
<ol>
<li>网络传输过程中，由于 MTU（最大传输单元）的限制，一个大的数据包被拆分成多个小的数据包进行传输。</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ol>
<blockquote>
<p><strong>那怎么解决呢？</strong></p>
</blockquote>
<ul>
<li>发送端将每个数据包封装为固定长度；</li>
<li>在数据尾部增加特殊字符进行分割；</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小；</li>
<li>设计特定的应用层协议，包含数据包头部（例如，标识符、长度字段、校验和等）和数据部分。接收方根据协议解析数据包。</li>
</ul>
<h3 id="如果已经建立了连接但是服务端的进程崩溃会发生什么服务器断电呢" class="heading-element"><span>4.21 如果已经建立了连接，但是服务端的进程崩溃会发生什么？服务器断电呢？</span>
  <a href="#%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%e4%bd%86%e6%98%af%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%b4%a9%e6%ba%83%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%96%ad%e7%94%b5%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<p>当服务器断电时，情况会有所不同：客户端在尝试与服务器通信时，会发现连接中断，通常会收到一个错误（如 <code>ECONNRESET</code> 或 <code>ETIMEDOUT</code>），客户端的应用程序需要处理这个错误，并可能尝试重新建立连接或采取其他应对措施。</p>
<h3 id="如果已经建立了连接但是客户端突然出现故障了怎么办" class="heading-element"><span>4.22 如果已经建立了连接，但是客户端突然出现故障了怎么办？</span>
  <a href="#%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%e4%bd%86%e6%98%af%e5%ae%a2%e6%88%b7%e7%ab%af%e7%aa%81%e7%84%b6%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h3 id="服务器出现大量-close_wait-状态的原因有哪些" class="heading-element"><span>4.23 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span>
  <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f-close_wait-%e7%8a%b6%e6%80%81%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%9c%89%e5%93%aa%e4%ba%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CLOSE_WAIT 状态是【被动关闭方】才会有的状态，而且如果【被动关闭方】没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因是：2，3，4，6步没有做</p>
<h2 id="udp" class="heading-element"><span>5 UDP</span>
  <a href="#udp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说-tcp-和-udp-的区别" class="heading-element"><span>5.1 说说 TCP 和 UDP 的区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e5%92%8c-udp-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">TCP</th>
<th style="text-align:center">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">连接</td>
<td style="text-align:center">面向连接，传输数据前需建立连接</td>
<td style="text-align:center">无需连接，立即传输数据</td>
</tr>
<tr>
<td style="text-align:center">服务对象</td>
<td style="text-align:center">一对一的两点服务</td>
<td style="text-align:center">支持一对一、一对多、多对多的交互通信</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">可靠交付，数据无差错、不丢失、不重复、按序到达</td>
<td style="text-align:center">尽最大努力交付，不保证可靠交付数据</td>
</tr>
<tr>
<td style="text-align:center">拥塞控制、流量控制</td>
<td style="text-align:center">有拥塞控制和流量控制机制</td>
<td style="text-align:center">无拥塞控制和流量控制机制，发送速率不受网络拥堵影响</td>
</tr>
<tr>
<td style="text-align:center">首部开销</td>
<td style="text-align:center">首部长度较长（20 字节—60字节）</td>
<td style="text-align:center">首部只有 8 字节，且固定不变，开销较小</td>
</tr>
<tr>
<td style="text-align:center">传输方式</td>
<td style="text-align:center">字节流式传输，无边界，保证顺序和可靠</td>
<td style="text-align:center">数据段报文传输，有边界，可能丢包和乱序</td>
</tr>
<tr>
<td style="text-align:center">分片</td>
<td style="text-align:center">在传输层进行分片，丢失分片时只重传丢失部分</td>
<td style="text-align:center">在 IP 层进行分片，接收后在 IP 层组装再传给传输层</td>
</tr>
<tr>
<td style="text-align:center">应用场景</td>
<td style="text-align:center">文件传输、邮件传输</td>
<td style="text-align:center">即时通讯、域名转换</td>
</tr>
</tbody>
</table>
<h3 id="为什么-qq-采用-udp-协议" class="heading-element"><span>5.2 为什么 QQ 采用 UDP 协议？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-qq-%e9%87%87%e7%94%a8-udp-%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>首先，QQ 并不是完全基于 UDP 实现。<font color="red">比如在使用 QQ 进行文件传输等活动的时候，就会使用 TCP 作为可靠传输的保证</font>。</li>
<li>使用 UDP 进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP 是一个全双工协议，需要建立连接，所以网络开销也会相对大。</li>
<li>如果使用 QQ 语音和 QQ 视频的话，UDP 的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li>
<li>由于 QQ 的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用 UDP 协议与客户端进行通讯才能保证这种超大规模的服务</li>
</ul>
<p>简单总结一下：UDP 协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。<strong>QQ 采用的通信协议以 UDP 为主，辅以 TCP 协议</strong>。</p>
<h3 id="udp-协议为什么不可靠" class="heading-element"><span>5.3 UDP 协议为什么不可靠？</span>
  <a href="#udp-%e5%8d%8f%e8%ae%ae%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e5%8f%af%e9%9d%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>UDP 在传输数据之前不需要先建立连接，远地主机的运输层在接收到 UDP 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="dns-为什么要用-udp" class="heading-element"><span>5.4 DNS 为什么要用 UDP?</span>
  <a href="#dns-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-udp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>更准确地说，DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。<font color="red">即在需要可靠传输或处理大数据包的特定场景下，DNS 也会使用 TCP 以确保传输的可靠性和完整性</font>。</p>
<p>当客户端想 DNS 服务器查询域名（域名解析）的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，用 UDP 传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="你会如何设计qq中的网络协议" class="heading-element"><span>5.5 你会如何设计QQ中的网络协议？</span>
  <a href="#%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1qq%e4%b8%ad%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>首先，我们要实现登录功能，这是使用 QQ 的第一步，为了保证账号和密码的安全性，我们可以选择 TCP + SSL/TLS 协议来进行登录。</p>
<p>因为 TCP 协议是一种可靠的传输协议，能够保证数据的完整性，而 SSL/TLS 能够对通信进行加密，保证数据的安全性。</p>
<p>接下来，我们需要考虑消息传递的实时性，如语音视频通话等，这时候我们可以选择 UDP 协议。UDP 的传输速度更快，对于实时性服务来说，速度是最重要的。</p>
<h3 id="udp如何尽量保证消息的不丢失" class="heading-element"><span>5.6 UDP如何尽量保证消息的不丢失</span>
  <a href="#udp%e5%a6%82%e4%bd%95%e5%b0%bd%e9%87%8f%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e7%9a%84%e4%b8%8d%e4%b8%a2%e5%a4%b1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于 TCP 协议来说，如果数据包在传输过程中丢失，TCP 协议会自动进行重传。</p>
<p>而对于 UDP 协议来说，我们可以通过应用层的重传机制来保证消息的不丢失。当接收方收到消息后，返回一个确认信息给发送方，如果发送方在一定时间内没有收到确认信息，就重新发送消息。</p>
<p>同时，每个消息都附带一个唯一的序列号，接收方根据序列号判断是否有消息丢失，如果发现序列号不连续，就可以要求发送方重新发送。这样还可以防止消息重复。</p>
<p>当然了，消息持久化也很重要，可以将消息保存在服务器或者本地的数据库中，即使在网络中断或者其他异常情况下，也能从数据库中恢复消息。</p>
<h2 id="quic" class="heading-element"><span>6 QUIC</span>
  <a href="#quic" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="quic是如何实现可靠传输的udp如何实现可靠传输" class="heading-element"><span>6.1 QUIC是如何实现可靠传输的？（UDP如何实现可靠传输？）</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%e7%9a%84udp%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">把TCP可靠传输的特性（序号，确认应答，超时重传，流量控制）在应用层实现一遍。</font></p>
<ul>
<li><strong>基于UDP</strong>：QUIC 建立在 UDP 之上，通过在 UDP 数据报中封装自己的数据包来实现可靠传输。</li>
<li><strong>可靠传输</strong>：QUIC 提供了类似于 TCP 的可靠传输机制，包括序列号、确认应答、重传和流量控制。</li>
<li><strong>多路复用</strong>：QUIC 支持多条独立的流，解决了 TCP 的队头阻塞问题。</li>
<li><strong>拥塞控制</strong>：QUIC 实现了拥塞控制算法，确保高效的数据传输。</li>
</ul>
<h3 id="quic是如何解决tcp队头阻塞问题的" class="heading-element"><span>6.2 QUIC是如何解决TCP队头阻塞问题的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3tcp%e9%98%9f%e5%a4%b4%e9%98%bb%e5%a1%9e%e9%97%ae%e9%a2%98%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP的队头阻塞（Head-of-Line Blocking）问题是指在数据传输过程中，如果某个数据包丢失了，后续的数据包即使已经到达接收方，也无法被处理，因为接收方必须按顺序处理数据包。</p>
<p>QUIC通过以下机制解决了这个问题：</p>
<ol>
<li><strong>多路复用</strong>：QUIC允许多个独立的流在同一个连接中传输，每个流都有自己的序列号和确认机制。这意味着即使某个流的数据包丢失了，也不会影响其他流的数据传输。</li>
<li><strong>独立流处理</strong>：接收方可以独立处理每个流的数据包，即使某个流的数据包丢失了，接收方仍然可以处理其他流的数据包，避免了队头阻塞。</li>
</ol>
<h3 id="quic是如何做流量控制的" class="heading-element"><span>6.3 QUIC是如何做流量控制的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>QUIC的流量控制机制与TCP类似，但更为灵活和高效：</p>
<ol>
<li><strong>流级别的流量控制</strong>：每个流都有自己的流量控制窗口，发送方在发送数据之前，必须确保数据大小不超过接收方为该流设定的窗口大小。</li>
<li><strong>连接级别的流量控制</strong>：除了流级别的流量控制，QUIC还支持连接级别的流量控制，限制整个连接上的未确认数据总量，防止网络拥塞。</li>
<li><strong>动态调整窗口大小</strong>：QUIC可以根据网络状况动态调整流量控制窗口的大小，提高数据传输的效率和适应性。</li>
</ol>
<h3 id="quic是如何迁移连接的" class="heading-element"><span>6.4 QUIC是如何迁移连接的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%81%e7%a7%bb%e8%bf%9e%e6%8e%a5%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p>
<p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过以下机制：</p>
<ol>
<li><strong>连接ID</strong>：QUIC为每个连接分配一个唯一的连接ID，连接ID与客户端和服务器的IP地址和端口无关。因此，即使客户端的IP地址或端口发生变化，只要连接ID不变，连接仍然有效。</li>
<li><strong>路径验证</strong>：在迁移连接时，QUIC会验证新的路径是否可用，确保数据能够通过新路径传输。</li>
<li><strong>迁移过程</strong>：当客户端检测到网络变化（例如，从WiFi切换到移动网络）时，会通知服务器新的地址和端口。服务器验证新的路径后，继续通过新的路径传输数据。</li>
<li><strong>无缝切换</strong>：通过连接ID和路径验证机制，QUIC实现了连接的无缝迁移，避免了因网络变化导致的连接中断和数据丢失。</li>
</ol>
<h2 id="ip" class="heading-element"><span>7 IP</span>
  <a href="#ip" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="ip-协议的定义和作用" class="heading-element"><span>7.1 IP 协议的定义和作用？</span>
  <a href="#ip-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>IP 协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在<strong>网际层</strong>，主要目的就是为了提高网络的可扩展性。</p>
<p>通过<strong>网际协议 IP</strong>，可以把参与互联的，性能各异的网络<strong>看作一个统一的网络</strong>。</p>
<p>和传输层 TCP 相比，IP 协议是一种无连接/不可靠、尽力而为的数据包传输服务，和 TCP 协议一起构成了 TCP/IP 协议的核心。</p>
<blockquote>
<p><strong>IP 协议有哪些作用？</strong></p>
</blockquote>
<p>IP 协议主要有以下几个作用：</p>
<ul>
<li><strong>寻址和路由</strong>：在 IP 数据报中携带源 IP 地址和目的 IP 地址来表示该数据包的源主机和目标主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至目标主机。</li>
<li><strong>分段和重组</strong>：IP 数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP 协议通过给每个 IP 数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的 IP 数据报。</li>
<li><strong>差错处理</strong>：虽然 IP 是尽力而为的协议，不保证数据报一定到达目的地，但它包含一些基本的差错处理机制，例如校验和（checksum），用于检测数据报头部的错误。</li>
<li><strong>控制信息</strong>：IP 头部包含了多个字段，用于控制和管理数据报的传输，如生存时间（TTL，Time to Live）字段，防止数据报在网络中无限循环。</li>
</ul>
<blockquote>
<p><strong>传输层协议和网络层协议有什么区别？</strong></p>
</blockquote>
<p><font oclor="red">网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。</font></p>
<h3 id="ip-地址有哪些分类" class="heading-element"><span>7.2 IP 地址有哪些分类？</span>
  <a href="#ip-%e5%9c%b0%e5%9d%80%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%86%e7%b1%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>IP地址（Internet Protocol Address）是用于标识网络中设备的唯一地址。IP地址有两种版本：IPv4和IPv6。IPv4是目前最广泛使用的版本，IPv6是为解决IPv4地址耗尽问题而设计的新版本。</p>
<p>IPv4地址是32位长的二进制数，通常表示为四个十进制数（每个数对应8位）之间用点分隔（例如，192.168.1.1）。IPv4地址可以按其用途和结构分为A，B，C，D，E五大类：</p>
<ul>
<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位，主要用于大型网络；</li>
<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位，主要用于中型网络；</li>
<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位，主要用于小型网络；</li>
<li>D 类地址 (224~239)：以 1110 开头，保留为多播地址，用于一对多通信；</li>
<li>E 类地址 (240~255)：以 1111 开头，保留位为将来使用，用于实验和研究。</li>
</ul>
<p>IPv4有以下特殊地址：</p>
<ul>
<li><strong>本地回环地址（Loopback Address）</strong>：127.0.0.0 到 127.255.255.255，用于主机自我测试，通常使用127.0.0.1。</li>
<li><strong>广播地址（Broadcast Address）</strong>：用于将信息发送到网络上的所有设备。例如，192.168.1.255。</li>
<li>私有地址（Private Address）：用于局域网（LAN）内部通信，不可在互联网上使用。包括以下范围：
<ul>
<li>A类：10.0.0.0 到 10.255.255.255</li>
<li>B类：172.16.0.0 到 172.31.255.255</li>
<li>C类：192.168.0.0 到 192.168.255.255</li>
</ul>
</li>
</ul>
<p>IPv6地址是128位长的二进制数，通常表示为八组十六进制数之间用冒号分隔（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。IPv6地址类型主要有以下几种：</p>
<ul>
<li><strong>单播地址（Unicast Address）</strong>：标识单一接口的地址。
<ul>
<li>全球单播地址（Global Unicast Address）：类似于IPv4的公有地址。</li>
<li>链路本地地址（Link-Local Address）：仅在单一链路上有效，前缀为fe80::/10。</li>
<li>站点本地地址（Site-Local Address）：类似于IPv4的私有地址，但已被弃用，前缀为fec0::/10。</li>
</ul>
</li>
<li><strong>多播地址（Multicast Address）</strong>：用于一对多通信，前缀为ff00::/8。</li>
<li><strong>任播地址（Anycast Address）</strong>：分配给多个接口，但数据包仅发送到距离最近的接口</li>
</ul>
<h3 id="域名和-ip-的关系一个-ip-可以对应多个域名吗一个域名可以对应多个ip吗" class="heading-element"><span>7.3 域名和 IP 的关系？一个 IP 可以对应多个域名吗？一个域名可以对应多个IP吗？</span>
  <a href="#%e5%9f%9f%e5%90%8d%e5%92%8c-ip-%e7%9a%84%e5%85%b3%e7%b3%bb%e4%b8%80%e4%b8%aa-ip-%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ba%94%e5%a4%9a%e4%b8%aa%e5%9f%9f%e5%90%8d%e5%90%97%e4%b8%80%e4%b8%aa%e5%9f%9f%e5%90%8d%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ba%94%e5%a4%9a%e4%b8%aaip%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>域名（Domain Name）</strong>：人类可读的地址，用于标识和访问网站及其他网络资源（例如，<code>www.example.com</code>）。</li>
<li><strong>IP地址（Internet Protocol Address）</strong>：计算机可读的地址，用于标识网络中的设备（例如，<code>192.168.1.1</code>）。</li>
</ul>
<p>域名和IP地址之间是通过DNS（Domain Name System）来进行映射和解析的。</p>
<p>一个域名可以对应多个 IP，但这种情况 DNS 做负载均衡的，在用户访问过程中，一个域名只能对应一个 IP。</p>
<p>而一个IP却可以对应多个域名，是一对多的关系。</p>
<h3 id="ipv4-地址不够如何解决" class="heading-element"><span>7.4 IPV4 地址不够如何解决？</span>
  <a href="#ipv4-%e5%9c%b0%e5%9d%80%e4%b8%8d%e5%a4%9f%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>DHCP：动态主机配置协议，<font color="red">动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用</font>。</li>
<li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效地分配 IPv4 的地址空间，但无法从根本上解决地址耗尽的问题。</li>
<li>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题，<font color="red">然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT 方法可以将该主机 IP 地址转换为全球 IP 地址</font>。该协议能够有效解决 IP 地址不足的问题。</li>
<li>IPv6：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个 IP 地址也够用，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>
</ul>
<h3 id="说下-arp-协议的工作过程" class="heading-element"><span>7.5 说下 ARP 协议的工作过程？</span>
  <a href="#%e8%af%b4%e4%b8%8b-arp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ARP（Address Resolution Protocol，地址解析协议）是用于将IP地址解析为对应物理网络地址（如MAC地址）的协议，主要在IPv4网络中使用。它在局域网（LAN）中起到了关键作用，使设备能够通过IP地址找到对应的硬件地址，从而实现数据帧在局域网中的正确传输。</p>
<ol>
<li><strong>ARP请求</strong>：当主机 A 要发送数据给主机 B 时，首先会在自己的 ARP 缓存中查找主机 B 的 MAC 地址。如果没有找到，主机 A 会向网络中广播一个 ARP 请求数据包，请求网络中的所有主机告诉它们的 MAC 地址；这个请求包含了请求设备和目标设备的 IP 和 MAC 地址。</li>
<li><strong>ARP应答</strong>：网络中的所有主机都会收到这个 ARP 请求，但只有主机 B 会回复 ARP 应答，告诉主机 A 自己的 MAC 地址。并且主机 B 会将主机 A 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中，以便下次通信时直接使用。</li>
<li><strong>数据传输</strong>：在获得主机B的MAC地址后，主机A（也会将主机 B 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中）就可以将目标MAC地址设置为主机B的MAC地址，从而正确地构建以太网帧并发送到局域网中，这些数据帧会通过交换机或集线器等网络设备正确地传送到主机B。</li>
</ol>
<h3 id="为什么既有-ip-地址又有-mac-地址" class="heading-element"><span>7.6 为什么既有 IP 地址，又有 MAC 地址？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%97%a2%e6%9c%89-ip-%e5%9c%b0%e5%9d%80%e5%8f%88%e6%9c%89-mac-%e5%9c%b0%e5%9d%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>MAC 地址和 IP 地址都有什么作用？</strong></p>
</blockquote>
<ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>
</ul>
<blockquote>
<p><strong>为什么有了 MAC 地址还需要 IP 地址？</strong></p>
</blockquote>
<p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是最多共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256T 的内存，显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<blockquote>
<p><strong>为什么有了 IP 地址还需要 MAC 地址？</strong></p>
</blockquote>
<ul>
<li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候，或者在分配 IP 的过程中。我们需要 MAC 地址来区分不同的设备。</li>
<li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li>
</ul>
<h3 id="icmp-协议的功能" class="heading-element"><span>7.7 ICMP 协议的功能？</span>
  <a href="#icmp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8a%9f%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ICMP（Internet Control Message Protocol，网际控制报文协议） 是用于在IP网络中传递控制和错误信息的协议。它是在网络层（OSI模型的第三层）之上运行的协议，主要用于在IP网络中进行诊断、错误报告和控制消息的传递。ICMP协议的功能包括但不限于以下几点：</p>
<ul>
<li><strong>错误报告</strong>：ICMP用于向发送者报告网络层发生的错误，例如目标不可达、超时、路由器发生故障等。</li>
<li><strong>路由器发现</strong>：ICMP可用于路由器的发现和配置，例如路由器通告消息（Router Advertisement）和路由器请求消息（Router Solicitation）。</li>
<li><strong>Ping测试</strong>：ICMP的Echo请求和Echo应答消息被用于Ping测试，以测试主机之间的连通性和延迟。</li>
<li><strong>TTL过期</strong>：ICMP的TTL（Time to Live）过期消息用于报告数据包在网络中被丢弃的情况，通常由于数据包在转发过程中超过了其TTL值。</li>
<li><strong>片段超时</strong>：ICMP的片段超时消息用于报告IP数据报在传输过程中被丢弃的情况，通常由于数据包片段未能在超时时间内到达目的地而被丢弃。</li>
<li><strong>重定向</strong>：ICMP的重定向消息用于告知发送者修改其路由表以改进数据包的转发效率。</li>
<li><strong>MTU探测</strong>：ICMP的路径MTU探测（Path MTU Discovery）用于发现通向目标主机的最大传输单元（MTU）以避免分片。</li>
<li><strong>多播/任播测试</strong>：ICMP用于进行多播和任播地址的测试和诊断。</li>
</ul>
<p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 ICMP 的。</p>
<p><font color="red">在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</font></p>
<p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p>
<h3 id="ping的工作原理" class="heading-element"><span>7.8 ping的工作原理</span>
  <a href="#ping%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ping，<strong>Packet Internet Groper</strong>，一个网络工具，主要用来测试网络连接的可达性和延迟。</p>
<p>ping 的过程主要基于 ICMP（Internet Control Message Protocol，互联网控制消息协议）实现，其基本过程包括：</p>
<ol>
<li>当执行 Ping 命令，如<code>ping www.google.com</code>，Ping 首先解析域名获取 IP 地址，然后向目标 IP 发送一个 ICMP Echo Request 消息。</li>
<li>当目标 IP 收到 ICMP Echo Request 消息后，它会生成一个 ICMP Echo Reply 消息并返回，即 Ping 响应消息。</li>
<li>发起 Ping 命令的设备接收到 ICMP Echo Reply 消息后，计算并显示从发送 Echo Request 到接收到 Echo Reply 的时间（通常称为往返时间 RTT，Round-Trip Time），以及可能的丢包情况。</li>
</ol>
<p>Ping 通常会发送多个请求，以便提供平均响应时间和丢包率等信息，以便我们了解网络连接的质量。</p>
<h3 id="断网了还能ping通127001吗" class="heading-element"><span>7.9 断网了，还能ping通127.0.0.1吗？</span>
  <a href="#%e6%96%ad%e7%bd%91%e4%ba%86%e8%bf%98%e8%83%bdping%e9%80%9a127001%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通常情况下，即使网络连接断开，也可以通过回环接口（Loopback Interface）ping通本地主机的回环地址127.0.0.1。回环地址是本地主机自身的虚拟网络接口，用于在本地主机内部进行通信，不经过物理网络设备，因此即使网络断开也可以正常工作。</p>
<p>回环接口是网络协议栈中的一个虚拟接口，用于模拟数据在网络中的传输。当数据发送到回环地址时，操作系统会将数据直接传输给回环接口，然后再从回环接口发送到目标地址，实现了数据的回环传输。</p>
<h3 id="和-localhost-以及-0000-有区别吗" class="heading-element"><span>7.10 和 localhost 以及 0.0.0.0 有区别吗</span>
  <a href="#%e5%92%8c-localhost-%e4%bb%a5%e5%8f%8a-0000-%e6%9c%89%e5%8c%ba%e5%88%ab%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>127.0.0.1</strong>：127.0.0.1是回环地址（Loopback Address），通常用于本地主机内部进行通信。当数据发送到127.0.0.1时，操作系统会将数据传输给回环接口，然后再从回环接口发送到目标地址，实现了数据的回环传输。127.0.0.1始终指向本地主机自身，不会通过网络传输，用于测试本地主机的网络协议栈是否正常工作以及网络服务是否可用。</li>
<li><strong>localhost</strong>：localhost是一个主机名（Hostname），通常映射到回环地址127.0.0.1。当在计算机上使用localhost时，实际上是在使用回环地址127.0.0.1，用于访问本地主机上的网络服务。localhost是一个常见的网络标识符，用于指代本地主机。</li>
<li><strong>0.0.0.0</strong>：0.0.0.0是一个特殊的IP地址，通常用于表示任意主机或任意地址。当服务器配置为监听0.0.0.0时，表示它将接受来自任何IP地址的连接，可以用于在所有可用网络接口上监听服务。在某些情况下，0.0.0.0也用于指示目标地址未指定或未知。</li>
</ol>
<h2 id="网络安全" class="heading-element"><span>8 网络安全</span>
  <a href="#%e7%bd%91%e7%bb%9c%e5%ae%89%e5%85%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说有哪些安全攻击" class="heading-element"><span>8.1 说说有哪些安全攻击？</span>
  <a href="#%e8%af%b4%e8%af%b4%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%94%bb%e5%87%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>络安全攻击主要分为两种类型，<strong>被动攻击</strong>和<strong>主动攻击</strong></p>
<ul>
<li><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。<font color="red">由于攻击者没有修改数据，使得这种攻击很难被检测到。</font></li>
<li><strong>主动攻击</strong>：直接对现有的数据和服务造成影响，常见的主动攻击类型有：
<ul>
<li><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</li>
<li><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</li>
<li><strong>拒绝服务 Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</li>
</ul>
</li>
</ul>
<h3 id="dns-劫持了解吗" class="heading-element"><span>8.2 DNS 劫持了解吗？</span>
  <a href="#dns-%e5%8a%ab%e6%8c%81%e4%ba%86%e8%a7%a3%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DNS劫持是一种网络攻击，通过篡改DNS（Domain Name System）解析结果来劫持用户的网络流量。DNS劫持攻击者会修改DNS解析请求或响应，将用户重定向到恶意网站或者欺骗页面。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DNS_Attack_Example.png" alt="03e093a40b15980c362ca54c98199b29" style="zoom:50%;" />
<p>DNS劫持可以通过多种方式实现，其中包括：</p>
<ol>
<li><strong>本地DNS劫持</strong>：攻击者在受害者计算机或网络中植入恶意软件，使其修改本地主机的DNS设置，将合法的DNS服务器替换为攻击者控制的恶意DNS服务器。</li>
<li><strong>路由器DNS劫持</strong>：攻击者入侵路由器或者通过社会工程手段获取路由器管理权限，然后修改路由器的DNS设置，使其指向恶意DNS服务器。</li>
<li><strong>ISP级别的DNS劫持</strong>：攻击者控制了受害者所使用的ISP（Internet Service Provider，互联网服务提供商）的DNS服务器，通过篡改ISP的DNS解析结果来实现DNS劫持。</li>
<li><strong>中间人攻击</strong>：攻击者通过中间人攻击拦截DNS请求或响应，然后篡改其中的域名解析结果，将用户重定向到恶意网站或者欺骗页面。</li>
</ol>
<blockquote>
<p><strong>怎么应对 DNS 劫持？</strong></p>
</blockquote>
<ul>
<li>直接通过 IP 地址访问网站，避开 DNS 劫持</li>
<li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选 DNS 服务器的地址固定为 8.8.8.8。</li>
</ul>
<h3 id="什么是-csrf-攻击如何避免" class="heading-element"><span>8.3 什么是 CSRF 攻击？如何避免？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-csrf-%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种网络安全攻击，<font color="red">利用用户在已认证的Web应用程序上的身份验证信息执行未经授权的操</font>作。攻击者通过诱使受害者在访问包含恶意代码的网页时，触发向目标网站发送请求的行为，从而在用户不知情的情况下执行攻击者预先设定的操作，如转账、更改密码等。</p>
<p>CSRF攻击通常包含以下步骤：</p>
<ol>
<li>攻击者准备好一个包含恶意请求的页面，例如一个钓鱼网站或者注入了恶意代码的广告。</li>
<li>受害者在已经登录的情况下访问了包含恶意请求的页面。</li>
<li>受害者的浏览器自动发送了被伪造的请求到目标网站，由于受害者已经在目标网站登录，因此请求被认为是合法的，从而执行了攻击者的操作。</li>
</ol>
<p>要防止CSRF攻击，可以采取以下措施：</p>
<ol>
<li><strong>使用CSRF Token</strong>：在Web应用程序中引入CSRF Token，确保每个请求都包含一个随机生成的Token，并在服务端验证Token的有效性。攻击者无法获取到有效的CSRF Token，因此无法伪造有效的请求。</li>
<li><strong>检查Referer头</strong>：Web应用程序可以检查请求的Referer头，确保请求来自合法的来源。但需要注意的是，Referer头可能会被篡改或者缺失，因此不能单独依赖Referer头来防止CSRF攻击。</li>
<li><strong>限制敏感操作</strong>：对于涉及到敏感操作的请求，应该要求用户输入额外的身份验证信息，例如密码、验证码等，以增加攻击者执行CSRF攻击的难度。</li>
<li><strong>使用SameSite属性</strong>：在设置Cookie时，可以使用SameSite属性来限制Cookie的发送，防止第三方网站携带Cookie发送CSRF攻击。可以将Cookie设置为SameSite=Strict或者SameSite=Lax，以限制Cookie仅在同源请求中发送。</li>
<li><strong>定期审查和更新代码</strong>：定期审查和更新Web应用程序的代码，修补已知的安全漏洞，并遵循安全最佳实践，以减少CSRF攻击的风险。</li>
<li><strong>添加校验 token</strong>：以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li>
</ol>
<h3 id="什么是-dosddosdrdos-攻击" class="heading-element"><span>8.4 什么是 DoS、DDoS、DRDoS 攻击？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-dosddosdrdos-%e6%94%bb%e5%87%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DoS（Denial of Service，拒绝服务）攻击、DDoS（Distributed Denial of Service，分布式拒绝服务）攻击和DRDoS（Distributed Reflection Denial of Service，分布式反射拒绝服务）攻击都是针对网络服务的攻击手法，旨在使目标系统无法正常提供服务，从而导致服务不可用或严重受损。</p>
<ol>
<li><strong>DoS 攻击</strong>：DoS攻击是由单个攻击者发起的攻击，通过向目标系统发送大量的请求或者恶意数据包，耗尽目标系统的资源（如带宽、处理能力、存储空间等），从而使正常用户无法访问或使用目标系统的服务。DoS攻击可以采用多种手段实现，包括网络层攻击（如SYN Flood、UDP Flood）、应用层攻击（如HTTP Flood、Slowloris攻击）等。</li>
<li><strong>DDoS 攻击</strong>：DDoS攻击是由多个攻击者协同发起的攻击，通过分布在全球各地的大量“僵尸”计算机（也称为“肉鸡”或“僵尸网络”）向目标系统发送大量的请求或者恶意数据包，造成目标系统过载，从而使其无法正常提供服务。DDoS攻击通常规模更大、更难以应对，因为攻击流量来自于多个来源，并且攻击者可以很容易地控制和伪装攻击流量的来源。</li>
<li><strong>DRDoS 攻击</strong>：DRDoS攻击是一种利用第三方系统的资源反射攻击目标系统的攻击方式。攻击者向第三方系统发送请求，伪装成目标系统的IP地址，并请求返回大量的响应数据，这些响应数据会发送到目标系统，造成目标系统的过载。DRDoS攻击利用了第三方系统的反射响应特性，使攻击者能够轻易地放大攻击流量，并且很难追溯到攻击者的真实身份。</li>
</ol>
<blockquote>
<p><strong>如何防范 DDoS?</strong></p>
</blockquote>
<p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。瓷碗，负载均衡，CDN 等技术都能有效对抗 DDos 攻击。</p>
<h3 id="什么是-xss-攻击如何避免" class="heading-element"><span>8.5 什么是 XSS 攻击，如何避免?</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-xss-%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的网络安全攻击，攻击者通过在受害者的浏览器中注入恶意脚本，来执行恶意操作。这些脚本通常以HTML、JavaScript等形式存在，可以窃取用户的会话信息、篡改网页内容、重定向用户到恶意网站等。XSS攻击通常分为以下几种类型：</p>
<ol>
<li><strong>存储型 XSS</strong>：攻击者将恶意脚本存储到目标网站的数据库中，当用户访问包含恶意脚本的页面时，脚本会从服务器端加载并执行。</li>
<li><strong>反射型 XSS</strong>：攻击者将恶意脚本作为参数或者URL的一部分，发送给目标用户，当用户点击恶意链接时，脚本会在用户的浏览器中执行。</li>
<li><strong>DOM-based XSS</strong>：攻击者利用客户端的DOM环境，通过修改页面的DOM结构来执行恶意脚本。</li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/typical_XSS_Example.png" alt="一个典型的 XSS" style="zoom:50%;" />
<blockquote>
<p><strong>如何应对 XSS 攻击？</strong></p>
</blockquote>
<ul>
<li>对输入进行过滤，过滤标签等，只允许合法值。</li>
<li>HTML 转义</li>
<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以 script 开头的非法链接。</li>
<li>限制输入长度</li>
<li>将Cookie设置为HttpOnly标志，可以防止JavaScript访问Cookie，从而减少XSS攻击的风险。</li>
</ul>
<h3 id="对称加密与非对称加密有什么区别" class="heading-element"><span>8.6 对称加密与非对称加密有什么区别？</span>
  <a href="#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e4%b8%8e%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对称加密和非对称加密是两种常见的加密算法，它们之间有几个关键区别：</p>
<ol>
<li><strong>密钥数量</strong>：
<ul>
<li>对称加密使用相同的密钥来加密和解密数据，因此只需要一个密钥。发送方使用该密钥将数据加密，接收方使用相同的密钥将数据解密。</li>
<li>非对称加密使用一对密钥：公钥和私钥。公钥用于加密数据，私钥用于解密数据。因此，发送方使用接收方的公钥来加密数据，接收方使用自己的私钥来解密数据。</li>
</ul>
</li>
<li><strong>密钥分发</strong>：
<ul>
<li>对称加密需要确保加密和解密双方都安全地共享相同的密钥。这意味着必须在通信双方之间建立一个安全的渠道来传输密钥，否则密钥可能会被窃取或篡改。</li>
<li>非对称加密不需要在通信双方之间共享密钥。接收方将自己的公钥公开发布，发送方使用该公钥加密数据，接收方使用自己的私钥解密数据。因此，不需要建立安全的通道来传输密钥。</li>
</ul>
</li>
<li><strong>性能</strong>：
<ul>
<li>对称加密通常比非对称加密更快速，因为它使用的密钥较少，加密和解密过程更简单。</li>
<li>非对称加密通常比对称加密更慢，因为它使用更复杂的数学运算来加密和解密数据。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>对称加密通常用于加密大量数据，如传输文件或通信内容。</li>
<li>非对称加密通常用于加密小块数据，如数字签名、SSL/TLS握手过程等。</li>
</ul>
</li>
</ol>
]]></description></item><item><title>数据结构与算法 面试题目总结</title><link>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 20:13:44 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="排序算法" class="heading-element"><span>1 排序算法</span>
  <a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最差时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">数据对象稳定性</th>
<th style="text-align:center">算法基本思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">反复交换相邻逆序的元素，直到没有逆序对</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">数组不稳定、链表稳定</td>
<td style="text-align:center">反复选择未排序部分中的最小（大）元素，放在已排序部分的末尾</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">逐一选择未排序元素，将其插入到已排序部分的正确位置</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(\log_2 n)$$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">选择基准，将数组分为小于和大于基准的两部分，递归排序</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">构建最大（小）堆，将堆顶元素与末尾元素交换，调整堆</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">递归地将数组分为两部分，分别排序后合并</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$$O(n \log_2 n)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">分组进行插入排序，逐渐减少间隔，直到间隔为1</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$$O(n + m)$$</td>
<td style="text-align:center">$$O(n + m)$$</td>
<td style="text-align:center">$$O(n + m)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">统计每个元素的出现次数，根据计数对元素进行排序</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(m)$$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">将元素分配到不同的桶中，分别排序后合并</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$$O(k \cdot n)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">取决于实现</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">逐位排序，从最低有效位到最高有效位进行</td>
</tr>
</tbody>
</table>
<h2 id="栈与队列的区别" class="heading-element"><span>2 栈与队列的区别</span>
  <a href="#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；</li>
<li>栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。</li>
<li>队列先进先出，栈先进后出。</li>
<li>栈只能在表尾插入删除，队列在表尾插入表头删除。</li>
<li>应用场景不同：
<ul>
<li>栈：括号问题的求解等</li>
<li>队列：计算机系统中各种资源的管理等。</li>
</ul>
</li>
<li>遍历速度不同：
<ul>
<li>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快；</li>
<li>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</li>
</ul>
</li>
</ul>
<h2 id="两个栈实现一个队列" class="heading-element"><span>3 两个栈实现一个队列</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e9%98%9f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个栈来实现一个队列，可以有效地利用栈的特性（后进先出）来模拟队列的特性（先进先出）。我们可以使用两个栈来分离入队和出队操作，具体实现步骤如下：</p>
<ul>
<li><strong>栈1</strong>（<code>stack1</code>）用于处理入队操作。</li>
<li><strong>栈2</strong>（<code>stack2</code>）用于处理出队操作。</li>
</ul>
<ol>
<li>入队列：直接压入元素至<code>stack1</code>即可</li>
<li>出队列：如果<code>stack2</code>不为空，把<code>stack2</code>中的栈顶元素直接弹出。否则，把<code>stack1</code>的所有元素全部弹出压入<code>stack2</code>中，再弹出<code>stack2</code>的栈顶元素</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stack1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack1</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Queue is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="两个队列实现栈" class="heading-element"><span>4 两个队列实现栈</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个队列来实现一个栈，可以利用队列的特性（先进先出）来模拟栈的特性（后进先出）。我们可以使用两个队列来分离入栈和出栈操作，具体实现步骤如下：</p>
<ul>
<li><strong>队列1</strong>（<code>queue1</code>）用于存储元素。</li>
<li><strong>队列2</strong>（<code>queue2</code>）作为辅助队列用于操作元素。</li>
</ul>
<ol>
<li><strong>入栈操作</strong>：将元素直接入队到<code>queue1</code>中。</li>
<li><strong>出栈操作</strong>：
<ul>
<li>将<code>queue1</code>中的所有元素（除了最后一个）逐个出队并入队到<code>queue2</code>中。</li>
<li>最后一个元素是栈顶元素，将其出队。</li>
<li>交换<code>queue1</code>和<code>queue2</code>，以保持<code>queue1</code>始终为主队列。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Stack is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="链表与数组的区别" class="heading-element"><span>5 链表与数组的区别</span>
  <a href="#%e9%93%be%e8%a1%a8%e4%b8%8e%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>数组静态分配内存，链表动态分配内存；。</li>
</ul>
<ul>
<li>数组在内存中连续，链表不连续。</li>
<li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)。</li>
<li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li>
<li><font color="red">数组元素在栈区，链表元素在堆区</font>。</li>
</ul>
<h2 id="什么是堆" class="heading-element"><span>6 什么是堆？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p>
<p><strong>最大堆的根结点中的元素在整个堆中是最大的；</strong></p>
<p><strong>最小堆的根结点中的元素在整个堆中是最小的。</strong></p>
<h2 id="什么是二叉排序树" class="heading-element"><span>7 什么是二叉排序树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ol>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<h2 id="什么是平衡二叉树" class="heading-element"><span>8 什么是平衡二叉树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p><font color="red">平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进</font>。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。</p>
<p>旋转是平衡二叉树维护平衡性的核心操作，包括以下几种：</p>
<ul>
<li>单右旋转（Right Rotation）：用于修复左子树过高的情况。</li>
<li>单左旋转（Left Rotation）：用于修复右子树过高的情况。</li>
<li>双旋转（Double Rotation）：包括先左后右旋转和先右后左旋转，用于修复特定的不平衡情况。</li>
</ul>
<h2 id="什么是b树" class="heading-element"><span>9 什么是B树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%afb%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>B树是一种自平衡的多路查找树，其中每个节点可以有多个子节点和多个键。B树具有以下特性：</p>
<ul>
<li><strong>节点包含多个键和子节点</strong>：每个节点可以存储多个键和子节点。节点中的键按照递增顺序存储。</li>
<li><strong>根节点至少有两个子节点</strong>（如果不是叶节点）。</li>
<li><strong>内部节点的子节点数受限</strong>：一个内部节点至少有$$[m/2]$$个子节点，最多有 $$m$$个子节点（这里的$m$是B树的阶）。</li>
<li><strong>所有叶子节点处于同一层</strong>：B树的所有叶子节点都在同一层，保证树的平衡性。</li>
</ul>
<p>B树的性质如下：</p>
<ul>
<li><strong>平衡性</strong>：B树是自平衡的，所有叶子节点处在同一层，树的高度通常较小，因而能够保证较快的搜索、插入和删除操作。</li>
<li><strong>高效的磁盘I/O操作</strong>：由于节点可以包含多个键和子节点，B树通常用于磁盘存储中，减少磁盘I/O操作的次数。</li>
<li><strong>时间复杂度</strong>：搜索、插入和删除操作的时间复杂度均为$O(\log n)$，其中$n$是树中的键的总数。</li>
</ul>
<p>B树的操作如下：</p>
<ul>
<li><strong>搜索</strong>：从根节点开始，根据当前节点中的键范围，递归或迭代地选择相应的子节点进行搜索，直到找到目标键或到达叶子节点。</li>
<li>插入：
<ul>
<li>在叶子节点插入新键。</li>
<li>如果叶子节点已满，则进行分裂操作，将中间键提升到父节点，并将叶子节点分裂为两个节点。</li>
<li>如果父节点也满，则递归进行分裂，直到树根。</li>
</ul>
</li>
<li>删除：
<ul>
<li>从树中删除键。</li>
<li>如果删除键导致节点下溢（键数少于$[m/2]$），则进行合并或借用操作，以保持B树的平衡性。</li>
</ul>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small" data-sub-html="<h2>clip_image020</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png" alt="clip_image020" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large 2x" data-title="clip_image020" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="trie-树" class="heading-element"><span>10 Trie 树</span>
  <a href="#trie-%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/trie1.png" alt="字典树(Trie) - OI Wiki" style="zoom:50%;" />
<h2 id="b树" class="heading-element"><span>11 B+树</span>
  <a href="#b%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">B+树通常用于数据库和操作系统的文件系统中</font>，B+树的结构如下：</p>
<ul>
<li><strong>根节点（Root Node）</strong>：B+树的根节点可以是叶子节点，也可以是内部节点。</li>
<li><strong>内部节点（Internal Nodes）</strong>：存储键值用于导航，不存储实际数据。每个内部节点包含若干个键和指向子节点的指针。</li>
<li><strong>叶子节点（Leaf Nodes）</strong>：存储所有的实际数据，并且包含指向相邻叶子节点的指针，形成一个双向链表。</li>
</ul>
<p>B+树的性质：</p>
<ul>
<li><strong>有序性</strong>：所有键按升序排列。</li>
<li><strong>平衡性</strong>：树的所有叶子节点处于同一层级，保证了平衡性。</li>
<li><strong>多路性</strong>：每个节点可以有多个子节点，具体数量由树的阶（order）决定。</li>
</ul>
<p>B+树的操作：</p>
<ul>
<li><strong>查找（Search）</strong>：从根节点开始，依次比较键值，沿着指向子节点的指针递归查找，直到找到目标叶子节点。</li>
<li><strong>插入（Insert）</strong>：将新键插入适当的叶子节点，如果叶子节点满了，则分裂叶子节点并将中间键上移到父节点，递归进行分裂直到树恢复平衡。</li>
<li><strong>删除（Delete）</strong>：从叶子节点删除键，如果删除导致节点键数目不足，则进行节点合并或键重新分配，直到树恢复平衡。</li>
</ul>
<p>B+树的优点：</p>
<ul>
<li><strong>高效的范围查询</strong>：由于所有数据都存储在叶子节点中，并且叶子节点形成双向链表，B+树能够高效地进行范围查询（range query）。</li>
<li><strong>高存储利用率</strong>：内部节点只存储键，数据存储在叶子节点中，节点分裂和合并更加高效。</li>
<li><strong>低树高（Tree Height）</strong>：B+树的多路性使得其树高较低，查找、插入和删除操作的时间复杂度为$O(\log_mn$，其中$m$为树的阶。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small" data-sub-html="<h2>ds-bplus-tree2</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg" alt="ds-bplus-tree2" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large 2x" data-title="ds-bplus-tree2" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是红黑树" class="heading-element"><span>12 什么是红黑树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%a2%e9%bb%91%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>红黑树（为了解决平衡树在插入、删除等操作需要频繁调整的情况）是一种自平衡的二叉查找树（BST），广泛用于计算机科学中实现高效的数据存储和检索。它通过在每个节点上附加一个颜色属性（红或黑）来保持树的平衡，从而确保树的高度在对数级别，提供较好的时间复杂度性能。</p>
<p>红黑树的性质：</p>
<ol>
<li><strong>每个结点不是红色就是黑色；</strong></li>
<li><strong>根节点是黑色的</strong>；</li>
<li><strong>叶子节点（NIL节点）是黑色</strong>：红黑树中的叶子节点，即树尾端的所有NULL节点，都是黑色的。</li>
<li><strong>红色节点的父节点和子节点必须是黑色的，即不能有两个连续的红色节点。</strong></li>
<li><strong>从任一节点到其每个叶子的所有路径包含相同数量的黑色节点</strong>：这保证了没有一条路径会比其他路径长出太多，从而确保了树的平衡。</li>
</ol>
<p>红黑树的操作：红黑树的操作包括插入、删除和查找，基本的操作步骤与普通的二叉查找树类似，但在维护平衡性方面有所不同。</p>
<ol>
<li>
<p>插入操作</p>
<ol>
<li>
<p><strong>普通BST插入</strong>：按二叉查找树的插入规则，将新节点插入适当位置。</p>
</li>
<li>
<p><strong>节点染色为红色</strong>：新插入的节点初始为红色。</p>
</li>
<li>
<p><strong>调整平衡</strong>：通过旋转和重新染色来保持红黑树的性质。</p>
<ul>
<li>
<p><strong>情况1：插入节点的父节点是黑色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：插入节点的父节点是红色</strong>：根据叔节点的颜色，有不同的调整方法，包括重新染色和旋转。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>删除操作</p>
<ol>
<li>
<p><strong>普通BST删除</strong>：按二叉查找树的删除规则，找到并删除节点。</p>
</li>
<li>
<p><strong>调整平衡</strong>：删除节点后可能破坏红黑树的性质，需要通过旋转和重新染色来恢复平衡。</p>
<ul>
<li>
<p><strong>情况1：删除节点是红色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：删除节点是黑色</strong>：通过双重黑色节点的概念和调整，包括重新染色和旋转，来恢复红黑树的平衡。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>红黑树的优点：</p>
<ul>
<li><strong>自平衡</strong>：通过颜色属性和旋转操作，红黑树可以保持平衡，确保基本操作的时间复杂度为$$O(\log n)$$。</li>
<li><strong>高效查找</strong>：由于平衡性，红黑树在最坏情况下的高度为$$2\log(n+1)$$，保证了查找操作的高效性。</li>
<li><strong>高效插入和删除</strong>：插入和删除操作在进行平衡调整时，旋转和重新染色的成本较低，确保了高效性。</li>
</ul>
<p>红黑树广泛应用于许多计算机系统和软件中，包括：</p>
<ul>
<li><strong>关联容器</strong>：C++的STL中的map和set，Java的TreeMap和TreeSet都基于红黑树实现。</li>
<li><strong>内存管理</strong>：Linux内核中的内存管理使用红黑树来管理空闲内存块。</li>
<li><strong>数据库索引</strong>：一些数据库系统使用红黑树作为索引结构，实现高效的数据检索。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是哈希表哈希表的实现方式怎么避免哈希冲突" class="heading-element"><span>13 什么是哈希表？哈希表的实现方式？怎么避免哈希冲突</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%93%88%e5%b8%8c%e8%a1%a8%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e6%80%8e%e4%b9%88%e9%81%bf%e5%85%8d%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>哈希表（Hash Table，也叫散列表），是根据键值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把键值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<p>哈希函数也称为散列函数，它接受一个键作为输入，并将其映射到哈希表的一个位置上。理想的哈希函数应该能够将键均匀地分布到哈希表的不同位置上，同时具有良好的计算效率。常见的哈希函数包括取余法、乘法哈希法、MD5、SHA等。选择合适的哈希函数取决于应用场景和性能要求。</p>
<p>当两个不同的键经过哈希函数映射后得到相同的位置时，就会发生哈希冲突。为了解决这个问题，常见的冲突解决方法包括：</p>
<ol>
<li><strong>开放定址法（Open Addressing）</strong>：当发生冲突时，顺序地查找下一个可用的位置，直到找到一个空槽位。常见的开放定址法包括线性探测、二次探测、双重哈希等。</li>
<li><strong>链地址法（Chaining）</strong>（最常用）：将哈希表的每个槽位都连接一个链表（或其他数据结构），当发生冲突时，将冲突的元素插入到对应位置的链表中。这样，相同哈希值的元素都存储在同一个链表中。</li>
<li><strong>再哈希法（Rehashing）</strong>：使用另一个哈希函数计算新的哈希值，然后再次查找空槽位。这样可以减少冲突的概率，提高哈希表的性能。</li>
<li><strong>建立公共溢出区</strong>：将哈希表的一部分空间作为溢出区，当发生冲突时，将冲突的元素存储在溢出区中。这样，哈希表的主要部分仍然保持较低的负载因子，提高了性能。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small" data-sub-html="<h2>image-20240601201150022</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png" alt="image-20240601201150022" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large 2x" data-title="image-20240601201150022" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>C/C++ 面试题目总结</title><link>https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 16:11:20 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<ol>
<li>
<p>const知道吗？解释其作用</p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
</li>
<li>
<p>宏定义 #define 和 const 常量</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏定义 #define</th>
<th style="text-align:center">const 常量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">宏定义，相当于字符替换         |</td>
<td style="text-align:center">常量声明    |</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">预处理器处理</font> |</td>
<td style="text-align:center">编译器处理   |</td>
</tr>
<tr>
<td style="text-align:center">无类型安全检查             |</td>
<td style="text-align:center">有类型安全检查 |</td>
</tr>
<tr>
<td style="text-align:center">不分配内存               |</td>
<td style="text-align:center">要分配内存   |</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">存储在代码段</font> |</td>
<td style="text-align:center">存储在数据段  |</td>
</tr>
<tr>
<td style="text-align:center">可通过 <code>#undef</code> 取消          |</td>
<td style="text-align:center">不可取消    |</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>static的作用</p>
<ol>
<li>修饰普通变量，<font color="red">修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间</font>，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，<font color="red">表明函数的作用范围</font>，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，<font color="red">修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员</font>。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，<font color="red">但是在 static 函数内不能访问非静态成员</font>。</li>
</ol>
</li>
<li>
<p>说说this指针</p>
<ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，<strong>编译程序先将对象的地址赋给 <code>this</code> 指针</strong>，然后调用成员函数，<font color="red">每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针</font>。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用<code>this</code>指针：
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>说说inline内联函数</p>
<p>相当于把内联函数里面的内容写在调用内联函数处，即不用执行进入函数的步骤，直接执行函数体；相当于宏，却比宏多了类型检查，真正具有函数特性；编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数（但虚函数也可以是内联函数，但是当虚函数表现出多态性时不能内联）。</p>
<p>优点：</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点：</p>
<ol start="4">
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。<font color="red">内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器</font>。</li>
</ol>
</li>
<li>
<p>说说volatile关键字</p>
<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以<font color="red">使用 volatile 告诉编译器不应对这样的对象进行优化</font>。</li>
<li>volatile 关键字声明的变量，<font color="red">每次访问时都必须从内存中取出值</font>（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
</li>
<li>
<p>说说assert()</p>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p><code>static_assert</code> 是一个编译时断言，用于在编译期间检查常量表达式是否为 <code>true</code>。它定义在 C++11 及更高版本的标准中。<code>static_assert</code> 通常用于模板编程和常量表达式中，以确保某些编译时条件成立。与 <code>assert</code> 不同的是，<code>static_assert</code> 在编译时进行检查，因此它不会影响运行时性能。</p>
</li>
<li>
<p>说说sizeof()</p>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
</li>
<li>
<p><code>#pragma pack(n)</code></p>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐，<code>#pragma pack(pop)</code>  恢复对齐状态</p>
</li>
<li>
<p><code>extern &quot;C&quot;</code></p>
<p>被 <code>extern</code> 限定的函数或变量是 <code>extern</code> 类型的，被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和链接的</p>
</li>
<li>
<p>C++ 中 struct 和 class</p>
<p>总的来说，<font color="red">struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体</font>。</p>
<p>最本质的一个区别就是默认的访问控制，struct 默认的数据访问控制是 public 的，class 默认的成员变量访问控制是 private 的。</p>
</li>
<li>
<p>union 联合</p>
<p>联合（union）是一种节省空间的特殊的类，<font color="red">一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值</font>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
</li>
<li>
<p>C 实现 C++ 类</p>
<p><font color="red">C 实现 C++ 的面向对象特性（封装、继承、多态）</font></p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
</li>
<li>
<p>explicit（显式）关键字</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li>
</ul>
</li>
<li>
<p>friend 友元类和友元函数</p>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
</li>
<li>
<p>谈谈using</p>
<p>using 关键字在 C++ 中有多种用途，主要包括类型别名、引入命名空间中的标识符。并且C++11 引入了别名模板，可以使用 <code>using</code> 创建模板的别名。</p>
<p>尽量少使用 using 指示：<code>using namespace std;</code>，会污染命名空间</p>
</li>
<li>
<p><code>::</code> 范围解析运算符</p>
<ol>
<li>
<p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>         <span class="c1">// 全局（::）的 count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>       <span class="c1">// 测试 1：设置全局的 count 的值为 12
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>   <span class="c1">// 类 A 的 count（A::count）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈<code>decltype</code>关键字</p>
<p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类，返回值为所属类型。语法：<code>decltype ( expression )</code></p>
</li>
<li>
<p>谈谈引用</p>
<p>在 C++ 中，引用（reference）是一种为已存在的变量创建别名的机制。引用可以让你通过另一个名字访问同一个变量。C++ 中的引用主要分为以下几种类型：</p>
<ol>
<li>
<p>左值引用（L-value References）：左值引用用于引用内存中已经存在的对象，通常用于函数参数传递和返回值。</p>
</li>
<li>
<p>右值引用（R-value References）：右值引用在 C++11 引入（<code>int&amp;&amp; rvalueRef = 10</code>），主要用于引用临时对象（右值），支持移动语义和完美转发，优化性能。</p>
</li>
<li>
<p>引用折叠（Reference Collapsing）：引用折叠是一种复杂的规则，决定了多层引用的结果。它在模板编程和完美转发中非常重要。</p>
<p><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code>
<code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></p>
</li>
</ol>
</li>
<li>
<p>成员初始化列表
好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：
<ul>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈面向对象</p>
<p>面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范式，基于“对象”的概念，用于组织代码和数据。OOP 提供了一种更自然和直观的方法来解决复杂的软件问题，使程序设计更加模块化和可维护。面向对象的三大特性：</p>
<ol>
<li><strong>封装（Encapsulation）</strong> ：封装是将数据和操作数据的方法捆绑在一起，形成一个自包含的单元—对象。<font color="red">封装通过定义类中的私有成员变量和公有成员函数，隐藏内部实现细节，只暴露必要的接口。封装提高了代码的安全性和可维护性</font>。</li>
<li><strong>继承（Inheritance）</strong> ：继承是一种机制，<font color="red">通过创建一个新的类（子类），该类可以继承一个或多个已有类（基类）的属性和方法，从而实现代码的重用和扩展</font>。继承支持多态性，并且使得代码更具层次性。</li>
<li><strong>多态（Polymorphism）</strong>：多态是指一个函数或方法可以有多种不同的表现形式。<font color="red">在C++中多态主要通过虚函数和函数重载实现，使得不同的对象可以用统一的接口进行操作，从而提高代码的灵活性和扩展性</font>。</li>
</ol>
</li>
<li>
<p>C++多态</p>
<p>C++ 多态分类及实现：</p>
<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
<li>
<p>谈谈虚析构函数</p>
<p>虚析构函数（Virtual Destructor）是面向对象编程中一个重要的概念，特别是在 C++ 中。它的主要目的是确保在通过基类指针删除派生类对象时，派生类的析构函数能够正确调用，从而防止资源泄漏和未定义行为。</p>
</li>
<li>
<p>在C++中，希望一个类不能被实例化，可以怎么做？</p>
<ol>
<li>
<p><strong>将类声明为抽象基类（Abstract Base Class, ABC）：</strong> <font color="red">如果一个类至少有一个纯虚函数，那么这个类就是抽象基类，无法被实例化</font>。纯虚函数是在基类中声明但不定义的虚函数，它在基类中的声明形式如下：<code>virtual void func() = 0;</code>。纯虚函数使得派生类必须提供自己的实现，否则派生类也将成为抽象基类。</p>
<p>如果其中没有其他合适的函数，可以把析构函数定义为纯虚析构函数</p>
</li>
<li>
<p><strong>声明类的构造函数为protected或private：</strong> 如果一个类的构造函数被声明为<code>protected</code>或<code>private</code>，那么在类的外部就不能直接调用这个构造函数来创建类的对象。只有类本身和它的友元函数或类可以访问它的私有或保护成员。</p>
</li>
</ol>
</li>
<li>
<p>虚函数、纯虚函数</p>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。而纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
</li>
<li>
<p>谈谈虚函数指针、虚函数表</p>
<p>虚函数指针是存储在对象中的特殊指针，用于指向对象的虚函数表。<font color="red">每个对象都有一个虚函数指针，它指向对象的虚函数表的首地址。</font>通过虚函数指针，可以在运行时动态地调用适当的虚函数。</p>
<p>虚函数表是存储在内存中的一张表格，用于存储类的虚函数地址。<font color="red">每个类（含有虚函数的类）都有一个对应的虚函数表，其中存放了该类所有虚函数的地址</font>。虚函数表是在编译阶段创建的，每个类的虚函数表在程序运行时都会存在于内存中。</p>
<p>虚函数指针指向虚函数表的首地址，通过虚函数指针可以访问到对象的虚函数表。当调用对象的虚函数时，编译器会使用虚函数指针找到对象的虚函数表，然后根据函数在虚函数表中的索引找到相应的虚函数地址，并进行调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span><span class="o">*</span> <span class="n">vptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="o">**</span><span class="p">)</span><span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表中第一个虚函数地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">funcAddr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 转换为函数指针并调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">funcAddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">func</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>谈谈虚继承</p>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，<font color="red">每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）</font>（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
</li>
<li>
<p>虚继承、虚函数</p>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：
<ul>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li><font color="red">虚基类表存储的是虚基类相对直接继承类的偏移</font></li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的抽象类、接口类、聚合类</p>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的模板机制</p>
<p>在C++中，模板（Template）是一种通用的代码生成机制，允许程序员编写通用的代码来处理不同类型的数据，而不需要为每种数据类型编写特定的代码。模板是C++中强大的特性之一，它提高了代码的重用性、可读性和可维护性。</p>
<ol>
<li>
<p>类模板（Class Templates）：类模板是一种用于创建通用类的模板，允许类中的数据成员和成员函数的类型参数化。通过类模板，可以定义一个通用的类，可以处理多种不同类型的数据。</p>
</li>
<li>
<p>函数模板（Function Templates）：函数模板是一种用于创建通用函数的模板，允许函数中的参数类型参数化。通过函数模板，可以定义一个通用的函数，可以处理多种不同类型的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">maximum</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板特化（Template Specialization）：模板特化是指针对某些特定的类型，为模板定义一个特殊的实现。当模板在处理特定类型时需要特殊的行为时，可以使用模板特化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Stack&lt;std::string&gt;::pop(): empty stack&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">element</span> <span class="o">=</span> <span class="n">elements</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板参数（Template Parameters）：模板参数是在定义模板时指定的参数，它可以是类型参数或非类型参数。类型参数指定了模板中的数据类型，而非类型参数可以是整数、指针等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>C++的new/delete和malloc/delete有什么区别？</p>
<p>C++中的<code>new</code>和<code>malloc()</code>都用于在堆上动态分配内存，但它们之间有一些重要的区别：</p>
<ol>
<li><code>new</code> 是C++中的关键字，可以为指定的类型动态分配内存，并返回相应类型的指针。而<code>malloc()</code>是C标准库函数，它返回<code>void*</code>类型的指针，需要手动进行类型转换，将其转换为所需类型的指针。这样的操作在C++中不够安全，可能导致编译器无法检测到的类型错误。</li>
<li><code>new</code> 分配内存时会调用对象的构造函数，确保对象被正确初始化。<code>malloc()</code> 只是简单地分配一块内存，并不会调用对象的构造函数。</li>
<li><code>new</code> 可以根据所需类型的大小自动计算要分配的内存空间大小，无需手动计算。而<code>malloc()</code> 需要手动指定要分配的内存空间大小，需要调用<code>sizeof</code>函数来计算所需的字节数。</li>
<li>在内存分配失败时，<code>new</code> 会抛出异常（<code>std::bad_alloc</code>），需要使用异常处理机制来处理。而<code>malloc()</code> 分配内存失败时会返回空指针（<code>NULL</code>），需要手动检查返回值并进行错误处理。</li>
<li>使用<code>new</code>分配的内存需要使用<code>delete</code>关键字进行释放，而使用<code>malloc()</code>分配的内存需要使用<code>free()</code>函数进行释放。</li>
</ol>
<p>本质：<code>new / new[]</code>：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。<code>delete/delete[]</code>：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p>
</li>
<li>
<p>delete this 合法吗？</p>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
</li>
<li>
<p>C++如何定义一个只能在堆上（栈上）生成对象的类？</p>
<ul>
<li>只能在堆上：将析构函数设置为私有。C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li>
<li>只能在栈上：将 new 和 delete 重载为私有。在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li>
</ul>
</li>
<li>
<p>介绍一下C++的智能指针</p>
<p>C++中的智能指针是一种特殊的指针对象，可以自动管理动态分配的内存，避免内存泄漏和悬空指针等常见问题。智能指针通过包装原始指针，提供了自动释放内存的机制，从而简化了内存管理的工作。常见的智能指针包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>（<code>auto_ptr</code>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。）。</p>
<ol>
<li><code>std::unique_ptr</code>是一种独占式智能指针，即同一时间只能有一个<code>std::unique_ptr</code>拥有某个对象的所有权。当<code>std::unique_ptr</code>超出作用域或被显式释放时，它所管理的对象会被自动释放。不能复制或赋值给其他<code>std::unique_ptr</code>，但可以通过<code>std::move()</code>来转移所有权。<font color="red">适用于需要严格所有权管理的情况，例如资源管理类对象</font>。</li>
<li><code>std::shared_ptr</code>是一种共享式智能指针，可以拥有多个<code>std::shared_ptr</code>共享同一个对象。使用引用计数来跟踪对象的引用次数，当引用次数为0时，对象会被自动释放。可以复制和赋值给其他<code>std::shared_ptr</code>，引用计数会增加。<font color="red">适用于需要多个指针共享同一资源的情况，例如多个对象共享一个动态分配的对象</font>。</li>
<li><code>std::weak_ptr</code>是一种弱引用智能指针，它不会增加对象的引用计数，也不会影响对象的生命周期。用于解决<code>std::shared_ptr</code>的循环引用问题，通过打破循环引用，<strong>防止内存泄漏</strong>。可以通过<code>lock()</code>方法获取一个指向被管理对象的<code>std::shared_ptr</code>，如果对象已经被释放，则返回空指针。</li>
</ol>
</li>
<li>
<p>谈谈C++的强制类型转换</p>
<p>在C++中，有四种主要的强制类型转换方式：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。用法：<code>static_cast&lt;typename&gt;(object)</code></p>
<ol>
<li>
<p><code>static_cast</code>用于进行静态类型转换，通常用于较为安全的转换，例如基本数据类型之间的转换、类层次结构中的向上转换（派生类指针转为基类指针）和向下转换（基类指针转为派生类指针）等。<font color="red">静态转换在编译时进行，不提供运行时类型检查</font>。</p>
</li>
<li>
<p><code>dynamic_cast</code>用于进行动态类型转换，用于安全地在类层次结构中进行向上或向下转换，并且提供了运行时类型检查。当进行向下转换时，如果指针不指向有效的派生类对象，则返回空指针。<font color="red">只能用于具有虚函数的类（即多态类）之间的转换。</font></p>
</li>
<li>
<p><code>const_cast</code>用于添加或删除对象的const属性、volatile属性，<font color="red">主要用于消除类型的const限制</font>。注意：不应该用于修改本来就不可修改的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 去除const属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// 合法，修改了const对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>reinterpret_cast</code>用于进行底层的重新解释转换，例如将一个指针转换为一个整数，或者一个整数转换为一个指针。这种转换非常危险，可能会导致未定义的行为，因此应该尽量避免使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 将int指针转换为void指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">newXPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 将void指针转换为int指针
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈运行时类型信息 (RTTI)</p>
<p>运行时类型信息（RTTI, Runtime Type Information）是C++提供的一种机制，用于在运行时识别对象的类型。RTTI允许程序在运行时获取关于对象类型的信息，主要包括两个关键特性：<code>typeid</code>操作符和<code>dynamic_cast</code>操作符。</p>
<ol>
<li><code>typeid</code>操作符用于获取表达式或对象的类型信息。<code>typeid</code>返回一个<code>std::type_info</code>对象，该对象包含了类型的信息，可以通过其成员函数来获取类型名等信息。</li>
<li><code>dynamic_cast</code>用于多态类型的转换</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnotherDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 成功转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AnotherDerived</span><span class="o">*</span> <span class="n">ad</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">AnotherDerived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 转换失败，返回nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is a Derived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is not an AnotherDerived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>RTTI通常用于以下场景：</p>
<ul>
<li><strong>安全类型转换</strong>：在复杂的类层次结构中，使用<code>dynamic_cast</code>进行安全的向下转换，确保类型转换的正确性。</li>
<li><strong>类型检查</strong>：使用<code>typeid</code>进行类型检查，调试和记录对象的实际类型信息，帮助诊断问题。</li>
</ul>
</li>
<li>
<p>谈谈C++中怎么处理异常</p>
<p>在C++中，异常处理是一种机制，用于捕获和处理程序运行过程中发生的错误或异常情况，从而避免程序崩溃。C++通过<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现异常处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能抛出异常的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理标准库异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Standard exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理整型异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Integer exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理其他所有类型的异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unknown exception caught&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>throw</code>表达式用于抛出异常，可以抛出任何类型的对象。</p>
<p>C++允许用户定义自己的异常类，通常继承自<code>std::exception</code>，并重写<code>what()</code>方法来提供异常信息。</p>
</li>
<li>
<p>STL容器</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">有无序</th>
<th style="text-align:center">可不可重复</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机读改 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">支持随机访问，大小固定，不能动态调整</td>
</tr>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">支持随机访问，动态调整大小，使用连续内存存储，插入删除效率视位置而定</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">双端队列</td>
<td style="text-align:center">头尾插入、头尾删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问，但随机访问效率略低于vector</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单向链表</td>
<td style="text-align:center">插入、删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不支持随机访问，只能单向遍历，适用于只需前向访问和修改的场景</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双向链表</td>
<td style="text-align:center">插入、删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不支持随机访问，支持双向遍历，适用于频繁插入和删除的场景</td>
</tr>
<tr>
<td style="text-align:center">stack</td>
<td style="text-align:center">deque / list</td>
<td style="text-align:center">顶部插入、顶部删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">适用于后进先出（LIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
</tr>
<tr>
<td style="text-align:center">queue</td>
<td style="text-align:center">deque / list</td>
<td style="text-align:center">尾部插入、头部删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">适用于先进先出（FIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
</tr>
<tr>
<td style="text-align:center">priority_queue</td>
<td style="text-align:center">vector + max-heap</td>
<td style="text-align:center">插入、删除 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">使用最大堆实现，适用于需要动态获取最大元素的场景，底层使用vector存储</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">自动排序且元素唯一，适用于需要有序且无重复元素的场景</td>
</tr>
<tr>
<td style="text-align:center">multiset</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">自动排序，允许重复元素，适用于需要有序且可重复元素的场景</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">键值对存储，键唯一，自动按键排序，适用于需要按键有序访问且键唯一的场景</td>
</tr>
<tr>
<td style="text-align:center">multimap</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">键值对存储，键可重复，自动按键排序，适用于需要按键有序访问且键可重复的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_set</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">使用哈希表实现，元素唯一，无序存储，适用于快速查找和插入的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_multiset</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">使用哈希表实现，允许重复元素，无序存储，适用于需要快速查找和插入且元素可重复的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_map</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">键值对存储，键唯一，使用哈希表实现，无序存储，适用于需要快速按键查找和插入的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_multimap</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">键值对存储，键可重复，使用哈希表实现，无序存储，适用于需要快速按键查找和插入且键可重复的场景</td>
</tr>
</tbody>
</table>
</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】GFS</title><link>https://hezephyr.github.io/posts/04.gfs/</link><pubDate>Tue, 28 May 2024 16:24:28 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.gfs/</guid><description><![CDATA[<h2 id="分布式存储系统难点" class="heading-element"><span>1 分布式存储系统难点</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f%e9%9a%be%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在设计大型分布式系统或存储系统时，初衷通常是为了获得显著的性能提升，通过数百台计算机的资源来并行完成大量工作。因此，性能问题成为最初的关注点。一个自然的想法是将数据分片（Sharding），分布到大量服务器上，从而并行读取数据。</p>
<p>当你在成百上千台服务器上进行分片时，服务器故障将成为常态。如果你有数千台服务器，每天甚至每小时都可能有服务器宕机。因此，需要自动化的方法来修复错误，而不是依赖人工介入。为此，自动容错系统至关重要，这引出了容错（fault tolerance）的概念。</p>
<p>实现容错最有效的方法之一是使用数据复制，只需维护2-3个数据副本，当其中一个故障时，可以使用另一个。因此，要实现容错，必须进行数据复制（replication）。</p>
<p>然而，数据复制带来了不一致性（inconsistency）问题。拥有多个数据副本，如果管理不当，副本之间可能不一致。理想情况下，可以任意使用任一副本进行容错，但如果副本不一致，应用程序将面临麻烦。因此，数据复制不可避免地会引发不一致性问题。</p>
<p>通过精巧的设计，可以减少甚至避免不一致性，使数据表现得符合预期。但要实现这一点，服务器之间需要进行额外的网络交互，这会降低性能。因此，如果追求一致性（consistency），必须付出性能的代价，这与最初的高性能目标相悖。</p>
<p>尽管可以构建高性能系统，但不可避免地会陷入性能与一致性的权衡之中。在实际应用中，为了获得良好的一致性，必须付出相应的代价。如果不愿付出代价，就需要忍受一定程度的不确定性。很多系统中都存在这种权衡，人们往往不愿为高一致性牺牲性能。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=small" data-sub-html="<h2>image-20240528101751499</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png" alt="image-20240528101751499" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DS_Why_Hard.png?size=large 2x" data-title="image-20240528101751499" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="错误的设计" class="heading-element"><span>2 错误的设计</span>
  <a href="#%e9%94%99%e8%af%af%e7%9a%84%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于强一致性系统，应用程序或客户端感受到的就像在与一台服务器通信。尽管系统由数百台计算机组成，但理想的强一致模型让它看起来像只有一台服务器，一份数据，并且一次只处理一个请求。这种设计确保了每个请求能看到之前所有请求按顺序执行的结果。</p>
<p>对于存储服务器来说，它通常包含一块磁盘。执行写请求可能意味着向磁盘写入数据或对数据进行自增操作。如果是一次修改操作，并且我们有一个以 key-value 为索引的数据表单，那么我们会更新这个表单。如果是读取操作，只需从表单中取出之前写入的数据即可。为了保证这个简单服务的行为可预期，需要遵循一个规则：每次只执行一个请求。这样，每个请求都能看到之前所有请求按顺序执行后的结果。如果服务器按某种顺序依次处理写请求，当你读取数据时，你就能看到预期的数据。</p>
<p>举例来说，客户端 C1 发起写请求将 X 设置为 1，同时客户端 C2 发起写请求将 X 设置为 2。待 C1 和 C2 的写请求都执行完毕后，客户端 C3 发送读取 X 的请求，得到一个结果；客户端 C4 也发送读取 X 的请求，得到另一个结果。此时，问题是这两个客户端看到的结果会是什么。</p>
<p>即使在一个非常简单的系统中，仍会出现一些模糊场景，使你无法确定系统的执行过程及其输出结果。你只能根据结果判断系统是否保持了一致性。</p>
<p>如果 C3 读取 X 得到 2，那么 C4 也应该读取到 2，因为这表明写 X 为 2 的请求是第二个执行的写请求。当 C4 读取 X 时，写 X 为 2 应该仍然是第二个写请求。</p>
<p>然而，单服务器设计存在容错能力差的问题。如果服务器故障或磁盘损坏，系统将无法使用。因此，现实中我们会构建多副本的分布式系统，这引发了一系列新的问题。</p>
<p>假设我们有两台服务器，每台服务器都有数据的一份完整拷贝，并在磁盘上存储一个 key-value 表单。我们希望这两个表单完全一致，这样当一台服务器故障时，可以切换到另一台服务器继续读写操作。</p>
<p>两个表单完全一致意味着，<font color="red">每一个写请求都必须在两台服务器上执行，而读请求只需要在一台服务器上执行</font>，否则就没有容错性了。因为如果读请求也需要从两台服务器读数据，那么一台服务器故障我们就没法提供服务了。现在问题来了，假设客户端C1和C2都想执行写请求，其中一个要写X为1，另一个写X为2。C1会将写X为1的请求发送个两个服务器，因为我们想要更新两台服务器上的数据。C2也会将写X为2的请求发送给两个服务器。</p>
<p>这里会出现什么错误呢？是的，我们没有做任何事情来保障两台服务器以相同的顺序处理这2个请求。如果服务器1（S1）先处理C1的请求，那么在它的表单里面，X先是1，之后S1看到了来自C2的请求，会将自己表单中的X覆盖成2。但是，如果S2恰好以不同的顺序收到客户端请求，那么S2会先执行C2的请求，将X设置为2，之后收到C1的请求，将X设置为1。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=small" data-sub-html="<h2>image-20240528104959963</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png" alt="image-20240528104959963" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/inconsistent_example.png?size=large 2x" data-title="image-20240528104959963" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>之后，如果另外一些客户端，假设C3从S1读数据，C4从S2读数据，我们就会面临一个可怕的场景：这两个客户端读取的数据不一样。但是从前一个例子中的简单模型可以看出，相连的读请求应该读出相同的数据。</p>
<p>这里的问题可以以另一种方式暴露出来。假设我们尝试修复上面的问题，我们让客户端在S1还在线的时候，只从S1读取数据，S1不在线了再从S2读取数据。这样最开始所有的客户端读X都能得到2。但是突然，如果S1故障了，尽管没有写请求将X改成1，客户端读X得到的数据将会从2变成1。因为S1故障之后，所有的客户端都会切换到S2去读数据。这种数据的神奇变化与任何写操作都没有关联，并且也不可能在前一个例子的简单模型中发生。</p>
<p>当然，这里的问题是可以修复的，修复需要服务器之间更多的通信，并且复杂度也会提升。由于获取强一致会带来不可避免的复杂性的提升，有大量的方法可以在好的一致性和一些小瑕疵行为之间追求一个平衡。</p>
<h2 id="gfs设计目标" class="heading-element"><span>3 GFS设计目标</span>
  <a href="#gfs%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Google的目标是构建一个大型且快速的文件系统（GFS），以便各种应用程序都能全局访问数据。传统的方法是为每个应用程序构建特定的存储系统，但这会导致重复建设。GFS 作为一个全局通用的存储系统，允许不同应用程序共享和访问数据。例如，存储了大量互联网抓取数据后，其他用户可以通过申请权限查看这些数据，因为大家使用的是同一个存储系统。这样，Google 内部的人员可以根据名字读取 GFS 中可共享的内容。</p>
<p>为了实现大容量和高速性能，GFS 将数据文件自动分割并存储在多台服务器上，这样可以并行读取同一个文件，从而获得更高的聚合吞吐量。文件分割存储还允许存储比单个磁盘更大的文件。由于存储系统分布在数百台服务器上，GFS 具备自动故障修复功能，不需要人工干预来修复服务器或迁移数据。</p>
<p>GFS 的一些特征并非设计目标。例如，GFS 只在一个数据中心内运行，多个副本并未分布在全球各地。理论上，数据副本应该地理分散，但实现起来很难，所以 GFS 局限于单个数据中心内。</p>
<p>此外，GFS 面向 Google 内部使用，供工程师开发应用程序，并不直接面向普通用户。虽然 Google 可能会出售基于 GFS 的服务，但 GFS 本身并不对外提供。</p>
<p>最后，GFS 专注于对大型顺序文件的读写优化。例如，银行账户系统需要能够读写小数据块的数据库，而 GFS 针对 TB 级别的文件进行优化，只支持顺序处理而非随机访问。某种程度上，它更像批处理系统，注重巨大的吞吐量而非低延迟，每次操作都涉及 MB 级别的数据。</p>
<h2 id="master节点" class="heading-element"><span>4 Master节点</span>
  <a href="#master%e8%8a%82%e7%82%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>假设我们有上百个客户端和一个Master节点。虽然实际中可以有多台机器作为Master节点，但GFS中Master采用Active-Standby模式（系统包含两个或多个实例，其中一个实例（Active）正在运行并处理所有的请求，而其他实例（Standby）则处于待命状态，准备在Active实例发生故障时立即接管工作。），所以只有一个Master节点在工作。Master节点保存了文件名和存储位置的对应关系。除此之外，还有大量的Chunk服务器，每个Chunk服务器上都有1-2块磁盘。</p>
<p>Master节点管理文件和Chunk的信息，而Chunk服务器存储实际数据。这种设计将管理和存储分开处理，提高了系统效率。在GFS中，Master节点知道每个文件对应的所有Chunk handle，这些Chunk每个是64MB大小，共同构成一个文件。例如，一个1GB的文件会分成多个Chunk，Master节点知道每个Chunk存储在哪。读取文件时，需要先向Master节点查询Chunk位置，然后从对应的Chunk服务器读取数据。</p>
<p>我们需要了解Master节点内保存的数据内容，这里我们关心的主要是两个表单：</p>
<ol>
<li><strong>文件名到Chunk handle的对应关系</strong>：Master节点有一个表单记录了文件名到Chunk handle数组的对应关系。</li>
<li><strong>Chunk handle到Chunk数据的对应关系</strong>：另一个表单记录了Chunk handle和它们的数据的对应关系，包括每个Chunk的服务器列表、当前版本号、主Chunk（Primary Chunk）和租约过期时间。</li>
</ol>
<p>这些数据都存储在内存中，但为了防止数据丢失，Master节点也将部分数据存储在磁盘上。Master节点的写操作会记录到磁盘的日志（log）中，并定期生成检查点（CheckPoint）。</p>
<p>有些数据需要存在磁盘上，而有些不用。它们分别是：</p>
<ul>
<li><strong>Chunk Handle数组</strong>（非易失性，NV）：保存到磁盘上。</li>
<li><strong>Chunk服务器列表</strong>（易失性，V）：不用写入磁盘，重启后可重新获取。</li>
<li><strong>版本号</strong>（非易失性，NV）：写入磁盘，确保数据一致性。</li>
<li><strong>主Chunk的handle</strong>（易失性，V）：不写入磁盘，重启后可重新分配。</li>
<li><strong>租约过期时间</strong>（易失性，V）：不写入磁盘。</li>
</ul>
<p>当文件扩展到新的64MB或主Chunk变更时，Master节点会向磁盘日志中追加记录。这种日志追加方式比数据库高效，因为它只需顺序写入，不涉及磁盘的随机访问。</p>
<p>Master节点故障重启时，会从最近的检查点开始恢复状态，然后通过执行日志中的记录恢复到最新状态。这种方式避免了从日志最开始重建状态的低效问题。</p>
<h2 id="读文件" class="heading-element"><span>5 读文件</span>
  <a href="#%e8%af%bb%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于读请求来说，应用程序或GFS客户端会提供一个文件名和读取的偏移量（offset）。首先，客户端将这些信息发送给Master节点。Master节点从自己的文件表单中查找文件名，获取对应的Chunk handle数组。每个Chunk大小为64MB，因此可以通过偏移量除以64MB来确定对应的Chunk handle。接着，Master节点从Chunk表单中找到包含该Chunk的服务器列表，并将这个列表返回给客户端。</p>
<p>具体步骤如下：</p>
<ol>
<li>客户端（或应用程序）将文件名和偏移量发送给Master节点。</li>
<li>Master节点将Chunk Handle（即Chunk ID）和服务器列表发送给客户端。</li>
</ol>
<p>客户端接下来可以从服务器列表中选择一个服务器来读取数据。根据GFS论文的描述，客户端会选择一个在网络上最近的服务器（在Google的数据中心中，通过IP地址的差异可以判断网络位置的远近），然后将读请求发送到这个服务器。由于客户端每次可能只读取1MB或64KB的数据，它可能会多次读取同一个Chunk的不同部分。为此，客户端会缓存Chunk和服务器的对应关系，这样在后续读取相同Chunk数据时，不需要每次都向Master请求相同的信息。</p>
<p>接下来，客户端会与选定的Chunk服务器通信，将Chunk Handle和偏移量发送给该服务器。Chunk服务器在本地硬盘上将每个Chunk存储为独立的Linux文件，并通过普通的Linux文件系统进行管理。可以推测，Chunk文件会按照Handle（即ID）命名。因此，Chunk服务器需要做的就是根据文件名找到对应的Chunk文件，从文件中读取相应的数据段，并将数据返回给客户端。</p>
<h2 id="写文件" class="heading-element"><span>6 写文件</span>
  <a href="#%e5%86%99%e6%96%87%e4%bb%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于应用程序来说，写文件的过程与读文件的接口非常类似，都是通过调用GFS的库函数进行操作。在写文件时，应用程序会告诉库函数，要将缓冲区中的数据追加到指定文件中。为了简化讨论，我们只考虑GFS论文中的记录追加（Record Append）的情况。</p>
<p>所以再次描述一下，对于写文件，客户端会向Master节点发送请求说：我想向这个文件名对应的文件追加数据，请告诉我文件中最后一个Chunk的位置。</p>
<p>当有多个客户端同时写同一个文件时，一个客户端并不能知道文件究竟有多长。因为如果只有一个客户端在写文件，客户端自己可以记录文件长度，而多个客户端时，一个客户端没法知道其他客户端写了多少。例如，不同客户端写同一份日志文件，没有一个客户端会知道文件究竟有多长，因此也就不知道该往什么样的偏移量，或者说向哪个Chunk去追加数据。这个时候，客户端可以向Master节点查询哪个Chunk服务器保存了文件的最后一个Chunk。</p>
<p>对于读操作，可以从任何最新的Chunk副本读取数据，但写操作必须通过Chunk的主副本（Primary Chunk）进行。Master节点需要确保Chunk的主副本存在。如果不存在，Master节点会查找所有存有该Chunk最新副本的Chunk服务器。Master节点确定哪些副本是最新的（副本中保存的版本号与Master中记录的Chunk的版本号一致），并从中选择一个作为Primary，其余作为Secondary。</p>
<p>之后，Master节点增加Chunk的版本号，并将新的版本号写入磁盘。Master节点通知Primary和Secondary服务器新的Chunk版本号，并指定它们的角色。Primary和Secondary服务器将新版本号存储在本地磁盘中，以便在重启时报告给Master。</p>
<p>所以客户端将要追加的数据发送给Primary和Secondary服务器，这些服务器将数据写入临时位置。所以最开始，这些数据不会追加到文件中。当所有服务器确认数据已写入临时位置后，客户端向Primary发送消息，要求将数据追加到文件中。Primary按照顺序处理来自多个客户端的并发请求，确保每次只执行一个请求。Primary将数据写入Chunk的末尾，并通知所有Secondary服务器也将数据写入它们的Chunk末尾。</p>
<p>Secondary服务器将数据写入本地磁盘后，向Primary发送确认消息。如果所有Secondary服务器成功写入数据并回复“yes”，Primary向客户端返回写入成功。如果任何Secondary服务器写入失败，Primary向客户端返回写入失败。</p>
<p>如果客户端接到写入失败的消息，应重新发起整个追加过程。首先，客户端再次与Master节点交互，找到文件末尾的Chunk，然后重新向Primary和Secondary发起追加操作。</p>
<h2 id="gfs的一致性" class="heading-element"><span>7 GFS的一致性</span>
  <a href="#gfs%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在GFS中，追加数据的过程相对复杂。我们通过一个例子来解释这一过程。</p>
<ol>
<li>
<p>**数据追加请求：**客户端发送一个追加数据的请求，例如数据A，要将数据A追加到文件末尾。Chunk的三个副本（一个Primary和两个Secondary）都成功将数据A追加到了Chunk中，因此Chunk中的第一个记录是A。</p>
</li>
<li>
<p>**网络问题导致的部分写入：**第二个客户端加入，想要追加数据B。但由于网络问题，消息只被Primary和一个Secondary收到并处理。因此，两个副本追加了数据B，而另一个副本没有。</p>
</li>
<li>
<p>**后续写入：**第三个客户端想要追加数据C，并且Primary选择了偏移量并通知Secondary。三个副本都成功追加了数据C。</p>
</li>
<li>
<p>**处理写入失败：**由于网络问题，第二个客户端会收到写入失败的回复，并重新发起追加数据B的请求。假设这次数据B没有丢包，三个副本都成功追加了数据B。现在，三个副本都在线，并且都有最新的版本号。</p>
</li>
<li>
<p>**读取数据的影响：**客户端读取文件时，读取的内容取决于读取的是哪个副本。例如：</p>
<ul>
<li>读取第一个副本时，可能会看到数据A、B、C，然后是重复的B。</li>
<li>读取第三个副本时，可能会看到数据A、一个空白数据、然后是C、B。</li>
</ul>
<p>所以不同的读请求可能得到不同的结果，具体取决于读取的是哪个副本。</p>
</li>
<li>
<p>**处理写入失败的复杂情况：**在最坏情况下，某个Secondary未能成功执行数据追加操作，客户端从Primary收到写入失败的回复。在客户端重新发送写文件请求之前，客户端可能故障，导致数据D只存在于某些副本中，而其他副本完全没有。</p>
</li>
</ol>
<p>在GFS的这种工作方式下，如果Primary返回写入成功，一切正常。如果Primary返回写入失败，不同副本的数据可能不同。GFS的设计简单，但可能会暴露一些奇怪的数据顺序问题。应用程序需要容忍数据乱序，或通过在文件中写入序列号来识别顺序。如果应用程序对数据顺序敏感，可以避免并发写入，例如，电影文件的写入应使用一个客户端顺序追加数据。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=small" data-sub-html="<h2>4f013eecba1d5a096fdac0325605e35f</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png" alt="4f013eecba1d5a096fdac0325605e35f" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS_Write_Example.png?size=large 2x" data-title="4f013eecba1d5a096fdac0325605e35f" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果要将GFS升级为强一致系统，需要考虑以下几点：</p>
<ol>
<li>**检测重复请求：**Primary需要能够检测重复的请求，确保数据不会重复写入。</li>
<li>**Secondary的强制执行：**Secondary必须执行Primary的请求，而不能简单地返回错误。对于永久性故障的Secondary，需要有机制将其移除。</li>
<li>**两阶段提交：**写请求需要两个阶段：首先Primary向Secondary发出请求并等待确认；如果所有Secondary都确认，Primary再指示实际执行操作。</li>
<li>**处理Primary崩溃：**当Primary崩溃时，新Primary需要与Secondary同步，确保操作历史一致。</li>
<li>**Secondary的租约系统：**Secondary需要一个类似Primary的租约系统，确保在合法时间内响应客户端请求。</li>
</ol>
<p>总体而言，GFS取得了巨大的成功，许多Google的应用都依赖于它。例如，BigTable和MapReduce等关键基础架构都是构建在GFS之上的，因此GFS在Google内部得到了广泛应用。然而，GFS也有其局限性，最严重的问题在于它只有一个Master节点，这带来了以下几个问题：</p>
<ol>
<li>
<p>**内存限制：**Master节点必须为每个文件和每个Chunk维护表单。随着使用量的增加，文件数量不断上升，最终Master节点会耗尽内存来存储这些表单。虽然可以增加内存，但单台计算机的内存总有上限，这成为了早期遇到的一个显著问题。</p>
</li>
<li>
<p>**处理能力：**单个Master节点需要处理数千个客户端的请求，而其CPU每秒只能处理数百个请求。尤其当Master节点还需要将部分数据写入磁盘时，这个问题变得更加严重，导致客户端数量很快超过了单个Master的处理能力。</p>
</li>
<li>
<p>**复杂的语义：**应用程序发现很难处理GFS复杂的语义，特别是副本数据同步问题（或不同步问题），这在一定程度上增加了开发难度。</p>
</li>
<li>
<p>**故障切换：**从GFS论文中可以了解到，Master节点的故障切换不是自动的。当Master节点永久故障时，需要人工干预来更换新的服务器，这可能需要几十分钟甚至更长时间来处理。对于某些应用程序来说，这样的停机时间是不可接受的。</p>
</li>
</ol>
<h2 id="faq" class="heading-element"><span>8 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li>应用程序如何知道Chunk的哪些部分由填充和重复记录组成？</li>
</ol>
<p>为了检测填充，应用程序可以在有效记录的开头放置一个可预测的幻数，或者包含一个校验和，该校验和可能仅在记录有效时才有效。应用程序可以通过在记录中包含唯一 ID 来检测重复项。然后，如果它读取的记录与之前的记录具有相同的 ID，它就知道它们是彼此的重复项。 GFS 为处理这些情况的应用程序提供了一个库。 GFS 设计的这一方面有效地将复杂性从 GFS 转移到了应用程序，但这可能并不理想。</p>
<ol start="2">
<li>怎样知道一个文件存储在哪台机器上？</li>
</ol>
<p>根据master中文件到chunk再到chunk位置的映射来定位具体的chunkserver。</p>
<ol start="3">
<li>论文提到了引用计数——它们是什么？</li>
</ol>
<p>它们是快照写时复制实现的一部分。当GFS创建快照时，它不会复制块，而是增加每个块的引用计数器。这使得创建快照的成本很低。如果客户端写入一个chunk并且主服务器注意到引用计数大于 1，则主服务器首先创建一个副本，以便客户端可以更新该副本（而不是属于快照一部分的块）。您可以将此视为延迟复制，直到绝对必要为止。希望并非所有块都会被修改，并且可以避免制作一些副本。</p>
<ol start="4">
<li>什么是租约？</li>
</ol>
<p>对于 GFS，租约是master授予 chunkserver 充当特定 chunk 的主chunkserver的能力的一段时间。master保证在租约期间不会分配不同的主chunkserver，并且主服务器同意在租约到期之前停止充当主chunkserver（除非主chunkserver要求master延长租约）。租约是避免主chunkserver必须反复询问master是否仍然是主chunkserver的一种方法—它知道它可以在下一分钟（或无论租约间隔是多少）充当主chunkserver，而无需再次与master通信。</p>
<ol start="5">
<li>什么是内部碎片？为什么惰性分配有帮助？</li>
</ol>
<p>内部碎片是当系统使用大于所请求分配所需的分配单元时浪费的空间。如果 GFS 以 64MB 为单位分配磁盘空间，那么一个 1 字节的文件将浪费近 64MB 的磁盘空间。 GFS 通过延迟分配磁盘空间来避免这个问题。每个块都是一个Linux文件，Linux文件系统使用的块大小为几十KB；<font color="red">因此，当应用程序创建一字节 GFS 文件时，该文件的块仅消耗 1 个 Linux 磁盘块，而不是 64 MB</font>。</p>
<ol start="6">
<li>Google 还在使用 GFS 吗？</li>
</ol>
<p>有传言称 GFS 已被 Colossus 所取代，总体目标相同，但在主性能和容错性方面有所改进。此外，Google内部的许多应用程序已经转向更多类似数据库的存储系统，例如BigTable和Spanner。然而，GFS 的大部分设计仍然存在于 HDFS（Hadoop 开源 MapReduce 的存储系统）中。</p>
</blockquote>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】 测试分布式系统的线性一致性</title><link>https://hezephyr.github.io/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Wed, 22 May 2024 09:33:17 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description><![CDATA[<p><a href="https://anishathalye.com/testing-distributed-systems-for-linearizability/"target="_blank" rel="external nofollow noopener noreferrer">Testing Distributed Systems for Linearizability 原文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="引言" class="heading-element"><span>1 引言</span>
  <a href="#%e5%bc%95%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>正确实现一个分布式系统是非常有挑战的一件事情，因为需要很好的处理并发和失败这些问题。网络包可能被延迟，重复，乱序或者丢弃，机器可能在任何时候宕机。即使一些计被论文证明是正确的，也仍然很难再实现中避免 bug。</p>
<p>除非我们使用形式方法，不然，即使我们假设实现是正确的，我们也需要去测试系统。测试分布式系统也是一件非常有挑战的事情。并发和不确定性使得我们在测试的时候非常难抓住 bug，尤其是在一些极端情况下面才会出现的 bug，譬如同时机器宕机或者极端网络延迟。</p>
<h2 id="正确性" class="heading-element"><span>2 正确性</span>
  <a href="#%e6%ad%a3%e7%a1%ae%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在讨论测试分布式系统的正确性之前，我们首先定义下什么是 “正确性”。即使对于一些简单的系统，要完全的确定系统符合预期也是一件相当复杂的事情。</p>
<p>考虑一个简单的 key-value store，譬如 etcd，支持两个操作：<code>Put(key, value)</code> 和 <code>Get(key)</code>，首先，我们需要考虑它在顺序情况下面的行为。</p>
<h3 id="顺序规范" class="heading-element"><span>2.1 顺序规范</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e8%a7%84%e8%8c%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通常对于一个 key-value store，我们对于它在顺序操作下面的行为都能有一个直观的认识：<code>Get</code> 操作如果在 <code>Put</code> 的后面，那么一定能得到 <code>Put</code> 的结果。譬如，如果 <code>Put(&quot;x&quot;, &quot;y&quot;)</code> ，那么后面的 <code>Get(&quot;x&quot;)</code> 就能得到 &ldquo;y&rdquo;，如果得到了 &ldquo;z&rdquo;，那么这就是不对的。</p>
<p>我们使用 Python 定义一个简单的 key-value store：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522085001276.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>上面的代码比较简单，但包含了足够的信息，包括初始状态是怎样的，内部状态是如何被操作的结果改变的，从 key-value存储里面操作返回的结果是怎样的。这里需要留意下 <code>Get()</code> 对于不存在的 key 的处理，通常会返回一个空字符串。</p>
<h2 id="线性一致性" class="heading-element"><span>3 线性一致性</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>接下来，我们来考虑我们的 key-value store在并发下面会有怎样的行为。需要注意顺序规范并没有指明在并发操作下面会发生什么。譬如，顺序规范并没有说 key-value store 在下面这个场景下可以允许的操作。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们并不能立刻知道 <code>Get(&quot;x&quot;)</code> 这个操作会允许返回怎样的结果。直觉上，我们可以说<code>Get(&quot;x&quot;)</code> 是跟 <code>Put(&quot;x&quot;, &quot;y&quot;)</code> 和 <code>Put(&quot;x&quot;, &quot;z&quot;)</code> 一起执行的，所以它能可能返回一个值，甚至也可能返回 <code>&quot;&quot;</code>。 如果有另一个 <code>Get(&quot;x&quot;)</code> 的操作在更后面执行，我们可以说这个一定能返回 <code>&quot;z&quot;</code>，因为它是最后一次写入的值，而且那个时候并没有其他的并发写入。</p>
<p>对于一个基于顺序规范的并发操作来说，我们会用一个一致性模型，也就是线性一致性来说明它的正确性。在一个线性一致性的系统里面，任何操作都可能在调用或者返回之间原子和瞬间执行。除了线性一致性，还有一些其他一致性的模型，但多数分布式系统都提供了线性一致性的操作：线性一致性是一个强的一致性模型，并且基于线性一致性系统，很容易去构建其他的系统。考虑到如下对 key-value store 操作的历史例子：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640.jpeg?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这个历史是一个线性的。在下面图片的蓝色地方，我们现实的标明了线性一致的点。这个顺序历史 <code>Put(&quot;x&quot;, &quot;0&quot;)</code>, <code>Get(&quot;x&quot;) -&gt; &quot;0&quot;</code>, <code>Put(&quot;x&quot;, &quot;1&quot;)</code>, <code>Get(&quot;x&quot;) -&gt; &quot;1&quot;</code>，对于顺序规范来说就是一个正确的历史。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921831.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>对应的，下面的历史就不是线性一致的。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084921964.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>对于顺序规范来说，这个历史并不是线性一致的：我们并不能在这个历史的操作里面指定出线性一致的点。我们可以画出 client 1，2 和 3 的，但我们并不能画出 client 4 的，因为这明显是一个过期的值。类似的，我们可以画出 client 1，2 和 4 的，那么 client 2 的操作一定会在 4 的操作开始的后面，但这样我们就不能处理 client 3，它只可能合法的返回 <code>&quot;&quot;</code>或者 <code>&quot;0&quot;</code>。</p>
<h2 id="测试" class="heading-element"><span>4 测试</span>
  <a href="#%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有了一个正确性的定义，我们就可以考虑如何去测试分布式系统了。通常的做法就是对于正确的操作，不停的进行随机的错误注入，类似机器宕机，网络隔离等。我们甚至能模拟整个网络，这样我们就能做长时间的网络延迟等。因为测试时随机的，我们需要跑很多次从而确定一个系统的实现是正确的。</p>
<h3 id="临时测试" class="heading-element"><span>4.1 临时测试</span>
  <a href="#%e4%b8%b4%e6%97%b6%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们实际如何做正确操作的测试呢？在最简单的软件里面，我们可以使用输入输出测试，譬如 <code>assert(expected_output == f(input))</code>，我们也可以在分布式系统上面使用一个类似的方法，譬如，对于 key-value store，当多个 client 开始执行操作的时候，我们可以有如下的测试：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922095.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果测试挂掉了，那么这个系统一定不是线性一致性的，当然，这个测试并不是很完备，因为有可能不是线性一致的系统也可能通过这个测试。</p>
<h3 id="线性一致性-1" class="heading-element"><span>4.2 线性一致性</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个更好的办法就是并发的客户端完全跑随机的操作。譬如，循环的去调用 <code>kvstore.put(rand(), rand())</code> 和 <code>kvstore.get(rand())</code>，有可能会只用很少的 key 去增大冲突的概率。但在这种情况下，我们如何定义什么是正确的操作呢？在上面的简单的测试里面，因为每个 client 都操作的是一个独立的 key，所以我们可以非常明确的知道输出结果。</p>
<p>但是 clients 并发的操作同一堆 keys，事情就变得复杂了。我们并不能预知每个操作的返回值因为这并没样一个唯一的答案。但我们可以用另一个办法：我们可以记录整个操作的历史，然后去验证这个操作历史是线性一致的。</p>
<h4 id="线性一致性验证" class="heading-element"><span>4.2.1 线性一致性验证</span>
  <a href="#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7%e9%aa%8c%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">一个线性一致性验证器会使用一个顺序规范和一个并发操作的历史，然后执行一个判定程序去检查这个历史在规范下面是否线性一致。</font></p>
<h4 id="np-完备" class="heading-element"><span>4.2.2 NP 完备</span>
  <a href="#np-%e5%ae%8c%e5%a4%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>但不幸的是，线性一致性验证是 NP 完备的。这个证明非常简单：我们能说明线性一致性验证是 NP 问题，并且也能展示一个 NP 困难问题能被简化成线性一致性验证。明显的，线性一致性验证是 NP 问题，譬如，所有操作的线性一致性点，根据相关的顺序规范，我们可以在多项式时间里验证。</p>
<p>为了说明线性一致性验证是 NP 困难的，我们可以将子集合问题简化成线性一致性验证。对于子集合问题，我们给出非负数的集合 $S={s_1,s_2,…,s_n}$ 和目标结果 $t$，然后我们必须确定是否存在一个子集 $S$ 的和等于 $t$。我们可以将这个问题简化成如下的线性一致性验证。考虑顺序规范：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922224.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>以及历史：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/640-20240522084922368.jpeg" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>当且仅当子集和问题的答案为“是”时，该历史才可线性化。如果历史是可线性化的，那么我们可以采用在 <code>Get()</code> 操作之前具有线性化点的所有操作 <code>Add(s_i)</code> ，并且这些操作对应于中的元素 $s_i$总和为 $t$ 的子集。如果该集合确实有一个总和为$t$的子集，那么我们可以通过与子集中的元素$s_i$对应的操作 <code>Add(s_i)</code> 来构造线性化放置在 <code>Get()</code> 操作之前，并使其余操作发生在 <code>Get()</code> 操作之后。</p>
<h4 id="实现" class="heading-element"><span>4.2.3 实现</span>
  <a href="#%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>即使线性一致性验证是 NP 完全的，在实际中，它仍然能在一些小的历史上面很好的工作。线性一致性验证器的实现会用一个可执行的规范，加上一个历史，执行一个搜索过程去构造一个线性化，并使用一些技巧来限制减少搜索的空间。</p>
<p>现有的线性化检查器如 Knossos，用于 Jepsen 测试系统。但不幸的是，在测试一些分布式 key-value store 的时候，Knossos 并不能很好的工作，它可能只能适用于一些少的并发 clients，以及只有几百的事件的历史。但在一些测试里面，有很多的 clients，以及会生成更多的历史事件。</p>
<p>为了解决 Knossos 的问题，作者开发了 Procupine，一个用 Go 写的更快的线性一致性验证工具。Porcupine 使用一个用 Go 开发的执行规范去验证历史是否是线性的。根据实际测试的情况，Porcupine 比 Knossos 快很多倍。</p>
<p><a href="https://github.com/anishathalye/porcupine"target="_blank" rel="external nofollow noopener noreferrer">Procupine Github<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h4 id="效果" class="heading-element"><span>4.2.4 效果</span>
  <a href="#%e6%95%88%e6%9e%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>使用故障注入和线性化检查来测试可线性化分布式系统是一种有效的方法。</p>
<p>作为对比，在使用专门的测试用 Porcupine 测试 key-value store 的时候，作者使用了这两种方式。作者在实现它自己的 key-value store 的时候引入不同的设计错误，譬如在修改之后会出现过期读，来看这些测试是否会挂掉。专门测试会捕捉到很多 bugs，但并没有能力去捕捉到更多的狡猾的 bugs。相对而言，作者现在还没找到一个正确性的 bug 是线性一致性测试不能抓住的。</p>
<ol>
<li>形式方法能够保证一个分布式系统的正确性。例如，UM PLSE 研究小组最近使用 Coq proof assistnt 来验证了 Raft 一致性协议。但不幸的的是，验证需要特定的知识，另外验证实际的系统需要做大量的工作。没准有一天，验证能被用在实际系统上面，但现在，主要还是测试，而不是验证。</li>
<li>理论上，所有的生产系统都会有一个形式规范，而且一些系统也已经有了，譬如 Raft 就有一个用 TLA+ 写的形式规范。但不幸的是，大部分的系统是没有的。</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程</title><link>https://hezephyr.github.io/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 15 May 2024 09:55:12 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/</guid><description><![CDATA[<h2 id="为什么选择go" class="heading-element"><span>1 为什么选择Go</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9go" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在实现分布式系统时，选择合适的编程语言非常重要。Go有以下特点：</p>
<ul>
<li>优秀的线程支持；</li>
<li>便捷的RPC机制、类型；</li>
<li>内存安全以及垃圾回收机制。</li>
</ul>
<p>这使Go成为了一个理想的选择。Go不仅相对简单，而且其垃圾回收机制使线程管理更加容易，避免了使用后释放问题。由于这些优势，Go在分布式系统中被广泛应用。</p>
<p><a href="https://golang.org/doc/effective_go.html"target="_blank" rel="external nofollow noopener noreferrer">Go Tutorial<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="线程与go中的goroutine" class="heading-element"><span>2 线程与Go中的Goroutine</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e4%b8%8ego%e4%b8%ad%e7%9a%84goroutine" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>线程是一种有用的结构工具，允许一个程序同时执行多项任务，每个线程串行执行，就像非线程程序一样。Go中称线程为Goroutine，每个Goroutine在执行时包含自己的程序计数器、寄存器和栈，但共享内存。使用线程可以提高I/O并发性和多核性能，同时也方便后台任务的处理。</p>
<h3 id="为什么使用线程" class="heading-element"><span>2.1 为什么使用线程？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>I/O并发性</strong>：客户端可以并行向多个服务器发送请求并等待回复，服务器可以同时处理多个客户端请求。</li>
<li><strong>多核性能</strong>：在多核处理器上并行执行代码，提高计算效率。</li>
<li><strong>便捷性</strong>：后台线程可以定期检查各个<code>worker</code>线程是否仍然活跃。</li>
</ol>
<h3 id="线程的替代方案" class="heading-element"><span>2.2 线程的替代方案</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>事件驱动编程（Event-driven programming）是一种替代传统多线程编程的方式，通过在单线程中显式交错处理活动来实现I/O并发性。这种编程模型常用于处理大量I/O操作的场景，例如网络服务器和图形用户界面（GUI）应用。</p>
<p>在事件驱动编程中，系统维护一个事件循环（event loop），不断检查并处理事件队列中的事件。每个事件通常对应某种外部输入或状态变化，如网络请求到达、用户点击按钮或定时器到期。事件处理程序（event handler）被注册到特定事件上，当相应事件发生时，处理程序被调用来执行预定义的操作。</p>
<h3 id="线程编程挑战" class="heading-element"><span>2.3 线程编程挑战</span>
  <a href="#%e7%ba%bf%e7%a8%8b%e7%bc%96%e7%a8%8b%e6%8c%91%e6%88%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>安全共享数据</strong>：多个线程同时访问共享数据时可能导致竞争条件，常用的解决方案是使用锁（如Go的<code>sync.Mutex</code>）或者避免共享可变数据。</li>
<li><strong>线程间协调</strong>：一个线程生产数据，另一个线程消费数据，需要使用Go的通道（<code>channel</code>）或条件变量（<code>sync.Cond</code>）或等待组（<code>sync.WaitGroup</code>）进行协调。</li>
<li><strong>死锁</strong>：线程之间通过锁或<code>channel</code>或RPC相互等待资源时可能导致死锁，需要小心避免。</li>
</ol>
<h2 id="以网络爬虫为例的线程应用" class="heading-element"><span>3 以网络爬虫为例的线程应用</span>
  <a href="#%e4%bb%a5%e7%bd%91%e7%bb%9c%e7%88%ac%e8%99%ab%e4%b8%ba%e4%be%8b%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>网络爬虫的目标是抓取所有网页内容，常见的实现方式有串行和并发两种。并发爬虫利用线程提高抓取效率，但也需要解决避免重复抓取和循环依赖的问题。</p>
<p>在本例中，我们使用一个填充的<code>Fetcher</code>来模拟抓取。<code>fetcher</code>结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">fakeResult</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">body</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">fakeFetcher</span><span class="p">)</span> <span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">url</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found:   %s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">urls</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;missing: %s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;not found: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fetcher is a populated fakeFetcher.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">fetcher</span> <span class="p">=</span> <span class="nx">fakeFetcher</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;The Go Programming Language&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/cmd/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Packages&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/cmd/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/fmt/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/os/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/fmt/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Package fmt&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;http://golang.org/pkg/os/&#34;</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">fakeResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;Package os&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="s">&#34;http://golang.org/pkg/&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="串行爬虫" class="heading-element"><span>3.1 串行爬虫</span>
  <a href="#%e4%b8%b2%e8%a1%8c%e7%88%ac%e8%99%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>串行爬虫通过递归调用实现深度优先搜索，使用一个共享的map记录已抓取的URL，防止重复抓取。然而，这种方式只能一次抓取一个页面，速度较慢。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Serial</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">fetched</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Use a map to keep track of fetched URLs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Recursively fetch URLs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Serial</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">,</span> <span class="nx">fetched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>我们是否可以在<code>Serial()</code>调用前面放一个<code>go</code>呢</p>
</blockquote>
<p>在 <code>Serial()</code> 调用前添加 <code>go</code> 关键字会导致并发执行多个爬虫任务，从而可能导致重复抓取相同的页面。这是因为每个爬虫任务都会尝试从未抓取过的页面开始递归抓取，而并发执行可能导致多个爬虫同时选择相同的页面作为起始点，进而重复抓取。</p>
<h3 id="并发爬虫" class="heading-element"><span>3.2 并发爬虫</span>
  <a href="#%e5%b9%b6%e5%8f%91%e7%88%ac%e8%99%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="使用锁" class="heading-element"><span>3.3 使用锁</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个页面的抓取在独立的线程中进行，为了确保抓取过程的正确性，我们使用了互斥锁来保护共享的 <code>fetchState</code> 结构体，避免了重复抓取和并发冲突的问题。在抓取过程中，我们使用了递归调用 <code>ConcurrentMutex</code> 函数来处理当前页面的所有子链接。每当发现一个新的子链接时，我们启动一个新的 Goroutine 来并发地抓取该链接，从而实现了多个页面的并行抓取。使用 <code>sync.WaitGroup</code> 来等待所有的子链接抓取任务完成，确保主线程在所有任务完成后才返回，以避免提前结束抓取过程。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">fetchState</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>      <span class="c1">// protect concurrent crawls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fetched</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span> <span class="c1">// Used to store crawled URLs. The key is URL and the value is whether it has been crawled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">fs</span> <span class="o">*</span><span class="nx">fetchState</span><span class="p">)</span> <span class="nf">testAndSet</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fs</span><span class="p">.</span><span class="nx">fetched</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">r</span> <span class="c1">// Return to previous crawling status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ConcurrentMutex</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">fs</span> <span class="o">*</span><span class="nx">fetchState</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">fs</span><span class="p">.</span><span class="nf">testAndSet</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">done</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// Create a wait group that waits for all subtasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">done</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1">// Increase the counter of the waiting group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">u</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Start a Go coroutine to concurrently crawl sub-links
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">defer</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nf">ConcurrentMutex</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">,</span> <span class="nx">fs</span><span class="p">)</span> <span class="c1">// Recursive call ConcurrentMutex, fetching sub-links.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}(</span><span class="nx">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// Wait for all subtasks to complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用通道" class="heading-element"><span>3.4 使用通道</span>
  <a href="#%e4%bd%bf%e7%94%a8%e9%80%9a%e9%81%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个<code>worker</code>线程将抓取到的URL发送到一个通道，<code>coordinator</code>从通道中读取URL并启动新的<code>worker</code>线程。这种方式避免了锁的使用，但需要小心避免通道阻塞导致的死锁。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">urls</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fetcher</span><span class="p">.</span><span class="nf">Fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">urls</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">coordinator</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">1</span>                           <span class="c1">// 记录正在处理的任务数量，初始值为 1，因为最开始只有一个初始 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fetched</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// 记录已经抓取的 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">urls</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>           <span class="c1">// 不断从通道中接收抓取到的链接列表，直到通道被关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">urls</span> <span class="p">{</span> <span class="c1">// 遍历接收到的链接列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">fetched</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fetched</span><span class="p">[</span><span class="nx">u</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">				<span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">				<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">ch</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span> <span class="c1">// 启动一个新的 worker 协程抓取该链接的子链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 如果当前没有正在处理的任务，则退出循环，结束并发抓取过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ConcurrentChannel 函数是并发抓取的入口函数，利用通道协调并发抓取的过程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ConcurrentChannel</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fetcher</span> <span class="nx">Fetcher</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 创建一个字符串切片类型的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>               <span class="c1">// 启动一个匿名函数的 Go 协程，用于向通道发送 URL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">url</span><span class="p">}</span> <span class="c1">// 向通道发送包含初始 URL 的字符串切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">coordinator</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">)</span> <span class="c1">// 调用 coordinator 函数，开始并发抓取的协调过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>worker</code> 函数中，每个<code>worker</code>线程会尝试抓取指定的URL，并将抓取到的子链接发送到通道中。如果抓取失败，则发送一个空的字符串切片到通道，以便通知<code>coordinator</code>任务失败。</p>
<p>在 <code>coordinator</code> 函数中，<code>coordinator</code>不断从通道中读取抓取到的链接列表，然后遍历这些链接，如果发现之前未抓取过的新链接，则将其标记为已抓取并启动一个新的<code>worker</code>线程进行抓取。同时，<code>coordinator</code>会维护一个计数器 <code>n</code> 来记录当前正在处理的任务数量，当所有任务都处理完成后，<code>coordinator</code>结束并发抓取的过程。</p>
<p>在 <code>ConcurrentChannel</code> 函数中，我们首先创建了一个字符串切片类型的通道，并启动了一个匿名的 Goroutine 来向通道发送初始的 URL。然后，调用 <code>coordinator</code> 函数开始并发抓取的协调过程。</p>
<blockquote>
<ol>
<li><code>coordinator</code>如何知道它已经完成？</li>
</ol>
<p><code>coordinator</code>知道它已完成的条件是 <code>n</code> 计数器的值归零。<code>coordinator</code>通过维护 <code>n</code> 计数器来跟踪当前正在处理的任务数量，每个<code>worker</code>线程处理完成后会将 <code>n</code> 减一。当 <code>n</code> 计数器的值为零时，表示所有的任务都已经完成，<code>coordinator</code>就知道自己的工作已经完成。</p>
<ol start="2">
<li>通道在这里有两个作用：</li>
</ol>
<p>- 通信值：<code>worker</code>线程将抓取到的链接列表发送到通道中，以便<code>coordinator</code>可以读取并处理。
- 事件通知：通道的关闭可作为事件通知，当通道关闭时，<code>coordinator</code>会知道所有的<code>worker</code>线程都已完成，并且没有新的任务需要处理。</p>
</blockquote>
<h2 id="远程过程调用rpc" class="heading-element"><span>4 远程过程调用（RPC）</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="介绍" class="heading-element"><span>4.1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h3 id="远程过程调用rpc-1" class="heading-element"><span>4.2 远程过程调用（RPC）</span>
  <a href="#%e8%bf%9c%e7%a8%8b%e8%bf%87%e7%a8%8b%e8%b0%83%e7%94%a8rpc-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>远程过程调用（RPC）是分布式系统中的关键技术之一，它使得客户端和服务器之间的通信变得简单而直观。在分布式系统中，不同的节点可能分布在不同的物理机器上，RPC允许这些节点之间进行远程通信，就像调用本地函数一样，无需了解底层的网络协议细节。</p>
<p>RPC的目标是实现易于编程的客户端/服务器通信，它隐藏了底层网络通信的复杂性，为开发人员提供了简单的接口。通过RPC，开发人员可以专注于业务逻辑的实现，而无需担心网络通信的细节。</p>
<p>在RPC中，数据在客户端和服务器之间通过网络传输，因此需要将数据转换为“有线格式”（wire format）。RPC库负责处理数据的序列化和反序列化，以确保数据可以在网络上传输并在另一端正确解析。</p>
<p>RPC消息的基本结构是请求-响应模式。<font color="red">客户端发送请求给服务器，服务器处理请求并发送响应给客户端。</font>这种简单的请求-响应模式使得RPC成为了一种非常有效的通信方式。</p>
<p>在RPC的软件结构中，通常会有以下几个组件：</p>
<ul>
<li>客户端应用程序：负责发起RPC请求的应用程序。</li>
<li>存根函数（Stub functions）：客户端应用程序调用的接口函数，实际上是一个本地代理，负责将RPC调用转发给远程服务器。</li>
<li>服务器处理函数（Handler functions）：服务器端实际执行业务逻辑的函数。</li>
<li>调度器（Dispatcher）：负责将RPC请求分发给正确的处理函数。</li>
<li>RPC库：提供了RPC通信所需的基本功能，例如序列化、网络通信等。</li>
</ul>
<p>通过RPC，不同语言编写的客户端和服务器可以进行通信，实现了跨语言的可移植性和互操作性。</p>
<h3 id="go的rpc实现" class="heading-element"><span>4.3 Go的RPC实现</span>
  <a href="#go%e7%9a%84rpc%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在Go中，实现RPC需要定义请求和回复的结构体，并使用Go的RPC库来处理通信。下面是一个示例，展示了如何在Go中实现一个简单的键值存储服务器（key/value storage server），并使用RPC进行通信。</p>
<ul>
<li>
<p>请求回复结构体</p>
<p>在键值存储服务器的示例中，我们定义了用于Put和Get操作的请求和回复结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PutArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PutReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GetArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GetReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>服务器端（Server）</p>
<p>在服务器端，首先需要定义一个对象，并在该对象上注册处理函数作为RPC处理程序。这些处理函数将处理客户端发送的RPC请求。服务器接受TCP连接并将其传递给RPC库。RPC库负责读取每个请求，并为每个请求创建一个新的Goroutine进行处理。处理函数会读取请求参数，并根据请求调用相应的方法。处理完请求后，服务器将回复信息进行序列化，并通过TCP连接发送回客户端。<font color="red">服务器端的处理函数必须使用锁进行同步，因为RPC库为每个请求创建了一个新的Goroutine。</font>处理函数需要读取请求参数并修改回复信息，因此需要确保并发访问的安全性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KV</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// 互斥锁，保护数据并发访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">KV</span><span class="p">{</span><span class="nx">data</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}}</span> <span class="c1">// 创建键值存储服务器实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcs</span> <span class="o">:=</span> <span class="nx">rpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>              <span class="c1">// 创建一个 RPC 服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rpcs</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">kv</span><span class="p">)</span>                    <span class="c1">// 注册 kv 为 RPC 服务器的服务对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1234&#34;</span><span class="p">)</span>   <span class="c1">// 监听 TCP 端口 1234
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 启动一个协程来处理客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span> <span class="c1">// 接受客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">go</span> <span class="nx">rpcs</span><span class="p">.</span><span class="nf">ServeConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// 启动一个协程来为客户端提供服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// 关闭监听器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get 方法用于处理客户端发送的 Get 请求，获取指定键的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Put 方法用于处理客户端发送的 Put 请求，存储键值对。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>客户端（Client）</p>
<p>在客户端，首先需要使用Dial函数建立与服务器的TCP连接。然后，客户端需要定义RPC请求的参数结构体和回复结构体，并实现对应的处理函数。客户端通过调用Call函数发起RPC调用，指定连接、函数名称、参数以及存放回复的位置。RPC库负责对参数进行序列化，并将请求发送给服务器。然后，客户端等待并接收服务器的回复，并将回复反序列化为指定的回复结构体。Call函数的返回值指示是否成功接收到了回复，通常还包括服务级别的错误信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// connect 函数用于与键值存储服务器建立连接，并返回一个 RPC 客户端对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">connect</span><span class="p">()</span> <span class="o">*</span><span class="nx">rpc</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1234&#34;</span><span class="p">)</span> <span class="c1">// 使用 TCP 协议连接服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;dialing:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// 如果连接失败，则记录错误并终止程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">connect</span><span class="p">()</span>                         <span class="c1">// 建立连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">GetArgs</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span>                        <span class="c1">// 构造 Get 请求的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">GetReply</span><span class="p">{}</span>                         <span class="c1">// 准备接收服务器的响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KV.Get&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span> <span class="c1">// 调用远程方法 Get，并传递参数 args，将响应写入 reply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>     <span class="c1">// 关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// 返回服务器返回的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// put 函数用于向键值存储服务器发送 Put 请求，存储键值对。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">connect</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">PutArgs</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">PutReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KV.Put&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>其他细节：</p>
<ul>
<li>
<p>绑定（Binding）：客户端如何知道要与哪台服务器通信？</p>
<p>在Go的RPC中，服务器的名称和端口是Dial函数的参数。在大型系统中，通常会有一种名称或配置服务器来管理这些信息。</p>
</li>
<li>
<p>序列化（Marshalling）：数据格式化为数据包。Go的RPC库可以传递字符串、数组、对象、映射等类型的数据。Go通过复制指向的数据来传递指针，但不能传递通道或函数。RPC库只序列化导出字段（即大写字母开头的字段）。</p>
</li>
</ul>
<h3 id="处理rpc中的失败" class="heading-element"><span>4.4 处理RPC中的失败</span>
  <a href="#%e5%a4%84%e7%90%86rpc%e4%b8%ad%e7%9a%84%e5%a4%b1%e8%b4%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在分布式系统中，网络故障和服务器故障是不可避免的。简单的解决方案是“尽力而为”的RPC，即在超时后重试请求，但这可能导致重复操作。</p>
<p>这种方法的缺点是，重试请求可能导致操作被重复执行。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果第二个<code>Put</code>请求因网络故障重试多次，可能会导致不一致的结果：</p>
<p>更好的解决方案是“至多一次”的RPC，“至多一次”的RPC通过以下机制实现更可靠的行为：</p>
<ul>
<li>客户端在未收到响应时重新发送请求。</li>
<li>服务器检测重复请求，并返回之前的响应，而不是重新执行处理函数。</li>
</ul>
<p>为了检测重复请求，客户端在每个请求中包含一个唯一的ID（XID）。每个请求使用相同的 XID 重新发送服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if seen[xid] {
</span></span><span class="line"><span class="cl">  reply = old[xid]
</span></span><span class="line"><span class="cl">} else {
</span></span><span class="line"><span class="cl">  reply = handler()
</span></span><span class="line"><span class="cl">  old[xid] = reply
</span></span><span class="line"><span class="cl">  seen[xid] = true
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一些“至多一次”复杂性问题：</strong></p>
<ul>
<li>
<p>如果两个客户端使用相同的XID？</p>
<ul>
<li>解决方案：使用大随机数生成唯一ID。</li>
</ul>
</li>
<li>
<p>如何避免seen[xid]表过大？</p>
<ul>
<li>每个客户端有一个唯一ID，使用序列号。</li>
<li>客户端在每次RPC中包含“已见到的最大回复”信息，类似于TCP序列号和确认号。</li>
</ul>
</li>
<li>
<p><strong>服务器崩溃和重启：</strong></p>
<ul>
<li>
<p>如果“至多一次”信息保存在内存中，服务器重启后将忘记这些信息，可能会接受重复请求。</p>
<p>解决方案：将重复检测信息写入磁盘，或使用复制服务器同步这些信息。</p>
</li>
</ul>
</li>
</ul>
<p>Go的RPC库是“至多一次”策略的简单实现：</p>
<ul>
<li>打开TCP连接。</li>
<li>将请求写入TCP连接。</li>
<li>Go RPC从不重发请求，因此服务器不会看到重复请求。</li>
<li>如果未收到回复，Go RPC代码返回错误（可能是由于TCP超时）。</li>
</ul>
<blockquote>
<p>关于“恰好一次”的RPC</p>
<p>“恰好一次”的RPC包括无限重试、重复检测和容错服务，这种方法更复杂，在实际系统中需要实现容错机制。</p>
<p>例如，lab 4中将探讨“恰好一次”RPC的实现。</p>
</blockquote>
<h2 id="faq" class="heading-element"><span>5 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<ol>
<li>Go通道是如何工作的？Go如何确保它们在多个goroutines之间同步？</li>
</ol>
<p>可以在<a href="https://go.dev/src/runtime/chan.go"target="_blank" rel="external nofollow noopener noreferrer">这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>查看源码，尽管不易理解。高层次上，<font color="red">通道是一个包含缓冲区和锁的结构体</font>。发送到通道涉及获取锁，等待（可能释放CPU）直到某个线程接收，并交付消息。接收涉及获取锁并等待发送者。可以使用Go的sync.Mutex和sync.Cond自己实现通道。</p>
<ol start="2">
<li>我使用通道唤醒另一个goroutine，通过在通道上发送一个虚拟的bool值。但如果另一个goroutine已经在运行（因此没有在通道上接收），发送goroutine会阻塞。我应该怎么做？</li>
</ol>
<p>尝试使用条件变量（Go的sync.Cond）而不是通道。条件变量非常适合通知可能（或可能不）等待某事的goroutines。由于通道是同步的，如果不确定通道另一端是否有goroutine在等待，使用通道会显得很尴尬。</p>
<ol start="3">
<li>如何让一个goroutine等待来自多个不同通道的输入？如果没有任何内容可读取，则尝试在任何一个通道上接收都会阻塞，从而阻止 goroutine 检查其他通道。</li>
</ol>
<p>尝试为每个通道创建一个单独的goroutine，每个goroutine阻塞在其通道上。这不是总能实现，但在可行时通常是最简单的方法。否则，尝试使用Go的select。</p>
<ol start="4">
<li>什么时候应该使用sync.WaitGroup而不是通道？反之亦然？</li>
</ol>
<p>WaitGroup用途较为特殊；它仅在等待一堆活动完成时有用。通道用途更广泛；例如，可以通过通道传递值。尽管比WaitGroup需要多写几行代码，但也可以使用通道等待多个goroutines。</p>
<ol start="5">
<li>如何创建一个通过互联网连接的Go通道？如何指定用于发送消息的协议？</li>
</ol>
<p>Go通道仅在单个程序内工作；通道不能用于与其他程序或计算机通信。可以查看Go的RPC包，它允许你通过互联网与其他Go程序通信：
<a href="https://golang.org/pkg/net/rpc/"target="_blank" rel="external nofollow noopener noreferrer">https://golang.org/pkg/net/rpc/<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol start="6">
<li>一些重要/有用的Go特定并发模式有哪些？</li>
</ol>
<p>这是一个关于该主题的幻灯片，由Go专家编写：
<a href="https://talks.golang.org/2012/concurrency.slide"target="_blank" rel="external nofollow noopener noreferrer">https://talks.golang.org/2012/concurrency.slide<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ol start="7">
<li>切片是如何实现的？</li>
</ol>
<p>切片是一个对象，包含指向数组的指针以及该数组的开始和结束索引。这种安排允许多个切片共享一个底层数组，每个切片可能暴露数组元素的不同范围。这里有一个更详细的讨论：
<a href="https://blog.golang.org/go-slices-usage-and-internals"target="_blank" rel="external nofollow noopener noreferrer">https://blog.golang.org/go-slices-usage-and-internals<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
Go切片比Go数组更灵活，因为数组的大小是其类型的一部分，而以切片作为参数的函数可以接受任何长度的切片。</p>
<ol start="8">
<li>什么时候使用同步RPC调用，什么时候使用异步RPC调用？</li>
</ol>
<p>大多数代码需要在继续执行前获得RPC回复；在这种情况下，使用同步RPC是合理的。但有时客户端希望启动许多并发RPC；在这种情况下，异步可能更好。或者客户端希望在等待RPC完成时做其他工作，可能是因为服务器很远（所以光速时间很高）或因为服务器可能不可达，从而RPC经历长时间的超时。我(Robert)从未在Go中使用异步RPC。当我想发送RPC但不必等待结果时，我创建一个goroutine，并让这个goroutine进行同步Call()。</p>
<ol start="9">
<li>开发人员在开始使用Go时常见的问题有哪些？</li>
</ol>
<p>以下是一些常见问题：</p>
<p>- 未在并发访问时使用锁保护映射。使用Go的竞态检测器！
- 使用通道时的死锁。
- 在创建goroutine时未捕获变量。
- 泄漏的goroutines。</p>
<ol start="10">
<li>Go是否支持继承？（像Java/C++那样的“扩展”方式？）</li>
</ol>
<p>Go不支持C++风格的继承，但有接口和嵌入结构体，可以完成在C++中使用继承的许多事情。这是Go设计中备受争议的部分；可以搜索“golang generics”。</p>
<ol start="11">
<li>我对选择值接收器或指针接收器仍有些困惑。能否提供一些具体的实际例子说明我们应该选择哪一个？</li>
</ol>
<p>当你想修改接收器的状态时，必须使用指针接收器。如果结构体非常大，你可能想使用指针接收器，因为值接收器操作的是一个副本。如果两者都不适用，可以使用值接收器。然而，要小心使用值接收器；例如，如果结构体中有一个互斥锁，你不能将其作为值接收器，因为互斥锁会被复制，从而失去其作用。</p>
</blockquote>
]]></description></item><item><title>【MIT 6.5840(6.824) 】Lab2:Key/Value Server 设计实现</title><link>https://hezephyr.github.io/posts/06.mit-6.58406.824-lab2-kv-server/</link><pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/06.mit-6.58406.824-lab2-kv-server/</guid><description><![CDATA[<h2 id="实验要求" class="heading-element"><span>1 实验要求</span>
  <a href="#%e5%ae%9e%e9%aa%8c%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在本次 Lab 中，你将在单机上构建一个键/值服务器，以确保即使网络出现故障，每个操作也只能执行一次，并且操作是可线性化的。</p>
<p>客户端可以向键/值服务器发送三个不同的 RPC： <code>Put(key, value)</code> 、 <code>Append(key, arg)</code> 和 <code>Get(key)</code> 。服务器在内存中维护键/值对的<code>map</code>。键和值是字符串。 <code>Put(key, value)</code> 设置或替换<code>map</code>中给定键的值， <code>Append(key, arg)</code> 将 arg 附加到键的值并返回旧值， <code>Get(key)</code> 获取键的当前值。不存在的键的 <code>Get</code>请求应返回空字符串；对于不存在的键的 <code>Append</code> 请求应该表现为现有值是零长度字符串。每个客户端都通过<code>Clerk</code>的 <code>Put/Append/Get</code> 方法与服务器进行通信。 <code>Clerk</code> 管理与服务器的 RPC 交互。</p>
<p>你的服务器必须保证应用程序对<code>Clerk Get/Put/Append</code> 方法的调用是线性一致的。 如果客户端请求不是并发的，每个客户端 Get/Put/Append 调用时能够看到之前调用序列导致的状态变更。 对于并发的请求来说，返回的结果和最终状态都必须和这些操作顺序执行的结果一致。如果一些请求在时间上重叠，则它们是并发的：例如，如果客户端 X 调用 <code>Clerk.Put()</code> ，并且客户端 Y 调用 <code>Clerk.Append()</code> ，然后客户端 X 的调用 返回。 一个请求必须能够看到已完成的所有调用导致的状态变更。</p>
<p>一个应用实现线性一致性就像一台单机服务器一次处理一个请求的行为一样简单。 例如，如果一个客户端发起一个更新请求并从服务器获取了响应，随后从其他客户端发起的读操作可以保证能看到改更新的结果。在单台服务器上提供线性一致性是相对比较容易的。</p>
<p>Lab 在 <code>src/kvsrv</code> 中提供了框架代码和单元测试。你需要更改 <code>kvsrv/client.go</code>、<code>kvsrv/server.go</code> 和 <code>kvsrv/common.go</code> 文件。</p>
<h2 id="无网络故障的kv-server" class="heading-element"><span>2 无网络故障的KV Server</span>
  <a href="#%e6%97%a0%e7%bd%91%e7%bb%9c%e6%95%85%e9%9a%9c%e7%9a%84kv-server" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="任务要求" class="heading-element"><span>2.1 任务要求</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e8%a6%81%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>此任务需要实现一个在没有丢失消息的情况下有效的解决方案。你需要在 <code>client.go</code> 中，在 Clerk 的 Put/Append/Get 方法中添加 RPC 的发送代码；并且实现 <code>server.go</code> 中 Put、Append、Get 三个 RPC handler。</p>
<p>当你通过了前两个测试 case：one client、many clients 时表示完成该任务。</p>
<h3 id="设计实现" class="heading-element"><span>2.2 设计实现</span>
  <a href="#%e8%ae%be%e8%ae%a1%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这个任务比较简单，我们只需要根据实验要求的逻辑进行实现即可。</p>
<ul>
<li>
<p><code>server.go</code></p>
<p>使用<code>map</code>保存键值信息，三种操作都需要通过锁来保证互斥访问共享<code>map</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldValue</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">oldValue</span> <span class="o">+</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">oldValue</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>client.go</code></p>
<p>只需要添加RPC的发送代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.Get&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">PutAppend</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">op</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span>   <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Value</span><span class="p">:</span> <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.&#34;</span><span class="o">+</span><span class="nx">op</span><span class="p">,</span> <span class="nx">arg</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ck</span><span class="p">.</span><span class="nf">PutAppend</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="s">&#34;Put&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="可能丢弃消息的kv-server" class="heading-element"><span>3 可能丢弃消息的KV Server</span>
  <a href="#%e5%8f%af%e8%83%bd%e4%b8%a2%e5%bc%83%e6%b6%88%e6%81%af%e7%9a%84kv-server" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="任务要求-1" class="heading-element"><span>3.1 任务要求</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e8%a6%81%e6%b1%82-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>现在，您应该修改您的解决方案，以便在遇到丢失的消息（例如 RPC 请求和 RPC 回复）时继续工作。如果消息丢失，则客户端的 <code>ck.server.Call()</code> 将返回 <code>false</code> （更准确地说， <code>Call()</code> 等待响应直至超市，如果在此时间内没有响应就返回<code>false</code>）。您将面临的一个问题是 <code>Clerk</code> 可能需要多次发送 RPC，直到成功为止。但是，每次调用 <code>Clerk.Put()</code> 或 <code>Clerk.Append()</code> 应该只会导致一次执行，因此您必须确保重新发送不会导致服务器执行请求两次。</p>
<p>你的任务是在 <code>Clerk</code> 中添加重试逻辑，并且在 <code>server.go</code> 中来过滤重复请求。</p>
<blockquote>
<center>Hint
</center>
<ol>
<li>您需要唯一地标识<code>client</code>操作，以确保KV Server仅执行每个操作一次。</li>
<li>您必须仔细考虑<code>server</code>必须维持什么状态来处理重复的 <code>Get()</code> 、 <code>Put()</code> 和 <code>Append()</code> 请求（如果有的话）。</li>
<li>您的重复检测方案应该快速释放服务器内存，例如让每个 RPC 暗示<code>client</code>已看到其前一个 RPC 的回复。可以假设<code>client</code>一次只向<code>Clerk</code>发起一次调用。</li>
</ol>
</blockquote>
<h3 id="方案设计" class="heading-element"><span>3.2 方案设计</span>
  <a href="#%e6%96%b9%e6%a1%88%e8%ae%be%e8%ae%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>根据提示，我们可以为<code>Put</code>和<code>Append</code>消息添加标识ID（<code>Get</code>消息只需不断重试，不会有影响），这里我们还需要用到<code>sync.Map</code>用于在键/值服务器中跟踪处理过的请求ID，以防止重复处理请求。每当服务器接收到一个新的RPC请求时，它会检查请求ID是否已存在于<code>sync.Map</code>中。如果存在，则表明该请求已经处理过，服务器可以跳过重复的处理，直接返回之前处理过的值。否则，服务器会记录该请求ID处理请求，并将回复结果记录。这种机制确保了操作的幂等性，避免了由于网络故障或重试机制导致的重复执行。</p>
<p>当然，还需要考虑一个问题，就是服务器会不断积压处理过的请求ID信息，所以我们需要快速释放服务器内存，即让<code>Client</code>通知<code>Server</code>这个任务操作已经完成，删除相关的记录信息。故我们还需要给消息结构添加一个<code>Type</code>字段标识为<code>Modify</code>还是<code>Report</code>。</p>
<p>整个流程图如下所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=small" data-sub-html="<h2>image-20240515111905159</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png" alt="image-20240515111905159" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/KV_Server_Example_2.png?size=large 2x" data-title="image-20240515111905159" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="代码实现" class="heading-element"><span>3.3 代码实现</span>
  <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>实验代码实现仓库：https://github.com/unique-pure/MIT6.5840/tree/main/src/kvsrv，实验代码已通过实验测试。</p>
<ul>
<li>
<p><code>common.go</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MessageType</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Modify</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Report</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Put or Append
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PutAppendArgs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MessageType</span> <span class="nx">MessageType</span> <span class="c1">// Modify or Report
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MessageID</span>   <span class="kt">int64</span>       <span class="c1">// Unique ID for each message
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>server.go</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KVServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">data</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">record</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">GetArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">GetReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">MessageType</span> <span class="o">==</span> <span class="nx">Report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">res</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 重复请求，返回之前的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">,</span> <span class="nx">old</span><span class="p">)</span> <span class="c1">// 记录请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">kv</span> <span class="o">*</span><span class="nx">KVServer</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">PutAppendArgs</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">PutAppendReply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">MessageType</span> <span class="o">==</span> <span class="nx">Report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">res</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="c1">// 重复请求，返回之前的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">old</span> <span class="o">+</span> <span class="nx">args</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kv</span><span class="p">.</span><span class="nx">record</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">MessageID</span><span class="p">,</span> <span class="nx">old</span><span class="p">)</span> <span class="c1">// 记录请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>client.go</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">args</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">GetReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.Get&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="c1">// keep trying forever
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">ck</span> <span class="o">*</span><span class="nx">Clerk</span><span class="p">)</span> <span class="nf">PutAppend</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">op</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MessageID</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Key</span><span class="p">:</span>         <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Value</span><span class="p">:</span>       <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageID</span><span class="p">:</span>   <span class="nx">MessageID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageType</span><span class="p">:</span> <span class="nx">Modify</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PutAppendReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.&#34;</span><span class="o">+</span><span class="nx">op</span><span class="p">,</span> <span class="nx">arg</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">PutAppendArgs</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageType</span><span class="p">:</span> <span class="nx">Report</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MessageID</span><span class="p">:</span>   <span class="nx">MessageID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">!</span><span class="nx">ck</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="s">&#34;KVServer.&#34;</span><span class="o">+</span><span class="nx">op</span><span class="p">,</span> <span class="nx">arg</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ go <span class="nb">test</span>
</span></span><span class="line"><span class="cl">Test: one client
</span></span><span class="line"><span class="cl">  ... Passed -- t  3.3 nrpc <span class="m">20037</span> ops <span class="m">13359</span>
</span></span><span class="line"><span class="cl">Test: many clients ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  3.7 nrpc <span class="m">85009</span> ops <span class="m">56718</span>
</span></span><span class="line"><span class="cl">Test: unreliable net, many clients ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  3.3 nrpc  <span class="m">1161</span> ops  <span class="m">632</span>
</span></span><span class="line"><span class="cl">Test: concurrent append to same key, unreliable ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.4 nrpc   <span class="m">131</span> ops   <span class="m">52</span>
</span></span><span class="line"><span class="cl">Test: memory use get ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.6 nrpc     <span class="m">8</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use put ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.3 nrpc     <span class="m">4</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use append ...
</span></span><span class="line"><span class="cl">  ... Passed -- t  0.5 nrpc     <span class="m">4</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use many put clients ...
</span></span><span class="line"><span class="cl">  ... Passed -- t 36.7 nrpc <span class="m">200000</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use many get client ...
</span></span><span class="line"><span class="cl">  ... Passed -- t 22.6 nrpc <span class="m">100002</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">Test: memory use many appends ...
</span></span><span class="line"><span class="cl">2024/05/15 12:48:26 m0 <span class="m">411000</span> m1 <span class="m">1550088</span>
</span></span><span class="line"><span class="cl">  ... Passed -- t  2.6 nrpc  <span class="m">2000</span> ops    <span class="m">0</span>
</span></span><span class="line"><span class="cl">PASS
</span></span><span class="line"><span class="cl">ok      6.5840/kvsrv    75.329s</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>【MIT 6.5840(6.824)】Lab1:MapReduce 设计实现</title><link>https://hezephyr.github.io/posts/05.mit-6.58406.824-lab1mapreduce-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 14 May 2024 19:56:28 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/05.mit-6.58406.824-lab1mapreduce-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</guid><description><![CDATA[<h2 id="介绍" class="heading-element"><span>1 介绍</span>
  <a href="#%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>本次实验是实现一个简易版本的<code>MapReduce</code>，你需要实现一个工作程序（worker process）和一个调度程序（coordinator process）。工作程序用来调用Map和Reduce函数，并处理文件的读取和写入。调度程序用来协调工作任务并处理失败的任务。你将构建出跟 <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf"target="_blank" rel="external nofollow noopener noreferrer">MapReduce论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 里描述的类似的东西。（注意：本实验中用&quot;coordinator&quot;替代里论文中的&quot;master&quot;。）</p>
<p>实验先决条件：</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/hzf0701/article/details/138770454?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">阅读MapReduce论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p><a href="http://nil.csail.mit.edu/6.5840/2024/labs/lab-mr.html"target="_blank" rel="external nofollow noopener noreferrer">阅读lab文档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p>理解MapReduce框架</p>
</li>
<li>
<p>理解原框架代码，理清所需完成任务</p>
</li>
</ul>
<p>实验代码实现仓库：https://github.com/unique-pure/MIT6.5840/tree/main/src/mr，实验代码已通过实验测试，并在以下清单中列出了实现的功能及待办事项。</p>
<ul>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> Complete the basic requirements for MapReduce</li>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> Handling worker failures</li>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> No data competition, a big lock ensures safety</li>
<li><i class="fa-regular fa-check-square fa-fw" aria-hidden="true"></i> Pass lab test</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> Communicate over TCP/IP and read/write files using a shared file system</li>
</ul>
<h2 id="原框架解析" class="heading-element"><span>2 原框架解析</span>
  <a href="#%e5%8e%9f%e6%a1%86%e6%9e%b6%e8%a7%a3%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><code>src/mrapps/wc.go</code></p>
<p>这是一个用于 MapReduce 的字数统计（Word Count）插件。该插件包含 Map 和 Reduce 函数，用于统计输入文本中的单词频率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Map</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">contents</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">mr</span><span class="p">.</span><span class="nx">KeyValue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// function to detect word separators.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ff</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsLetter</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// split contents into an array of words.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">FieldsFunc</span><span class="p">(</span><span class="nx">contents</span><span class="p">,</span> <span class="nx">ff</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">kva</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">mr</span><span class="p">.</span><span class="nx">KeyValue</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">words</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kv</span> <span class="o">:=</span> <span class="nx">mr</span><span class="p">.</span><span class="nx">KeyValue</span><span class="p">{</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">kva</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">kva</span><span class="p">,</span> <span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">kva</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Reduce</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">values</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// return the number of occurrences of this word.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>src/main/mrcoordinator.go</code></p>
<p><code>mrcoordinator.go</code> 定义了调度器（Coordinator）的主要逻辑。调度器通过 <code>MakeCoordinator</code> 启动一个 <code>Coordinator</code> 实例 <code>c</code>，并在 <code>c.server()</code> 中通过协程 <code>go http.Serve(l, nil)</code> 启动一个 HTTP 服务器来接收和处理 RPC 调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rpc</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rpc</span><span class="p">.</span><span class="nf">HandleHTTP</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//l, e := net.Listen(&#34;tcp&#34;, &#34;:1234&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sockname</span> <span class="o">:=</span> <span class="nf">coordinatorSock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sockname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">l</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="nx">sockname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeCoordinator</span><span class="p">(</span><span class="nx">files</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">nReduce</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Coordinator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">Coordinator</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">server</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意：在 Go 的 <code>net/http</code> 包中，使用 <code>http.Serve(l, nil)</code> 启动 HTTP 服务器时，服务器会为每个传入的请求自动启动一个新的协程。这意味着每个 RPC 调用都是在独立的协程中处理的，从而允许并发处理多个请求。因此，在设计时可能需要使用锁等同步原语来保护共享资源。此外，Coordinator 不会主动与 Worker 通信（除非额外实现），只能通过 Worker 的 RPC 通信来完成任务。同时，当所有任务完成时，<code>Done</code> 方法将返回 <code>false</code>，从而关闭 Coordinator。</p>
</li>
<li>
<p><code>src/main/mrworker.go</code></p>
<p><code>mrworker.go</code> 通过 <code>Worker</code> 函数运行。因此，<code>Worker</code> 函数需要完成请求任务、执行任务、报告任务状态等多个任务。可以推测，<code>Worker</code> 需要在这个函数中不断地轮询 Coordinator，并根据 Coordinator 的不同回复来驱动当前 Worker 完成各种任务。</p>
</li>
<li>
<p><code>src/main/mrsequential.go</code></p>
<p><code>mrsequential.go</code> 实现了一个简单的顺序 MapReduce 应用程序。该程序读取输入文件，执行 Map 和 Reduce 操作，并将结果写入输出文件。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/mrsequential_example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ul>
<h2 id="设计实现" class="heading-element"><span>3 设计实现</span>
  <a href="#%e8%ae%be%e8%ae%a1%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="任务分析" class="heading-element"><span>3.1 任务分析</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>总体而言，<code>Worker</code>通过RPC轮询<code>Coordinator</code>请求任务，例如Map或者Reduce任务，<code>Coordinator</code>将剩余任务分配给<code>Worker</code>处理（先处理完Map任务才能处理Reduce任务）。</p>
<blockquote>
<p>其中，在此实验中Map任务数量就是输入文件数量，每个<code>Map Task</code>的任务就是处理一个<code>.txt</code>文件；Reduce任务的数量是<code>nReduce</code>。</p>
<p>由于Map任务会将文件的内容分割为指定的<code>nReduce</code>份，每一份应当由序号标明，拥有这样的序号的多个Map任务的输出汇总起来就是对应的Reduce任务的输入。</p>
</blockquote>
<p>请求完任务后，<code>Worker</code>需要根据任务类型进行处理，这段处理过程跟<code>mrsequential.go</code>基本一致，但需要注意的就是论文中提到的，如果同一个任务被多个<code>Worker</code>执行，针对同一个最终的输出文件将有多个重命名操作执行。我们这就依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个任务产生的数据。即通过<code>os.Rename()</code>。</p>
<p>处理完任务后，<code>Worker</code>通过RPC告知<code>Coordinator</code>任务结果。</p>
<p><font color="red">所以，我们可以知道<code>Coordinator</code>管理着任务状态和任务分配，而无需记录<code>Worker</code>的信息，<code>Worker</code>实现任务处理。</font></p>
<p>整个任务流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=small" data-sub-html="<h2>image-20240514154125349</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png" alt="image-20240514154125349" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_processs_Example.png?size=large 2x" data-title="image-20240514154125349" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>MapReduce处理WordCount程序的流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Word_Count_MapReduce_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="rpc" class="heading-element"><span>3.2 RPC</span>
  <a href="#rpc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通信时首先需要确定这个消息是什么类型, 通过前述分析可知：</p>
<ul>
<li>
<p>对于<code>Worker</code>发送消息，<code>Worker</code>需要跟<code>Coordinator</code>报告<code>Map</code>或<code>Reduce</code>任务的执行情况(成功或失败)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskCompletedStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MapTaskCompleted</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MapTaskFailed</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ReduceTaskCompleted</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ReduceTaskFailed</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<ul>
<li>
<p>对于<code>Coordinator</code>回复消息，<code>Coordinator</code>需要分配<code>Reduce</code>或<code>Map</code>任务，告知任务的类型，或者告知<code>Worker</code>休眠（暂时没有任务需要执行）、<code>Worker</code>退出（所有任务执行成功）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskType</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MapTask</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ReduceTask</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Wait</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Exit</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>同时，消息还需要附带额外的信息，我这里的设计是发送消息包含任务ID，以便<code>Coordinator</code>更新任务状态，结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MessageSend</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TaskID</span>              <span class="kt">int</span>                 <span class="c1">// task id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskCompletedStatus</span> <span class="nx">TaskCompletedStatus</span> <span class="c1">// task completed status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>回复消息结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MessageReply</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TaskID</span>   <span class="kt">int</span>      <span class="c1">// task id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskType</span> <span class="nx">TaskType</span> <span class="c1">// task type, map or reduce or wait or exit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskFile</span> <span class="kt">string</span>   <span class="c1">// task file name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NReduce</span>  <span class="kt">int</span>      <span class="c1">// reduce number, indicate the number of reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NMap</span>     <span class="kt">int</span>      <span class="c1">// map number, indicate the number of map tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些字段都是为了辅助<code>Worker</code>进行任务处理，如<code>NMap</code>是为了提供Map任务的数量，以便生成中间文件名，<code>TaskFile</code>是保存Map任务需要处理的输入文件。</p>
<p>对于通信，原框架已提供Unix套接字通信，如果有想法，我们可以将 RPC 设置为通过 TCP/IP 而不是 Unix 套接字进行通信（请参阅 <code>Coordinator.server()</code> 中注释掉的行），并使用共享文件系统读/写文件。</p>
<h3 id="coordinator" class="heading-element"><span>3.3 Coordinator</span>
  <a href="#coordinator" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="结构" class="heading-element"><span>3.3.1 结构</span>
  <a href="#%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>如前所述，<code>Coordinator</code>需要管理任务的状态信息，对于一个任务而言，我们这里定义它的状态为：未分配、已分配、完成、失败。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskStatus</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Unassigned</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Assigned</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Completed</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Failed</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>那么，任务结构应该包括任务状态，同时，如论文中提到的，可能有<code>Worker</code>成为落伍者，所以我们还需要考虑一个任务是否执行了很长时间还没结束，故这里需要记录任务分配时的时间戳，以便计算运行时间。另外，我们还需要一个字段来存储需要处理的任务文件名。故任务信息结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TaskInfo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TaskStatus</span> <span class="nx">TaskStatus</span> <span class="c1">// task status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TaskFile</span>   <span class="kt">string</span>     <span class="c1">// task file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TimeStamp</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>  <span class="c1">// time stamp, indicating the running time of the task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于<code>Coordinator</code>结构，首先肯定是需要两个数据结构来存储所有的Map任务状态和Reduce任务状态，我这里使用的列表；然后由于是并发执行，更新共享任务状态数据，需要一把大锁保平安；最后需要一些额外变量存储任务数量（也可以直接<code>len(list)</code>）以及标志某阶段任务是否完成（如在Reduce任务进行之前Map任务是否已经完成）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Coordinator</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NMap</span>                   <span class="kt">int</span>        <span class="c1">// number of map tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NReduce</span>                <span class="kt">int</span>        <span class="c1">// number of reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MapTasks</span>               <span class="p">[]</span><span class="nx">TaskInfo</span> <span class="c1">// map task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ReduceTasks</span>            <span class="p">[]</span><span class="nx">TaskInfo</span> <span class="c1">// reduce task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">AllMapTaskCompleted</span>    <span class="kt">bool</span>       <span class="c1">// whether all map tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">AllReduceTaskCompleted</span> <span class="kt">bool</span>       <span class="c1">// whether all reduce tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Mutex</span>                  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// mutex, used to protect the shared data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="初始化" class="heading-element"><span>3.3.2 初始化</span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们需要对<code>Coordinator</code>初始化，其中最重要的是更新任务初始状态，一开始都是未分配，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">InitTask</span><span class="p">(</span><span class="nx">file</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">idx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="p">=</span> <span class="nx">TaskInfo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TaskFile</span><span class="p">:</span>   <span class="nx">file</span><span class="p">[</span><span class="nx">idx</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TaskStatus</span><span class="p">:</span> <span class="nx">Unassigned</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TimeStamp</span><span class="p">:</span>  <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">idx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="p">=</span> <span class="nx">TaskInfo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TaskStatus</span><span class="p">:</span> <span class="nx">Unassigned</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MakeCoordinator</span><span class="p">(</span><span class="nx">files</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">nReduce</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Coordinator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">Coordinator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">NReduce</span><span class="p">:</span>                <span class="nx">nReduce</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">NMap</span><span class="p">:</span>                   <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MapTasks</span><span class="p">:</span>               <span class="nb">make</span><span class="p">([]</span><span class="nx">TaskInfo</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ReduceTasks</span><span class="p">:</span>            <span class="nb">make</span><span class="p">([]</span><span class="nx">TaskInfo</span><span class="p">,</span> <span class="nx">nReduce</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">AllMapTaskCompleted</span><span class="p">:</span>    <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">AllReduceTaskCompleted</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Mutex</span><span class="p">:</span>                  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">InitTask</span><span class="p">(</span><span class="nx">files</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">server</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="requesttask函数" class="heading-element"><span>3.3.3 RequestTask函数</span>
  <a href="#requesttask%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这部分比较复杂，根据我们之前的分析，处理逻辑如下：</p>
<ol>
<li>如果有未分配的任务、之前执行失败、已分配但已经超时（10s）的<code>Map</code>任务，则选择这个任务进行分配；</li>
<li>如果以上的<code>Map</code>任务均不存在，但<code>Map</code>又没有全部执行完成，告知<code>Worker</code>先等待；</li>
<li><code>Map</code>任务全部执行完成的情况下，按照<code>1</code>和<code>2</code>相同的逻辑进行<code>Reduce</code>任务的分配；</li>
<li>所有的任务都执行完成了, 告知<code>Worker</code>退出。</li>
</ol>
<p>因此，处理代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">RequestTask</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">MessageSend</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// assign map task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">AllMapTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// count the number of completed map tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">NMapTaskCompleted</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">idx</span><span class="p">,</span> <span class="nx">taskInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Unassigned</span> <span class="o">||</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Failed</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Assigned</span> <span class="o">&amp;&amp;</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TimeStamp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span> <span class="p">=</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskFile</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span> <span class="p">=</span> <span class="nx">idx</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">MapTask</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NReduce</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NMap</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NMap</span>
</span></span><span class="line"><span class="cl">				<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Assigned</span>  <span class="c1">// mark the task as assigned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TimeStamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="c1">// update the time stamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Completed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">NMapTaskCompleted</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// check if all map tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">NMapTaskCompleted</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">AllMapTaskCompleted</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">Wait</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// assign reduce task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">AllReduceTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// count the number of completed reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">NReduceTaskCompleted</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">idx</span><span class="p">,</span> <span class="nx">taskInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Unassigned</span> <span class="o">||</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Failed</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Assigned</span> <span class="o">&amp;&amp;</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TimeStamp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span> <span class="p">=</span> <span class="nx">idx</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">ReduceTask</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NReduce</span>
</span></span><span class="line"><span class="cl">				<span class="nx">reply</span><span class="p">.</span><span class="nx">NMap</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NMap</span>
</span></span><span class="line"><span class="cl">				<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Assigned</span>  <span class="c1">// mark the task as assigned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">TimeStamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="c1">// update the time stamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">taskInfo</span><span class="p">.</span><span class="nx">TaskStatus</span> <span class="o">==</span> <span class="nx">Completed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">NReduceTaskCompleted</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// check if all reduce tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">NReduceTaskCompleted</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">AllReduceTaskCompleted</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">Wait</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// all tasks have been completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">=</span> <span class="nx">Exit</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="reporttask函数" class="heading-element"><span>3.3.4 ReportTask函数</span>
  <a href="#reporttask%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这个函数则是根据<code>Worker</code>发送的消息任务完成状态来更新任务状态信息即可，<font color="red">记住，一把大锁保平安</font>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Coordinator</span><span class="p">)</span> <span class="nf">ReportTask</span><span class="p">(</span><span class="nx">args</span> <span class="o">*</span><span class="nx">MessageSend</span><span class="p">,</span> <span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">MapTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Completed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">MapTaskFailed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">MapTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Failed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">ReduceTaskCompleted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Completed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">args</span><span class="p">.</span><span class="nx">TaskCompletedStatus</span> <span class="o">==</span> <span class="nx">ReduceTaskFailed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">ReduceTasks</span><span class="p">[</span><span class="nx">args</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">].</span><span class="nx">TaskStatus</span> <span class="p">=</span> <span class="nx">Failed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="worker" class="heading-element"><span>3.4 Worker</span>
  <a href="#worker" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="worker轮询" class="heading-element"><span>3.4.1 Worker轮询</span>
  <a href="#worker%e8%bd%ae%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>Worker</code>需要通过RPC轮询<code>Coordinator</code>请求任务，然后根据返回的任务类型进行处理（即调用相应函数）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Worker</span><span class="p">(</span><span class="nx">mapf</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">reducef</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">args</span> <span class="o">:=</span> <span class="nx">MessageSend</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">reply</span> <span class="o">:=</span> <span class="nx">MessageReply</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.RequestTask&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reply</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">MapTask</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nf">HandleMapTask</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">reply</span><span class="p">,</span> <span class="nx">mapf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">ReduceTask</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nf">HandleReduceTask</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">reply</span><span class="p">,</span> <span class="nx">reducef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">Wait</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">Exit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="处理map任务" class="heading-element"><span>3.4.2 处理Map任务</span>
  <a href="#%e5%a4%84%e7%90%86map%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>跟<code>mrsequential.go</code>处理基本一致，处理完成后需要通过RPC告知<code>Coordinator</code>结果。但需要注意的是，我们需要通过<code>os.Rename()</code>原子重命名来保证最终的文件系统状态仅仅包含一个任务产生的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">HandleMapTask</span><span class="p">(</span><span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">,</span> <span class="nx">mapf</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">KeyValue</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// open the file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot open %v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// read the file, get the content
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot read %v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// call the map function to get the key-value pairs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">kva</span> <span class="o">:=</span> <span class="nf">mapf</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">TaskFile</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">content</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// create intermediate files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">intermediate</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="nx">KeyValue</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">kv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">kva</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span> <span class="o">:=</span> <span class="nf">ihash</span><span class="p">(</span><span class="nx">kv</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="o">%</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">NReduce</span>
</span></span><span class="line"><span class="cl">		<span class="nx">intermediate</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">[</span><span class="nx">r</span><span class="p">],</span> <span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// write the intermediate files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">kva</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intermediate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">oname</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-%v-%v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ofile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">CreateTemp</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot create tempfile %v&#34;</span><span class="p">,</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">enc</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">ofile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">kv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">kva</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// write the key-value pairs to the intermediate file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">enc</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ofile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Atomic file renaming：rename the tempfile to the final intermediate file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">ofile</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// send the task completion message to the coordinator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">MessageSend</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskID</span><span class="p">:</span>              <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskCompletedStatus</span><span class="p">:</span> <span class="nx">MapTaskCompleted</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.ReportTask&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">MessageReply</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="处理reduce任务" class="heading-element"><span>3.4.3 处理Reduce任务</span>
  <a href="#%e5%a4%84%e7%90%86reduce%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>这里利用我们生成的中间文件名特点，对于每个<code>Reduce</code>任务，它的输入文件（中间文件）名为<code>mr-MapID-ReduceID</code>，所以我们构造出输入文件数组，将其解码得到键值对，再进行处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// generate the intermediate files for reduce tasks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">generateFileName</span><span class="p">(</span><span class="nx">r</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">NMap</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fileName</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">TaskID</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">TaskID</span> <span class="p">&lt;</span> <span class="nx">NMap</span><span class="p">;</span> <span class="nx">TaskID</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fileName</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-%d-%d&#34;</span><span class="p">,</span> <span class="nx">TaskID</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">fileName</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">HandleReduceTask</span><span class="p">(</span><span class="nx">reply</span> <span class="o">*</span><span class="nx">MessageReply</span><span class="p">,</span> <span class="nx">reducef</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// load the intermediate files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">intermediate</span> <span class="p">[]</span><span class="nx">KeyValue</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// get the intermediate file names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">intermediateFiles</span> <span class="o">:=</span> <span class="nf">generateFileName</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">NMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// fmt.Println(intermediateFiles)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intermediateFiles</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot open %v&#34;</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// decode the intermediate file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">dec</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">kv</span> <span class="o">:=</span> <span class="nx">KeyValue</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">kv</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">intermediate</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">,</span> <span class="nx">kv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// sort the intermediate key-value pairs by key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span> <span class="p">&lt;</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Key</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// write the key-value pairs to the output file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">oname</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;mr-out-%v&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ofile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot create %v&#34;</span><span class="p">,</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">);</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">values</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">values</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// call the reduce function to get the output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">output</span> <span class="o">:=</span> <span class="nf">reducef</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// write the key-value pairs to the output file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">ofile</span><span class="p">,</span> <span class="s">&#34;%v %v\n&#34;</span><span class="p">,</span> <span class="nx">intermediate</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ofile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// rename the output file to the final output file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">ofile</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">oname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// send the task completion message to the coordinator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">MessageSend</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskID</span><span class="p">:</span>              <span class="nx">reply</span><span class="p">.</span><span class="nx">TaskID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TaskCompletedStatus</span><span class="p">:</span> <span class="nx">ReduceTaskCompleted</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">call</span><span class="p">(</span><span class="s">&#34;Coordinator.ReportTask&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">MessageReply</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="测试和常见问题" class="heading-element"><span>4 测试和常见问题</span>
  <a href="#%e6%b5%8b%e8%af%95%e5%92%8c%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><code>test-mr.sh</code>为测试脚本，也可以通过运行<code>sh test-mr-many.sh n</code>来运行$n$次测试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">❯ bash test-mr.sh
</span></span><span class="line"><span class="cl">*** Starting wc <span class="nb">test</span>
</span></span><span class="line"><span class="cl">--- wc test: PASS
</span></span><span class="line"><span class="cl">*** Starting indexer test.
</span></span><span class="line"><span class="cl">--- indexer test: PASS
</span></span><span class="line"><span class="cl">*** Starting map parallelism test.
</span></span><span class="line"><span class="cl">--- map parallelism test: PASS
</span></span><span class="line"><span class="cl">*** Starting reduce parallelism test.
</span></span><span class="line"><span class="cl">--- reduce parallelism test: PASS
</span></span><span class="line"><span class="cl">*** Starting job count test.
</span></span><span class="line"><span class="cl">--- job count test: PASS
</span></span><span class="line"><span class="cl">*** Starting early <span class="nb">exit</span> test.
</span></span><span class="line"><span class="cl">--- early <span class="nb">exit</span> test: PASS
</span></span><span class="line"><span class="cl">*** Starting crash test.
</span></span><span class="line"><span class="cl">--- crash test: PASS
</span></span><span class="line"><span class="cl">*** PASSED ALL TESTS</span></span></code></pre></td></tr></table>
</div>
</div><p>常见的问题如下：</p>
<ol>
<li>
<p>不能通过<code>job-count</code>测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="o">***</span> <span class="nx">Starting</span> <span class="nx">job</span> <span class="nx">count</span> <span class="nx">test</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="o">---</span> <span class="kd">map</span> <span class="nx">jobs</span> <span class="nx">ran</span> <span class="nx">incorrect</span> <span class="nx">number</span> <span class="nx">of</span> <span class="nf">times</span> <span class="p">(</span><span class="mi">10</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">---</span> <span class="nx">job</span> <span class="nx">count</span> <span class="nx">test</span><span class="p">:</span> <span class="nx">FAIL</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因为多次处理同一个任务，且任务没有异常。这是因为在分配任务后没有更新任务的状态，例如标记为已分配和记录当前时间戳。</p>
</li>
</ol>
]]></description></item><item><title>【MIT 6.5840(6.824)学习笔记】 分布式系统介绍</title><link>https://hezephyr.github.io/posts/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 14 May 2024 14:12:32 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</guid><description><![CDATA[<h2 id="概念" class="heading-element"><span>1 概念</span>
  <a href="#%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当我们谈论分布式系统时，我们指的是一组通过网络连接的计算机，它们协同工作以完成某种共同的任务或目标。</p>
<p>在分布式系统中，通信是通过消息传递进行的。<font color="red">这意味着各个计算节点之间通过发送和接收消息来进行通信，而不是通过共享内存。</font>这种消息传递模型使得分布式系统的设计和实现更为灵活，因为每个节点可以独立地运行，并通过消息传递来进行协作。</p>
<p>尽管消息传递模型具有很多优点，但也需要注意到它引入了一些复杂性。例如，需要考虑消息的传递延迟、顺序和可靠性等问题。因此，在设计分布式系统时，需要仔细考虑如何有效地管理消息传递，以确保系统的正确性和性能。</p>
<blockquote>
<p>TIP：在设计系统或解决问题时，应该始终优先考虑在单台计算机上解决。只有在问题规模超出单台计算机的处理能力，或者需要满足高可用性、容错性等需求时，才需要考虑采用分布式系统。因此，深入了解问题的性质和需求，以及权衡利弊，是设计分布式系统的关键。</p>
</blockquote>
<h2 id="驱动力和挑战" class="heading-element"><span>2 驱动力和挑战</span>
  <a href="#%e9%a9%b1%e5%8a%a8%e5%8a%9b%e5%92%8c%e6%8c%91%e6%88%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>当人们构建分布式系统时，驱动力主要包括以下几个方面：</p>
<ol>
<li><strong>追求更高的计算性能</strong>：分布式系统能够利用大量的计算资源，实现并行运算，充分利用多个CPU、大容量内存和磁盘资源。</li>
<li><strong>实现容错性</strong>：即使在其中一台计算机发生故障时，系统仍然能够保持正常运行。</li>
<li><strong>解决空间分布性问题</strong>：某些问题天然具有空间分布性，需要跨越不同地理位置的计算资源和数据进行协同处理。例如，银行跨地域的资金转移需要协调不同地点的数据和操作，这就需要分布式系统来实现数据的同步和协调，以确保交易的准确性和可靠性。</li>
<li><strong>提高安全性</strong>：分布式系统可以通过将系统分散在多个计算机上来提高安全性。不信任的代码或系统可能存在潜在的安全风险，通过在分布式环境中运行代码并采用加密通信等安全措施，可以有效降低风险，并限制错误和攻击的影响范围。</li>
</ol>
<p>分布式系统的挑战源自其驱动力：</p>
<ol>
<li><strong>并发执行和复杂交互</strong>：分布式系统中存在大量并发执行的部分，以及复杂的交互关系。这导致了在并发编程中遇到各种问题，例如同步、异步操作的管理以及处理时间依赖性。</li>
<li><strong>意外故障</strong>：分布式系统由多个组成部分和计算机网络组成，因此容易受到意外故障的影响。与单个计算机不同，这些组件可能在工作或停止状态之间切换，同时还受到网络中断或不稳定性的影响。</li>
<li><strong>性能预期</strong>：分布式系统的设计旨在实现更高的性能，例如利用大量计算资源实现并行处理。但实际评估多台计算机或磁盘臂的性能存在一定挑战，需要仔细的设计和调整以实现预期的性能水平。</li>
</ol>
<h2 id="抽象和实现工具" class="heading-element"><span>3 抽象和实现工具</span>
  <a href="#%e6%8a%bd%e8%b1%a1%e5%92%8c%e5%ae%9e%e7%8e%b0%e5%b7%a5%e5%85%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>分布式系统基础架构主要包括<font color="red">存储、通信（网络）和计算</font>这三种类型。我们的目标是设计简单的接口，使第三方应用程序能够轻松使用这些分布式存储和计算功能，这样才能简单的在这些基础架构之上，构建第三方应用程序。</p>
<p>通过这种抽象接口，我们可以将分布式系统的复杂性隐藏在系统内部，使用户专注于应用程序的开发。举例来说，在存储方面，用户可以将整个系统视为非分布式系统，类似于一个文件系统或者常规的编程模型，而不必担心分布式系统的细节。我们的目标是构建一个接口，使其看起来像一个非分布式存储和计算系统，但实际上却具备了分布式系统的高性能和容错性。</p>
<p>但实际上，很难能找到一个抽象来描述分布式的存储或者计算，使得它们能够像非分布式系统一样有简单易懂的接口。</p>
<p>抽象的实际实现是我们首先要考虑的问题。在构建分布式系统时，人们使用了许多工具：</p>
<ul>
<li><strong>RPC（Remote Procedure Call）</strong>：RPC旨在掩盖在不可靠网络上通信的复杂性，使得远程调用过程更为简单直接。</li>
<li><strong>线程</strong>：线程是一种重要的编程技术，可用于充分利用多核心计算机。它不仅仅是为了提高计算机的利用率，更重要的是提供了结构化的并发操作方式，简化了程序员对并发操作的处理。</li>
<li><strong>分布式文件系统</strong>：分布式文件系统是分布式系统中常用的存储工具之一，它提供了分布式的数据存储和访问接口。通过分布式文件系统，可以实现数据的分布式存储和管理，从而支持大规模数据处理和分布式计算任务的执行。</li>
</ul>
<h2 id="分布式系统特性" class="heading-element"><span>4 分布式系统特性</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%89%b9%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="可扩展性" class="heading-element"><span>4.1 可扩展性</span>
  <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>分布式系统的主要特性是可扩展性（Scalability）。可扩展性指的是，增加计算资源后系统能够以相应的方式提高性能或吞吐量。举例来说，如果一台计算机能够解决一定量的问题，那么增加第二台计算机后，系统能够以更快的速度解决相同数量的问题，或者在相同时间内处理更多的问题。如果由两台计算机组成的系统能够实现两倍的性能或吞吐量，那就达到了可扩展性的标准。</p>
<p>这是一个极为强大的特性，因为只需花钱就可以购买计算机。如果构建的系统能够通过增加计算机数量来提高性能或吞吐量，那将是一个巨大的成就。相比之下，通过雇佣程序员来优化系统或应用更优的算法通常是一种昂贵的方法。我们希望通过增加计算机数量，从十台提升到一千台，来应对一百倍的流量。</p>
<p>例如在构建一个常规网站时，通常会有一个HTTP服务器、一些用户和浏览器以及基于Python或PHP的Web服务器，它们与数据库进行交互。</p>
<p>在初始阶段，一台计算机可以运行Web服务器和数据库，或者将Web服务器和数据库分别部署在两台计算机上。但是，当网站突然迎来数以亿计的用户登录请求时，单一服务器显然无法满足需求。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=small" data-sub-html="<h2>image-20240513103410005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web" alt="image-20240513103410005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Web?size=large 2x" data-title="image-20240513103410005" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了应对高流量，第一步是购买更多的Web服务器，并将用户分配到不同的服务器上。这样，不同的用户可以访问不同的Web服务器，但它们需要访问相同的数据，因此所有的Web服务器都需要与后端数据库通信。在这个阶段，通过添加更多的Web服务器来提高代码效率是一个有效的方法，前提是单个服务器不会给数据库带来过大的压力。</p>
<p>然而，可扩展性并非无限的。随着Web服务器数量的增加，数据库很可能成为性能的瓶颈。即使增加更多的Web服务器也无法解决问题。在某个临界点，系统中添加更多计算机将不再有效，而瓶颈将转移到其他地方，比如从Web服务器转移到数据库。</p>
<p>在这种情况下，必须进行一些重构工作。然而，重构一个单一的数据库是困难的，尽管可以将数据库拆分为多个来提高性能，但这需要大量的工作。</p>
<h3 id="可用性" class="heading-element"><span>4.2 可用性</span>
  <a href="#%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在构建系统时，使用单台计算机往往具有较高的可靠性。单台计算机通常可以长时间稳定运行，这是因为计算机和操作系统都很可靠，而且电源也很稳定。然而，如果系统由数千台计算机构成，即使每台计算机都能稳定运行一年，每天也会有多台计算机发生故障。</p>
<p>因此，大型分布式系统面临的一个主要问题是放大一些罕见问题的影响。在这样的系统中，总会有一些机器故障、运行错误、执行缓慢或执行错误任务的情况发生。网络问题也是一个常见的挑战，比如网线踩断或交换机故障。这些小问题在大规模系统中会变成持续不断的问题。</p>
<p>因此，在设计系统时必须考虑系统的容错性，即使发生错误也要能够继续运行。同时，为了简化应用开发人员的工作，需要构建一个基础架构，能够尽可能屏蔽和掩盖错误。</p>
<p>容错有多种概念和表述方式，其中一个重要思想是可用性（Availability）。通过精心设计，系统可以在特定类型的错误发生时继续提供服务，就像没有错误一样。某些系统通过多副本的方式实现可用性。比如，构建一个有两个拷贝的多副本系统，其中一个故障了，另一个仍然可以正常运行。可用性意味着在特定的故障范围内，系统仍能提供服务。</p>
<p>另一种容错特性是自我可恢复性（Recoverability），即在出现问题后系统停止工作，不再响应请求，等待修复，然后恢复正常运行。</p>
<p>可恢复性是一个重要的需求，尽管它比可用性更弱。在故障发生到修复期间，系统将完全停止工作。但修复后，系统应能正确运行，因此可恢复性至关重要。对于可恢复的系统，通常需要采取一些措施，如将最新数据存储在磁盘中，以便在供电恢复后检索。甚至对于具备可用性的系统，在实际应用中，也需要具备可恢复性。</p>
<p>为了实现这些特性，有两个关键工具。</p>
<ul>
<li>一个是非易失存储（Non-volatile storage），如硬盘或闪存，用于存储系统状态的checkpoint或日志。这样，即使出现电源故障，系统也能从存储中读取最新状态，并继续运行。</li>
<li>另一个重要工具是复制（Replication），即通过多副本系统实现容错。管理复制的多副本系统可能会面临同步偏移等问题，这在容错系统中是一个挑战。</li>
</ul>
<h3 id="一致性" class="heading-element"><span>4.3 一致性</span>
  <a href="#%e4%b8%80%e8%87%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>最后一个很重要的特性是一致性（Consistency）。一致性定义了操作的行为，特别是在分布式系统中。在分布式存储系统中，例如键值（KV）服务，put操作将一个值存储到一个键中，而get操作从键中获取值。在分布式系统中，多个副本可能存在不同版本的数据，因此一致性变得至关重要。</p>
<p>强一致性（Strong Consistency）要求get请求总是返回最近一次完成的put请求写入的值，这确保了数据的完全一致。然而，实现强一致性需要大量的通信和延迟。弱一致性（Weak Consistency）不保证get请求获取到最新的数据，但通常可以提供更高的性能。</p>
<p>因此，为了尽可能减少通信，特别是当副本相距很远时，人们会构建弱一致性系统，只需要更新最近的数据副本，并且只需要从最近的副本获取数据，并允许读取旧数据。当然，为了使弱一致性更具实际意义，人们会定义更多的规则。</p>
<h2 id="mapreduce论文阅读笔记" class="heading-element"><span>5 MapReduce论文阅读笔记</span>
  <a href="#mapreduce%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a href="https://blog.csdn.net/hzf0701/article/details/138770454?spm=1001.2014.3001.5501"target="_blank" rel="external nofollow noopener noreferrer">MapReduce论文阅读笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>【论文阅读笔记】MapReduce: Simplified Data Processing on Large Clusters</title><link>https://hezephyr.github.io/posts/01.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0mapreduce/</link><pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0mapreduce/</guid><description><![CDATA[<h2 id="概念" class="heading-element"><span>1 概念</span>
  <a href="#%e6%a6%82%e5%bf%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><code>MapReduce</code> 是一种用于在大型集群上进行简化数据处理的编程模型和计算框架。它最初由 Google 公司设计用于解决大规模数据处理问题，后来被广泛应用于各种大数据处理场景。</p>
<p><code>MapReduce</code> 模型的核心思想是将大规模的数据集分解成多个小的数据块，然后分配给集群中的多个计算节点进行并行处理，最终将结果合并成最终的输出。</p>
<h2 id="编程模型" class="heading-element"><span>2 编程模型</span>
  <a href="#%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>MapReduce 编程模型由两个主要阶段组成：map 阶段和 reduce 阶段。</p>
<ul>
<li><strong>map 阶段</strong>：在 map 阶段，输入数据被分割成若干个数据块，并由不同的计算节点进行并行处理。每个计算节点都会执行用户定义的 map 函数，将输入数据转换为键值对的形式，并发出中间结果。</li>
<li><strong>reduce 阶段</strong>：在 reduce 阶段，会将中间结果按照键进行分组，并由不同的计算节点进行并行处理。每个计算节点都会执行用户定义的 reduce 函数，对相同键的数据进行合并和处理，最终生成最终的输出结果。</li>
</ul>
<p>对于用户(MapReduce的使用者)而言：MapReduce是一种抽象化的编程模型，它隐藏了分布式数据处理的细节，仅对外暴露<code>map</code>和<code>reduce</code>的抽象，用户来实现具体的<code>map</code>和<code>reduce</code>功能。MapReduce自身关注的是并行计算、容错、分布式数据、负载均衡等一系列问题，并且保证分布计算的结果和无错误的串形计算的结果一致。</p>
<p>形式化地说，由用户提供的 <code>map</code> 函数和 <code>reduce</code> 函数应有如下类型：
$$
\begin{align*}
\text{map} &amp;\quad (k_1, v_1)\quad\quad\quad\rightarrow\quad\text{list}(k_2, v_2)\
\text{reduce} &amp;\quad (k_2,\text{list}(v_2))\quad\rightarrow\quad\text{list}(v_2)
\end{align*}
$$
其中，输入的 <code>key</code> 和 <code>value</code> 值与输出的 <code>key</code> 和 <code>value</code> 值在类型上推导的域不同。此外，中间结果 <code>key</code> 和 <code>value</code> 值与输出 <code>key</code> 和 <code>value</code> 值在类型上推导的域相同。</p>
<p>例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">map(String key, String value):
</span></span><span class="line"><span class="cl">    // key: document name
</span></span><span class="line"><span class="cl">    // value: document contents
</span></span><span class="line"><span class="cl">    for each word w in value:
</span></span><span class="line"><span class="cl">        EmitIntermediate(w, “1″);
</span></span><span class="line"><span class="cl">reduce(String key, Iterator values):
</span></span><span class="line"><span class="cl">    // key: a word
</span></span><span class="line"><span class="cl">    // values: a list of counts
</span></span><span class="line"><span class="cl">    int result = 0;
</span></span><span class="line"><span class="cl">    for each v in values:
</span></span><span class="line"><span class="cl">        result += ParseInt(v);
</span></span><span class="line"><span class="cl">    Emit(AsString(result));</span></span></code></pre></td></tr></table>
</div>
</div><p><code>map</code> 函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是 1)。<code>reduce</code> 函数把 <code>map</code> 函数产生的每一个特定的词的计数累加起来。</p>
<p>值得注意的是，在实际的实现中 <code>MapReduce</code> 框架使用 <code>Iterator</code> 来代表作为输入的集合，主要是为了避免集合过大，无法被完整地放入到内存中。</p>
<h2 id="实现" class="heading-element"><span>3 实现</span>
  <a href="#%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="mapreduce执行流程" class="heading-element"><span>3.1 MapReduce执行流程</span>
  <a href="#mapreduce%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>下图展示了<code>MapReduce</code>操作的全部流程。当用户调用 <code>MapReduce</code> 函数时，将发生下面的一 系列动作（下面的序号和图中的序号一一对应）：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=small" data-sub-html="<h2>image-20240512144947298</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png" alt="image-20240512144947298" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MapReduce_Execution_Overview.png?size=large 2x" data-title="image-20240512144947298" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li>用户程序首先调用的 <code>MapReduce</code> 库将输入文件分成 $M$ 个数据片度，每个数据片段的大小一般从 $16\text{ MB}$ 到$64\text{ MB}$(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在集群中创建大量的程序副本。</li>
<li>这些程序副本中的有一个特殊的程序—<code>master</code>。副本中其它的程序都是 <code>worker</code> 程序，由 <code>master</code> 分配 任务。有 $M$ 个 <code>map</code> 任务和 $R$ 个 <code>reduce</code> 任务将被分配，<code>master</code> 将一个 <code>map</code> 任务或 <code>reduce</code> 任务分配给一个空闲的 <code>worker</code>。</li>
<li>被分配了 <code>map</code> 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出键值对，然后把键值对传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间结果键值对，并缓存在内存中。</li>
<li>缓存中的键值对通过分区函数（可由用户指定，默认为<code>hasy(key) mod R</code>）分成 $R$ 个区域，之后周期性的写入到本地磁盘上。缓存的键值对在本地磁盘上的存储位置将被回传给 <code>master</code>，由 <code>master</code> 负责把这些存储位置再传送给 <code>reduce worker</code>。</li>
<li>当 <code>reduce worker</code> 程序接收到 <code>master</code> 程序发来的数据存储位置信息后，使用 <code>RPC</code> 从 <code>Map worker</code> 所在主机的磁盘上读取这些缓存数据。当 <code>reduce worker</code> 读取了所有的中间数据后，通过对 <code>key</code> 进行排序后使得具有相同 <code>key</code> 值的数据聚合在一起。由于许多不同的 <code>key</code> 值会映射到相同的 <code>reduce</code> 任务上， 因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</li>
<li><code>reduce worker</code> 程序遍历排序后的中间数据，对于每一个唯一的中间 <code>key</code> 值，<code>reduce worker</code> 程序将这 个 <code>key</code> 值和它相关的中间结果<code>value</code> 值的集合传递给用户自定义的 <code>reduce</code> 函数。<code>reduce</code> 函数的输出被追加到所属分区的输出文件。</li>
<li>当所有的 <code>map</code> 和 <code>reduce</code> 任务都完成之后，<code>master</code> 唤醒用户程序。在这个时候，在用户程序里的对 <code>MapReduce</code> 调用才返回。</li>
</ol>
<p>在成功完成任务之后，<code>MapReduce</code> 的输出存放在 $R$ 个输出文件中（对应每个 <code>reduce</code> 任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这 $R$ 个输出文件合并成一个文件—他们经常把这些文件作为另外一个 <code>MapReduce</code> 的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。</p>
<h3 id="master数据结构" class="heading-element"><span>3.2 master数据结构</span>
  <a href="#master%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>master</code> 持有一些数据结构，它存储每一个 <code>map</code> 和 <code>reduce</code> 任务的状态（空闲、工作中或完成)，以及 <code>worker</code> 机器(非空闲任务的机器)的标识。</p>
<p><code>master</code> 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从 <code>map</code> 传递到 <code>reduce</code>。因此， 对于每个已经完成的 <code>map</code> 任务，<code>master</code> 存储了 <code>map</code> 任务产生的 $R$ 个中间文件存储区域的大小和位置。当 <code>map</code> 任务完成时，<code>master</code> 接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的 <code>reduce</code> 任务。</p>
<h3 id="容错机制" class="heading-element"><span>3.3 容错机制</span>
  <a href="#%e5%ae%b9%e9%94%99%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="worker故障" class="heading-element"><span>3.3.1 worker故障</span>
  <a href="#worker%e6%95%85%e9%9a%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li>
<p>故障判定</p>
<p><code>master</code> 周期性的 <code>ping</code> 每个 <code>worker</code>。如果在一个约定的时间范围内没有收到 <code>worker</code> 返回的信息，<code>master</code> 将 把这个 <code>worker</code> 标记为失效。</p>
</li>
<li>
<p>故障处理</p>
<ul>
<li>正在运行：正在运行的 <code>map</code> 或 <code>reduce</code> 任务将被重新置为空闲状态，等待重新调度。</li>
<li>已完成：所有由这个故障的<code>worker</code> 完成的 <code>map</code> 任务也会被重设为初始的空闲状态，等待重新调度，因为该 <code>worker</code> 不可用也意味着存储在该 <code>worker</code> 本地磁盘上的中间结果也不可用了；已经完成的 <code>reduce</code> 任务的输出存储在全局文件系统（eg. Google File System）上，因此不需要重新执行。</li>
</ul>
</li>
</ul>
<p>当一个 <code>map</code> 任务首先被 <code>worker A</code> 执行，之后由于 <code>worker A</code> 故障了又被调度到 <code>worker B</code> 执行，这个“重新执行”的动作会被通知给所有执行 <code>reduce</code> 任务的 <code>worker</code>。任何还没有从 <code>worker A</code> 读取数据的 <code>reduce</code> 任务 将从 <code>worker B</code>读取数据。</p>
<h4 id="master故障" class="heading-element"><span>3.3.2 master故障</span>
  <a href="#master%e6%95%85%e9%9a%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>一个简单的解决办法是让 <code>master</code> 周期性的将上面描述的master数据结构的写入磁盘，<font color="red">即检查点（checkpoint）</font>。如果这个 master 任务失败了，可以从最后一个检查点（checkpoint）开始启动另一个 <code>master</code> 进程。</p>
<p>然而，由于只有一个 <code>master</code> 进程，<code>master</code> 失效后再恢复是比较麻烦的，因此现在的实现是如果 <code>master</code> 故障，就中止<code>MapReduce</code> 运算。用户可以检查到这个状态，并且可以根据需要重新执行 <code>MapReduce</code> 操作。</p>
<h4 id="出现故障时的语义" class="heading-element"><span>3.3.3 出现故障时的语义</span>
  <a href="#%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e6%97%b6%e7%9a%84%e8%af%ad%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当用户提供的 <code>map</code> 和 <code>reduce</code> 操作是输入确定性函数（即相同的输入产生相同的输出）时，MapReduce保证任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 这依赖对 <code>map</code> 和 <code>reduce</code> 任务的输出是原子提交的来完成这个特性。</p>
<ul>
<li>每个工作中的任务把它的输出写到私有的临时文件中。</li>
<li>每个 <code>reduce</code> 任务生成一个这样的文件，而每个 <code>map</code> 任务则生成 $R$ 个这样的文件（一 个 <code>reduce</code> 任务对应一个文件）。</li>
<li>当一个 <code>map</code> 任务完成的时，<code>worker</code> 发送一个包含 <code>R</code> 个临时文件名的完成消息给<code>master</code>。如果 <code>master</code> 从一个已经完成的 <code>map</code> 任务再次接收到到一个完成消息，<code>master</code> 将忽略这个消息；否 则，<code>master</code> 将这 $R$ 个文件的名字记录在数据结构里。</li>
<li>当 <code>reduce</code> 任务完成时，<code>reduce worker</code> 进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个 <code>reduce</code> 任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。这就依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 <code>reduce</code>任务产生的数据。</li>
</ul>
<p>使用 MapReduce 模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的 <code>map</code> 和 <code>reduce</code> 操作是确定性的，而且存在这样的一个事实：我们的语义（也可以理解为处理机制）等价于一个顺序的执行的操作。</p>
<p>当 <code>map</code> and/or <code>reduce</code> 操作是不确定性的时候，MapReduce提供虽然较弱但是依然合理的语义。当使用非确定操作的时候， 一个 <code>reduce</code> 任务 $R_1$ 的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个 <code>reduce</code> 任务 $R_2$的输出也许符合一个不同的非确定程序顺序执行产生的 $R_2$ 的输出。</p>
<p>考虑 <code>map</code> 任务 $M$ 和 <code>reduce</code> 任务 $R_1$、$R_2$ 的情况。我们设定 $e(R_i)$是 $R_i$ 已经提交的执行过程（有且仅有一个这样的执行过程）。出现较弱语义是因为 $e(R_1)$可能读取了$M$ 一次执行产生的输出，而 $e(R_2)$可能读取了 $M$ 的另一次执行产生的输出。</p>
<h3 id="存储位置" class="heading-element"><span>3.4 存储位置</span>
  <a href="#%e5%ad%98%e5%82%a8%e4%bd%8d%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">核心思想：尽量把输入数据(由 GFS 管理)存储在集群中机器的本地磁盘上来节省网络带宽。</font></p>
<p>GFS 把每个文件按 64MB 一个 Block 分隔，每个 Block 保存 在多台机器上，环境中就存放了多份拷贝(一般是 3 个拷贝)。MapReduce 的 <code>master</code> 在调度 <code>map</code> 任务时会考虑输入文件的位置信息，尽量将一个 <code>map</code> 任务调度在包含相关输入数据拷贝的机器上执行；</p>
<p>如果上述努力失败 了，<code>master</code> 将尝试在保存有输入数据拷贝的机器附近的机器上执行 <code>map</code> 任务(例如，分配到一个和包含输入数据的机器在一个 switch 里的 worker 机器上执行)。当在一个足够大的 cluster 集群上运行大型 MapReduce 操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。</p>
<h3 id="任务粒度" class="heading-element"><span>3.5 任务粒度</span>
  <a href="#%e4%bb%bb%e5%8a%a1%e7%b2%92%e5%ba%a6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>理想情况下，$M$ 和 $R$ 应当比集群中 <code>worker</code> 的机器数量要多得多。在每台 <code>worker</code> 机器都执行大量的不同任务能够<strong>提高集群的动态的负载均衡能力</strong>，并且能够加快故障恢复的速度：失效机器上执行的大量 <code>map</code> 任务都可以分布到所有其他的 <code>worker</code> 机器上去执行。</p>
<p>但是实际上，在具体实现中对 $M$ 和 $R$ 的取值都有一定的客观限制，因为 <code>master</code> 必须执行 $O(M+R) $次调度，并且在内存中保存 $O(M\times R)$个状态（对影响内存使用的因素还是比较小的：$O(M\times R)$块状态，大概每对 <code>map</code> 任务/<code>reduce</code> 任务 1 个字节就可以了）。</p>
<p>更进一步，$R$ 值通常是由用户指定的，因为每个 <code>reduce</code> 任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的 $M$ 值，<font color="red">以使得每一个独立任务都是处理大约 16M 到 64M 的输入数据</font>（这样， 上面描写的输入数据本地存储优化策略才最有效），另外，我们把 $R$ 值设置为我们想使用的 <code>worker</code> 机器数量的小的倍数。</p>
<p>所以我们通常会用这样的比例来执行 MapReduce：$M=200000$，$R=5000$，使用 $2000$ 台 <code>worker</code> 机器。</p>
<h3 id="备用任务" class="heading-element"><span>3.6 备用任务</span>
  <a href="#%e5%a4%87%e7%94%a8%e4%bb%bb%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>如果集群中有某个 <code>worker</code> 花了特别长的时间来完成最后的几个 <code>map</code> 或 <code>reduce</code> 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 <code>worker</code> 也就成了落后者（Straggler）。</p>
<p>因此，论文提出一个通用的机制来减少“落伍者”出现的情况。当一个 MapReduce 操作接近完成的时候，<code>master</code> 会调度备用（backup）任务进程来执行剩下的、处于处理中状态（in-progress）的任务。<font color="red">无论是最初的执行、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。</font></p>
<h2 id="扩展技巧" class="heading-element"><span>4 扩展技巧</span>
  <a href="#%e6%89%a9%e5%b1%95%e6%8a%80%e5%b7%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="分区函数" class="heading-element"><span>4.1 分区函数</span>
  <a href="#%e5%88%86%e5%8c%ba%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>MapReduce 的使用者通常会指定 <code>reduce</code> 任务和 <code>reduce</code> 任务输出文件的数量（$R$）。我们在中间结果<code>key</code> 上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。</p>
<p>一个缺省的分区函数是使用 <code>hash</code> 方法(比如， <code>hash(key) mod R</code>)进行分区。<code>hash</code> 方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 <code>key</code> 值进行的分区将非常有用。</p>
<p>比如，输出的 <code>key</code> 值是 URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用<code>hash(Hostname(urlkey)) mod R</code>作为分区函数就可以把所有来自同一个主机的 URLs 保存在同一个输出文件中。</p>
<h3 id="顺序保证" class="heading-element"><span>4.2 顺序保证</span>
  <a href="#%e9%a1%ba%e5%ba%8f%e4%bf%9d%e8%af%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在给定的分区$R$中，MapReduce保证所有中间键值对数据的处理顺序是按照 <code>key</code> 值增量顺序处理的。</p>
<h3 id="combiner函数" class="heading-element"><span>4.3 Combiner函数</span>
  <a href="#combiner%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在某些情况下，<code>map</code> 函数产生的中间 <code>key</code> 值的重复数据会占很大的比重，并且，用户自定义的 <code>reduce</code> 函数满足结合律和交换律。词数统计程序是个很好的例子。由于词频率倾向于一个 zipf 分布，每个 <code>map</code> 任务将产生成千上万个这样的记录。所有的这些记录将通过网络被发送到一个单独的 <code>reduce</code> 任务，然后由这个<code>reduce</code> 任务把所有这些记录累加起来产生一个数字。</p>
<p>MapReduce允许用户指定一个可选的 <code>combiner</code> 函数，<code>combiner</code> 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出 去。 <code>combiner</code> 函数在每台执行 Map 任务的机器上都会被执行一次。一般情况下，<code>combiner</code> 和 <code>reduce</code> 函数是 一样的。<code>combiner</code> 函数和 Reduce 函数之间唯一的区别是 MapReduce 库怎样控制函数的输出。</p>
<p><code>reduce</code> 函数的输出被保存在最终的输出文件里，而 <code>combiner</code> 函数的输出被写到中间文件里，然后被发送给 <code>reduce</code> 任务。 部分的合并中间结果可以显著的提高一些 MapReduce 操作的速度。</p>
<h3 id="输入和输出的类型" class="heading-element"><span>4.4 输入和输出的类型</span>
  <a href="#%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba%e7%9a%84%e7%b1%bb%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>MapReduce库支持几种不同的格式的输入数据。比如文本模式中，<code>key</code>是文件的偏移量，<code>value</code>是该行内容。</p>
<p>程序员可以定义<code>Reader</code>接口来适应不同的输入类型，程序员需要保证必须能把输入数据切分成数据片段，且这些数据片段能够由单独的Map任务来处理就行了。<code>Reader</code>的数据源可能是数据库，可能是文本文件，甚至是内存等。</p>
<p>同样，用户采用类似添加新的输入数据类型的方式增加新的输出类型（定义<code>Writer</code>接口）。</p>
<h3 id="副作用" class="heading-element"><span>4.5 副作用</span>
  <a href="#%e5%89%af%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>程序员在写<code>map</code>和/或<code>reduce</code>操作的时候，可能会因为方便，定义很多额外功能，比如增加辅助的输出文件等。但应当时刻记住，<code>map</code>和<code>reduce</code>操作应当保证原子性和幂等性。</p>
<p>比如，一个任务生成了多个输出文件，但是我们没有原子化多段commit的操作。这就需要程序员自己保证生成多个输出的任务是确定性任务。</p>
<h3 id="跳过损坏的记录" class="heading-element"><span>4.6 跳过损坏的记录</span>
  <a href="#%e8%b7%b3%e8%bf%87%e6%8d%9f%e5%9d%8f%e7%9a%84%e8%ae%b0%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>有时候，用户程序中的 bug 导致 <code>map</code> 或者 <code>reduce</code> 函数在处理某些记录的时候 crash 掉，MapReduce 操作 无法顺利完成。相较于修复无法执行的 Bug，跳过引发 Bug 的记录可能更为明智。因此，我们希望 MapReduce 检测哪些记录导致确定性的crash， 并且跳过这些记录不处理。</p>
<p>MapReduce 如何自动检测这种情况呢？首先，每个<code>worker</code>进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。 在执行 <code>map</code> 或者 <code>reduce</code> 操作之前，MapReduce 库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，信号处理函数将用“最后一口气”通过 UDP 包向 <code>master</code> 发送处理的最后一条记录的序号。当 <code>master</code> 看到在处理某条特定记录不止失败一次时，<code>master</code> 就标志这条记录需要被跳过，并且在下次重新执行相关的<code>map</code> 或者 <code>reduce</code> 任务的时候跳过这条记录。</p>
<h3 id="本地执行" class="heading-element"><span>4.7 本地执行</span>
  <a href="#%e6%9c%ac%e5%9c%b0%e6%89%a7%e8%a1%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>调试 <code>map</code> 和 <code>reduce</code> 函数的 bug 非常困难，因为它们在分布式系统中执行，并且通常跨多台计算机执行，由 <code>master</code> 动态调度。为了简化调试、性能分析和小规模测试，Google开发了本地版本的 MapReduce 库。这个本地版本可以让 MapReduce 操作在单台计算机上顺序执行。用户可以控制操作的执行，并且可以将其限制在特定的 <code>map</code> 任务上。通过设置特殊标志，用户可以在本地执行他们的程序，并且轻松使用本地调试和测试工具（如 <code>gdb</code>）。</p>
<h3 id="状态信息" class="heading-element"><span>4.8 状态信息</span>
  <a href="#%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 <code>master</code> 内部，设有一个内置的 HTTP 服务器，用于展示一系列状态信息页面。这些页面会显示计算进度，例如已完成的任务数量、正在执行的任务数量、输入、中间数据和输出的字节数，以及处理速率等。</p>
<p>这些页面还包含了指向每个任务的<code>stderr</code>和<code>stdout</code>文件的链接。用户可以利用这些数据来预测计算完成所需的时间，以及是否需要增加更多资源。当计算花费的时间超过预期时，这些页面还可以帮助用户找出执行速度缓慢的原因。</p>
<p>另外，顶层状态页面还会显示出现故障的<code>worker</code>及其故障时正在执行的 <code>map</code> 和 <code>reduce</code> 任务。这些信息对于调试用户代码中的 bug 非常有帮助。</p>
<p><strong>很多分布式系统架构都会提供可视化监控界面，这是提升分布式系统的可维护性的重要手段</strong>。</p>
<h3 id="计数器" class="heading-element"><span>4.9 计数器</span>
  <a href="#%e8%ae%a1%e6%95%b0%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>MapReduce 库提供计数器机制，用来统计不同操作发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇 German 文档等等。</p>
<p>要想使用这个特性，用户需要创建Counter对象，然后在<code>map</code>和<code>reduce</code>函数中以正确的方式增加<code>counter</code>。这些计数器的值周期性的从各个单独的<code>worker</code>机器上传递给<code>master</code>（附加在ping的应答包中传递）。<code>master</code> 把执行成功的 <code>map</code> 和 <code>reduce</code> 任务的计数器值进行累计，当 MapReduce 操作完成之后，返回给用户代码。 计数器当前的值也会显示在 <code>master</code> 的状态页面上，这样用户就可以看到当前计算的进度。</p>
<p>当累加这些<code>counter</code>的值时，<code>master</code>会去掉那些重复执行的相同<code>map</code>或者<code>reduce</code>操作的次数，以此避免重复计数（之前提到的备用任务和故障后重新执行任务，这两种情况会导致相同的任务被多次执行）。</p>
<p>有些<code>counter</code>值是由MapReduce库自动维护的，例如已经处理过的输入键值对的数量以及生成的输出键值对的数量等等。</p>
<h2 id="应用场景" class="heading-element"><span>5 应用场景</span>
  <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="论文中提出的应用场景" class="heading-element"><span>5.1 论文中提出的应用场景</span>
  <a href="#%e8%ae%ba%e6%96%87%e4%b8%ad%e6%8f%90%e5%87%ba%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>分布式的 Grep：<code>map</code> 函数输出匹配某个模式的一行，<code>reduce</code> 函数是一个恒等函数，即把中间数据复制到输出。</li>
<li>计算 URL 访问频率：<code>map</code> 函数处理日志中 web 页面请求的记录，然后输出 (URL,1)。<code>reduce</code> 函数把相同 URL 的 value 值都累加起来，产生 (URL, 记录总数）结果。</li>
<li>倒转网络链接图：<code>map</code> 函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。 <code>reduce</code> 函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</li>
<li>每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。<code>map</code> 函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的 URL。<code>reduce</code> 函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。</li>
<li>倒排索引：<code>map</code> 函数分析每个文档输出一个(词,文档号)的列表，<code>reduce</code> 函数的输入是一个给定词的所有 （词，文档号），排序所有的文档号，输出(词,list(文档号))。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</li>
<li>分布式排序：<code>map</code> 函数从每个记录提取 <code>key</code>，输出(key,record)。<code>reduce</code> 函数不改变任何的值。这个运算依赖<strong>分区机制和排序属性</strong>。</li>
<li>重建索引系统：重写了 Google 网络搜索服务所使用的索引系统。这个索引系统的输入数据是网络爬虫抓取回来的大量文档，这些文档数据保存在 GFS 文件系统中，其原始内容超过了 20TB。通过一系列的 MapReduce 操作（大约 5 到 10 次），来建立索引。使用 MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：
<ul>
<li>简化的代码：索引部分的代码变得简单、小巧、易于理解；</li>
<li>灵活性：MapReduce 库的性能已经足够好，因此可以将概念上不相关的计算步骤分开处理，减少数据传递的额外开销；</li>
<li>操作管理的简化：因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由 MapReduce 库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</li>
</ul>
</li>
</ul>
<h3 id="其他应用场景" class="heading-element"><span>5.2 其他应用场景</span>
  <a href="#%e5%85%b6%e4%bb%96%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>数据清洗和预处理：MapReduce 可以用于处理大规模数据集的清洗和预处理，包括数据去重、数据过滤、数据格式转换等操作；</li>
<li>日志分析和异常检测：MapReduce 可以用于分析大规模日志数据，检测异常行为、故障事件和系统性能问题；</li>
<li>图算法和社交网络分析：MapReduce 可以应用于图算法和社交网络分析，包括图的遍历、最短路径计算、社区发现等操作；</li>
<li>文本挖掘和信息抽取：MapReduce 可以用于处理文本数据，进行信息抽取、实体识别、主题建模等自然语言处理任务。</li>
</ul>
<h2 id="faq" class="heading-element"><span>6 FAQ</span>
  <a href="#faq" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>当你调用emit时，数据会发生什么变化？emit函数在哪运行？</p>
<p>首先看，这些函数在哪运行。这里可以看MapReduce论文的图1。现实中，MapReduce运行在大量的服务器之上，我们称之为worker服务器或者worker。同时，也会有一个Master节点来组织整个计算过程。这里实际发生的是，Master服务器知道有多少输入文件，例如5000个输入文件，之后它将Map函数分发到不同的worker。所以，它会向worker服务器发送一条消息说，请对这个输入文件执行Map函数吧。之后，MapReduce框架中的worker进程会读取文件的内容，调用Map函数并将文件名和文件内容作为参数传给Map函数。worker进程还需要实现emit，这样，每次Map函数调用emit，worker进程就会将数据写入到本地磁盘的文件中。所以，Map函数中调用emit的效果是在worker的本地磁盘上创建文件，这些文件包含了当前worker的Map函数生成的所有的key和value。</p>
<p>所以，Map阶段结束时，我们看到的就是Map函数在worker上生成的一些文件。之后，MapReduce的worker会将这些数据移动到Reduce所需要的位置。对于一个典型的大型运算，Reduce的入参包含了所有Map函数对于特定key的输出。通常来说，每个Map函数都可能生成大量key。所以通常来说，在运行Reduce函数之前。运行在MapReduce的worker服务器上的进程需要与集群中每一个其他服务器交互来询问说，看，我需要对key=a运行Reduce，请看一下你本地磁盘中存储的Map函数的中间输出，找出所有key=a，并通过网络将它们发给我。所以，Reduce worker需要从每一个worker获取特定key的实例。这是通过由Master通知到Reduce worker的一条指令来触发。一旦worker收集完所有的数据，它会调用Reduce函数，Reduce函数运算完了会调用自己的emit，这个emit与Map函数中的emit不一样，它会将输出写入到一个Google使用的共享文件服务中。</p>
<p>有关输入和输出文件的存放位置，这是我之前没有提到的，它们都存放在文件中，但是因为我们想要灵活的在任意的worker上读取任意的数据，这意味着我们需要某种网络文件系统（network file system）来存放输入数据。所以实际上，MapReduce论文谈到了GFS（Google File System）。GFS是一个共享文件服务，并且它也运行在MapReduce的worker集群的物理服务器上。GFS会自动拆分你存储的任何大文件，并且以64MB的块存储在多个服务器之上。所以，如果你有了10TB的网页数据，你只需要将它们写入到GFS，甚至你写入的时候是作为一个大文件写入的，GFS会自动将这个大文件拆分成64MB的块，并将这些块平均的分布在所有的GFS服务器之上，而这是极好的，这正是我们所需要的。如果我们接下来想要对刚刚那10TB的网页数据运行MapReduce Job，数据已经均匀的分割存储在所有的服务器上了。如果我们有1000台服务器，我们会启动1000个Map worker，每个Map worker会读取1/1000输入数据。这些Map worker可以并行的从1000个GFS文件服务器读取数据，并获取巨大的读取吞吐量，也就是1000台服务器能提供的吞吐量。</p>
</blockquote>
<h2 id="参考" class="heading-element"><span>7 参考</span>
  <a href="#%e5%8f%82%e8%80%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf"target="_blank" rel="external nofollow noopener noreferrer">paper:MapReduce<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pdos.csail.mit.edu/6.824/schedule.html"target="_blank" rel="external nofollow noopener noreferrer">MIT 6.824<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/525032069"target="_blank" rel="external nofollow noopener noreferrer">知乎 【分布式】MapReduce论文笔记<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34849261"target="_blank" rel="external nofollow noopener noreferrer">知乎 Google MapReduce 论文详解<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>【论文阅读笔记】The Google File System</title><link>https://hezephyr.github.io/posts/02.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0gfs/</link><pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0gfs/</guid><description><![CDATA[<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Google File System (GFS) 是一个可扩展的分布式文件系统，专为快速增长的Google数据处理需求而设计。这篇论文发表于2003年，此前已在Google内部大规模应用。</p>
<p>GFS不仅追求性能、可伸缩性、可靠性和可用性等传统分布式文件系统的设计目标，还基于对自身应用负载情况和技术环境的深入观察，提出了独特的设计思路，与早期文件系统的假设明显不同。</p>
<h2 id="设计概述" class="heading-element"><span>2 设计概述</span>
  <a href="#%e8%ae%be%e8%ae%a1%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="设计目标" class="heading-element"><span>2.1 设计目标</span>
  <a href="#%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 在设计的时候有一些假想，即预期要实现的目标。</p>
<ol>
<li>系统由许多廉价的普通组件组成，因此<font color="red">组件失效是一种常态</font>。GFS必须能够持续监控自身的状态，将组件失效作为一种常态事件，并能够迅速侦测、冗余和恢复失效的组件。</li>
<li>系统能存储一定数量的大文件。Google预期会存储几百万个文件，这些文件通常大小在100MB以上，数GB大小的文件也是普遍存在的。系统必须能够高效管理这些大文件，同时，系统也必须支持小文件，但不需要针对小文件进行专门优化。</li>
<li>工作负载主要包括两类读操作：
<ul>
<li><strong>大规模流式读取</strong>：单个读操作一般读几百 KB，更常见的是读 1MB 甚至更多。来自同一个客户端的连续操作通常是读取同一个文件中连续的一个区域。</li>
<li><strong>小规模随机读取</strong>：一般是在文件的某个随机位置读几个 KB 数据。注重性能的应用程序通常会将小规模随机读取操作合并并排序，之后按顺序批量读取，避免在文件中前后移动读取位置。</li>
</ul>
</li>
<li>系统的工作负载也会有很多大规模的、顺序的、数据追加方式的写操作。一般这种操作的大小和大规模读类似。一旦写入操作完成，这个文件很少会被修改。小规模的随机写也支持，但是不太高效。</li>
<li><font color="red">系统必须高效的、行为定义明确的实现多客户端并行追加数据到同一个文件里的语意</font>。GFS 中的文件通常用作“生产者—消费者”队列或其他多路文件合并操作。系统中通常有数百个生产者，每个机器上运行一个，这些生产者并发地追加修改一个文件，<font color="red">因此以最小的同步开销来实现原子性是必不可少的</font>。这些文件可能随后被读取，也可能是消费者在追加的操作的同时读取文件。</li>
<li><font color="red">高性能的稳定网络带宽远比低延迟重要</font>。GFS 的大多数目标应用程序都重视以高速率的、大批量的处理数据，而很少有应用程序对单个读或写有严格的响应时间要求。</li>
</ol>
<h3 id="接口" class="heading-element"><span>2.2 接口</span>
  <a href="#%e6%8e%a5%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 提供了一套类似传统文件系统的 API 接口函数，虽然并不是严格按照 POSIX 等标准 API 的形式实现的。<font color="red">文件以分层目录的形式组织，用路径名来标识</font>。GFS 支持常用操作以创建(create)、删除(delete)、打开(open)、关闭(close)、读(read)和写(write)文件。</p>
<p>另外，GFS 提供了快照和记录追加操作。</p>
<ul>
<li><font color="red">快照以很低的成本创建一个文件或者目录树的拷贝</font>。</li>
<li><font color="red">记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的</font>。这对于实现多路结果合并、“生产者-消费者”队列非常有用，多个客户端可以同时追加写入，而不需要额外的同步锁。Google 发现在构建大型分布式应用时，这些类型的文件是非常有用的。</li>
</ul>
<h3 id="架构" class="heading-element"><span>2.3 架构</span>
  <a href="#%e6%9e%b6%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 GFS 集群包含一个单独的master节点和多个chunk服务器，允许多个客户端访问，如下图所示。</p>
<p>所有这些机器通常是普通的 Linux 机器，运行用户级别的服务进程。可以将 chunkserver和客户端部署在同一台机器上，前提是机器资源允许，并能接受稳定性降低的风险。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=small" data-sub-html="<h2>image-20240522203712282</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS" alt="image-20240522203712282" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/GFS?size=large 2x" data-title="image-20240522203712282" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>其中GFS存储的文件都被分割成固定大小的chunk。在chunk 创建的时候，master会给每个 chunk 分 配一个不变的、全局唯一的 64 位的 chunk 句柄来标识。chunkserver把 chunk 以 Linux 文件的形式保存在本地硬盘上，并且根据指定的 chunk 句柄和字节范围来读写块数据。出于可靠性的考虑，每个chunk都会复制到多个chunk服务器上。默认使用3 个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>
<p>master节点管理所有的文件系统元数据。这些元数据包括命名空间、访问控制信息、文件和chunk 的映射信息、以及chunk当前的位置信息。Master 节点还管理着系统范围内的活动，比如，chunk 租用管理、孤儿 chunk的回收、以及 chunk 在 chunkserver之间的迁移。master 节点使用心跳信息周期地和每个 chunkserver通讯，发送指令到各个 chunkserver并接收 chunkserver的状态信息。</p>
<p>链接到每个应用程序的 GFS 客户端代码中实现了文件系统 API，这个 GFS 客户端代表应用程序与 master 和 chunk服务器通信以读写数据。<font color="red">客户端与 master 交互只进行元数据操作，所有的数据操作都是由客户端直接和 chunkserver进行交互的</font>。GFS 没有提供 POSIX标准的API，因此不需要深入到 Linux 的 vnode 层。</p>
<p>客户端和 chunk服务器都不缓存文件数据。</p>
<ul>
<li>客户端缓存文件数据几乎没什么好处，因为大多数应用程序通过巨大的文件进行流式传输，或者工作集太大而无法缓存。不缓存文件数据使得客户端代码和总体系统的代码得以简化，因为无需编写代码解决缓存一致性的问题（不过客户端是缓存元数据的）。</li>
<li>chunk服务器不需要缓存文件数据是因为 chunk 以本地文件的方式保存，Linux 操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</li>
</ul>
<h3 id="单个master" class="heading-element"><span>2.4 单个Master</span>
  <a href="#%e5%8d%95%e4%b8%aamaster" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>单一的 Master 节点策略大大简化了系统设计。单一的 Master 节点能够通过全局信息精确定位 chunk 的位置，并做出复制决策。<font color="red">不过必须最小化在读写中 master 的调用次数，防止 master 成为 GFS 系统的性能瓶颈</font>。客户端永远不通过 Master 节点直接读写文件数据，而是向 master 节点请求应联系的 chunkserver，并将这些元数据缓存一段时间，后续操作直接与 chunkserver进行。</p>
<p>以上图GFS架构为例，在一次简单读取操作中：</p>
<ol>
<li>客户端将文件名和字节偏移量转换成文件的 chunk索引（<code>chunk_index = offset / chunk_size</code>），并将文件名和 chunk 索引发送给 master 节点。</li>
<li>master 节点返回相应的 chunk 句柄和副本的位置信息，客户端将这些信息缓存。</li>
<li>客户端将请求发送给一个副本，通常选择最近的副本，请求包含 chunk 句柄和字节范围。在后续对该 chunk 的读取操作中，客户端无需再次与 master 节点通讯，除非缓存的元数据信息过期或文件被重新打开。</li>
</ol>
<p>客户端通常会在一次请求中查询多个 chunk 信息，master 节点的回复可能包含后续 chunk 的信息，<strong>这些额外信息在避免未来多次通讯的同时，不增加额外代价</strong>。这种设计保证了系统的高效性，减少了 master 节点的负担，提高了整体性能。</p>
<h3 id="chunk大小" class="heading-element"><span>2.5 chunk大小</span>
  <a href="#chunk%e5%a4%a7%e5%b0%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>chunk 的大小是 GFS 的关键设计参数之一，GFS 选择了 64MB 的 chunk 大小，这远大于一般文件系统的 block 大小。<font color="red">每个 chunk 的副本都以普通 Linux 文件的形式保存在 chunkserver上，并且只有在需要时才扩大，采用惰性空间分配策略避免了内部碎片造成的空间浪费。</font></p>
<p>将 chunk 设置为 64MB 这么大，有以下几个有点：</p>
<ol>
<li>它减少了客户端和 master 节点之间的通信需求。因为一次与 master 节点通信即可获取 chunk 的位置信息，之后可以对同一个 chunk 进行多次读写操作。</li>
<li>较大的 chunk大小使客户端能够对同一个 chunk 进行多次操作，通过与 chunkserver保持较长时间的 TCP 连接来减少网络负载。</li>
<li>较大的 chunk大小减少了 master 节点需要保存的元数据数量，允许将所有元数据放在内存中，从而提高访问速度。</li>
</ol>
<p>然而，较大的 chunk 大小也有缺点。小文件包含的 chunk 较少，甚至只有一个 chunk。当多个客户端频繁访问同一个小文件时，存储这些 chunk 的服务器容易成为热点。在实际应用中，这种情况较少发生，因为程序通常是连续读取包含多个 chunk 的大文件。</p>
<p>但将GFS应用于批处理队列系统中，热点问题曾经出现过：一个可执行文件保存在一个单一 chunk 中，当数百台机器同时启动这个文件时，存储这个 chunk 的服务器因并发请求导致系统局部过载。为解决这个问题，<font color="red">GFS通过增加可执行文件的复制参数和错开程序启动时间来缓解。</font>此外，一个长效解决方案是<strong>允许客户端在这种情况下从其他客户端读取数据</strong>。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=small" data-sub-html="<h2>image-20240527103425005</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png" alt="image-20240527103425005" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/chunk_storage_Placement.png?size=large 2x" data-title="image-20240527103425005" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="元数据" class="heading-element"><span>2.6 元数据</span>
  <a href="#%e5%85%83%e6%95%b0%e6%8d%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>master 中主要存储三种类型的元数据：</p>
<ol>
<li>文件和 chunk 的命名空间；</li>
<li>文件和 chunk 的映射；</li>
<li>每个 chunk 的副本的位置。</li>
</ol>
<p><font color="red">所有的元数据都存储在 master 的内存里</font>。前两种类型也会通过在操作日志(operation log)上记录修改来持久化，操作日志文件存储在 master 的本地磁盘上，同时日志会被复制到其它的远程master服务器上。使用日志使得我们能够简单可靠的更新 master 的状态，，而不用担心 master 崩溃导致的不一致性的风险。master 不会持久的存储 chunk 位置信息，<font color="red">而是会在 master 启动时或一个 chunkserver加入集群时向 chunkserver轮询其 chunk 信息</font>。</p>
<h4 id="内存中的数据结构" class="heading-element"><span>2.6.1 内存中的数据结构</span>
  <a href="#%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>GFS 的设计<font color="red">将所有元数据保存在内存中</font>，使 master 的操作速度非常快。这种设计允许 master 在后台简单而高效地周期性扫描所有状态信息，实现如 chunk 垃圾收集、在 chunkserver失效的时重新复制数据、通过 chunk 的迁移实现跨 chunkserver的负载均衡以及磁盘使用状况统计等功能。</p>
<p>虽然将元数据保存在内存中会使 chunk 的数量和系统的承载能力受限于 master 的内存大小，但在实际应用中，这并不是严重问题。具体而言，master 管理每个 64MB 的 chunk 只需不到 64字节的元数据。由于大多数文件包含多个 chunk，绝大多数chunk 都是满的，只有最后一个 chunk 可能部分填充。同样，每个文件在命名空间中的数据大小通常在 64 字节以下，因为文件名经过前缀压缩。</p>
<p>即便需要支持更大的文件系统，增加 master 的内存成本也相对较低。通过增加少量内存，可以使元数据全部保存在内存中，从而增强系统的简洁性、可靠性、高性能和灵活性。</p>
<h4 id="chunk位置信息" class="heading-element"><span>2.6.2 chunk位置信息</span>
  <a href="#chunk%e4%bd%8d%e7%bd%ae%e4%bf%a1%e6%81%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">master 不持久化存储哪个 chunkserver包含指定 chunk 副本的信息，master 只是在启动时会轮询 chunkserver以获取这些信息，并通过控制 chunk 位置分配和定期的心跳信息监控chunk服务器状态保持最新。</font></p>
<p>Google起初尝试将 chunk 位置信息持久化保存在 master 上，但发现启动时轮询 chunkserver并定期更新更为简便。这种设计简化了在 chunkserver加入、离开、更名、故障和重启时的数据同步问题，适应了大规模集群中频繁发生的事件。</p>
<p>这个设计的另一个理解思路：只有 chunkserver才能最终确定一个 chunk 是否在其硬盘上。在 master 上维护全局视图是不现实的，因为 chunkserver的错误可能导致 chunk 自动消失，或者操作人员可能重命名 chunkserver。这种方法确保了系统的简洁性和可靠性。</p>
<h4 id="操作日志" class="heading-element"><span>2.6.3 操作日志</span>
  <a href="#%e6%93%8d%e4%bd%9c%e6%97%a5%e5%bf%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><font color="red">操作日志包含关键的元数据变更历史记录，是元数据唯一的持久化存储和判断同步操作顺序的逻辑时间基线。</font>每个文件和 chunk，还有它们的版本， 都由它们创建的逻辑时间唯一的、永久的标识。</p>
<p>日志文件必须确保完整性。<font color="red">只有在元数据变更被持久化后，日志才对客户端可见，以防止丢失文件系统或最近的客户端操作。</font>为此，日志会被复制到多台远程机器，只有在本地和远程机器都写入日志后，master 才响应客户端请求。master 会收集多个日志记录后批量处理，以减少写入和复制对系统性能的影响。</p>
<p>在灾难恢复时，master 通过重演操作日志恢复文件系统。为了缩短启动时间，日志必须足够小。当日志增长到一定量时，master 会进行 checkpoint，将所有状态数据写入 checkpoint 文件。<font color="red">恢复时，master读取 Checkpoint 文件并重演之后的日志文件即可</font>。Checkpoint 文件以压缩 B-树形式存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析，提高了恢复速度和系统可用性。</p>
<p>创建 Checkpoint 文件时，master 确保不会阻塞正在进行的操作，通过独立线程切换到新的日志文件和创建新的 Checkpoint 文件。生成一个 Checkpoint 文件大约需要一分钟，完成后Checkpoint会被写入本地和远程硬盘。</p>
<p><font color="red">master 恢复仅需最新的 Checkpoint 文件和后续日志文件</font>。虽然旧的 Checkpoint 文件和日志文件可以删除，但通常会保留一些历史文件以应对灾难性故障。Checkpoint 失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的 Checkpoint 文件（<font color="red">使用前一个完整的 Checkpoint 文件和之后的操作日志来恢复系统</font>）。</p>
<h3 id="一致性模型" class="heading-element"><span>2.7 一致性模型</span>
  <a href="#%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 有一个宽松的一致性模型，很好地支持我们的高度分布式应用程序，但是实现起来依然简单且高效。</p>
<p>我们现在讨论 GFS 如何保证一致性，以及这对应用程序来说有何意义。我们也会强调 GFS 如何维护这些保证，但是更详细的内容将在本文的其他部分来说。</p>
<h4 id="gfs一致性保障机制" class="heading-element"><span>2.7.1 GFS一致性保障机制</span>
  <a href="#gfs%e4%b8%80%e8%87%b4%e6%80%a7%e4%bf%9d%e9%9a%9c%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>文件命名空间的修改（例如，文件创建）是原子性的，且仅由 master 控制。命名空间锁保证了操作的原子性和正确性（详见4.1），而操作日志定义了这些操作的全局顺序（详见2.6.3）。</p>
<p>数据修改后的文件区域状态取决于操作类型、成功与否以及是否同步修改。下表总结了各种操作的结果。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=small" data-sub-html="<h2>image-20240523094914274</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png" alt="image-20240523094914274" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/File_Region_State.png?size=large 2x" data-title="image-20240523094914274" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ul>
<li>如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件区域是<em>consistent</em>；</li>
<li>如果对文件的数据修改之后，文件区域是一致的，并且客户端能够看到写入操作全部的内容，那么这个 region 是<em>defined</em>。</li>
</ul>
<p>其中，对于一个文件区域，只要所有客户端看到的数据都是一样的，那这个区域就是 <em>consistent</em> 的。在 <em>consistent</em> 的前提下，如果所有修改都已经被写入，就是 <em>defined</em> 的。<em>consistent</em> 是 <em>defined</em> 的子集。即 <em>defined</em> 的一定是 <em>consistent</em> 的，但 <em>consistent</em> 的不一定是 <em>defined</em> 的。</p>
<p>当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰（即串行修改），那么受影响的区域就是 <em>defined</em>（隐含了 <em>consistent</em> ）：所有的客户端都可以看到写入的内容。</p>
<p>当多个并行修改操作成功完成后，文件区域处于<em>consistent</em>但<em>undefined</em>的状态：即所有的客户端看到的数据是一样的，但这并不意味着每个修改都已经被写入。一般来说，写入的内容由多个修改的混合片段组成。</p>
<p>失败的修改操作导致文件区域<em>inconsistent</em> (因此也是 <em>undefined</em> )：不同客户端在不同时间看到的数据不同。后面我们将描述应用如何区分 <em>defined</em> 和 <em>undefined</em> 的区域。应用程序没有必要再去细分 <em>undefined</em> 区域的不同类型。</p>
<p>数据修改操作分为写入或者记录追加两种：</p>
<ul>
<li><strong>写入操作</strong>：数据写在应用程序指定的文件偏移位置上。</li>
<li><strong>记录追加操作</strong>：数据（记录）原子性追加到文件中至少一次（即使是并发修改），但偏移位置由 GFS 选择（3.3）。</li>
</ul>
<p>作为对比，一个普通的追加操作仅仅是一个在客户端认为是当前文件末尾的偏移处的写入操作。GFS 返回给客户端一个偏移量，表示包含写入记录的 <em>defined</em> 区域的起点。另外，GFS 可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件区域被认定是 <em>inconsistent</em>（即上表 中的 <em>defined</em> interspersed with <em>inconsistent</em>，即 <em>defined</em> 区域中穿插了 <em>inconsistent</em> 区域，但这些区域不会影响读取数据的结果，因为会被过滤掉）， 这些数据通常比用户数据小的多。</p>
<p>经过一系列成功的修改操作后，GFS 确保被修改的文件区域是<em>defined</em>的，并包含最后一次修改操作写入的数据。GFS 通过以下措施确保这一点：</p>
<ol>
<li><strong>对chunk的所有副本的修改操作顺序一致</strong>。</li>
<li><strong>使用 chunk 版本号检测副本</strong>是否因其所在的 chunkserver宕机而错过了修改操作导致失效。失效的副本不再进行修改操作，master 也不会返回该副本的位置信息给客户端，失效副本会被垃圾收集系统尽快回收。</li>
</ol>
<p>由于 chunk 位置信息会被客户端缓存，在信息刷新前，客户端可能从失效的副本读取数据。只有当缓存条目超时，或文件被重新打开时，这个问题才能解决，因为条目超时或重新打开文件会清除客户端缓存中的所有跟这个文件有关的 chunk 信息。此外，大多数文件只进行追加操作，因此失效副本通常返回一个提前结束的 chunk 而不是过期的数据（也就是说，数据还是有效的数据，只是返回的偏移位置不对）。当 Reader 程序 重新尝试联络 master 时，会立刻得到最新的 chunk 位置信息。</p>
<p>即使修改操作成功执行后很长时间，组件故障仍可能损坏或删除数据。GFS 通过 master 和所有 chunkserver的定期“握手”找到失效的 chunkserver，并使用<strong>校验和检测数据是否损坏</strong>。一旦发现问题，数据将尽快利用有效副本进行恢复。只有当一个 chunk 的所有副本在 GFS 检测到错误并采取应对措施之前全部丢失，chunk 才会不可逆转地丢失。通常，GFS 的反应时间（master 节点检测到错误并采取应对措施）为几分钟。即便如此，chunk 也只是不可用而非损坏，应用程序会收到明确的错误信息而非损坏的数据。</p>
<h4 id="对应用程序的影响" class="heading-element"><span>2.7.2 对应用程序的影响</span>
  <a href="#%e5%af%b9%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%bd%b1%e5%93%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>使用 GFS 的应用程序可以利用一些简单的技术来实现宽松的一致性模型，也可以实现其他目标功能，包括<font color="red">尽量采用追加写入而不是覆盖、Checkpoint、写入自验证和自识别的记录</font>。</p>
<p>在实际应用中，我们所有的应用程序对文件的写入操作都尽量采用追加方式而不是覆盖方式。例如，应用程序从头到尾写入数据生成一个文件，写入完成后自动将文件改名为一个永久文件名，或者定期进行 Checkpoint，记录成功写入的数据量。Checkpoint 文件可以包含程序级别的校验和。<font color="red">Readers 仅校验并处理上个 Checkpoint 之后的文件区域，这些区域的状态是<em>defined</em>的</font>。这种方法满足了我们的一致性和并发处理需求。追加写入比随机写入更加高效，对应用程序的失败处理更具弹性。Checkpoint 允许 Writer 以渐进方式重新开始，并防止 Reader 处理已成功写入但从应用程序的角度来看未完成的数据。</p>
<p>另一个典型的应用场景是，许多应用程序并行追加数据到同一个文件，例如进行结果合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”特性保证了 Writer 的输出。Readers 可以通过以下方法处理偶然性的填充数据和重复内容：Writers 在每条写入记录中包含额外信息，例如 Checksum，用来验证有效性。Reader 可以利用 Checksum 识别并丢弃额外的填充数据和记录片段。如果应用不能容忍偶尔的重复内容，可以使用记录的唯一标识符来过滤重复数据，这些唯一标识符通常用于命名程序中处理的实体对象，如 web 文档。这些记录 I/O 功能都包含在我们共享的程序库中，并适用于 Google 内部的其他文件接口实现。这样，相同序列的记录，加上偶尔出现的重复数据，都能正确分发给 Reader。</p>
<h2 id="系统交互" class="heading-element"><span>3 系统交互</span>
  <a href="#%e7%b3%bb%e7%bb%9f%e4%ba%a4%e4%ba%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">Google 设计 GFS 系统一个重要的原则是最小化所有操作和 master 的交互（因为 master 只有一个，必须减轻 master 的压力）</font>。在这个背景下，我们现在来说客户端、master 和 chunk服务器如何互动以实现数据修改、原子记录追加(append)，以及快照(snapshot)。</p>
<h3 id="租约lease和变更顺序" class="heading-element"><span>3.1 租约（lease）和变更顺序</span>
  <a href="#%e7%a7%9f%e7%ba%a6lease%e5%92%8c%e5%8f%98%e6%9b%b4%e9%a1%ba%e5%ba%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>变更是一个会改变 chunk 内容或者元数据的操作（如写入或记录追加），会在 chunk 的所有副本上执行。为了保持多个副本间变更顺序的一致性，GFS 采用了租约（lease）机制。master 节点为 chunk 的一个副本（主 chunk）建立租约，初始租期为 60 秒。主 chunk 对所有更改操作进行序列化，所有副本遵从这个序列进行修改。因此，修改操作全局的顺序首先由 master 选择的租约的顺序决定，然后由租约中主 chunk 分配的序列号决定。</p>
<p>只要 chunk 被修改了，主 chunk 就可以申请更长的租期，通常会得到 master 的确认并收到租约延长的时间。 这些租约延长请求和批准的信息通常都是附加在 master 和 chunkserver之间的心跳消息中来传递。有时 master 会试图提前取消租约（例如，master 想取消在一个已经被改名的文件上的修改操作）。<font color="red">即使 master 和主chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个chunk副本签订新的租约</font>。</p>
<p>在下图中，我们通过列出 写入操作的控制流描述了这个过程，并且用数字标记了步骤顺序。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=small" data-sub-html="<h2>image-20240525151330305</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png" alt="image-20240525151330305" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Write_Control_And_Data_Flow.png?size=large 2x" data-title="image-20240525151330305" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<ol>
<li>客户端向master询问哪个chunk服务器持有当前的租约，以及其他副本的位置。如果没有一个chunk服务器持有租约，master则会选择其中一个副本建立一个租约（图中没有显示此步骤）；</li>
<li>master将主chunk的标识符以及其他副本（又称二级副本）的位置返回给客户端。客户端缓存这些数据以便后续的操作。<font color="red">只有在主 chunk 不可用，或者主 chunk 回复信息表明它已不再持有租约的时候，客户端才需要重新跟 master 联系</font>。</li>
<li>客户端把数据 push 给所有的副本，客户端可以以任意的顺序 push。chunkserver接收到数据并保存在它的内部 LRU 缓存中，一直到数据被使用或者过期交换出去。通过将数据流与控制流解耦，我们可以基于网络拓扑情况调度昂贵的数据流来提高性能，而不管哪个 chunk服务器是主 chunk。</li>
<li>当所有的副本都确认接收到了数据，客户端发送写请求到主chunk服务器。这个请求标识了之前推送到所有副本的数据。主 chunk 为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户端，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中。</li>
<li>主chunk把写请求传递到所有的二级副本。每个二级副本依照主chunk分配的序列号以相同的顺序执行这些操作。</li>
<li>所有完成了操作的二级副本向主chunk 回复，表明它们已经完成了操作。</li>
<li>主 chunk 回复客户端。任何副本产生的任何错误都会返回给客户端。在出现错误的情况下，写入操作可能在主chunk和一些二级副本执行成功（因为是主chunk 先成功完成修改后，才会让二级副本开始应用修改，如果主 chunk 失败了，二级副本就不会收到序列号以及应用更改的命令）。客户端的请求被确认为失败，被修改的区域处于<em>inconsistent</em>的状态。我们的客户端代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户端会先从步骤（3）到步骤（7） 做几次尝试。（Q：已经完成操作或部分完成操作的副本，接收到重试的数据后，如何处理？A：直接在文件末尾（最后一个 chunk 末尾）继续写入，之前成功的二级副本会重复写入，去重任务由读取数据的客户端来完成。）</li>
</ol>
<p>如果应用程序一次写入的数据量很大，或者数据跨越了多个 chunk，GFS 客户端代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户端上同时进行的操作打断或者覆盖。 因此，共享的文件区域的尾部可能包含来自不同客户端的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，chunk 的所有副本都是一致的。这使文件 region 处于 2.7 节描述 的<em>consistent</em>但是<em>undefined</em>的状态。</p>
<h3 id="数据流" class="heading-element"><span>3.2 数据流</span>
  <a href="#%e6%95%b0%e6%8d%ae%e6%b5%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了提高网络效率，GFS采取了将数据流和控制流分开的措施。在控制流从客户端到主 chunk再到所有二级副本的同时，数据以管道方式顺序沿着精心选择的 chunkserver链推送，充分利用每台机器的带宽，避免网络瓶颈和高延时连接，最小化数据推送延时。</p>
<p>数据顺序沿着一个 chunkserver链推送，而不是分散推送（如树型拓扑结构），以充分利用每台机器的出口带宽，实现最快速度的传输，而不分散带宽。为避免网络瓶颈和高延迟连接，<font color="red">每台机器尽量选择网络拓扑中离自己最近且尚未接收到数据的机器作为目标推送数据</font>。例如，客户端将数据推送到最近的 chunkserver S1，S1 推送到 S2，以此类推，<strong>基于 IP 地址计算节点距离</strong>。</p>
<p>利用基于 TCP 连接的管道式数据推送方式最小化延迟。chunkserver接收到数据后立即向前推送，利用全双工交换网络的优势，传输不会减慢接收速度。在无网络拥塞情况下，传送 $B$ 字节的数据到 $R$ 个副本的理想时间为 $\frac{B}{T} + RL$（$T$ 是网络吞吐量，$L$ 是传输延迟）。通常，我们的网络连接速度是 100Mbps，传输 1MB 数据的理想时间约为 80ms。</p>
<h3 id="原子的记录追加" class="heading-element"><span>3.3 原子的记录追加</span>
  <a href="#%e5%8e%9f%e5%ad%90%e7%9a%84%e8%ae%b0%e5%bd%95%e8%bf%bd%e5%8a%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 提供了一种原子的记录追加操作，客户端只需指定要写入的数据，GFS 保证至少一次原子写入成功执行（即写入一个顺序的byte流），写入数据追加到 GFS 指定的偏移位置，并返回该偏移量给客户端。类似于 Unix 的 <code>O_APPEND</code> 模式，多个并发写操作无竞态条件。</p>
<p>记录追加在分布式应用中频繁使用，特别是在多个客户端并行追加数据的情况下。<font color="red">传统写入需要复杂的同步机制，如分布式锁管理器，而记录追加简化了这种需求，常用于生产者/消费者队列系统或数据合并文件</font>。</p>
<p>记录追加遵循 3.1 节描述的控制流程，主 chunk 有额外控制逻辑。客户端将数据推送到最后一个 chunk 的所有副本，然后发送请求给主 chunk。主 chunk 检查是否超出最大大小（64MB），如果超出，则填充到最大大小并通知二级副本做同样的操作，然后回复客户端要求其对下一个chunk重新进行记录追加。通常情况下，主 chunk 追加数据并通知二级副本写入相同位置，最后回复客户端操作成功。</p>
<p>如果记录追加在任何副本上失败，客户端需要重新操作，可能导致同一个chunk的不同副本包含不同数据。GFS 只保证数据整体原子性写入至少一次，而不保证字节级别一致。成功执行操作的数据区域是<em>defined</em>的（且<em>consistent</em>的），否则是<em>inconsistent</em>的（且<em>undefined</em>义的）。程序可以处理这些<em>inconsistent</em>区域。</p>
<h3 id="快照" class="heading-element"><span>3.4 快照</span>
  <a href="#%e5%bf%ab%e7%85%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>快照操作在 GFS 中几乎瞬间完成，且不干扰其他操作。用户可以用快照快速创建数据集的分支拷贝或在实验前备份当前状态，方便之后提交或回滚。</p>
<p>就像AFS（Andrew File System，一种分布式文件系统），GFS 使用标准的“写时复制”（copy-on-write）技术实现快照。当 master 收到快照请求时，它会取消作快照的文件的所有 chunk 的租约，确保后续写操作必须与 master 交互，使 master 有机会先创建 chunk 的新拷贝。</p>
<p>租约取消或过期后，master 将操作记录到硬盘日志，并通过复制源文件或目录的元数据将变化反映到内存中。新创建的快照文件与源文件共享相同的 chunk 地址。</p>
<p>快照操作后，当客户端首次写入 chunk <code>C</code> 时，会先请求 master 查询当前租约持有者。master 发现 chunk C 的引用计数超过 1（<font color="red">写时复制方法创建快照时是给这个chunk加一个引用计数，没有立刻真的拷贝，一个 chunk 的引用计数大于 1 的话就代表这个 chunk 是某个快照的一部分，要保留原样数据的。当这个 chunk 上有新的写入的时候，这个 chunk 才会真的被复制，客户端在新复制的 chunk 上写入，而原来的旧 chunk 被快照继续引用</font>），不立即回复客户端，而是选择新的 chunk 句柄 <code>C'</code>，<strong>并要求所有持有 chunk C 副本的服务器创建 <code>C'</code></strong>。通过在本地创建新的 chunk 避免了网络复制，提高了效率。master 确保新 chunk <code>C'</code>的一个副本拥有租约后回复客户机，客户机即可正常写入该 chunk。</p>
<h2 id="master操作" class="heading-element"><span>4 Master操作</span>
  <a href="#master%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>master 执行所有的命名空间操作。此外，它还管理着整个系统里所有 Chunk 的副本：</p>
<ol>
<li>master 决定 chunk 副本的存储位置；</li>
<li>创建新的 chunk 和它的副本；</li>
<li>协调各种各样的系统范围内的活动以保证 chunk 被完全拷贝；</li>
<li>在所有的 chunkserver上做负载均衡；</li>
<li>回收不再使用的存储空间。</li>
</ol>
<p>下面我们深入讨论下上述的几点。</p>
<h3 id="命名空间管理和锁" class="heading-element"><span>4.1 命名空间管理和锁</span>
  <a href="#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86%e5%92%8c%e9%94%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 GFS 中，master 节点的操作可能耗时较长，例如快照操作需取消所有相关 chunk 的租约。为避免延缓其他操作，GFS 允许多个操作同时进行，并通过命名空间的区域锁保证顺序正确。</p>
<p><font color="red">GFS 命名空间是一个全路径与元数据映射的查找表，采用前缀压缩高效存储在内存中</font>。不同于传统文件系统，GFS 不支持列出目录下所有文件的结构，也不支持文件或目录的链接。<font color="red">每个节点（绝对路径的文件名或目录名）有一个关联的读写锁</font>。</p>
<p>每个 master 操作开始前都要获得相关锁。通常，涉及路径<code>/d1/d2/.../dn/leaf</code> 的操作需要获得<code>/d1</code>，<code>/d1/d2</code>，&hellip;，<code>/d1/d2/.../dn</code> 的读锁，以及<code>/d1/d2/.../dn/leaf</code> 的读写锁。根据操作不同，<code>leaf</code> 可以是文件或目录。例如，在<code>/home/user</code> 快照到<code>/save/user</code> 时，锁机制防止创建文件<code>/home/user/foo</code>。快照操作获得<code>/home</code> 和<code>/save</code> 的读锁及<code>/home/user</code> 和<code>/save/user</code> 的写锁；文件创建操作获得<code>/home</code> 和<code>/home/user</code> 的读锁及<code>/home/user/foo</code> 的写锁。由于<code>/home/user</code> 锁冲突，这两个操作顺序执行。文件创建操作不需要获取父目录的写入锁，因为这里没有“目录”，或者类似 inode 等用来 禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p>
<p><font color="red">这种锁方案支持对同一目录的并行操作</font>。例如，可在同一目录下同时创建多个文件：每个操作获取目录名的读锁和文件名的写锁。<font color="red">目录名的读锁防止目录被删除、改名或快照；文件名的写锁序列化文件创建操作，确保不会多次创建同名文件。</font></p>
<p>由于命名空间节点众多，读写锁采用惰性分配策略，不再使用时立刻删除。锁的获取依据全局一致的顺序避免死锁：首先按命名空间层次排序，在同一层次内按字典顺序排序。</p>
<h3 id="副本放置" class="heading-element"><span>4.2 副本放置</span>
  <a href="#%e5%89%af%e6%9c%ac%e6%94%be%e7%bd%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 集群采用高度分布的多层布局结构，典型拓扑包括数百个 chunkserver分布在多个机架上，由来自同一或不同机架的数百个客户机访问。<font color="red">通信可能跨越一个或多个网络交换机，且机架出入带宽可能较小</font>。多层分布架构带来数据灵活性、可靠性和可用性挑战。</p>
<p>chunk 副本位置选择旨在最大化数据可靠性和可用性，以及网络带宽利用率。仅在多台机器上存储副本不足以达到目标，需在多个机架间分布储存 chunk 的副本。这保证即使整个机架故障或掉线，某些副本仍可用，且网络流量尤其读操作可利用多个机架的带宽。尽管写操作需与多个机架设备通信，但这是值得的。</p>
<h3 id="创建重新复制重新平衡" class="heading-element"><span>4.3 创建、重新复制、重新平衡</span>
  <a href="#%e5%88%9b%e5%bb%ba%e9%87%8d%e6%96%b0%e5%a4%8d%e5%88%b6%e9%87%8d%e6%96%b0%e5%b9%b3%e8%a1%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>chunk 副本在 GFS 中有三个主要用途：chunk 创建、重新复制和重新平衡。</p>
<ol>
<li>
<p>Master 节点在创建 chunk 时选择存放初始空副本的位置，考虑以下因素：</p>
<ul>
<li>优先选择硬盘使用率低于平均值的 chunkserver，以平衡硬盘使用率。</li>
<li>限制每个 chunkserver上最近 chunk 创建操作的次数，以减少写入操作的集中度。</li>
<li>分布在多个机架之间，以提高可靠性。</li>
</ul>
</li>
<li>
<p>当有效副本数量低于指定复制因数时，master 节点会重新复制 chunk，可能原因包括：</p>
<ul>
<li>
<p>chunkserver不可用或报告副本损坏。</p>
</li>
<li>
<p>磁盘错误或复制因数增加。</p>
</li>
<li>
<p>重新复制优先级基于现有副本数量与复制因数的差异、chunk 活跃状态及其对客户端的影响。</p>
</li>
</ul>
<p>master 选择优先级最高的chunk，命令 chunkserver克隆副本，选择新副本的位置的策略类似于 chunk 创建。为防止克隆操作超载网络，master会限制克隆操作数量及其读请求频率。</p>
</li>
<li>
<p>master 周期性检查副本分布，移动副本以优化硬盘空间利用和平衡。在这个过程中，master 渐进式填充新 chunkserver，避免短期内填充过载。副本位置选择策略同上，并优先移走剩余空间低于平均值的服务器上的副本，以平衡整体硬盘使用率。</p>
</li>
</ol>
<h3 id="垃圾回收" class="heading-element"><span>4.4 垃圾回收</span>
  <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>GFS 在文件删除后不会立即回收物理空间，而是采用惰性垃圾回收策略，仅在文件和 chunk 级的常规垃圾收集中进行。这样简化了系统设计，提高了可靠性。</p>
<h4 id="机制" class="heading-element"><span>4.4.1 机制</span>
  <a href="#%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当一个文件被应用程序删除时，master立刻把删除操作以日志的方式记录下来。但是，<font color="red">master 并不马上回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字</font>。当 master 对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件（这个时间间隔是可以设置的）。在文件被真正删除之前，它们仍旧可以用新的特殊的名字（即被重命名后的带有删除时间戳的名字）读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“取消删除”。当隐藏文件被从命名空间中删除，master 内存中保存的这个文件的相关元数据才会被删除。这也有效的切断了文件和它包含的所有 chunk 的连接。</p>
<p><font color="red">在对 chunk 命名空间做类似的常规扫描时，master 找到孤儿 chunk（不被任何文件包含的 Chunk） 并删除它们的元数据</font>。chunkserver在和 master 交互的心跳信息中，报告它拥有的 chunk 子集的信息， master 回复 chunkserver哪些 chunk 在 master 保存的元数据中已经不存在了。chunkserver可以任意删除这些 chunk 的副本。</p>
<h4 id="讨论" class="heading-element"><span>4.4.2 讨论</span>
  <a href="#%e8%ae%a8%e8%ae%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>GFS 的垃圾回收方案简单可靠。可以轻易得到chunk 的引用：存储在 master 的文件到chunk的映射表中；也可以轻松得到chunk所有副本：以Linux文件的形式存储在 chunkserver指定目录下。所有master 不能识别的副本即为“垃圾”。</p>
<p>垃圾回收在空间回收方面相比直接删除有几个优势。</p>
<ol>
<li>在大规模分布式系统中，组件失效是常态。chunk 可能在某些服务器上创建成功，但在其他服务器上失败，失败的副本处于无法被 master 识别的状态。副本删除消息可能丢失，master 必须重新发送失败的删除消息， 包括自身的（元数据）和 chunkserver的。垃圾回收提供了一致的、可靠的清除无用副本的方法。</li>
<li>垃圾回收将存储空间回收操作合并到 master 的规律性后台活动中，如例行扫描和与 chunkserver的握手。因此操作被批量执行，减少开销。回收在 master 相对空闲时进行，提高了响应速度。</li>
<li>延迟回收为意外、不可逆转的删除操作提供了安全保障，防止误删。</li>
</ol>
<p>虽然延迟回收可能阻碍存储优化，尤其在空间紧缺时。但可以通过显式再次删除文件可以加速回收。用户可以为不同命名空间设置不同的复制和回收策略，以优化存储使用。</p>
<h3 id="过期副本检测" class="heading-element"><span>4.5 过期副本检测</span>
  <a href="#%e8%bf%87%e6%9c%9f%e5%89%af%e6%9c%ac%e6%a3%80%e6%b5%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">当 chunkserver失效时，chunk 的副本可能因错失一些修改操作而过期。master 通过保存每个 Chunk 的版本号来区分当前副本和过期副本。</font>每次与 chunk 签订新租约时，master 都会增加 chunk 的版本号，并通知最新的副本，且这些副本会将新的版本号记录在其持久化存储中。这个过程在任何客户端得到通知前完成，因此也是在对这个 chunk 开始写之前完成的。如果某个副本所在的 chunkserver正好失效，那么其版本号就不会被更新。待该 chunkserver重新启动并向 master 报告其持有的 chunk 及相应版本号时，master 会检测出其包含过期的 chunk。若 master 发现一个比其记录的版本号更高的版本号，会认为之前签订租约的操作失败，并选择更高的版本号作为当前版本号。</p>
<p>master 在例行垃圾回收过程中移除所有过期副本。在此之前，master 在回复客户端的 chunk 信息请求时，master 实际上会认为根本不存在一个过期的副本（也就是说，给客户端返回的 chunk 列表中可能包含过期的 chunk，客户端有可能去读过期的 chunk。GFS 是弱一致性的）。另外一重保障措施是，master 在通知客户端哪个 chunkserver持有租约或指示 chunkserver从哪个 chunkserver进行克隆时，消息中都会附带 chunk 的版本号。客户端或 chunkserver在执行操作时会验证版本号，以确保总是访问当前版本的数据。</p>
<h2 id="容错和诊断" class="heading-element"><span>5 容错和诊断</span>
  <a href="#%e5%ae%b9%e9%94%99%e5%92%8c%e8%af%8a%e6%96%ad" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="高可用性" class="heading-element"><span>5.1 高可用性</span>
  <a href="#%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 GFS 集群中，高可用性的策略主要包括快速恢复和复制。</p>
<ul>
<li>首先，对于快速恢复，无论是 master 还是 chunkserver，它们都能在数秒内恢复状态并重新启动。系统不区分正常关闭和异常关闭，通常通过直接终止进程来关闭服务器。</li>
<li>其次，对于 chunk 复制，每个 chunk 都被复制到不同机架上的不同 chunkserver上，并可以根据需要设定不同的复制级别。当有 chunkserver 离线或发现数据损坏时，master 通过克隆已有的副本来确保每个 chunk 都被完整复制。</li>
<li>最后，master 的状态也需要复制以保证其可靠性。master 的所有操作日志和 checkpoint 文件都被复制到多台机器上，确保操作日志写入备用节点和本机磁盘，以支持失败后的快速重新启动。此外，还存在“影子”master，用于提供文件系统的只读访问。这些“影子”服务器能够保持状态最新，并通过与主 master 相同的方式处理数据结构的更改。它们定期从 chunkserver拉取数据，并与其握手以确定状态，从而确保系统的高可用性。</li>
</ul>
<h3 id="数据完整性" class="heading-element"><span>5.2 数据完整性</span>
  <a href="#%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>每个 Chunkserver使用 checksum 来检查保存的数据是否损坏。由于 GFS 集群通常包含数百台机器和数千块硬盘，磁盘损坏导致的数据丢失或损坏在读写过程中是常见的。虽然可以通过其他副本恢复数据，但跨服务器比较副本以检查数据完整性并不实际。此外，由于 GFS 允许存在有歧义的副本，特别是在原子记录追加操作中，副本并不总是完全一致的（副本不是 byte-wise 完全一致的）。因此，每个 chunkserver必须独立维护 checksum 来校验自己的副本完整性。</p>
<p>每个 chunk 被分为 64KB 的块，每个块对应一个 32 位的 checksum，存储在内存和硬盘上，并记录在操作日志中。在读取数据之前，chunkserver会校验与读取范围重叠的数据块的checksum。如果 checksum 不匹配，服务器返回错误信息并通知 master，之后从其他副本读取数据并进行克隆恢复。一旦新的副本就绪，master 通知 chunkserver删除错误的副本。</p>
<p>checksum 对读操作性能影响很小，因为大部分读操作涉及多个块，而只需读取少量额外数据进行校验。通过对齐读操作到 checksum块的边界，可以进一步减少额外读取操作的影响。此外，checksum 的查找和比较不需要额外的 I/O 操作，计算可以与 I/O 操作并行进行。</p>
<p>针对追加写入操作，checksum 的计算进行了优化，因为这种操作在 GFS 工作中占很大比例。只需增量更新最后一个不完整块的 checksum，并使用新写入的数据计算新的 checksum。如果最后一个checksum块损坏，问题会在下次读取时被发现。</p>
<p>相比之下，覆盖写操作需要读取和校验被覆盖范围内的第一个和最后一个块，操作完成后重新计算和写入新的 checksum。如果不校验第一个和最后一个被写的块，新的 checksum 可能会隐藏未覆盖区域内的数据错误。</p>
<p><font color="red">当 chunkserver空闲时，会扫描和校验每个不活动 chunk 的内容，以发现很少被读取的 chunk 是否完整</font>。一旦发现数据损坏，master 可以创建新的正确副本并删除损坏的副本，避免非活动的损坏 chunk 误导 master，使其认为副本数量足够。</p>
<h3 id="诊断工具" class="heading-element"><span>5.3 诊断工具</span>
  <a href="#%e8%af%8a%e6%96%ad%e5%b7%a5%e5%85%b7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>详尽的、深入细节的诊断日志在问题隔离、调试和性能分析等方面提供了极大的帮助，而所需开销却很小。没有日志，我们很难理解短暂的、不重复的机器间消息交互。GFS 服务器会生成大量日志，记录关键事件（如 chunkserver 的启动和关闭）以及所有 RPC 请求和回复。这些日志可以随时删除，不影响系统的正确运行，但我们在存储空间允许的情况下尽量保留这些日志。</p>
<p>RPC 日志详细记录了网络上的所有请求和响应，但不包括读写的文件数据。通过匹配请求与回应，并收集不同机器上的 RPC 日志，我们可以重现所有消息交互来诊断问题。这些日志还用于跟踪负载测试和进行性能分析。</p>
<p>日志对性能的影响很小，因为日志写入是顺序且异步的。最近的事件日志保存在内存中，用于持续的在线监控。</p>
<h2 id="经验" class="heading-element"><span>6 经验</span>
  <a href="#%e7%bb%8f%e9%aa%8c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在构建和部署 GFS 的过程中，Google 遇到了许多问题，包括操作和技术方面的挑战。最初，GFS 主要作为生产系统的后端文件系统，后来逐渐支持研究和开发任务，增加了权限和配额等功能。</p>
<p>最大的难题是磁盘和 Linux 相关问题。许多磁盘声称支持 Linux IDE 驱动，但实际应用中情况不一，导致协议不匹配，数据可能因内核问题而被破坏。为此，Google 使用校验和来验证数据，并修改内核处理这些问题。</p>
<p>早期使用 Linux 2.2 内核时，fsync() 效率与文件大小相关而非修改部分大小相关，导致操作日志文件过大时出现问题，尤其是在尚未实现checkpoint 的时候。Google费了很大的力气用同步写来解决这个问题，但是最后还是移植到了 Linux2.4 内核上。</p>
<p>另一个问题是单个读写锁，导致系统偶尔超时。Google 通过用 pread() 替代 mmap() 并增加额外复制操作解决了这个问题。</p>
<p>在任意地址空间的线程在磁盘读入（读锁）时或 <code>mmap()</code> 调用（写锁）时必须持有锁。即使系统负载很轻，也会偶尔超时。Google花费大量精力查找资源瓶颈或硬件问题，最终发现磁盘线程在交换数据到磁盘时，锁住了当前网络线程，阻止其将新数据映射到内存。由于性能主要受限于网络接口而非内存复制带宽，Google用 <code>pread()</code> 替代 <code>mmap()</code>，通过额外复制操作解决了问题。</p>
]]></description></item><item><title>AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识</title><link>https://hezephyr.github.io/posts/ai%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84gpu%E7%94%9F%E5%AD%98%E5%B7%A5%E5%85%B7%E5%8C%85%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/ai%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84gpu%E7%94%9F%E5%AD%98%E5%B7%A5%E5%85%B7%E5%8C%85%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid><description><![CDATA[<p><a href="https://journal.hexmos.com/gpu-survival-toolkit/"target="_blank" rel="external nofollow noopener noreferrer">翻译原文地址<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="cpu知识为何不再足够" class="heading-element"><span>1 CPU知识为何不再足够</span>
  <a href="#cpu%e7%9f%a5%e8%af%86%e4%b8%ba%e4%bd%95%e4%b8%8d%e5%86%8d%e8%b6%b3%e5%a4%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在当今的人工智能时代，大多数开发者都是按照CPU的方式进行训练。这种认知也已经成为我们学术中的一部分，因此很自然地会<strong>以CPU为导向</strong>来思考和解决问题。</p>
<p>然而，CPU 的问题在于它们<strong>依赖于串行架构</strong>。在当今世界中，我们依赖大量并行任务的情况下，CPU 无法很好地处理这些场景。</p>
<p>因此，开发者面临着如下问题。</p>
<ul>
<li>
<p><strong>执行并行任务</strong></p>
<blockquote>
<p>CPU 传统上是线性运行的，一次执行一条指令。这种限制源于这样一个事实：CPU 通常具有一些针对单线程性能进行优化的强大内核。当面临多个任务时，CPU会分配其资源来逐个处理每个任务，从而导致指令的顺序执行。在需要同时关注众多任务的情况下，这种方法变得低效。</p>
<p>尽管我们通过诸如多线程等技术来提高CPU性能，但CPU的基本设计理念是优先考虑顺序执行。</p>
</blockquote>
</li>
<li>
<p><strong>高效运行AI模型</strong></p>
<blockquote>
<p>AI 模型采用 Transformer 等先进架构，利用并行处理来增强性能。与顺序运行的<strong>旧递归神经网络 (RNN)</strong> 不同，<strong>GPT 等现代 Transformer</strong> 可以同时处理多个单词，从而提高训练效率和能力。因为当我们并行训练时，会产生更大的模型，而更大的模型会产生更好的输出。</p>
<p>并行的概念已从自然语言处理扩展到<strong>图像识别</strong>等其他领域。例如，图像识别架构 AlexNet 通过同时处理图像的不同部分，展示了并行处理的威力，从而实现准确的模式识别。</p>
<p>然而，CPU 的设计侧重于单线程性能，很难充分挖掘并行处理的潜力。它们难以有效分配和执行复杂AI模型所需的大量并行计算。</p>
</blockquote>
</li>
</ul>
<h2 id="gpu驱动开发如何解决这些问题" class="heading-element"><span>2 GPU驱动开发如何解决这些问题</span>
  <a href="#gpu%e9%a9%b1%e5%8a%a8%e5%bc%80%e5%8f%91%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e8%bf%99%e4%ba%9b%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>GPU 核心的大规模并行性</strong></p>
<blockquote>
<p>与 CPU 中<strong>更大、更强大的内核</strong>相比，工程师设计的 GPU 具有<strong>更小、高度专业化的内核</strong>。该架构允许 GPU 同时执行多个并行任务。</p>
<p>GPU 中的大量核心非常适合依赖于并行性的工作负载，例如图形渲染和复杂的数学计算。</p>
<p>如下图所示，5.3.2使用 GPU 并行性来减少复杂任务所需的时间。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/55f060b6b97ac9b7c285a8732c69829e12e3211339b992c18ec49716a6fac938.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/55f060b6b97ac9b7c285a8732c69829e12e3211339b992c18ec49716a6fac938.png?size=small" data-sub-html="<h2>GPUDemo1</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/55f060b6b97ac9b7c285a8732c69829e12e3211339b992c18ec49716a6fac938.png" alt="GPUDemo1" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/55f060b6b97ac9b7c285a8732c69829e12e3211339b992c18ec49716a6fac938.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/55f060b6b97ac9b7c285a8732c69829e12e3211339b992c18ec49716a6fac938.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/55f060b6b97ac9b7c285a8732c69829e12e3211339b992c18ec49716a6fac938.png?size=large 2x" data-title="GPUDemo1" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
<li>
<p><strong>AI 模型中使用的并行性</strong></p>
<blockquote>
<p>人工智能模型，特别是基于 <a href="https://www.tensorflow.org/?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">TensorFlow<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 等深度学习框架构建的模型，表现出高度的并行性。神经网络训练涉及大量矩阵运算，而 GPU 凭借其庞大的核心数量，擅长并行化这些运算。 TensorFlow 与其他流行的深度学习框架一起进行优化，以利用 GPU 的能力来加速模型训练和推理。</p>
<p>如下图所示，5.3.3使用 GPU 的强大功能来训练神经网络。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/5078635f14fc266b48058cafe1f214608eecd89f0ddfebfc481df24704a7bba9.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/5078635f14fc266b48058cafe1f214608eecd89f0ddfebfc481df24704a7bba9.png?size=small" data-sub-html="<h2>GPUDemo1</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/5078635f14fc266b48058cafe1f214608eecd89f0ddfebfc481df24704a7bba9.png" alt="GPUDemo1" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/5078635f14fc266b48058cafe1f214608eecd89f0ddfebfc481df24704a7bba9.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/5078635f14fc266b48058cafe1f214608eecd89f0ddfebfc481df24704a7bba9.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/5078635f14fc266b48058cafe1f214608eecd89f0ddfebfc481df24704a7bba9.png?size=large 2x" data-title="GPUDemo1" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
</ul>
<h2 id="gpu和cpu有什么区别" class="heading-element"><span>3 GPU和CPU有什么区别</span>
  <a href="#gpu%e5%92%8ccpu%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>CPU</strong></p>
<ul>
<li>
<p><strong>串行架构</strong></p>
<blockquote>
<p>中央处理单元 (CPU) 的设计重点是顺序处理。它们擅长线性执行一组指令。CPU 针对需要高单线程性能的任务进行了优化，例如：</p>
<ul>
<li><strong>通用计算</strong></li>
<li><strong>系统操作</strong></li>
<li><strong>处理涉及条件分支的复杂算法</strong></li>
</ul>
</blockquote>
</li>
<li>
<p><strong>并行任务的核心数量有限</strong></p>
<blockquote>
<p>CPU 的核心数量较少，在消费级处理器中通常为 <strong>2-16</strong> 个核心。每个内核都能够独立处理自己的指令集。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>GPU</strong></p>
<ul>
<li>
<p><strong>并行架构</strong></p>
<blockquote>
<p>图形处理单元（GPU）采用并行架构设计，使其能够高效地执行并行处理任务。这有利于：</p>
<ul>
<li><strong>渲染图形</strong></li>
<li><strong>执行复杂的数学计算</strong></li>
<li><strong>运行可并行算法</strong></li>
</ul>
<p>GPU 通过将多个任务分解为更小的并行子任务来同时处理多个任务。</p>
</blockquote>
</li>
<li>
<p><strong>数千个内核用于并行任务</strong></p>
<blockquote>
<p>与 CPU 不同，GPU 拥有更多的核心，通常有数千个。这些内核被组织成流式多处理器 (SM) 或类似的结构。丰富的内核使 GPU 能够同时处理大量数据，非常适合并行任务，例如图像和视频处理、深度学习和科学模拟。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="gpu类型" class="heading-element"><span>4 GPU类型</span>
  <a href="#gpu%e7%b1%bb%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>通用 Gpu</strong></p>
<blockquote>
<p>通用 GPU 实例（P3 和 P4 实例）适用于广泛的工作负载，包括机器学习训练和推理、图像处理和视频编码。它们的平衡性能使它们成为各种计算任务的理想选择。</p>
</blockquote>
</li>
<li>
<p><strong>推理优化的 GPU</strong></p>
<blockquote>
<p>推理是运行已经训练好的 AI 模型并对实时数据进行预测或任务求解的过程。推理优化的 GPU 实例（P5 和 Inf1 实例）在低延迟和成本效率至关重要的情况下表现出色，特别适用于机器学习推理任务。</p>
</blockquote>
</li>
<li>
<p><strong>图形优化的 GPU</strong></p>
<blockquote>
<p>图形优化的 GPU 实例（G4 实例）专门设计用于处理图形密集型任务，如视频游戏开发中的 3D 图形渲染。这些实例非常适合需要处理大量图形数据的应用程序。</p>
</blockquote>
</li>
<li>
<p><strong>托管 GPU</strong></p>
<blockquote>
<p>Amazon SageMaker 是一种托管服务，为机器学习提供了易于使用的 GPU 实例。它提供对多种 GPU 实例（包括 P3、P4 和 P5 实例）的访问，适用于想要轻松开始机器学习而无需管理底层基础设施的组织。</p>
</blockquote>
</li>
</ul>
<h2 id="使用-nvidia-的-cuda-进行-gpu-驱动开发" class="heading-element"><span>5 使用 Nvidia 的 CUDA 进行 GPU 驱动开发</span>
  <a href="#%e4%bd%bf%e7%94%a8-nvidia-%e7%9a%84-cuda-%e8%bf%9b%e8%a1%8c-gpu-%e9%a9%b1%e5%8a%a8%e5%bc%80%e5%8f%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>CUDA 是 NVIDIA 开发的并行计算平台和编程模型，使开发人员能够利用 GPU 加速器的强大功能来加速其应用程序。</p>
<h3 id="linux安装cuda" class="heading-element"><span>5.1 Linux安装CUDA</span>
  <a href="#linux%e5%ae%89%e8%a3%85cuda" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p>下载<a href="https://developer.nvidia.com/cuda-downloads?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">CUDA<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p>从上面的链接下载基本安装程序以及驱动程序安装程序</p>
</li>
<li>
<p>转到主文件夹中的 <code>.bashrc</code>（如果使用其他shell则使用对应的配置文件）</p>
</li>
<li>
<p>在配置文件中添加以下行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">export</span> <span class="n">PATH</span><span class="o">=</span><span class="s2">&#34;/usr/local/cuda-12.3/bin:$PATH&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">export</span> <span class="n">LD_LIBRARY_PATH</span><span class="o">=</span><span class="s2">&#34;/usr/local/cuda-12.3/lib64:$LD_LIBRARY_PATH&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>然后执行以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">cuda</span><span class="o">-</span><span class="n">toolkit</span>
</span></span><span class="line"><span class="cl"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">nvidia</span><span class="o">-</span><span class="n">gds</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h3 id="基本命令" class="heading-element"><span>5.2 基本命令</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><code>lspci | grep VGA</code></p>
<blockquote>
<p>识别并列出系统中的 GPU。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea108a4de53720d8e4de22247f92b43481a000cfe41026826e52f4af020b9c0f-20240319153537737.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea108a4de53720d8e4de22247f92b43481a000cfe41026826e52f4af020b9c0f-20240319153537737.png?size=small" data-sub-html="<h2>Alt text</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea108a4de53720d8e4de22247f92b43481a000cfe41026826e52f4af020b9c0f-20240319153537737.png" alt="Alt text" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea108a4de53720d8e4de22247f92b43481a000cfe41026826e52f4af020b9c0f-20240319153537737.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea108a4de53720d8e4de22247f92b43481a000cfe41026826e52f4af020b9c0f-20240319153537737.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ea108a4de53720d8e4de22247f92b43481a000cfe41026826e52f4af020b9c0f-20240319153537737.png?size=large 2x" data-title="Alt text" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
<li>
<p><code>nvidia-smi</code></p>
<blockquote>
<p>“NVIDIA 系统管理界面”，它提供有关系统中 NVIDIA GPU 的详细信息，包括利用率、温度、内存使用情况等。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b467adbefdfe4fced1552ca63134994c2924dc648955adb585c80d1a6356f10f.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b467adbefdfe4fced1552ca63134994c2924dc648955adb585c80d1a6356f10f.png?size=small" data-sub-html="<h2>Alt text</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b467adbefdfe4fced1552ca63134994c2924dc648955adb585c80d1a6356f10f.png" alt="Alt text" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b467adbefdfe4fced1552ca63134994c2924dc648955adb585c80d1a6356f10f.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b467adbefdfe4fced1552ca63134994c2924dc648955adb585c80d1a6356f10f.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b467adbefdfe4fced1552ca63134994c2924dc648955adb585c80d1a6356f10f.png?size=large 2x" data-title="Alt text" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
<li>
<p><code>sudo lshw -C display</code></p>
<blockquote>
<p>提供有关系统中显示控制器（包括显卡）的详细信息。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0af5ca02e576f5da48a561ebffb4bd20e4051899cb1b1e69caca78aeff58cff7.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0af5ca02e576f5da48a561ebffb4bd20e4051899cb1b1e69caca78aeff58cff7.png?size=small" data-sub-html="<h2>Alt text</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0af5ca02e576f5da48a561ebffb4bd20e4051899cb1b1e69caca78aeff58cff7.png" alt="Alt text" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0af5ca02e576f5da48a561ebffb4bd20e4051899cb1b1e69caca78aeff58cff7.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0af5ca02e576f5da48a561ebffb4bd20e4051899cb1b1e69caca78aeff58cff7.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/0af5ca02e576f5da48a561ebffb4bd20e4051899cb1b1e69caca78aeff58cff7.png?size=large 2x" data-title="Alt text" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
<li>
<p><code>inxi -G</code></p>
<blockquote>
<p>提供有关图形子系统的信息，包括有关 GPU 和显示器的详细信息。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8352bf05d3be3b8085e837de0f69f244ab6c34041c6b462cf78513fcae6373c0.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8352bf05d3be3b8085e837de0f69f244ab6c34041c6b462cf78513fcae6373c0.png?size=small" data-sub-html="<h2>Alt text</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8352bf05d3be3b8085e837de0f69f244ab6c34041c6b462cf78513fcae6373c0.png" alt="Alt text" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8352bf05d3be3b8085e837de0f69f244ab6c34041c6b462cf78513fcae6373c0.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8352bf05d3be3b8085e837de0f69f244ab6c34041c6b462cf78513fcae6373c0.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/8352bf05d3be3b8085e837de0f69f244ab6c34041c6b462cf78513fcae6373c0.png?size=large 2x" data-title="Alt text" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
<li>
<p><code>sudo hwinfo --gfxcard</code></p>
<blockquote>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/70fa1b931593c213a1a949dbc700d47cca2e933cee331d63e03e0806d6327baa.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/70fa1b931593c213a1a949dbc700d47cca2e933cee331d63e03e0806d6327baa.png?size=small" data-sub-html="<h2>Alt text</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/70fa1b931593c213a1a949dbc700d47cca2e933cee331d63e03e0806d6327baa.png" alt="Alt text" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/70fa1b931593c213a1a949dbc700d47cca2e933cee331d63e03e0806d6327baa.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/70fa1b931593c213a1a949dbc700d47cca2e933cee331d63e03e0806d6327baa.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/70fa1b931593c213a1a949dbc700d47cca2e933cee331d63e03e0806d6327baa.png?size=large 2x" data-title="Alt text" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</blockquote>
</li>
</ul>
<h3 id="开始使用cuda框架" class="heading-element"><span>5.3 开始使用CUDA框架</span>
  <a href="#%e5%bc%80%e5%a7%8b%e4%bd%bf%e7%94%a8cuda%e6%a1%86%e6%9e%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>当我们安装了 CUDA 框架后，让我们开始执行展示其功能的操作。</p>
<h4 id="数组加法问题" class="heading-element"><span>5.3.1 数组加法问题</span>
  <a href="#%e6%95%b0%e7%bb%84%e5%8a%a0%e6%b3%95%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>数组加法问题是演示 GPU 并行化的一个合适问题。考虑以下数组：</p>
<ul>
<li>
<p>数组 $A = [1,2,3,4,5,6]$</p>
</li>
<li>
<p>数组 $B = [7,8,9,10,11,12]$</p>
</li>
<li>
<p>我们需要存储每个元素的和并将其存储在数组$C$中。我们需要存储每个元素的和并将其存储在数组$C$中。</p>
</li>
<li>
<p>就像 $C = [1+7,2+8,3+9,4+10,5+11,6+12] = [8,10,12,14,16,18]$</p>
</li>
<li>
<p>如果CPU要执行这样的操作，它将执行如下代码所示的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>  <span class="c1">// Number of elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;c[%d] = %d&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>这种方法是逐个遍历数组元素并依次执行加法。然而，当处理大量数字时，这种方法由于其顺序性质而变得缓慢。</p>
<p>为了解决这个限制，GPU 通过并行化加法过程提供了一种解决方案。与依次执行运算的 CPU 不同，GPU 可以同时执行多项加法。例如，运算$1+7、2+8、3+9、4+10、5+11$和$6+12$可以借助GPU并行化同时执行。</p>
<p>利用CUDA，我们将使用内核文件 (.cu) 进行展示。实现并行加法的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">vectorAdd</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>__global__</code> 说明符表明该函数是一个内核函数，将在 GPU 上调用。</li>
<li><code>vectorAdd</code> 采用三个整数指针（$a$、$b$ 和 $c$）作为参数，表示要相加的向量。</li>
<li><code>threadIdx.x</code> 检索当前线程的索引（在一维网格中）。</li>
<li>向量 $a$ 和 $b$ 的相应元素之和存储在向量 $c$ 中。</li>
</ul>
<p>现在我们来看看主要功能。创建指针 <code>cudaA</code> 、 <code>cudaB</code> 和 <code>cudaC</code> 来指向 GPU 上的内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 利用 CUDA 使用并行计算加法的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建指向 GPU 的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">cudaA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">cudaB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">cudaC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>cudaMalloc</code> ，在 GPU 上为向量 <code>cudaA</code>、<code>cudaB</code> 和 <code>cudaC</code> 分配内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 在GPU中分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaA</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nf">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaB</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nf">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaC</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div><p>内核函数 <code>vectorAdd</code> 使用一个块和等于向量大小的多个线程启动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 用一个程序块和与向量大小相等的线程数启动内核
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vectorAdd</span> <span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">cudaA</span><span class="p">,</span> <span class="n">cudaB</span><span class="p">,</span> <span class="n">cudaC</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果向量 <code>cudaC</code> 从GPU复制回主机。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 将结果向量复制回主机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">cudaMemcpy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cudaC</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后我们可以照常打印结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="c1">// 打印结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;c[%d] = %d&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了执行此代码，我们将使用 <code>nvcc</code> 命令。我们将得到输出为：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/144c2193b0d5ad71eb7bd4da490534fb278ed174df6ec8c6411b039f16757116.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/144c2193b0d5ad71eb7bd4da490534fb278ed174df6ec8c6411b039f16757116.png?size=small" data-sub-html="<h2>GPU Output</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/144c2193b0d5ad71eb7bd4da490534fb278ed174df6ec8c6411b039f16757116.png" alt="GPU Output" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/144c2193b0d5ad71eb7bd4da490534fb278ed174df6ec8c6411b039f16757116.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/144c2193b0d5ad71eb7bd4da490534fb278ed174df6ec8c6411b039f16757116.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/144c2193b0d5ad71eb7bd4da490534fb278ed174df6ec8c6411b039f16757116.png?size=large 2x" data-title="GPU Output" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是<a href="https://github.com/RijulTP/GPUToolkit/tree/main/array-addition?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">完整的代码<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>供读者参考。</p>
<h4 id="使用-gpu-在-python-中优化图像生成" class="heading-element"><span>5.3.2 使用 GPU 在 Python 中优化图像生成</span>
  <a href="#%e4%bd%bf%e7%94%a8-gpu-%e5%9c%a8-python-%e4%b8%ad%e4%bc%98%e5%8c%96%e5%9b%be%e5%83%8f%e7%94%9f%e6%88%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>本节探讨使用 GPU 处理来优化性能密集型任务，例如图像生成。</p>
<p><strong>Mandelbrot 集</strong>是一种数学构造，它根据规定方程中特定数字的行为形成复杂的视觉模式。生成一个这样的图案需要耗费大量资源。在下面的代码片段中，您可以观察到使用 CPU 处理生成 Mandelbrot 集的传统方法，该方法速度很慢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="c1"># 导入必要的库</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">imshow</span><span class="p">,</span> <span class="n">show</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算给定点 (x, y) 的 Mandelbrot 集的函数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mandel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 迭代检查该点是否在 Mandelbrot 集中</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果在最大迭代次数内，则将其视为集合的一部分</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">max_iters</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在指定区域内创建 Mandelbrot 分形的函数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">create_fractal</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">height</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">width</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 根据指定区域计算像素大小</span>
</span></span><span class="line"><span class="cl">    <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
</span></span><span class="line"><span class="cl">    <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 在图像中迭代每个像素并计算Mandelbrot值</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">real</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pixel_size_x</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">imag</span> <span class="o">=</span> <span class="n">min_y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">pixel_size_y</span>
</span></span><span class="line"><span class="cl">            <span class="n">color</span> <span class="o">=</span> <span class="n">mandel</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">iters</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 为 Mandelbrot 集创建一个空白图像数组</span>
</span></span><span class="line"><span class="cl"><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1536</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 记录性能测量的开始时间</span>
</span></span><span class="line"><span class="cl"><span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在指定的区域和迭代次数内生成Mandelbrot集合</span>
</span></span><span class="line"><span class="cl"><span class="n">create_fractal</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算创建 Mandelbrot 集所需的时间</span>
</span></span><span class="line"><span class="cl"><span class="n">dt</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印生成 Mandelbrot 集所需的时间</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Mandelbrot created in </span><span class="si">%f</span><span class="s2"> s&#34;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 matplotlib 显示 Mandelbrot 集</span>
</span></span><span class="line"><span class="cl"><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">show</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码在 <code>4.07</code> 秒内生成输出。<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/14af8fd709215ad96688a3364deefea9cfc2fa13497810587106cef04c5a413c.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/14af8fd709215ad96688a3364deefea9cfc2fa13497810587106cef04c5a413c.png?size=small" data-sub-html="<h2>Mandelbrot without GPU</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/14af8fd709215ad96688a3364deefea9cfc2fa13497810587106cef04c5a413c.png" alt="Mandelbrot without GPU" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/14af8fd709215ad96688a3364deefea9cfc2fa13497810587106cef04c5a413c.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/14af8fd709215ad96688a3364deefea9cfc2fa13497810587106cef04c5a413c.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/14af8fd709215ad96688a3364deefea9cfc2fa13497810587106cef04c5a413c.png?size=large 2x" data-title="Mandelbrot without GPU" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>为了加快速度，我们可以使用 <a href="https://numba.pydata.org/?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">Numba<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 库将代码与 GPU 并行化，具体操作如下：</p>
<ul>
<li>
<p>我们将从 numba 导入即时编译、用于 GPU 加速的 CUDA 以及其他工具库</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">uint32</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">uint8</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">imshow</span><span class="p">,</span> <span class="n">show</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>@jit</code> 装饰器指示 Numba 执行即时编译，将 Python 代码转换为机器代码以提高执行速度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nd">@jit</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mandel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">max_iters</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>mandel_gpu</code> 是使用 <code>cuda.jit</code> 创建的 mandel 函数的 GPU 兼容版本。这允许将 mandel 逻辑卸载到 GPU。这是通过使用 <code>@cuda.jit</code> 装饰器并指定函数参数的数据类型（<code>f8</code> 表示浮点数，``uint32<code> 表示无符号32位整数）来完成的。</code>device=True` 参数指示该函数将在 GPU 上运行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">mandel_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">((</span><span class="n">f8</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">uint32</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">mandel</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>mandel_kernel</code> 函数被定义为在 CUDA GPU 上执行。它负责跨 GPU 线程并行生成 Mandelbrot 集。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nd">@cuda.jit</span><span class="p">((</span><span class="n">f8</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">f8</span><span class="p">,</span> <span class="n">uint8</span><span class="p">[:,:],</span> <span class="n">uint32</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mandel_kernel</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">height</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">width</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
</span></span><span class="line"><span class="cl">    <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">startX</span><span class="p">,</span> <span class="n">startY</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">gridX</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">gridDim</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="n">gridY</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">gridDim</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">gridX</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">real</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pixel_size_x</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startY</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">gridY</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">imag</span> <span class="o">=</span> <span class="n">min_y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">pixel_size_y</span>
</span></span><span class="line"><span class="cl">            <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">mandel_gpu</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">iters</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>现在，我们可以在 <code>create_fractal_gpu</code> 函数中使用 GPU 加速的 Mandelbrot 集生成。该函数分配 GPU 内存，启动 GPU 内核 (mandel_kernel)，并将结果复制回 CPU。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">create_fractal_gpu</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">iters</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 1: 为图像分配GPU内存</span>
</span></span><span class="line"><span class="cl">    <span class="n">d_image</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 2: 定义GPU并行化的线程和块数</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadsperblock</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">blockspergrid_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="n">blockspergrid_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="n">blockspergrid</span> <span class="o">=</span> <span class="p">(</span><span class="n">blockspergrid_x</span><span class="p">,</span> <span class="n">blockspergrid_y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 3: 测量开始时间</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 4: 启动 GPU 内核（mandel_kernel）在 GPU 上计算 Mandelbrot 集。</span>
</span></span><span class="line"><span class="cl">    <span class="n">mandel_kernel</span><span class="p">[</span><span class="n">blockspergrid</span><span class="p">,</span> <span class="n">threadsperblock</span><span class="p">](</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">d_image</span><span class="p">,</span> <span class="n">iters</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 5: 等待 GPU 完成其工作（同步）</span>
</span></span><span class="line"><span class="cl">    <span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 6: 测量GPU处理所需的时间</span>
</span></span><span class="line"><span class="cl">    <span class="n">dt</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 7: 将结果从 GPU 内存复制回 CPU</span>
</span></span><span class="line"><span class="cl">    <span class="n">d_image</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Step 8: 显示 Mandelbrot 集图像</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Mandelbrot created on GPU in </span><span class="si">%f</span><span class="s2"> s&#34;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">show</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>上面的代码在 <code>0.0046 seconds</code> 中执行。这比我们之前的基于 CPU 的代码要快得多。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4d62577a332918dc7b5fefc924f27aa6c62599e101e1494184860b82e0e8ddd2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4d62577a332918dc7b5fefc924f27aa6c62599e101e1494184860b82e0e8ddd2.png?size=small" data-sub-html="<h2>Mandelbrot with GPU</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4d62577a332918dc7b5fefc924f27aa6c62599e101e1494184860b82e0e8ddd2.png" alt="Mandelbrot with GPU" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4d62577a332918dc7b5fefc924f27aa6c62599e101e1494184860b82e0e8ddd2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4d62577a332918dc7b5fefc924f27aa6c62599e101e1494184860b82e0e8ddd2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/4d62577a332918dc7b5fefc924f27aa6c62599e101e1494184860b82e0e8ddd2.png?size=large 2x" data-title="Mandelbrot with GPU" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是<a href="https://github.com/RijulTP/GPUToolkit/tree/main/mandelbrot?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">完整的代码<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>供读者参考。</p>
<h4 id="使用-gpu-训练猫狗神经网络" class="heading-element"><span>5.3.3 使用 GPU 训练猫狗神经网络</span>
  <a href="#%e4%bd%bf%e7%94%a8-gpu-%e8%ae%ad%e7%bb%83%e7%8c%ab%e7%8b%97%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们现在看到的热门话题之一是 GPU 如何在人工智能中使用，因此为了证明我们将创建一个神经网络来区分猫和狗。我们将使用以下代码训练和使用猫与狗模型，其中使用了卷积神经网络（CNN），您可以阅读有关它的<a href="https://www.analyticsvidhya.com/blog/2021/06/beginner-friendly-project-cat-and-dog-classification-using-cnn/?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">更多详细信息<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<ul>
<li>
<p><strong>先决条件</strong></p>
<ol>
<li>
<p>CUDA</p>
</li>
<li>
<p>Tensorflow -&gt; 可以通过 <code>pip install tensorflow[and-cuda]</code> 安装</p>
</li>
<li>
<p>我们将使用来自<a href="https://www.kaggle.com/competitions/dogs-vs-cats/overview?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">kaggle<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>的猫和狗的数据集</p>
</li>
<li>
<p>下载完成后，解压，将训练文件夹中的猫和狗的图片整理到不同的子文件夹中，如下图所示。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/47b0cc05fa99283bd8dcd39a801809bdf5521a285df558c1436460ddf4d1ebdd.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/47b0cc05fa99283bd8dcd39a801809bdf5521a285df558c1436460ddf4d1ebdd.png?size=small" data-sub-html="<h2>CNN File Structure</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/47b0cc05fa99283bd8dcd39a801809bdf5521a285df558c1436460ddf4d1ebdd.png" alt="CNN File Structure" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/47b0cc05fa99283bd8dcd39a801809bdf5521a285df558c1436460ddf4d1ebdd.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/47b0cc05fa99283bd8dcd39a801809bdf5521a285df558c1436460ddf4d1ebdd.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/47b0cc05fa99283bd8dcd39a801809bdf5521a285df558c1436460ddf4d1ebdd.png?size=large 2x" data-title="CNN File Structure" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
</li>
</ol>
</li>
<li>
<p><strong>导入库</strong></p>
<blockquote>
<ul>
<li>
<p><code>pandas</code> 和 <code>numpy</code> 用于数据操作。</p>
</li>
<li>
<p><code>Sequential</code>用于在神经网络中创建线性层堆栈。</p>
</li>
<li>
<p><code>Convolution2D</code>、``MaxPooling2D<code>、</code>Dense<code>和</code>Flatten` 是用于构建卷积神经网络 (CNN) 的层。</p>
</li>
<li>
<p><code>ImageDataGenerator </code>用于在训练期间进行实时数据增强。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Sequential</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Convolution2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Flatten</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.preprocessing.image</span> <span class="kn">import</span> <span class="n">ImageDataGenerator</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>初始化卷积神经网络</strong></p>
<blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">classifier</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>加载训练数据</strong></p>
<blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">train_datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">shear_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">zoom_range</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">horizontal_flip</span><span class="o">=</span><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">test_datagen</span> <span class="o">=</span> <span class="n">ImageDataGenerator</span><span class="p">(</span><span class="n">rescale</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">training_set</span> <span class="o">=</span> <span class="n">train_datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="s1">&#39;./training_set&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">class_mode</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">test_set</span> <span class="o">=</span> <span class="n">test_datagen</span><span class="o">.</span><span class="n">flow_from_directory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="s1">&#39;./test_set&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="n">class_mode</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>构建 CNN 架构</strong></p>
<blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Convolution2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>编译模型</strong></p>
<blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>训练模型</strong></p>
<blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_set</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">validation_data</span><span class="o">=</span><span class="n">test_set</span><span class="p">,</span> <span class="n">validation_steps</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">classifier</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;trained_model.h5&#39;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
</ul>
<p>一旦我们训练完模型，模型就会使用 <code>classifier.save</code> 存储在 <code>.h5</code> 文件中。在下面的代码中，我们将使用这个 <code>trained_model.h5</code> 文件来识别猫和狗。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">load_model</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">keras.utils</span> <span class="k">as</span> <span class="nn">image</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict_image</span><span class="p">(</span><span class="n">imagepath</span><span class="p">,</span> <span class="n">classifier</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">predict</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">load_img</span><span class="p">(</span><span class="n">imagepath</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">predict_modified</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">img_to_array</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">predict_modified</span> <span class="o">=</span> <span class="n">predict_modified</span> <span class="o">/</span> <span class="mi">255</span>
</span></span><span class="line"><span class="cl">    <span class="n">predict_modified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">predict_modified</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">predict_modified</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">prediction</span> <span class="o">=</span> <span class="s1">&#39;dog&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="n">probability</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Probability = &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">probability</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Prediction = &#34;</span> <span class="o">+</span> <span class="n">prediction</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">prediction</span> <span class="o">=</span> <span class="s1">&#39;cat&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="n">probability</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Probability = &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">probability</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Prediction = &#34;</span> <span class="o">+</span> <span class="n">prediction</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加载训练好的模型</span>
</span></span><span class="line"><span class="cl"><span class="n">loaded_classifier</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="s1">&#39;trained_model.h5&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例用法</span>
</span></span><span class="line"><span class="cl"><span class="n">dog_image</span> <span class="o">=</span> <span class="s2">&#34;dog.jpg&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">predict_image</span><span class="p">(</span><span class="n">dog_image</span><span class="p">,</span> <span class="n">loaded_classifier</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cat_image</span> <span class="o">=</span> <span class="s2">&#34;cat.jpg&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">predict_image</span><span class="p">(</span><span class="n">cat_image</span><span class="p">,</span> <span class="n">loaded_classifier</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果如下：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d546542af4055bc7163bc49055d5a623a44ad0cc3022d02d0aaa791b9a83d75b.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d546542af4055bc7163bc49055d5a623a44ad0cc3022d02d0aaa791b9a83d75b.png?size=small" data-sub-html="<h2>Alt text</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d546542af4055bc7163bc49055d5a623a44ad0cc3022d02d0aaa791b9a83d75b.png" alt="Alt text" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d546542af4055bc7163bc49055d5a623a44ad0cc3022d02d0aaa791b9a83d75b.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d546542af4055bc7163bc49055d5a623a44ad0cc3022d02d0aaa791b9a83d75b.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d546542af4055bc7163bc49055d5a623a44ad0cc3022d02d0aaa791b9a83d75b.png?size=large 2x" data-title="Alt text" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>这是<a href="https://github.com/RijulTP/GPUToolkit/tree/main/neural-network?ref=journal.hexmos.com"target="_blank" rel="external nofollow noopener noreferrer">完整的代码<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>供读者学习参考。</p>
<h2 id="结论" class="heading-element"><span>6 结论</span>
  <a href="#%e7%bb%93%e8%ae%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在即将到来的AI时代，GPU是一个不容忽视的东西，我们应该更加了解它的能力。随着我们从传统的串行算法过渡到日益流行的并行算法，GPU 成为加速复杂计算不可或缺的工具。 GPU 的并行处理能力在处理人工智能和机器学习任务固有的海量数据集和复杂的神经网络架构方面特别有优势。此外，GPU 的作用超出了传统的机器学习领域，在科学研究、模拟和数据密集型任务中找到了应用。事实证明，GPU 的并行处理能力有助于解决从药物发现、气候建模到金融模拟等各个领域的挑战。</p>
]]></description></item><item><title>优秀的CS学习网站</title><link>https://hezephyr.github.io/posts/01.%E8%AF%BE%E7%A8%8B%E7%BD%91%E7%AB%99/</link><pubDate>Sat, 11 May 2024 21:46:26 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E8%AF%BE%E7%A8%8B%E7%BD%91%E7%AB%99/</guid><description><![CDATA[<h2 id="操作系统" class="heading-element"><span>1 操作系统</span>
  <a href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="nju操作系统设计与实现" class="heading-element"><span>1.1 NJU操作系统：设计与实现</span>
  <a href="#nju%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>先修要求：</p>
<ul>
<li>C语言</li>
<li>一些汇编语言基础</li>
<li>计算机基础</li>
</ul>
<p>这是NJU jyy老师的操作系统课程，每年都会在B站更新最新的操作系统课程视频，当然过往课程也可以找到。</p>
<p><a href="https://jyywiki.cn/OS/2022/index.html"target="_blank" rel="external nofollow noopener noreferrer">2022年OS 网站<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://www.bilibili.com/video/BV1Cm4y1d7Ur/?spm_id_from=333.788&amp;vd_source=cf653f235f52de98cb93354b5c75a0bc"target="_blank" rel="external nofollow noopener noreferrer">2022年OS 视频<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/"target="_blank" rel="external nofollow noopener noreferrer">课程教程OSTEP<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://jyywiki.cn/OS/2022/index.html"target="_blank" rel="external nofollow noopener noreferrer">2022年OS Lab<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h3 id="mit6s081-operating-system-engineering" class="heading-element"><span>1.2 MIT6.S081: Operating System Engineering</span>
  <a href="#mit6s081-operating-system-engineering" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>先修要求：</p>
<ul>
<li>C语言</li>
<li>一些汇编语言基础</li>
<li>计算机基础</li>
</ul>
<p><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html"target="_blank" rel="external nofollow noopener noreferrer">课程网站<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://www.youtube.com/watch?v=L6YqHxYHa7A"target="_blank" rel="external nofollow noopener noreferrer">课程视频<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/"target="_blank" rel="external nofollow noopener noreferrer">课程视频翻译文档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf"target="_blank" rel="external nofollow noopener noreferrer">课程教材<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html"target="_blank" rel="external nofollow noopener noreferrer">课程作业<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="分布式系统" class="heading-element"><span>2 分布式系统</span>
  <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="mit6824after-2022-65840-distributed-system" class="heading-element"><span>2.1 MIT6.824(after 2022, 6.5840): Distributed System</span>
  <a href="#mit6824after-2022-65840-distributed-system" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>先修要求：</p>
<ul>
<li>Go语言</li>
<li>操作系统</li>
<li>并发编程</li>
<li>计算机体系结构</li>
</ul>
<p><a href="https://pdos.csail.mit.edu/6.824/"target="_blank" rel="external nofollow noopener noreferrer">课程网站<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://www.bilibili.com/video/BV1CU4y1P7PE/?spm_id_from=333.337.search-card.all.click"target="_blank" rel="external nofollow noopener noreferrer">课程视频-中文字幕<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824"target="_blank" rel="external nofollow noopener noreferrer">课程中文文档<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a href="http://nil.csail.mit.edu/6.824/2022/"target="_blank" rel="external nofollow noopener noreferrer">课程作业<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item></channel></rss>