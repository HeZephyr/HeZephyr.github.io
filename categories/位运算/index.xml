<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>位运算 - 分类 | ZephyrHe</title><link>https://lruihao.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/</link><description>位运算 - 分类 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Fri, 28 May 2021 13:12:04 +0000</lastBuildDate><atom:link href="https://lruihao.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="self" type="application/rss+xml"/><item><title>位运算全面总结</title><link>https://lruihao.cn/posts/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 28 May 2021 13:12:04 +0000</pubDate><author>HeZephyr</author><guid>https://lruihao.cn/posts/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</guid><description><![CDATA[<h2 id="位运算概述" class="heading-element"><span>1 位运算概述</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们知道，==计算机中的数在内存中都是以二进制形式进行存储的== ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。
<a class="lightgallery" href="https://i-blog.csdnimg.cn/direct/35c5fd04622d42e28a82695a72876c0f.png?size=large" data-thumbnail="https://i-blog.csdnimg.cn/direct/35c5fd04622d42e28a82695a72876c0f.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://i-blog.csdnimg.cn/direct/35c5fd04622d42e28a82695a72876c0f.png" alt="在这里插入图片描述" srcset="https://i-blog.csdnimg.cn/direct/35c5fd04622d42e28a82695a72876c0f.png?size=small, https://i-blog.csdnimg.cn/direct/35c5fd04622d42e28a82695a72876c0f.png?size=medium 1.5x, https://i-blog.csdnimg.cn/direct/35c5fd04622d42e28a82695a72876c0f.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>那么，涉及位运算的运算符如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">运算规则</th>
<th style="text-align:center">实例（以四位二进制数为例）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">与</td>
<td style="text-align:center">两个位都为1时，结果才为1。</td>
<td style="text-align:center">$0001&amp;0001=1,0001&amp;0000=0,0000&amp;0000=0000$</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">或</td>
<td style="text-align:center">两个位都为0时，结果才为0。</td>
<td style="text-align:center">$0001|0001=0001,0001|0000=0001,0000|0000=0000$</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">异或</td>
<td style="text-align:center">两个位相同为0，相异为1。</td>
<td style="text-align:center">$0001 \wedge0001=0000,0001\wedge0000=1,0000\wedge 0000=0$</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取反</td>
<td style="text-align:center">0变1，1变0。</td>
<td style="text-align:center">$\sim0=1,\sim 1 = 0$</td>
</tr>
<tr>
<td style="text-align:center">&laquo;</td>
<td style="text-align:center">左移</td>
<td style="text-align:center">各二进位全部左移若干位，高位丢弃，低位补0。</td>
<td style="text-align:center">$0001&laquo;k=0100，k=2$，$k$是左移的位数，这里$k=2$</td>
</tr>
<tr>
<td style="text-align:center">&raquo;</td>
<td style="text-align:center">右移</td>
<td style="text-align:center">各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补$1$。</td>
<td style="text-align:center">$0100&raquo;k=0001，k=2$，$k$是右移的位数，这里$k=2$</td>
</tr>
</tbody>
</table>
<p>看完，你可能会觉得挺简单的，==但位运算的难点并不在这，而在于其性质、高级操作和它的应用。==</p>
<h2 id="位运算的性质" class="heading-element"><span>2 位运算的性质</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9a%84%e6%80%a7%e8%b4%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="运算符的优先级" class="heading-element"><span>2.1 运算符的优先级</span>
  <a href="#%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>优先级需要弄清楚，如果不太清楚可以加小括号确保是想要的运算顺序，==这里只是相对优先级，即只是和一些常用的算术运算符做比较。==</p>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">结合方向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$-（符号运算符）,\sim（取反运算符）， ++（自增），&ndash;（自减）$</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">$*（乘）,/（除）,%（取余）$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">$+（加）,-（减）$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$&laquo;（左移），&raquo;（右移）$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">$&gt;（大于）,&lt;(小于),&gt;=(大于等于),&lt;=(小于等于)$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">$==(等于),!=（不等于）$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">$&amp;（按位与）$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">$\wedge (按位异或)$</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">$|(按位或)$</td>
<td style="text-align:center">从左到右</td>
</tr>
</tbody>
</table>
<h3 id="位运算符的运算律" class="heading-element"><span>2.2 位运算符的运算律</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
<thead>
<tr>
<th style="text-align:center">公式名称</th>
<th style="text-align:center">运算规则</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">交换律</td>
<td style="text-align:center">$A&amp;B=B&amp;A ,A\wedge B=B\wedgeA$</td>
</tr>
<tr>
<td style="text-align:center">结合律（注意结合律只能在同符号下进行）</td>
<td style="text-align:center">$(A&amp;B)&amp;C=A&amp;(B&amp;C)$</td>
</tr>
<tr>
<td style="text-align:center">等幂律</td>
<td style="text-align:center">$A&amp;A=A，A|A=A$</td>
</tr>
<tr>
<td style="text-align:center">零律</td>
<td style="text-align:center">$A&amp;0=0$</td>
</tr>
<tr>
<td style="text-align:center">互补律（注意，这不同于逻辑运算）</td>
<td style="text-align:center">$A&amp;\sim A=0, A|\sim A=-1$</td>
</tr>
<tr>
<td style="text-align:center">同一律</td>
<td style="text-align:center">$A|0=A, A\wedge 0 =A$</td>
</tr>
</tbody>
</table>
<p>以上仅为已证明的运算律（可能存在遗漏），其余的博主均认为是不符合不成立的，==注意：千万不要将逻辑运算的运算律或者其他的运算律与这混为一谈。==</p>
<h2 id="位运算高级操作" class="heading-element"><span>3 位运算高级操作</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e9%ab%98%e7%ba%a7%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如下表，请读者认真阅读理解，在阅读的过程中可以对示例进行运算。</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">位运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">去掉最后一位</td>
<td style="text-align:center">$0100-&gt;0010$</td>
<td style="text-align:center">$x&raquo;1$</td>
</tr>
<tr>
<td style="text-align:center">在最后加一个$0$</td>
<td style="text-align:center">$0100-&gt;1000$</td>
<td style="text-align:center">$x&laquo;1$</td>
</tr>
<tr>
<td style="text-align:center">在最后加一个1</td>
<td style="text-align:center">$0100-&gt;1001$</td>
<td style="text-align:center">$(x&laquo;1)+1$</td>
</tr>
<tr>
<td style="text-align:center">将最后一位变为$1$</td>
<td style="text-align:center">$0100-&gt;0101$</td>
<td style="text-align:center">$x|1$</td>
</tr>
<tr>
<td style="text-align:center">将最后一位变为$0$</td>
<td style="text-align:center">$0101-&gt;0100$，这里实际上就是先确保最低位变为$1$，再减去$1$。</td>
<td style="text-align:center">$(x|1)-1$</td>
</tr>
<tr>
<td style="text-align:center">最后一位取反</td>
<td style="text-align:center">$0100-&gt;0101$ ，利用异或性质，其中除最后一位其余不变。</td>
<td style="text-align:center">$x\wedge1$</td>
</tr>
<tr>
<td style="text-align:center">把右数的第$k$位变为$1$</td>
<td style="text-align:center">$0001-&gt;1001,k=4$</td>
<td style="text-align:center">$x|(1&laquo;(k-1))$</td>
</tr>
<tr>
<td style="text-align:center">把右数的第$k$位变为$0$</td>
<td style="text-align:center">$1001-&gt;0001,k=4$，这个操作实际上就是先得到了$1000$，然后取反得到$0111$，最后利用按位与的性质其余位不变，最高位为$0$</td>
<td style="text-align:center">$x&amp;(\sim(1&laquo;(k-1)))$</td>
</tr>
<tr>
<td style="text-align:center">把右数的第$k$位取反</td>
<td style="text-align:center">$1000-&gt;0000,k=4$，利用异或性质</td>
<td style="text-align:center">$x\wedge (1&laquo;(k-1))$</td>
</tr>
</tbody>
</table>
<p>由于表长限制，这里接下表继续：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">位运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">取末$k$位</td>
<td style="text-align:center">$1011-&gt;0011,k=2$</td>
<td style="text-align:center">$x&amp;((1&laquo;k)-1)$</td>
</tr>
<tr>
<td style="text-align:center">取右数的第$k$位</td>
<td style="text-align:center">$1011-&gt;0001,k=4$，右移$k-1$位则是去掉了最后的$k-1$位，我们利用按位与即可将其提取出来</td>
<td style="text-align:center">$x&raquo;(k-1)&amp;1$</td>
</tr>
<tr>
<td style="text-align:center">把末$k$位全变为$1$</td>
<td style="text-align:center">$1000-&gt;1111,k=3$</td>
<td style="text-align:center">$x|((1&laquo;k)-1)$</td>
</tr>
<tr>
<td style="text-align:center">把末$k$位取反</td>
<td style="text-align:center">$0101-&gt;1010,k=4$</td>
<td style="text-align:center">$x\wedge ((1&laquo;k)-1)$</td>
</tr>
<tr>
<td style="text-align:center">把右边连续的$1$变为$0$</td>
<td style="text-align:center">$0111-&gt;0000$ ，注意是右起连续的$1$</td>
<td style="text-align:center">$x&amp;(x+1)$</td>
</tr>
<tr>
<td style="text-align:center">把右起的第一个$0$变为$1$</td>
<td style="text-align:center">$0011-&gt;0111$</td>
<td style="text-align:center">$x|(x+1)$</td>
</tr>
<tr>
<td style="text-align:center">把右起连续的$0$变为$1$</td>
<td style="text-align:center">$1000-&gt;1111$，注意是右起连续的$0$</td>
<td style="text-align:center">$x|(x-1)$</td>
</tr>
<tr>
<td style="text-align:center">取右边连续的$1$</td>
<td style="text-align:center">$1011-&gt;0011$</td>
<td style="text-align:center">$(x\wedge (x+1))&raquo;1$</td>
</tr>
<tr>
<td style="text-align:center">去掉右起的第一个$1$的左边</td>
<td style="text-align:center">$1101-&gt;0001$</td>
<td style="text-align:center">$x&amp;(x\wedge (x-1))$</td>
</tr>
</tbody>
</table>
<p>当然，这里只是一些常用的，并不是全部，位运算的神奇远不止于此。</p>
<h2 id="负数的位运算" class="heading-element"><span>4 负数的位运算</span>
  <a href="#%e8%b4%9f%e6%95%b0%e7%9a%84%e4%bd%8d%e8%bf%90%e7%ae%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，==负数的补码则是符号位不变，其余按位取反，最后再$+1$得到的，== 例如：</p>
<p>$15$,原码:$00001111\space$补码:$00001111$</p>
<p>$-15$,原码:$10001111\space$补码:$11110001$</p>
<p>那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。
但需要注意的是，对于有符号数的右移操作，不同的处理器架构可能有不同的规定。在某些架构中（如x86），如果对有符号数执行算术右移（arithmetic right shift），则高位空出来的位置会补上符号位；对于无符号数的右移操作，所有架构都遵循相同的规则：高位空出来的位置会补0。例如对于$-15$，其补码为$11110001,$右移一位$(-15&raquo;1)$得到的是$11111000$，即$-8$，其他的同理。
在大多数现代处理器上，无论是有符号数还是无符号数，左移操作总是将空出来的低位补0。</p>
<p>这里我们介绍几个特殊的性质：</p>
<ul>
<li>
<p><strong>快速判断是否为$-1$</strong></p>
<p>在链式前向星中，我们初始化$head$数组为$-1$，最后判断是否遍历完$u$的所有边时，即判断$i$是否为$-1$，我们直接用$\sim i$即可。原因就在于$-1$的补码是$11111111$，按位取反就变为$00000000$，这实际上就是$0$。</p>
</li>
<li>
<p><strong>取最低位的$1$，lowbit函数</strong></p>
<p>也就是$x&amp;(-x)$，这在树状数组中起着巨大作用，这里指路一篇树状数组讲解$blog$:<a href="https://blog.csdn.net/hzf0701/article/details/116208699?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162212420516780264027190%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162212420516780264027190&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-116208699.nonecase&amp;utm_term=%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84&amp;spm=1018.2226.3001.4450"target="_blank" rel="external nofollow noopener noreferrer">点这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，我们来证明一下，这里取$x=15$，对于$15&amp;(-15)$，我们知道，在补码上进行运算得到的是$00000001$，需要注意二元运算的符号位我们需要进行运算。</p>
</li>
</ul>
<h2 id="位运算的一些应用" class="heading-element"><span>5 位运算的一些应用</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9a%84%e4%b8%80%e4%ba%9b%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>位运算实现乘除法</strong></p>
<blockquote>
<p>将$x$左移一位实现$\times 2$，将$x$右移一位实现$\div2$。</p>
<p>$a&laquo;1 \equiv a*2$</p>
<p>$a &raquo;1 \equiv a/2$</p>
</blockquote>
</li>
<li>
<p><strong>位运算交换两整数</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span> <span class="o">^=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">b</span> <span class="o">^=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span> <span class="o">^=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这效率非常高，我们来剖析其原理，对于$a=a\wedge b$，则$b = b\wedge(a\wedge b)$，根据交换律以及异或性质，得$b=b\wedge b\wedge a=0\wedge a=a$，同理$a=(a\wedge b)\wedge a=0\wedge b=b$。这样就实现了交换操作。</p>
<ul>
<li>
<p><strong>位运算判断奇偶数</strong></p>
<blockquote>
<p>我们知道，在二进制中，最低位决定了是奇数还是偶数，所以我们可以提取出最低位的值，即与$1$相与即可实现目的，为$0$则是偶数，为$1$则是奇数。</p>
</blockquote>
</li>
<li>
<p><strong>位运算改变正负性和求绝对值</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">change</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">~</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于正数而言，补码就是原码，所以按位取反再$+1$则得到对应真值负数的补码，而对于负数，其补码进行按位取反再$+1$则得到对应真值正数的补码，变为原码。那么知道这个我们就可以特判是否为负数 ==（这里通过右移$31$位，若为正数，则得到的是$0$，若为负数，则得到的是$-1$，而$0$的补码为$0000$,$-1$的补码为$1111$，<del>根据异或性质即可判断</del>感谢读者
（恢。）指出错误，这里应该是要进行按位取反操作，这样如果为负数判断结果才为0
。）==  ，利用条件表达式就可以根据判断结果求绝对值了。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="o">~</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>位运算实现对$p$取余（p为$2^k$）</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mod</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>取余实际上就是舍去大于等于$p$的位数，所以我们只需要保留在$p$范围内的数。由于我们限定了$p$为$2^k$，所以$(p - 1)$一定是将小于$p$的最高位全部变为了$1$，这样再进行与操作即可得到余数。</p>
<ul>
<li><strong>位运算统计二进制数$1$的个数</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span> <span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于任意的$x$，转换成二进制后，是形如这样的数字：$aa&hellip;aa10&hellip;00$，从右向左数有任意多个$0$，直到遇见第一个$1$，字母$a$用来占位，代表$1$左边的任意数字。$x-1$转换成二进制后，是形如这样的数字：$aa&hellip;aa01&hellip;11$，从右向左数，原来的任意多个$0$都变成$1$，原来的第一个$1$，变成$0$，字母$a$部分不变。对$x$ 和 $x-1$ 进行 按位与 计算，会得到：$aa&hellip;aa00&hellip;00$，从右向左数，原来的第一个$1$变成了$0$，字母a部分不变。所以 $x &amp; (x-1)$相当于消除了 $x$ 从右向左数遇到的第一个$1$。那么，$x$转换成二进制后包含多少个$1$，count函数里的循环就会进行多少次，直到$x$所有的$1$都被“消除”。</p>
<h2 id="位运算例题" class="heading-element"><span>6 位运算例题</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e4%be%8b%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="更新二进制位" class="heading-element"><span>6.1 更新二进制位</span>
  <a href="#%e6%9b%b4%e6%96%b0%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%bd%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）</p>
<p>样例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输入: N=(10000000000)2 M=(10101)2 i=2 j=6
</span></span><span class="line"><span class="cl">输出: N=(10001010100)2
</span></span><span class="line"><span class="cl">输入: N=(10000000000)2 M=(11111)2 i=2 j=6
</span></span><span class="line"><span class="cl">输出: N=(10001111100)2</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>结合所学，我们的思路应该就是先将第$i$位到第$j$位全部变为$0$，再将与左移$i$位的$M$进行或操作。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">updateBits</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="c1">// 循环遍历从第 i 位到第 j 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">pos</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        	<span class="c1">// 将 n 的第 pos 位设为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ~(1 &lt;&lt; pos) 创建一个在第 pos 位为 0 其他位为 1 的掩码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 然后使用按位与运算符（&amp;）来将 n 的第 pos 位设置为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        	<span class="n">n</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 m 左移 i 位，使 m 的低位对齐到 n 的第 i 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 然后使用按位或运算符（|）合并 n 和 m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这样 n 的第 i 到第 j 位就被 m 的相应位所替换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">n</span> <span class="o">|</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="ab问题" class="heading-element"><span>6.2 A+B问题</span>
  <a href="#ab%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>给出两个整数 a 和 b , 求他们的和并以整数（int）的形式返回。<strong>不能使用</strong> <strong>+ 等数学运算符。</strong></p>
<p>样例：</p>
<p>输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a = 1
</span></span><span class="line"><span class="cl">b = 2</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">3</span></span></code></pre></td></tr></table>
</div>
</div><p>输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a = -1
</span></span><span class="line"><span class="cl">b = 1</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>这题我们可以利用异或操作来实现，因为异或操作有一个别名叫不进位加法。那么进位操作我们实际上就可以通过$a&amp;b$来实现，因为$a&amp;b$得到的都是$a$和$b$上都有的$1$，我们再左移即得到的是进位之后的结果，所以$a+b=(a\wedge b)+(a&amp;b&laquo;1)$。通过这样模拟竖式加法操作即可。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aplusb</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="c1">// 当没有进位需要处理时循环结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        	<span class="c1">// temp_a 存储 a 和 b 的按位异或结果，这相当于不带进位的加法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">temp_a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// temp_b 存储 a 和 b 的按位与结果并左移一位，这相当于计算进位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为只有两个位都是1时才会产生进位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">temp_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// 更新 a 为不带进位的加法结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">a</span> <span class="o">=</span> <span class="n">temp_a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">			<span class="c1">// 更新 b 为进位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">b</span> <span class="o">=</span> <span class="n">temp_b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当没有进位时，a 中存储了最终结果，返回 a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="o1时间检测2的幂次" class="heading-element"><span>6.3 O(1)时间检测2的幂次</span>
  <a href="#o1%e6%97%b6%e9%97%b4%e6%a3%80%e6%b5%8b2%e7%9a%84%e5%b9%82%e6%ac%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>用 O(<em>1</em>) 时间检测整数 <em>n</em> 是否是 <em>2</em> 的幂次。</p>
<p>样例</p>
<p><code>n=4</code>，返回 <code>true</code>;</p>
<p><code>n=5</code>，返回 <code>false</code>.</p>
<p>挑战</p>
<p>O(<em>1</em>) 时间复杂度</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>首先我们知道$2^k$是大于$0$的，这里我们需要特判，同理，$2^k$的二进制表示中只有$1$个$1$，故我们可以利用$x&amp;(x-1)$来消除唯一的$1$判断是否等于$0$即可。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">checkPowerOf2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查 n 是否大于 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2 的幂必须是正数，因为 0 和负数都不是 2 的幂
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 检查 n 和 n - 1 的按位与操作是否为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果 n 是 2 的幂，则其二进制表示中只有一个 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 例如 2 (10), 4 (100), 8 (1000)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此 n &amp; (n - 1) 将得到 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item></channel></rss>