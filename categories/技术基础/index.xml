<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>技术基础 - 分类 | ZephyrHe</title><link>https://lruihao.cn/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</link><description>技术基础 - 分类 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Sat, 01 Jun 2024 16:11:20 +0000</lastBuildDate><atom:link href="https://lruihao.cn/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" rel="self" type="application/rss+xml"/><item><title>C/C++ 面试题目总结</title><link>https://lruihao.cn/posts/01.c-%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 16:11:20 +0000</pubDate><author>HeZephyr</author><guid>https://lruihao.cn/posts/01.c-%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<ol>
<li>
<p>const知道吗？解释其作用</p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
</li>
<li>
<p>宏定义 #define 和 const 常量</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏定义 #define</th>
<th style="text-align:center">const 常量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">宏定义，相当于字符替换         |</td>
<td style="text-align:center">常量声明    |</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">预处理器处理</font> |</td>
<td style="text-align:center">编译器处理   |</td>
</tr>
<tr>
<td style="text-align:center">无类型安全检查             |</td>
<td style="text-align:center">有类型安全检查 |</td>
</tr>
<tr>
<td style="text-align:center">不分配内存               |</td>
<td style="text-align:center">要分配内存   |</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">存储在代码段</font> |</td>
<td style="text-align:center">存储在数据段  |</td>
</tr>
<tr>
<td style="text-align:center">可通过 <code>#undef</code> 取消          |</td>
<td style="text-align:center">不可取消    |</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>static的作用</p>
<ol>
<li>修饰普通变量，<font color="red">修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间</font>，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，<font color="red">表明函数的作用范围</font>，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，<font color="red">修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员</font>。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，<font color="red">但是在 static 函数内不能访问非静态成员</font>。</li>
</ol>
</li>
<li>
<p>说说this指针</p>
<ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，<strong>编译程序先将对象的地址赋给 <code>this</code> 指针</strong>，然后调用成员函数，<font color="red">每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针</font>。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用<code>this</code>指针：
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>说说inline内联函数</p>
<p>相当于把内联函数里面的内容写在调用内联函数处，即不用执行进入函数的步骤，直接执行函数体；相当于宏，却比宏多了类型检查，真正具有函数特性；编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数（但虚函数也可以是内联函数，但是当虚函数表现出多态性时不能内联）。</p>
<p>优点：</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点：</p>
<ol start="4">
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。<font color="red">内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器</font>。</li>
</ol>
</li>
<li>
<p>说说volatile关键字</p>
<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以<font color="red">使用 volatile 告诉编译器不应对这样的对象进行优化</font>。</li>
<li>volatile 关键字声明的变量，<font color="red">每次访问时都必须从内存中取出值</font>（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
</li>
<li>
<p>说说assert()</p>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p><code>static_assert</code> 是一个编译时断言，用于在编译期间检查常量表达式是否为 <code>true</code>。它定义在 C++11 及更高版本的标准中。<code>static_assert</code> 通常用于模板编程和常量表达式中，以确保某些编译时条件成立。与 <code>assert</code> 不同的是，<code>static_assert</code> 在编译时进行检查，因此它不会影响运行时性能。</p>
</li>
<li>
<p>说说sizeof()</p>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
</li>
<li>
<p><code>#pragma pack(n)</code></p>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐，<code>#pragma pack(pop)</code>  恢复对齐状态</p>
</li>
<li>
<p><code>extern &quot;C&quot;</code></p>
<p>被 <code>extern</code> 限定的函数或变量是 <code>extern</code> 类型的，被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和链接的</p>
</li>
<li>
<p>C++ 中 struct 和 class</p>
<p>总的来说，<font color="red">struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体</font>。</p>
<p>最本质的一个区别就是默认的访问控制，struct 默认的数据访问控制是 public 的，class 默认的成员变量访问控制是 private 的。</p>
</li>
<li>
<p>union 联合</p>
<p>联合（union）是一种节省空间的特殊的类，<font color="red">一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值</font>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
</li>
<li>
<p>C 实现 C++ 类</p>
<p><font color="red">C 实现 C++ 的面向对象特性（封装、继承、多态）</font></p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
</li>
<li>
<p>explicit（显式）关键字</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li>
</ul>
</li>
<li>
<p>friend 友元类和友元函数</p>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
</li>
<li>
<p>谈谈using</p>
<p>using 关键字在 C++ 中有多种用途，主要包括类型别名、引入命名空间中的标识符。并且C++11 引入了别名模板，可以使用 <code>using</code> 创建模板的别名。</p>
<p>尽量少使用 using 指示：<code>using namespace std;</code>，会污染命名空间</p>
</li>
<li>
<p><code>::</code> 范围解析运算符</p>
<ol>
<li>
<p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>         <span class="c1">// 全局（::）的 count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>       <span class="c1">// 测试 1：设置全局的 count 的值为 12
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>   <span class="c1">// 类 A 的 count（A::count）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈<code>decltype</code>关键字</p>
<p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类，返回值为所属类型。语法：<code>decltype ( expression )</code></p>
</li>
<li>
<p>谈谈引用</p>
<p>在 C++ 中，引用（reference）是一种为已存在的变量创建别名的机制。引用可以让你通过另一个名字访问同一个变量。C++ 中的引用主要分为以下几种类型：</p>
<ol>
<li>
<p>左值引用（L-value References）：左值引用用于引用内存中已经存在的对象，通常用于函数参数传递和返回值。</p>
</li>
<li>
<p>右值引用（R-value References）：右值引用在 C++11 引入（<code>int&amp;&amp; rvalueRef = 10</code>），主要用于引用临时对象（右值），支持移动语义和完美转发，优化性能。</p>
</li>
<li>
<p>引用折叠（Reference Collapsing）：引用折叠是一种复杂的规则，决定了多层引用的结果。它在模板编程和完美转发中非常重要。</p>
<p><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code>
<code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></p>
</li>
</ol>
</li>
<li>
<p>成员初始化列表
好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：
<ul>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈面向对象</p>
<p>面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范式，基于“对象”的概念，用于组织代码和数据。OOP 提供了一种更自然和直观的方法来解决复杂的软件问题，使程序设计更加模块化和可维护。面向对象的三大特性：</p>
<ol>
<li><strong>封装（Encapsulation）</strong> ：封装是将数据和操作数据的方法捆绑在一起，形成一个自包含的单元—对象。<font color="red">封装通过定义类中的私有成员变量和公有成员函数，隐藏内部实现细节，只暴露必要的接口。封装提高了代码的安全性和可维护性</font>。</li>
<li><strong>继承（Inheritance）</strong> ：继承是一种机制，<font color="red">通过创建一个新的类（子类），该类可以继承一个或多个已有类（基类）的属性和方法，从而实现代码的重用和扩展</font>。继承支持多态性，并且使得代码更具层次性。</li>
<li><strong>多态（Polymorphism）</strong>：多态是指一个函数或方法可以有多种不同的表现形式。<font color="red">在C++中多态主要通过虚函数和函数重载实现，使得不同的对象可以用统一的接口进行操作，从而提高代码的灵活性和扩展性</font>。</li>
</ol>
</li>
<li>
<p>C++多态</p>
<p>C++ 多态分类及实现：</p>
<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
<li>
<p>谈谈虚析构函数</p>
<p>虚析构函数（Virtual Destructor）是面向对象编程中一个重要的概念，特别是在 C++ 中。它的主要目的是确保在通过基类指针删除派生类对象时，派生类的析构函数能够正确调用，从而防止资源泄漏和未定义行为。</p>
</li>
<li>
<p>在C++中，希望一个类不能被实例化，可以怎么做？</p>
<ol>
<li>
<p><strong>将类声明为抽象基类（Abstract Base Class, ABC）：</strong> <font color="red">如果一个类至少有一个纯虚函数，那么这个类就是抽象基类，无法被实例化</font>。纯虚函数是在基类中声明但不定义的虚函数，它在基类中的声明形式如下：<code>virtual void func() = 0;</code>。纯虚函数使得派生类必须提供自己的实现，否则派生类也将成为抽象基类。</p>
<p>如果其中没有其他合适的函数，可以把析构函数定义为纯虚析构函数</p>
</li>
<li>
<p><strong>声明类的构造函数为protected或private：</strong> 如果一个类的构造函数被声明为<code>protected</code>或<code>private</code>，那么在类的外部就不能直接调用这个构造函数来创建类的对象。只有类本身和它的友元函数或类可以访问它的私有或保护成员。</p>
</li>
</ol>
</li>
<li>
<p>虚函数、纯虚函数</p>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。而纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
</li>
<li>
<p>谈谈虚函数指针、虚函数表</p>
<p>虚函数指针是存储在对象中的特殊指针，用于指向对象的虚函数表。<font color="red">每个对象都有一个虚函数指针，它指向对象的虚函数表的首地址。</font>通过虚函数指针，可以在运行时动态地调用适当的虚函数。</p>
<p>虚函数表是存储在内存中的一张表格，用于存储类的虚函数地址。<font color="red">每个类（含有虚函数的类）都有一个对应的虚函数表，其中存放了该类所有虚函数的地址</font>。虚函数表是在编译阶段创建的，每个类的虚函数表在程序运行时都会存在于内存中。</p>
<p>虚函数指针指向虚函数表的首地址，通过虚函数指针可以访问到对象的虚函数表。当调用对象的虚函数时，编译器会使用虚函数指针找到对象的虚函数表，然后根据函数在虚函数表中的索引找到相应的虚函数地址，并进行调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span><span class="o">*</span> <span class="n">vptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="o">**</span><span class="p">)</span><span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表中第一个虚函数地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">funcAddr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 转换为函数指针并调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">funcAddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">func</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>谈谈虚继承</p>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，<font color="red">每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）</font>（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
</li>
<li>
<p>虚继承、虚函数</p>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：
<ul>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li><font color="red">虚基类表存储的是虚基类相对直接继承类的偏移</font></li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的抽象类、接口类、聚合类</p>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的模板机制</p>
<p>在C++中，模板（Template）是一种通用的代码生成机制，允许程序员编写通用的代码来处理不同类型的数据，而不需要为每种数据类型编写特定的代码。模板是C++中强大的特性之一，它提高了代码的重用性、可读性和可维护性。</p>
<ol>
<li>
<p>类模板（Class Templates）：类模板是一种用于创建通用类的模板，允许类中的数据成员和成员函数的类型参数化。通过类模板，可以定义一个通用的类，可以处理多种不同类型的数据。</p>
</li>
<li>
<p>函数模板（Function Templates）：函数模板是一种用于创建通用函数的模板，允许函数中的参数类型参数化。通过函数模板，可以定义一个通用的函数，可以处理多种不同类型的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">maximum</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板特化（Template Specialization）：模板特化是指针对某些特定的类型，为模板定义一个特殊的实现。当模板在处理特定类型时需要特殊的行为时，可以使用模板特化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Stack&lt;std::string&gt;::pop(): empty stack&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">element</span> <span class="o">=</span> <span class="n">elements</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板参数（Template Parameters）：模板参数是在定义模板时指定的参数，它可以是类型参数或非类型参数。类型参数指定了模板中的数据类型，而非类型参数可以是整数、指针等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>C++的new/delete和malloc/delete有什么区别？</p>
<p>C++中的<code>new</code>和<code>malloc()</code>都用于在堆上动态分配内存，但它们之间有一些重要的区别：</p>
<ol>
<li><code>new</code> 是C++中的关键字，可以为指定的类型动态分配内存，并返回相应类型的指针。而<code>malloc()</code>是C标准库函数，它返回<code>void*</code>类型的指针，需要手动进行类型转换，将其转换为所需类型的指针。这样的操作在C++中不够安全，可能导致编译器无法检测到的类型错误。</li>
<li><code>new</code> 分配内存时会调用对象的构造函数，确保对象被正确初始化。<code>malloc()</code> 只是简单地分配一块内存，并不会调用对象的构造函数。</li>
<li><code>new</code> 可以根据所需类型的大小自动计算要分配的内存空间大小，无需手动计算。而<code>malloc()</code> 需要手动指定要分配的内存空间大小，需要调用<code>sizeof</code>函数来计算所需的字节数。</li>
<li>在内存分配失败时，<code>new</code> 会抛出异常（<code>std::bad_alloc</code>），需要使用异常处理机制来处理。而<code>malloc()</code> 分配内存失败时会返回空指针（<code>NULL</code>），需要手动检查返回值并进行错误处理。</li>
<li>使用<code>new</code>分配的内存需要使用<code>delete</code>关键字进行释放，而使用<code>malloc()</code>分配的内存需要使用<code>free()</code>函数进行释放。</li>
</ol>
<p>本质：<code>new / new[]</code>：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。<code>delete/delete[]</code>：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p>
</li>
<li>
<p>delete this 合法吗？</p>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
</li>
<li>
<p>C++如何定义一个只能在堆上（栈上）生成对象的类？</p>
<ul>
<li>只能在堆上：将析构函数设置为私有。C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li>
<li>只能在栈上：将 new 和 delete 重载为私有。在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li>
</ul>
</li>
<li>
<p>介绍一下C++的智能指针</p>
<p>C++中的智能指针是一种特殊的指针对象，可以自动管理动态分配的内存，避免内存泄漏和悬空指针等常见问题。智能指针通过包装原始指针，提供了自动释放内存的机制，从而简化了内存管理的工作。常见的智能指针包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>（<code>auto_ptr</code>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。）。</p>
<ol>
<li><code>std::unique_ptr</code>是一种独占式智能指针，即同一时间只能有一个<code>std::unique_ptr</code>拥有某个对象的所有权。当<code>std::unique_ptr</code>超出作用域或被显式释放时，它所管理的对象会被自动释放。不能复制或赋值给其他<code>std::unique_ptr</code>，但可以通过<code>std::move()</code>来转移所有权。<font color="red">适用于需要严格所有权管理的情况，例如资源管理类对象</font>。</li>
<li><code>std::shared_ptr</code>是一种共享式智能指针，可以拥有多个<code>std::shared_ptr</code>共享同一个对象。使用引用计数来跟踪对象的引用次数，当引用次数为0时，对象会被自动释放。可以复制和赋值给其他<code>std::shared_ptr</code>，引用计数会增加。<font color="red">适用于需要多个指针共享同一资源的情况，例如多个对象共享一个动态分配的对象</font>。</li>
<li><code>std::weak_ptr</code>是一种弱引用智能指针，它不会增加对象的引用计数，也不会影响对象的生命周期。用于解决<code>std::shared_ptr</code>的循环引用问题，通过打破循环引用，<strong>防止内存泄漏</strong>。可以通过<code>lock()</code>方法获取一个指向被管理对象的<code>std::shared_ptr</code>，如果对象已经被释放，则返回空指针。</li>
</ol>
</li>
<li>
<p>谈谈C++的强制类型转换</p>
<p>在C++中，有四种主要的强制类型转换方式：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。用法：<code>static_cast&lt;typename&gt;(object)</code></p>
<ol>
<li>
<p><code>static_cast</code>用于进行静态类型转换，通常用于较为安全的转换，例如基本数据类型之间的转换、类层次结构中的向上转换（派生类指针转为基类指针）和向下转换（基类指针转为派生类指针）等。<font color="red">静态转换在编译时进行，不提供运行时类型检查</font>。</p>
</li>
<li>
<p><code>dynamic_cast</code>用于进行动态类型转换，用于安全地在类层次结构中进行向上或向下转换，并且提供了运行时类型检查。当进行向下转换时，如果指针不指向有效的派生类对象，则返回空指针。<font color="red">只能用于具有虚函数的类（即多态类）之间的转换。</font></p>
</li>
<li>
<p><code>const_cast</code>用于添加或删除对象的const属性、volatile属性，<font color="red">主要用于消除类型的const限制</font>。注意：不应该用于修改本来就不可修改的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 去除const属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// 合法，修改了const对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>reinterpret_cast</code>用于进行底层的重新解释转换，例如将一个指针转换为一个整数，或者一个整数转换为一个指针。这种转换非常危险，可能会导致未定义的行为，因此应该尽量避免使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 将int指针转换为void指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">newXPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 将void指针转换为int指针
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈运行时类型信息 (RTTI)</p>
<p>运行时类型信息（RTTI, Runtime Type Information）是C++提供的一种机制，用于在运行时识别对象的类型。RTTI允许程序在运行时获取关于对象类型的信息，主要包括两个关键特性：<code>typeid</code>操作符和<code>dynamic_cast</code>操作符。</p>
<ol>
<li><code>typeid</code>操作符用于获取表达式或对象的类型信息。<code>typeid</code>返回一个<code>std::type_info</code>对象，该对象包含了类型的信息，可以通过其成员函数来获取类型名等信息。</li>
<li><code>dynamic_cast</code>用于多态类型的转换</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnotherDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 成功转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AnotherDerived</span><span class="o">*</span> <span class="n">ad</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">AnotherDerived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 转换失败，返回nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is a Derived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is not an AnotherDerived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>RTTI通常用于以下场景：</p>
<ul>
<li><strong>安全类型转换</strong>：在复杂的类层次结构中，使用<code>dynamic_cast</code>进行安全的向下转换，确保类型转换的正确性。</li>
<li><strong>类型检查</strong>：使用<code>typeid</code>进行类型检查，调试和记录对象的实际类型信息，帮助诊断问题。</li>
</ul>
</li>
<li>
<p>谈谈C++中怎么处理异常</p>
<p>在C++中，异常处理是一种机制，用于捕获和处理程序运行过程中发生的错误或异常情况，从而避免程序崩溃。C++通过<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现异常处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能抛出异常的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理标准库异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Standard exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理整型异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Integer exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理其他所有类型的异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unknown exception caught&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>throw</code>表达式用于抛出异常，可以抛出任何类型的对象。</p>
<p>C++允许用户定义自己的异常类，通常继承自<code>std::exception</code>，并重写<code>what()</code>方法来提供异常信息。</p>
</li>
<li>
<p>STL容器</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">有无序</th>
<th style="text-align:center">可不可重复</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机读改 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">支持随机访问，大小固定，不能动态调整</td>
</tr>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">支持随机访问，动态调整大小，使用连续内存存储，插入删除效率视位置而定</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">双端队列</td>
<td style="text-align:center">头尾插入、头尾删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问，但随机访问效率略低于vector</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单向链表</td>
<td style="text-align:center">插入、删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不支持随机访问，只能单向遍历，适用于只需前向访问和修改的场景</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双向链表</td>
<td style="text-align:center">插入、删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">不支持随机访问，支持双向遍历，适用于频繁插入和删除的场景</td>
</tr>
<tr>
<td style="text-align:center">stack</td>
<td style="text-align:center">deque / list</td>
<td style="text-align:center">顶部插入、顶部删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">适用于后进先出（LIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
</tr>
<tr>
<td style="text-align:center">queue</td>
<td style="text-align:center">deque / list</td>
<td style="text-align:center">尾部插入、头部删除 O(1)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">适用于先进先出（FIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
</tr>
<tr>
<td style="text-align:center">priority_queue</td>
<td style="text-align:center">vector + max-heap</td>
<td style="text-align:center">插入、删除 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">使用最大堆实现，适用于需要动态获取最大元素的场景，底层使用vector存储</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">自动排序且元素唯一，适用于需要有序且无重复元素的场景</td>
</tr>
<tr>
<td style="text-align:center">multiset</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">自动排序，允许重复元素，适用于需要有序且可重复元素的场景</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">键值对存储，键唯一，自动按键排序，适用于需要按键有序访问且键唯一的场景</td>
</tr>
<tr>
<td style="text-align:center">multimap</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">插入、删除、查找 O(log2n)</td>
<td style="text-align:center">有序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">键值对存储，键可重复，自动按键排序，适用于需要按键有序访问且键可重复的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_set</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">使用哈希表实现，元素唯一，无序存储，适用于快速查找和插入的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_multiset</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">使用哈希表实现，允许重复元素，无序存储，适用于需要快速查找和插入且元素可重复的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_map</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">不可重复</td>
<td style="text-align:center">键值对存储，键唯一，使用哈希表实现，无序存储，适用于需要快速按键查找和插入的场景</td>
</tr>
<tr>
<td style="text-align:center">unordered_multimap</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">插入、删除、查找 O(1) 最差 O(n)</td>
<td style="text-align:center">无序</td>
<td style="text-align:center">可重复</td>
<td style="text-align:center">键值对存储，键可重复，使用哈希表实现，无序存储，适用于需要快速按键查找和插入且键可重复的场景</td>
</tr>
</tbody>
</table>
</li>
</ol>
]]></description></item><item><title>如何使用C语言从一定范围内生成随机整数？</title><link>https://lruihao.cn/posts/02.c%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%80%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0/</link><pubDate>Wed, 27 Mar 2024 22:20:31 +0000</pubDate><author>HeZephyr</author><guid>https://lruihao.cn/posts/02.c%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%80%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0/</guid><description><![CDATA[<p><a href="https://stackoverflow.com/questions/2509679/how-to-generate-a-random-integer-number-from-within-a-range"target="_blank" rel="external nofollow noopener noreferrer">出处<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>如何使用C语言生成随机数？例如希望生成一段特定范围的随机数，如$[1,6]$来模拟掷骰子。</p>
<blockquote>
<p>到目前为止，所有答案在数学上都是错误的。返回 <code>rand() % N</code> 并不统一给出 <code>[0, N)</code> 范围内的数字，除非 <code>N</code> 除以 <code>rand()</code> 返回的区间长度（即是 2 的幂）。此外，我们不知道 <code>rand()</code> 的模数是否独立：它们有可能是 <code>0, 1, 2, ...</code> ，这是均匀的但不是很随机。唯一似乎合理的假设是 <code>rand()</code> 给出泊松分布：任何两个相同大小的非重叠子区间均可能且独立。对于一组有限的值，这意味着均匀分布，并且还确保 <code>rand()</code> 的值很好地分散。</p>
<p>这意味着更改 <code>rand()</code> 范围的唯一正确方法是将其分为多个框；例如，如果 <code>RAND_MAX == 11</code> 并且您想要 <code>1..6</code> 的范围，则应将 <code>{0,1}</code> 分配给 1，将 <code>{2,3}</code> 分配给 2，依此类推在。这些是不相交的、大小相等的区间，因此是均匀且独立分布的。</p>
<p>使用浮点除法的建议在数学上是合理的，但原则上存在舍入问题。也许 <code>double</code> 的精度足以使其工作；也许不是。我不知道，也不想弄清楚；无论如何，答案取决于系统。</p>
<p>正确的方法是使用整数运算。也就是说，您想要如下所示的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; // For random(), RAND_MAX</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Assumes 0 &lt;= max &lt;= RAND_MAX
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns in the closed interval [0, max]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="nf">random_at_most</span><span class="p">(</span><span class="kt">long</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">long</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// max &lt;= RAND_MAX &lt; ULONG_MAX, so this is okay.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">num_bins</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">num_rand</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">bin_size</span> <span class="o">=</span> <span class="n">num_rand</span> <span class="o">/</span> <span class="n">num_bins</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">defect</span>   <span class="o">=</span> <span class="n">num_rand</span> <span class="o">%</span> <span class="n">num_bins</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">x</span> <span class="o">=</span> <span class="nf">random</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// This is carefully written not to overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">num_rand</span> <span class="o">-</span> <span class="n">defect</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Truncated division is intentional
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="n">bin_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了获得完全均匀的分布，循环是必要的。例如，如果给你 0 到 2 之间的随机数，而你只想要 0 到 1 之间的数字，你就继续拉，直到没有 2 为止；不难检查这是否以相同的概率给出 0 或 1。 这里使用 <code>random()</code> 而不是 <code>rand()</code> 因为它具有更好的分布（如 <code>rand()</code> 的手册页所述）。</p>
<p>如果你想获得默认范围 <code>[0, RAND_MAX]</code> 之外的随机值，那么你必须做一些棘手的事情。也许最方便的方法是定义一个函数 <code>random_extended()</code> 提取 <code>n</code> 位（使用 <code>random_at_most()</code> ）并返回 <code>[0, 2**n)</code> ，然后应用 <code>random_at_most()</code> 用 <code>random_extended()</code> 代替 <code>random()</code> （并用 <code>2**n - 1</code> 代替 <code>RAND_MAX</code> ）来提取随机值小于 <code>2**n</code> ，假设您有一个可以保存这样的值的数字类型。最后，当然，您可以使用 <code>min + random_at_most(max - min)</code> 获取 <code>[min, max]</code> 中的值，包括负值。</p>
</blockquote>
<p>这段代码通过以下方式确保生成的随机数在闭区间 [0, max] 内均匀分布：</p>
<ol>
<li><strong>确定随机数的范围和数量</strong>：
<ul>
<li><code>num_bins</code> 表示生成的随机数的数量，即 <code>max</code> 的值加一，因为随机数生成器的范围是左闭右开的。</li>
<li><code>num_rand</code> 表示随机数生成器的最大值加一，表示总的可能的随机数的数量。</li>
</ul>
</li>
<li><strong>计算每个区间的大小</strong>：
<ul>
<li><code>bin_size</code> 表示每个区间的大小，即将随机数的总数量除以可能的随机数的数量，以确保每个随机数的概率相等。</li>
</ul>
</li>
<li><strong>处理不能均匀分配的情况</strong>：
<ul>
<li><code>defect</code> 表示随机数总数量除以可能的随机数数量的余数，用于处理不能均匀分配的情况。</li>
</ul>
</li>
<li><strong>生成随机数并检查范围</strong>：
<ul>
<li>使用 <code>do-while</code> 循环来生成随机数，并检查生成的随机数是否在指定的范围内，如果不在范围内则重新生成，直到生成的随机数在指定范围内。</li>
</ul>
</li>
<li><strong>返回均匀分布的随机数</strong>：
<ul>
<li>将生成的随机数除以区间大小得到的结果，即在闭区间 [0, max] 内均匀分布的随机数。</li>
</ul>
</li>
</ol>
<p>通过以上步骤，代码确保了生成的随机数在指定范围内且分布均匀。</p>
]]></description></item><item><title>C++11多线程 std::thread详解</title><link>https://lruihao.cn/posts/01.c-11%E5%A4%9A%E7%BA%BF%E7%A8%8B-stdthread%E8%AF%A6%E8%A7%A3/</link><pubDate>Thu, 07 Apr 2022 21:04:13 +0000</pubDate><author>HeZephyr</author><guid>https://lruihao.cn/posts/01.c-11%E5%A4%9A%E7%BA%BF%E7%A8%8B-stdthread%E8%AF%A6%E8%A7%A3/</guid><description><![CDATA[<h2 id="前言" class="heading-element"><span>1 前言</span>
  <a href="#%e5%89%8d%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>我们知道，当程序运行起来，生成一个进程，该进程所属的主线程开始自动运行，C/C++的主线程就是main函数；当主线程从main()函数返回，则整个进程执行完毕。</p>
</blockquote>
<p>所以主线程是从main()开始执行，其中我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行。<font color="red">所以整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止（符合大部分规律，也有例外）。</font></p>
<p>我们需要明白，如果有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行。</p>
<p>在C++11以前，使用线程库特别麻烦，C++11提供了一个新标准线程库，即<code>thread</code>，意味着C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量。</p>
<h2 id="stdthread" class="heading-element"><span>2 std::thread</span>
  <a href="#stdthread" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="构造函数" class="heading-element"><span>2.1 构造函数</span>
  <a href="#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>构造函数如下，其含义分别注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">thread</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// 创建不代表线程的新线程对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">thread</span><span class="p">(</span> <span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// 移动构造函数。构造表示曾为 other 所表示的执行线程的 thread 对象。此调用后 other 不再表示执行线程。一般需要使用move方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Function</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">Args</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="kr">thread</span><span class="p">(</span> <span class="n">Function</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">);</span> <span class="c1">// 构造新的 std::thread 对象并将它与执行线程关联。新的执行线程开始执行。其中f为可调用函数对象，args为传递的函数参数，一定要相互对应。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">thread</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 复制构造函数被删除，线程不可复制。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>创建线程对象总共有以下几种方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"> </span><span class="c1">// 提供sleep函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">();</span> <span class="c1">// 不是线程，使用第一种构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 是线程，按值传递，使用第三种构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">// 是线程，按引用传递，使用第三种构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">));</span> <span class="c1">// t3现在是线程，运行sum，t2不再是线程。这是使用第二种构造方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>官网上的给的代码如下（这种种类更多，适合用来分析学习，上面列举的内容实际上就够用了）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 1 executing</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 2 executing</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">foo</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 3 executing</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">baz</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 4 executing</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">foo</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">baz</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">// t1 is not a thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// pass by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="c1">// pass by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t4</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t3</span><span class="p">));</span> <span class="c1">// t4 is now running f2(). t3 is no longer a thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t5</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span> <span class="c1">// t5 runs foo::bar() on object f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t6</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// t6 runs baz::operator() on a copy of object b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t5</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t6</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final value of n is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final value of f.n (foo::n) is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final value of b.n (baz::n) is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="观察器" class="heading-element"><span>2.2 观察器</span>
  <a href="#%e8%a7%82%e5%af%9f%e5%99%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="stdthreadjoinable" class="heading-element"><span>2.2.1 std:&#x1f9f5;:joinable</span>
  <a href="#stdthreadjoinable" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">joinable</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数用来检查this是否标识了一个活动的执行线程，即如果this标识了一个活动的执行线程，就返回true，否则返回false。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;before starting, joinable: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;after starting, joinable: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;after joining, joinable: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">before starting, joinable: false
</span></span><span class="line"><span class="cl">after starting, joinable: true
</span></span><span class="line"><span class="cl">after joining, joinable: false</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdthreadget_id" class="heading-element"><span>2.2.2 std:&#x1f9f5;:get_id</span>
  <a href="#stdthreadget_id" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>返回标识与 *this 关联的线程的 <code>std::thread::id</code> 。如果没有关联线程，则返回默认构造的<code>std::thread::id</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">t1_id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">get_id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">t2_id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">get_id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;t1&#39;s id: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">t1_id</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;t2&#39;s id: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">t2_id</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Possible output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">t1&#39;s id: 2
</span></span><span class="line"><span class="cl">t2&#39;s id: 3</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="操作" class="heading-element"><span>2.3 操作</span>
  <a href="#%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="stdthreadjoin" class="heading-element"><span>2.3.1 std:&#x1f9f5;:join</span>
  <a href="#stdthreadjoin" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">join</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>阻塞当前线程直至 <code>*this</code>所标识的线程结束其执行。<code>*this</code> 所标识的线程的完成同步于对应的从 join() 成功返回。<code>*this</code> 自身上不进行同步。同时从多个线程在同一 thread 对象上调用 join() 构成数据竞争，导致未定义行为。</p>
<p>可能引发的异常为：<code>std::system_error</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// simulate expensive operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// simulate expensive operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;starting first helper...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">helper1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;starting second helper...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">helper2</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;waiting for helpers to finish...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">helper1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">helper2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;done!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">starting first helper...
</span></span><span class="line"><span class="cl">starting second helper...
</span></span><span class="line"><span class="cl">waiting for helpers to finish...
</span></span><span class="line"><span class="cl">done!</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdthreaddetach" class="heading-element"><span>2.3.2 std:&#x1f9f5;:detach</span>
  <a href="#stdthreaddetach" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">detach</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从 thread 对象分离执行线程，允许执行独立地持续。一旦该线程退出，则释放任何分配的资源。调用 detach 后 *this 不再占有任何线程。</p>
<p>可能引发的异常为：<code>std::system_error</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">independentThread</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Starting concurrent thread.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Exiting concurrent thread.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadCaller</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Starting thread caller.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">independentThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Exiting thread caller.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadCaller</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Possible output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Starting thread caller.
</span></span><span class="line"><span class="cl">Starting concurrent thread.
</span></span><span class="line"><span class="cl">Exiting thread caller.
</span></span><span class="line"><span class="cl">Exiting concurrent thread.</span></span></code></pre></td></tr></table>
</div>
</div><p>这个示例即表明了主线程将先执行完。</p>
]]></description></item></channel></rss>