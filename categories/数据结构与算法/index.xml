<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据结构与算法 - 分类 | ZephyrHe</title><link>https://hezephyr.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>数据结构与算法 - 分类 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Sat, 01 Jun 2024 20:13:44 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>数据结构与算法 面试题目总结</title><link>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 20:13:44 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="排序算法" class="heading-element"><span>1 排序算法</span>
  <a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><table>
  <thead>
      <tr>
          <th style="text-align: center">排序算法</th>
          <th style="text-align: center">平均时间复杂度</th>
          <th style="text-align: center">最差时间复杂度</th>
          <th style="text-align: center">空间复杂度</th>
          <th style="text-align: center">数据对象稳定性</th>
          <th style="text-align: center">算法基本思路</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">冒泡排序</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">反复交换相邻逆序的元素，直到没有逆序对</td>
      </tr>
      <tr>
          <td style="text-align: center">选择排序</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">数组不稳定、链表稳定</td>
          <td style="text-align: center">反复选择未排序部分中的最小（大）元素，放在已排序部分的末尾</td>
      </tr>
      <tr>
          <td style="text-align: center">插入排序</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">逐一选择未排序元素，将其插入到已排序部分的正确位置</td>
      </tr>
      <tr>
          <td style="text-align: center">快速排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(\log_2 n)$$</td>
          <td style="text-align: center">不稳定</td>
          <td style="text-align: center">选择基准，将数组分为小于和大于基准的两部分，递归排序</td>
      </tr>
      <tr>
          <td style="text-align: center">堆排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">不稳定</td>
          <td style="text-align: center">构建最大（小）堆，将堆顶元素与末尾元素交换，调整堆</td>
      </tr>
      <tr>
          <td style="text-align: center">归并排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">递归地将数组分为两部分，分别排序后合并</td>
      </tr>
      <tr>
          <td style="text-align: center">希尔排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">不稳定</td>
          <td style="text-align: center">分组进行插入排序，逐渐减少间隔，直到间隔为1</td>
      </tr>
      <tr>
          <td style="text-align: center">计数排序</td>
          <td style="text-align: center">$$O(n + m)$$</td>
          <td style="text-align: center">$$O(n + m)$$</td>
          <td style="text-align: center">$$O(n + m)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">统计每个元素的出现次数，根据计数对元素进行排序</td>
      </tr>
      <tr>
          <td style="text-align: center">桶排序</td>
          <td style="text-align: center">$$O(n)$$</td>
          <td style="text-align: center">$$O(n)$$</td>
          <td style="text-align: center">$$O(m)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">将元素分配到不同的桶中，分别排序后合并</td>
      </tr>
      <tr>
          <td style="text-align: center">基数排序</td>
          <td style="text-align: center">$$O(k \cdot n)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">取决于实现</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">逐位排序，从最低有效位到最高有效位进行</td>
      </tr>
  </tbody>
</table>
<h2 id="栈与队列的区别" class="heading-element"><span>2 栈与队列的区别</span>
  <a href="#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；</li>
<li>栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。</li>
<li>队列先进先出，栈先进后出。</li>
<li>栈只能在表尾插入删除，队列在表尾插入表头删除。</li>
<li>应用场景不同：
<ul>
<li>栈：括号问题的求解等</li>
<li>队列：计算机系统中各种资源的管理等。</li>
</ul>
</li>
<li>遍历速度不同：
<ul>
<li>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快；</li>
<li>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</li>
</ul>
</li>
</ul>
<h2 id="两个栈实现一个队列" class="heading-element"><span>3 两个栈实现一个队列</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e9%98%9f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个栈来实现一个队列，可以有效地利用栈的特性（后进先出）来模拟队列的特性（先进先出）。我们可以使用两个栈来分离入队和出队操作，具体实现步骤如下：</p>
<ul>
<li><strong>栈1</strong>（<code>stack1</code>）用于处理入队操作。</li>
<li><strong>栈2</strong>（<code>stack2</code>）用于处理出队操作。</li>
</ul>
<ol>
<li>入队列：直接压入元素至<code>stack1</code>即可</li>
<li>出队列：如果<code>stack2</code>不为空，把<code>stack2</code>中的栈顶元素直接弹出。否则，把<code>stack1</code>的所有元素全部弹出压入<code>stack2</code>中，再弹出<code>stack2</code>的栈顶元素</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stack1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack1</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Queue is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="两个队列实现栈" class="heading-element"><span>4 两个队列实现栈</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个队列来实现一个栈，可以利用队列的特性（先进先出）来模拟栈的特性（后进先出）。我们可以使用两个队列来分离入栈和出栈操作，具体实现步骤如下：</p>
<ul>
<li><strong>队列1</strong>（<code>queue1</code>）用于存储元素。</li>
<li><strong>队列2</strong>（<code>queue2</code>）作为辅助队列用于操作元素。</li>
</ul>
<ol>
<li><strong>入栈操作</strong>：将元素直接入队到<code>queue1</code>中。</li>
<li><strong>出栈操作</strong>：
<ul>
<li>将<code>queue1</code>中的所有元素（除了最后一个）逐个出队并入队到<code>queue2</code>中。</li>
<li>最后一个元素是栈顶元素，将其出队。</li>
<li>交换<code>queue1</code>和<code>queue2</code>，以保持<code>queue1</code>始终为主队列。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Stack is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="链表与数组的区别" class="heading-element"><span>5 链表与数组的区别</span>
  <a href="#%e9%93%be%e8%a1%a8%e4%b8%8e%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>数组静态分配内存，链表动态分配内存；。</li>
</ul>
<ul>
<li>数组在内存中连续，链表不连续。</li>
<li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)。</li>
<li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li>
<li><font color="red">数组元素在栈区，链表元素在堆区</font>。</li>
</ul>
<h2 id="什么是堆" class="heading-element"><span>6 什么是堆？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p>
<p><strong>最大堆的根结点中的元素在整个堆中是最大的；</strong></p>
<p><strong>最小堆的根结点中的元素在整个堆中是最小的。</strong></p>
<h2 id="什么是二叉排序树" class="heading-element"><span>7 什么是二叉排序树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ol>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<h2 id="什么是平衡二叉树" class="heading-element"><span>8 什么是平衡二叉树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p><font color="red">平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进</font>。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。</p>
<p>旋转是平衡二叉树维护平衡性的核心操作，包括以下几种：</p>
<ul>
<li>单右旋转（Right Rotation）：用于修复左子树过高的情况。</li>
<li>单左旋转（Left Rotation）：用于修复右子树过高的情况。</li>
<li>双旋转（Double Rotation）：包括先左后右旋转和先右后左旋转，用于修复特定的不平衡情况。</li>
</ul>
<h2 id="什么是b树" class="heading-element"><span>9 什么是B树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%afb%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>B树是一种自平衡的多路查找树，其中每个节点可以有多个子节点和多个键。B树具有以下特性：</p>
<ul>
<li><strong>节点包含多个键和子节点</strong>：每个节点可以存储多个键和子节点。节点中的键按照递增顺序存储。</li>
<li><strong>根节点至少有两个子节点</strong>（如果不是叶节点）。</li>
<li><strong>内部节点的子节点数受限</strong>：一个内部节点至少有$$[m/2]$$个子节点，最多有 $$m$$个子节点（这里的$m$是B树的阶）。</li>
<li><strong>所有叶子节点处于同一层</strong>：B树的所有叶子节点都在同一层，保证树的平衡性。</li>
</ul>
<p>B树的性质如下：</p>
<ul>
<li><strong>平衡性</strong>：B树是自平衡的，所有叶子节点处在同一层，树的高度通常较小，因而能够保证较快的搜索、插入和删除操作。</li>
<li><strong>高效的磁盘I/O操作</strong>：由于节点可以包含多个键和子节点，B树通常用于磁盘存储中，减少磁盘I/O操作的次数。</li>
<li><strong>时间复杂度</strong>：搜索、插入和删除操作的时间复杂度均为$O(\log n)$，其中$n$是树中的键的总数。</li>
</ul>
<p>B树的操作如下：</p>
<ul>
<li><strong>搜索</strong>：从根节点开始，根据当前节点中的键范围，递归或迭代地选择相应的子节点进行搜索，直到找到目标键或到达叶子节点。</li>
<li>插入：
<ul>
<li>在叶子节点插入新键。</li>
<li>如果叶子节点已满，则进行分裂操作，将中间键提升到父节点，并将叶子节点分裂为两个节点。</li>
<li>如果父节点也满，则递归进行分裂，直到树根。</li>
</ul>
</li>
<li>删除：
<ul>
<li>从树中删除键。</li>
<li>如果删除键导致节点下溢（键数少于$[m/2]$），则进行合并或借用操作，以保持B树的平衡性。</li>
</ul>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small" data-sub-html="<h2>clip_image020</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png" alt="clip_image020" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large 2x" data-title="clip_image020" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="trie-树" class="heading-element"><span>10 Trie 树</span>
  <a href="#trie-%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/trie1.png" alt="字典树(Trie) - OI Wiki" style="zoom:50%;" />
<h2 id="b树" class="heading-element"><span>11 B+树</span>
  <a href="#b%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">B+树通常用于数据库和操作系统的文件系统中</font>，B+树的结构如下：</p>
<ul>
<li><strong>根节点（Root Node）</strong>：B+树的根节点可以是叶子节点，也可以是内部节点。</li>
<li><strong>内部节点（Internal Nodes）</strong>：存储键值用于导航，不存储实际数据。每个内部节点包含若干个键和指向子节点的指针。</li>
<li><strong>叶子节点（Leaf Nodes）</strong>：存储所有的实际数据，并且包含指向相邻叶子节点的指针，形成一个双向链表。</li>
</ul>
<p>B+树的性质：</p>
<ul>
<li><strong>有序性</strong>：所有键按升序排列。</li>
<li><strong>平衡性</strong>：树的所有叶子节点处于同一层级，保证了平衡性。</li>
<li><strong>多路性</strong>：每个节点可以有多个子节点，具体数量由树的阶（order）决定。</li>
</ul>
<p>B+树的操作：</p>
<ul>
<li><strong>查找（Search）</strong>：从根节点开始，依次比较键值，沿着指向子节点的指针递归查找，直到找到目标叶子节点。</li>
<li><strong>插入（Insert）</strong>：将新键插入适当的叶子节点，如果叶子节点满了，则分裂叶子节点并将中间键上移到父节点，递归进行分裂直到树恢复平衡。</li>
<li><strong>删除（Delete）</strong>：从叶子节点删除键，如果删除导致节点键数目不足，则进行节点合并或键重新分配，直到树恢复平衡。</li>
</ul>
<p>B+树的优点：</p>
<ul>
<li><strong>高效的范围查询</strong>：由于所有数据都存储在叶子节点中，并且叶子节点形成双向链表，B+树能够高效地进行范围查询（range query）。</li>
<li><strong>高存储利用率</strong>：内部节点只存储键，数据存储在叶子节点中，节点分裂和合并更加高效。</li>
<li><strong>低树高（Tree Height）</strong>：B+树的多路性使得其树高较低，查找、插入和删除操作的时间复杂度为$O(\log_mn$，其中$m$为树的阶。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small" data-sub-html="<h2>ds-bplus-tree2</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg" alt="ds-bplus-tree2" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large 2x" data-title="ds-bplus-tree2" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是红黑树" class="heading-element"><span>12 什么是红黑树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%a2%e9%bb%91%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>红黑树（为了解决平衡树在插入、删除等操作需要频繁调整的情况）是一种自平衡的二叉查找树（BST），广泛用于计算机科学中实现高效的数据存储和检索。它通过在每个节点上附加一个颜色属性（红或黑）来保持树的平衡，从而确保树的高度在对数级别，提供较好的时间复杂度性能。</p>
<p>红黑树的性质：</p>
<ol>
<li><strong>每个结点不是红色就是黑色；</strong></li>
<li><strong>根节点是黑色的</strong>；</li>
<li><strong>叶子节点（NIL节点）是黑色</strong>：红黑树中的叶子节点，即树尾端的所有NULL节点，都是黑色的。</li>
<li><strong>红色节点的父节点和子节点必须是黑色的，即不能有两个连续的红色节点。</strong></li>
<li><strong>从任一节点到其每个叶子的所有路径包含相同数量的黑色节点</strong>：这保证了没有一条路径会比其他路径长出太多，从而确保了树的平衡。</li>
</ol>
<p>红黑树的操作：红黑树的操作包括插入、删除和查找，基本的操作步骤与普通的二叉查找树类似，但在维护平衡性方面有所不同。</p>
<ol>
<li>
<p>插入操作</p>
<ol>
<li>
<p><strong>普通BST插入</strong>：按二叉查找树的插入规则，将新节点插入适当位置。</p>
</li>
<li>
<p><strong>节点染色为红色</strong>：新插入的节点初始为红色。</p>
</li>
<li>
<p><strong>调整平衡</strong>：通过旋转和重新染色来保持红黑树的性质。</p>
<ul>
<li>
<p><strong>情况1：插入节点的父节点是黑色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：插入节点的父节点是红色</strong>：根据叔节点的颜色，有不同的调整方法，包括重新染色和旋转。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>删除操作</p>
<ol>
<li>
<p><strong>普通BST删除</strong>：按二叉查找树的删除规则，找到并删除节点。</p>
</li>
<li>
<p><strong>调整平衡</strong>：删除节点后可能破坏红黑树的性质，需要通过旋转和重新染色来恢复平衡。</p>
<ul>
<li>
<p><strong>情况1：删除节点是红色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：删除节点是黑色</strong>：通过双重黑色节点的概念和调整，包括重新染色和旋转，来恢复红黑树的平衡。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>红黑树的优点：</p>
<ul>
<li><strong>自平衡</strong>：通过颜色属性和旋转操作，红黑树可以保持平衡，确保基本操作的时间复杂度为$$O(\log n)$$。</li>
<li><strong>高效查找</strong>：由于平衡性，红黑树在最坏情况下的高度为$$2\log(n+1)$$，保证了查找操作的高效性。</li>
<li><strong>高效插入和删除</strong>：插入和删除操作在进行平衡调整时，旋转和重新染色的成本较低，确保了高效性。</li>
</ul>
<p>红黑树广泛应用于许多计算机系统和软件中，包括：</p>
<ul>
<li><strong>关联容器</strong>：C++的STL中的map和set，Java的TreeMap和TreeSet都基于红黑树实现。</li>
<li><strong>内存管理</strong>：Linux内核中的内存管理使用红黑树来管理空闲内存块。</li>
<li><strong>数据库索引</strong>：一些数据库系统使用红黑树作为索引结构，实现高效的数据检索。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是哈希表哈希表的实现方式怎么避免哈希冲突" class="heading-element"><span>13 什么是哈希表？哈希表的实现方式？怎么避免哈希冲突</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%93%88%e5%b8%8c%e8%a1%a8%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e6%80%8e%e4%b9%88%e9%81%bf%e5%85%8d%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>哈希表（Hash Table，也叫散列表），是根据键值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把键值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<p>哈希函数也称为散列函数，它接受一个键作为输入，并将其映射到哈希表的一个位置上。理想的哈希函数应该能够将键均匀地分布到哈希表的不同位置上，同时具有良好的计算效率。常见的哈希函数包括取余法、乘法哈希法、MD5、SHA等。选择合适的哈希函数取决于应用场景和性能要求。</p>
<p>当两个不同的键经过哈希函数映射后得到相同的位置时，就会发生哈希冲突。为了解决这个问题，常见的冲突解决方法包括：</p>
<ol>
<li><strong>开放定址法（Open Addressing）</strong>：当发生冲突时，顺序地查找下一个可用的位置，直到找到一个空槽位。常见的开放定址法包括线性探测、二次探测、双重哈希等。</li>
<li><strong>链地址法（Chaining）</strong>（最常用）：将哈希表的每个槽位都连接一个链表（或其他数据结构），当发生冲突时，将冲突的元素插入到对应位置的链表中。这样，相同哈希值的元素都存储在同一个链表中。</li>
<li><strong>再哈希法（Rehashing）</strong>：使用另一个哈希函数计算新的哈希值，然后再次查找空槽位。这样可以减少冲突的概率，提高哈希表的性能。</li>
<li><strong>建立公共溢出区</strong>：将哈希表的一部分空间作为溢出区，当发生冲突时，将冲突的元素存储在溢出区中。这样，哈希表的主要部分仍然保持较低的负载因子，提高了性能。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small" data-sub-html="<h2>image-20240601201150022</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png" alt="image-20240601201150022" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large 2x" data-title="image-20240601201150022" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>状压DP学习总结+经典例题精解</title><link>https://hezephyr.github.io/posts/02.%E7%8A%B6%E5%8E%8Bdp/</link><pubDate>Mon, 31 May 2021 21:34:31 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E7%8A%B6%E5%8E%8Bdp/</guid><description><![CDATA[<h2 id="前言" class="heading-element"><span>1 前言</span>
  <a href="#%e5%89%8d%e8%a8%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>学了这么久，说真的，动态规划是一个特别难的领域，而状压$DP$我感觉是其中一个比较难的分支，其中的状态定义、状态转移、状态计算都是难点。如果要完全搞懂状压$DP$是需要花很多时间去吸收去实践的，所以建议读者多刷$DP$题。同时，学习本文的先修知识为二进制位运算操作、基础动态规划和动态规划的分析。这里指路一篇二进制讲解$blog$:<a href="https://unique-pure.github.io/pages/41f1cd/"target="_blank" rel="external nofollow noopener noreferrer">点这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
</blockquote>
<h2 id="状态压缩" class="heading-element"><span>2 状态压缩</span>
  <a href="#%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们知道状态压缩，顾名思义，<font color="red">就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。</font> 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有$0$和$1$，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。</p>
<p>那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如$00001001$这个状态则表示第一个点和第四个点状态为$1$，其余的点状态为$0$。所以按照这种思想，我们能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。</p>
<p>知道了这个，我们就按照正常动态规划的思想去写这类题目即可。</p>
<h2 id="使用场景" class="heading-element"><span>3 使用场景</span>
  <a href="#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>由上我们知道，状态压缩其实是有适用环境的：</p>
<ol>
<li><strong>状态需要有一定的状态单元。</strong> 即一个状态应该是保存一个集合，其中的元素值对应着$0$或$1$，例如我们常见的棋盘，我们可以用$0$或$1$来表示棋子的放置状态。而整个集合即是一个$01$串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二进制，再将二进制转化为十进制。</li>
<li><strong>题目中限制的集合大小不会超过$20$。</strong> 这是最显著的特征，为什么呢？我们知道如果用二进制表示状态，那么集合大小为$20$的二进制状态有$2^{20} - 1$，已经达到$1e7$的数量级了。</li>
<li><strong>具有动态规划的特性。</strong> 对于动态规划，一般都是要求最优化某个值，具有最优子结构的性质。同时也需要满足状态转移的特性，而不是前一个状态毫无关系的。</li>
</ol>
<h2 id="常用模板" class="heading-element"><span>4 常用模板</span>
  <a href="#%e5%b8%b8%e7%94%a8%e6%a8%a1%e6%9d%bf" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>下面的模板适用于大多数题目，特殊题目需要灵活变动，总之，多刷题自然就都会了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span><span class="c1">//总状态数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//枚举已有的集合数。按照状态转移的顺序，一般从小编号到大编号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//枚举当前集合中的状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//判断当前集合是否处于合法状态，通常我们需用一个数组提前处理好。如g数组;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="err">当前状态是否合格</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//枚举上一个集合的状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="err">上一个集合的状态是否合格</span> <span class="o">+</span> <span class="err">上一个集合的状态和当前状态的集合是否产生了冲突</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                        <span class="err">列写状态转移方程。</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="经典例题" class="heading-element"><span>5 经典例题</span>
  <a href="#%e7%bb%8f%e5%85%b8%e4%be%8b%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="51-usaco06nov-corn-fields-ghttpswwwluogucomcnproblemp1879" class="heading-element"><span>5.1 <a href="https://www.luogu.com.cn/problem/P1879"target="_blank" rel="external nofollow noopener noreferrer">5.1 USACO06NOV Corn Fields G<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#51-usaco06nov-corn-fields-ghttpswwwluogucomcnproblemp1879" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p>
<p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p>
<p>John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p>
<p><strong>输入格式</strong></p>
<p>第一行：两个整数M和N，用空格隔开。</p>
<p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，即牧场分配总方案数除以100,000,000的余数。</p>
<p><strong>输入</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">2 3
</span></span><span class="line"><span class="cl">1 1 1
</span></span><span class="line"><span class="cl">0 1 0</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">9</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>我们先作出规定，定义$n$代表的是行，$m$代表的是列。那么牧场大小就是$n\times m$。我们看到数据范围,$n,m$都特别小，同时所求为方案数，这很符合状压DP的适用条件。<font color="red">那么对于每一行，我们就可以看成一个未知集合，而集合的大小自然就是列$m$。对于每一个单元，其取值范围为$0,1$，而$1$代表放置奶牛，$0$代表不放置奶牛，所以我们自然可以用二进制表示，那么状态总数就是$(1 &laquo; m) - 1$。</font> 对于每一个状态，我们需要判断是否合格，而其中明确不能选择两块相邻的土地，在集合内，即相邻位不能全为$1$，所以我们可以预处理$g$数组，处理方式即为:<code>g[i] = !(i &amp; (i &lt;&lt; 1))</code>；同样，我们还应该知晓土地的状况，因为毕竟只有土地肥沃才可以放置奶牛，则我们可以通过一个$st$数组判断，集合与集合之间，我们也需要考虑相邻位不能全为$1$，所以在枚举上一个集合的状态也需要严格判断。对于状态定义，我们可以用$f[i][j]$表示第$i$行且状态为$j$的方案数。对于状态转移，假设上一行状态为$k$，则状态转移方程为：</p>
<p>$f[i][j] += f[i - 1][k]$</p>
<p>具体见$AC$代码。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:Corn Field G
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-28 16:50
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span><span class="n">M</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1e8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span><span class="c1">//n行m列的土地。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">],</span><span class="n">st</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="c1">//a代表土地，st代表每一行的土地状况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">];</span><span class="c1">//g得到所有状态中的合法状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">];</span><span class="c1">//f[i][j]表示的则是第i行且状态为j的方案数，是由上一行转移过来的，所以我们定义上一行的状态为k。
</span></span></span><span class="line"><span class="cl"><span class="c1">//则状态转移方程为f[i][j] += f[i - 1][k];//其中j和k必须满足条件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//得到每一行的土地状况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//得到所有状态中的合法状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">;</span><span class="c1">//总状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//初始化，这种也算一种。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span><span class="c1">//由于不能相邻，所以我们左移判断是否符合条件。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//枚举每一行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//枚举每一行的状态，判断此状态是否符合条件。1.不能相邻。2.是全部状态的子集。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//如果符合条件。则我们去判断上一行是否符合。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//枚举上一行状态。注意，这里我们无需判断上一行状态是否存在，因为不存在即为0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">//只需要判断j和k是否存在相邻草地。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="n">k</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="52-吃奶酪luogucomcnproblemp1433" class="heading-element"><span>5.2 <a href="luogu.com.cn/problem/P1433">5.2 吃奶酪</a></span>
  <a href="#52-%e5%90%83%e5%a5%b6%e9%85%aaluogucomcnproblemp1433" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>房间里放着$n$块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$点处。</p>
<p><strong>输入格式</strong></p>
<p>第一行有一个整数，表示奶酪的数量 n。</p>
<p>第 22 到第 (n + 1)行，每行两个实数，第 $(i + 1)$行的实数分别表示第 $i$ 块奶酪的横纵坐标 $x_i, y_i$。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个实数，表示要跑的最少距离，保留 2位小数。</p>
<p><strong>输入 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">4
</span></span><span class="line"><span class="cl">1 1
</span></span><span class="line"><span class="cl">1 -1
</span></span><span class="line"><span class="cl">-1 1
</span></span><span class="line"><span class="cl">-1 -1</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">7.41</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>数据规模与约定</strong></p>
<p>对于全部的测试点，保证 $1\leq n\leq 15，|x_i|, |y_i| \leq 200$，小数点后最多有 3位数字。</p>
<p><strong>提示</strong></p>
<p>对于两个点$$ (x_1,y_1)，(x_2, y_2)$$，两点之间的距离公式为$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>同样，根据数据量等信息我们很容易发现这是一个状压$DP$。奶酪的状态无非两种$0,1$，而根据题意我们的集合数量只有$1$个，集合大小自然是奶酪的数量，而奶酪有$n$个，所以我们的集合情况也有$(1 &laquo; n)-1$种，同样在此题我们需要先初始化好奶酪的合法状态，用$g$数组表示，更严格的说，$g[i]$表示第$i$个奶酪所在的二进制中的位置，用十进制数表示 。由于我们还需要计算距离，所以我们需要将每个点之间的距离也求出来，用$dist$数组预处理奶酪之间的距离以及起点与各个奶酪的距离。 <font color="red">那么在状态定义上，我们可以用$f[i][j]$表示当前为$i$状态，且处于第$j$个奶酪的最小距离，故状态转移方程易知为：</font></p>
<p><font color="red">$f[i][j]=min(f[i][j],f[i-g[j]][k]+dist[k][j])$</font></p>
<p>据此，题目可解，具体看代码。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:吃奶酪
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-30 14:20
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define x first 
</span></span></span><span class="line"><span class="cl"><span class="cp">#define y second
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">pdd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">pdd</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">dist</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="c1">//dist[i][j]表示第i个奶酪到第j个奶酪的距离。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">];</span><span class="c1">//奶酪的状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="c1">//f[i][j]表示当前为i状态，且处于第j个奶酪的最小距离。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pdd</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">get</span><span class="p">(</span><span class="n">pdd</span> <span class="n">a</span><span class="p">,</span><span class="n">pdd</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//先计算距离。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">st</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">st</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">st</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化奶酪的状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化最大值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fill</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="mh">0x3f3f3f3f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//确定只吃了一个奶酪的距离。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//最开始自然为0，0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span> <span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//枚举所有状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//该状态如果包含此奶酪就跳过。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//说明符合条件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span><span class="c1">//进行状态转移。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">maxx</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">maxx</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span><span class="n">f</span><span class="p">[</span><span class="n">maxn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%.2lf</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">maxx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%lf%lf&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="53--usaco13nov-no-change-ghttpswwwluogucomcnproblemp3092" class="heading-element"><span>5.3 <a href="https://www.luogu.com.cn/problem/P3092"target="_blank" rel="external nofollow noopener noreferrer">5.3  USACO13NOV No Change G<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#53--usaco13nov-no-change-ghttpswwwluogucomcnproblemp3092" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>约翰到商场购物，他的钱包里有K(1 &lt;= K &lt;= 16)个硬币，面值的范围是1..100,000,000。</p>
<p>约翰想按顺序买 N个物品(1 &lt;= N &lt;= 100,000)，第i个物品需要花费c(i)块钱，(1 &lt;= c(i) &lt;= 10,000)。</p>
<p>在依次进行的购买N个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。</p>
<p>请计算出在购买完N个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1</p>
<p><strong>输入格式</strong></p>
<p>*Line 1: Two integers, K and N.</p>
<p>* Lines 2..1+K: Each line contains the amount of money of one of FJ&rsquo;s coins.</p>
<p>* Lines 2+K..1+N+K: These N lines contain the costs of FJ&rsquo;s intended purchases.</p>
<p><strong>输出格式</strong></p>
<p>* Line 1: The maximum amount of money FJ can end up with, or -1 if FJ cannot complete all of his purchases.</p>
<p><strong>输入 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">3 6 
</span></span><span class="line"><span class="cl">12 
</span></span><span class="line"><span class="cl">15 
</span></span><span class="line"><span class="cl">10 
</span></span><span class="line"><span class="cl">6 
</span></span><span class="line"><span class="cl">3 
</span></span><span class="line"><span class="cl">3 
</span></span><span class="line"><span class="cl">2 
</span></span><span class="line"><span class="cl">3 
</span></span><span class="line"><span class="cl">7 </span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">12 </span></span></code></pre></td></tr></table>
</div>
</div><p>说明/提示</p>
<p>FJ has 3 coins of values 12, 15, and 10. He must make purchases in sequence of value 6, 3, 3, 2, 3, and 7.</p>
<p>FJ spends his 10-unit coin on the first two purchases, then the 15-unit coin on the remaining purchases. This leaves him with the 12-unit coin.</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>此题状态定义比较简单，因为实际上我们只在乎了硬币的花费，这已经是一个集合了，花费为$1$不花费为$0$，而其他并不用在乎。所以我们完全可以用$f[i]$表示在$i$状态下能够购买的最大物品数。此题难点在于状态转移。同样在此题我们需要先初始化好硬币的合法状态，用$g$数组表示，更严格的说，$g[i]$表示第$i$个硬币所在的二进制中的位置。用十进制数表示。为了方便处理，我们需要用前缀和来优化本题，因为在处理过程中我们随时都要计算当前已有的总价值能够换取多少物品。 <font color="red">同样，在状态转移方面，我们需要根据前面的状态得到后者的状态，而由于我们是从小到大枚举状态的，故一定可以利用前面的状态而不会出现前面状态不是最优解，我们对于每一种状态，我们可以排除一个硬币获取前面的最优解，即枚举该状态已有的硬币，通过异或排除，最后利用二分查找所能购买的最大值得到最优解。</font> 说起来有点乱，详情可见$AC$代码。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:No_Change_G
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-28 17:14
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">g</span><span class="p">[</span><span class="n">K</span><span class="p">];</span><span class="c1">//每个硬币的状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">w</span><span class="p">[</span><span class="n">K</span><span class="p">];</span><span class="c1">//硬币的价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="c1">//物品价值的前缀和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">K</span><span class="p">];</span><span class="c1">//f[i]表示在i状态下能够购买的最大物品数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化硬币状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">;</span><span class="c1">//得到
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//枚举每一种状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//枚举所有的硬币。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//说明该硬币在当前状态使用过。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">int</span> <span class="n">te</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span><span class="c1">//获取该状态不使用j能获得的物品数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">te</span> <span class="o">=</span> <span class="n">upper_bound</span><span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">sum</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">sum</span><span class="p">[</span><span class="n">te</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="n">sum</span><span class="p">;</span><span class="c1">//这里需要减1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">te</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">maxx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//说明该状态能够将所有物品都买完。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">temp</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxx</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span><span class="n">ans</span> <span class="o">-</span> <span class="n">temp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">maxx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">maxx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//求硬币总价值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="54-scoi2005互不侵犯httpswwwluogucomcnproblemp1896" class="heading-element"><span>5.4 <a href="https://www.luogu.com.cn/problem/P1896"target="_blank" rel="external nofollow noopener noreferrer">5.4 SCOI2005互不侵犯<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#54-scoi2005%e4%ba%92%e4%b8%8d%e4%be%b5%e7%8a%afhttpswwwluogucomcnproblemp1896" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p>
<p><strong>输入格式</strong></p>
<p>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</p>
<p><strong>输出格式</strong></p>
<p>所得的方案数</p>
<p><strong>输入 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">3 2</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">16</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>这道题跟$5.1$例题有点相似，只不过这里多了左上左下右上右下这几个点，处理方法一样，我们需要知道每个状态的放置国王数，所以这我们需要预处理。定义状态$f[i][j][k]$表示在第$i$行且处于$j$状态时已经放置了$k$个国王。其他的处理方式和$5.1$相同，这里不作叙述，可见$AC$代码。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:互不侵犯
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-31 16:32
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">tot</span><span class="p">,</span><span class="n">num</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">];</span><span class="c1">//num[i]表示第i种可行状态的国王所放数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ll</span> <span class="n">f</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">][</span><span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">];</span><span class="c1">//f[i][j][k]表示前i行，当前处于j状态且已经放置了k个国王。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取该状态有多少国王。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span><span class="k">continue</span><span class="p">;</span><span class="c1">//说明存在相邻的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//枚举所有状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//枚举上一行的所有状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(((</span><span class="n">k</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="n">k</span> <span class="o">||</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)))){</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">cnt</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span> <span class="n">cnt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">cnt</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span>  <span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>位运算全面总结</title><link>https://hezephyr.github.io/posts/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 28 May 2021 13:12:04 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</guid><description><![CDATA[<h2 id="位运算概述" class="heading-element"><span>1 位运算概述</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们知道，<font color="red">计算机中的数在内存中都是以二进制形式进行存储的</font> ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/35c5fd04622d42e28a82695a72876c0f.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/35c5fd04622d42e28a82695a72876c0f.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/35c5fd04622d42e28a82695a72876c0f.png" alt="img" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/35c5fd04622d42e28a82695a72876c0f.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/35c5fd04622d42e28a82695a72876c0f.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/35c5fd04622d42e28a82695a72876c0f.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>那么，涉及位运算的运算符如下表所示：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">符号</th>
          <th style="text-align: center">描述</th>
          <th style="text-align: center">运算规则</th>
          <th style="text-align: center">实例（以四位二进制数为例）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">&amp;</td>
          <td style="text-align: center">与</td>
          <td style="text-align: center">两个位都为1时，结果才为1。</td>
          <td style="text-align: center">$0001&amp;0001=1,0001&amp;0000=0,0000&amp;0000=0000$</td>
      </tr>
      <tr>
          <td style="text-align: center">|</td>
          <td style="text-align: center">或</td>
          <td style="text-align: center">两个位都为0时，结果才为0。</td>
          <td style="text-align: center">$0001|0001=0001,0001|0000=0001,0000|0000=0000$</td>
      </tr>
      <tr>
          <td style="text-align: center">^</td>
          <td style="text-align: center">异或</td>
          <td style="text-align: center">两个位相同为0，相异为1。</td>
          <td style="text-align: center">$0001 \wedge0001=0000,0001\wedge0000=1,0000\wedge 0000=0$</td>
      </tr>
      <tr>
          <td style="text-align: center">~</td>
          <td style="text-align: center">取反</td>
          <td style="text-align: center">0变1，1变0。</td>
          <td style="text-align: center">$\sim0=1,\sim 1 = 0$</td>
      </tr>
      <tr>
          <td style="text-align: center">&laquo;</td>
          <td style="text-align: center">左移</td>
          <td style="text-align: center">各二进位全部左移若干位，高位丢弃，低位补0。</td>
          <td style="text-align: center">$0001&laquo;k=0100，k=2$，$k$是左移的位数，这里$k=2$</td>
      </tr>
      <tr>
          <td style="text-align: center">&raquo;</td>
          <td style="text-align: center">右移</td>
          <td style="text-align: center">各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补$1$。</td>
          <td style="text-align: center">$0100&raquo;k=0001，k=2$，$k$是右移的位数，这里$k=2$</td>
      </tr>
  </tbody>
</table>
<p>看完，你可能会觉得挺简单的， <font color="red">但位运算的难点并不在这，而在于其性质、高级操作和它的应用</font>。</p>
<h2 id="位运算的性质" class="heading-element"><span>2 位运算的性质</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9a%84%e6%80%a7%e8%b4%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="运算符的优先级" class="heading-element"><span>2.1 运算符的优先级</span>
  <a href="#%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>优先级需要弄清楚，如果不太清楚可以加小括号确保是想要的运算顺序，<font color="red">这里只是相对优先级，即只是和一些常用的算术运算符做比较。</font></p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">优先级</th>
          <th style="text-align: center">运算符</th>
          <th style="text-align: center">结合方向</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">1</td>
          <td style="text-align: center">$-（符号运算符）,\sim（取反运算符）， ++（自增），&ndash;（自减）$</td>
          <td style="text-align: center">从右到左</td>
      </tr>
      <tr>
          <td style="text-align: center">2</td>
          <td style="text-align: center">$*（乘）,/（除）,%（取余）$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">3</td>
          <td style="text-align: center">$+（加）,-（减）$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">4</td>
          <td style="text-align: center">$&laquo;（左移），&raquo;（右移）$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">5</td>
          <td style="text-align: center">$&gt;（大于）,&lt;(小于),&gt;=(大于等于),&lt;=(小于等于)$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">6</td>
          <td style="text-align: center">$==(等于),!=（不等于）$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">7</td>
          <td style="text-align: center">$&amp;（按位与）$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">8</td>
          <td style="text-align: center">$\wedge (按位异或)$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
      <tr>
          <td style="text-align: center">9</td>
          <td style="text-align: center">$|(按位或)$</td>
          <td style="text-align: center">从左到右</td>
      </tr>
  </tbody>
</table>
<h3 id="位运算符的运算律" class="heading-element"><span>2.2 位运算符的运算律</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
  <thead>
      <tr>
          <th style="text-align: center">公式名称</th>
          <th style="text-align: center">运算规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">交换律</td>
          <td style="text-align: center">$A&amp;B=B&amp;A ,A\wedge B=B\wedgeA$</td>
      </tr>
      <tr>
          <td style="text-align: center">结合律（注意结合律只能在同符号下进行）</td>
          <td style="text-align: center">$(A&amp;B)&amp;C=A&amp;(B&amp;C)$</td>
      </tr>
      <tr>
          <td style="text-align: center">等幂律</td>
          <td style="text-align: center">$A&amp;A=A，A|A=A$</td>
      </tr>
      <tr>
          <td style="text-align: center">零律</td>
          <td style="text-align: center">$A&amp;0=0$</td>
      </tr>
      <tr>
          <td style="text-align: center">互补律（注意，这不同于逻辑运算）</td>
          <td style="text-align: center">$A&amp;\sim A=0, A|\sim A=-1$</td>
      </tr>
      <tr>
          <td style="text-align: center">同一律</td>
          <td style="text-align: center">$A|0=A, A\wedge 0 =A$</td>
      </tr>
  </tbody>
</table>
<p>以上仅为已证明的运算律（可能存在遗漏），其余的博主均认为是不符合不成立的，<font color="red">注意：千万不要将逻辑运算的运算律或者其他的运算律与这混为一谈。</font></p>
<h2 id="位运算高级操作" class="heading-element"><span>3 位运算高级操作</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e9%ab%98%e7%ba%a7%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如下表，请读者认真阅读理解，在阅读的过程中可以对示例进行运算。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">功能</th>
          <th style="text-align: center">示例</th>
          <th style="text-align: center">位运算</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">去掉最后一位</td>
          <td style="text-align: center">$0100-&gt;0010$</td>
          <td style="text-align: center">$x&raquo;1$</td>
      </tr>
      <tr>
          <td style="text-align: center">在最后加一个$0$</td>
          <td style="text-align: center">$0100-&gt;1000$</td>
          <td style="text-align: center">$x&laquo;1$</td>
      </tr>
      <tr>
          <td style="text-align: center">在最后加一个1</td>
          <td style="text-align: center">$0100-&gt;1001$</td>
          <td style="text-align: center">$(x&laquo;1)+1$</td>
      </tr>
      <tr>
          <td style="text-align: center">将最后一位变为$1$</td>
          <td style="text-align: center">$0100-&gt;0101$</td>
          <td style="text-align: center">$x|1$</td>
      </tr>
      <tr>
          <td style="text-align: center">将最后一位变为$0$</td>
          <td style="text-align: center">$0101-&gt;0100$，这里实际上就是先确保最低位变为$1$，再减去$1$。</td>
          <td style="text-align: center">$(x|1)-1$</td>
      </tr>
      <tr>
          <td style="text-align: center">最后一位取反</td>
          <td style="text-align: center">$0100-&gt;0101$ ，利用异或性质，其中除最后一位其余不变。</td>
          <td style="text-align: center">$x\wedge1$</td>
      </tr>
      <tr>
          <td style="text-align: center">把右数的第$k$位变为$1$</td>
          <td style="text-align: center">$0001-&gt;1001,k=4$</td>
          <td style="text-align: center">$x|(1&laquo;(k-1))$</td>
      </tr>
      <tr>
          <td style="text-align: center">把右数的第$k$位变为$0$</td>
          <td style="text-align: center">$1001-&gt;0001,k=4$，这个操作实际上就是先得到了$1000$，然后取反得到$0111$，最后利用按位与的性质其余位不变，最高位为$0$</td>
          <td style="text-align: center">$x&amp;(\sim(1&laquo;(k-1)))$</td>
      </tr>
      <tr>
          <td style="text-align: center">把右数的第$k$位取反</td>
          <td style="text-align: center">$1000-&gt;0000,k=4$，利用异或性质</td>
          <td style="text-align: center">$x\wedge (1&laquo;(k-1))$</td>
      </tr>
  </tbody>
</table>
<p>由于表长限制，这里接下表继续：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">功能</th>
          <th style="text-align: center">示例</th>
          <th style="text-align: center">位运算</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">取末$k$位</td>
          <td style="text-align: center">$1011-&gt;0011,k=2$</td>
          <td style="text-align: center">$x&amp;((1&laquo;k)-1)$</td>
      </tr>
      <tr>
          <td style="text-align: center">取右数的第$k$位</td>
          <td style="text-align: center">$1011-&gt;0001,k=4$，右移$k-1$位则是去掉了最后的$k-1$位，我们利用按位与即可将其提取出来</td>
          <td style="text-align: center">$x&raquo;(k-1)&amp;1$</td>
      </tr>
      <tr>
          <td style="text-align: center">把末$k$位全变为$1$</td>
          <td style="text-align: center">$1000-&gt;1111,k=3$</td>
          <td style="text-align: center">$x|((1&laquo;k)-1)$</td>
      </tr>
      <tr>
          <td style="text-align: center">把末$k$位取反</td>
          <td style="text-align: center">$0101-&gt;1010,k=4$</td>
          <td style="text-align: center">$x\wedge ((1&laquo;k)-1)$</td>
      </tr>
      <tr>
          <td style="text-align: center">把右边连续的$1$变为$0$</td>
          <td style="text-align: center">$0111-&gt;0000$ ，注意是右起连续的$1$</td>
          <td style="text-align: center">$x&amp;(x+1)$</td>
      </tr>
      <tr>
          <td style="text-align: center">把右起的第一个$0$变为$1$</td>
          <td style="text-align: center">$0011-&gt;0111$</td>
          <td style="text-align: center">$x|(x+1)$</td>
      </tr>
      <tr>
          <td style="text-align: center">把右起连续的$0$变为$1$</td>
          <td style="text-align: center">$1000-&gt;1111$，注意是右起连续的$0$</td>
          <td style="text-align: center">$x|(x-1)$</td>
      </tr>
      <tr>
          <td style="text-align: center">取右边连续的$1$</td>
          <td style="text-align: center">$1011-&gt;0011$</td>
          <td style="text-align: center">$(x\wedge (x+1))&raquo;1$</td>
      </tr>
      <tr>
          <td style="text-align: center">去掉右起的第一个$1$的左边</td>
          <td style="text-align: center">$1101-&gt;0001$</td>
          <td style="text-align: center">$x&amp;(x\wedge (x-1))$</td>
      </tr>
  </tbody>
</table>
<p>当然，这里只是一些常用的，并不是全部，位运算的神奇远不止于此。</p>
<h2 id="负数的位运算" class="heading-element"><span>4 负数的位运算</span>
  <a href="#%e8%b4%9f%e6%95%b0%e7%9a%84%e4%bd%8d%e8%bf%90%e7%ae%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，<font color="red">负数的补码则是符号位不变，其余按位取反，最后再$+1$得到的，</font> 例如：</p>
<p>$15$,原码:$00001111\space$补码:$00001111$</p>
<p>$-15$,原码:$10001111\space$补码:$11110001$</p>
<p>那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。
但需要注意的是，对于有符号数的右移操作，不同的处理器架构可能有不同的规定。在某些架构中（如x86），如果对有符号数执行算术右移（arithmetic right shift），则高位空出来的位置会补上符号位；对于无符号数的右移操作，所有架构都遵循相同的规则：高位空出来的位置会补0。例如对于$-15$，其补码为$11110001,$右移一位$(-15&raquo;1)$得到的是$11111000$，即$-8$，其他的同理。
在大多数现代处理器上，无论是有符号数还是无符号数，左移操作总是将空出来的低位补0。</p>
<p>这里我们介绍几个特殊的性质：</p>
<ul>
<li>
<p><strong>快速判断是否为$-1$</strong></p>
<p>在链式前向星中，我们初始化$head$数组为$-1$，最后判断是否遍历完$u$的所有边时，即判断$i$是否为$-1$，我们直接用$\sim i$即可。原因就在于$-1$的补码是$11111111$，按位取反就变为$00000000$，这实际上就是$0$。</p>
</li>
<li>
<p><strong>取最低位的$1$，lowbit函数</strong></p>
<p>也就是$x&amp;(-x)$，这在树状数组中起着巨大作用，这里指路一篇树状数组讲解$blog$:<a href="https://blog.csdn.net/hzf0701/article/details/116208699?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162212420516780264027190%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162212420516780264027190&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-116208699.nonecase&amp;utm_term=%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84&amp;spm=1018.2226.3001.4450"target="_blank" rel="external nofollow noopener noreferrer">点这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，我们来证明一下，这里取$x=15$，对于$15&amp;(-15)$，我们知道，在补码上进行运算得到的是$00000001$，需要注意二元运算的符号位我们需要进行运算。</p>
</li>
</ul>
<h2 id="位运算的一些应用" class="heading-element"><span>5 位运算的一些应用</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9a%84%e4%b8%80%e4%ba%9b%e5%ba%94%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>位运算实现乘除法</strong></p>
<blockquote>
<p>将$x$左移一位实现$\times 2$，将$x$右移一位实现$\div2$。</p>
<p>$a&laquo;1 \equiv a*2$</p>
<p>$a &raquo;1 \equiv a/2$</p>
</blockquote>
</li>
<li>
<p><strong>位运算交换两整数</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span> <span class="o">^=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">b</span> <span class="o">^=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span> <span class="o">^=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这效率非常高，我们来剖析其原理，对于$a=a\wedge b$，则$b = b\wedge(a\wedge b)$，根据交换律以及异或性质，得$b=b\wedge b\wedge a=0\wedge a=a$，同理$a=(a\wedge b)\wedge a=0\wedge b=b$。这样就实现了交换操作。</p>
<ul>
<li>
<p><strong>位运算判断奇偶数</strong></p>
<blockquote>
<p>我们知道，在二进制中，最低位决定了是奇数还是偶数，所以我们可以提取出最低位的值，即与$1$相与即可实现目的，为$0$则是偶数，为$1$则是奇数。</p>
</blockquote>
</li>
<li>
<p><strong>位运算改变正负性和求绝对值</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">change</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">~</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于正数而言，补码就是原码，所以按位取反再$+1$则得到对应真值负数的补码，而对于负数，其补码进行按位取反再$+1$则得到对应真值正数的补码，变为原码。那么知道这个我们就可以特判是否为负数 ==（这里通过右移$31$位，若为正数，则得到的是$0$，若为负数，则得到的是$-1$，而$0$的补码为$0000$,$-1$的补码为$1111$，<del>根据异或性质即可判断</del>感谢读者
（恢。）指出错误，这里应该是要进行按位取反操作，这样如果为负数判断结果才为0
。）==  ，利用条件表达式就可以根据判断结果求绝对值了。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="o">~</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>位运算实现对$p$取余（p为$2^k$）</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">mod</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>取余实际上就是舍去大于等于$p$的位数，所以我们只需要保留在$p$范围内的数。由于我们限定了$p$为$2^k$，所以$(p - 1)$一定是将小于$p$的最高位全部变为了$1$，这样再进行与操作即可得到余数。</p>
<ul>
<li><strong>位运算统计二进制数$1$的个数</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span> <span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于任意的$x$，转换成二进制后，是形如这样的数字：$aa&hellip;aa10&hellip;00$，从右向左数有任意多个$0$，直到遇见第一个$1$，字母$a$用来占位，代表$1$左边的任意数字。$x-1$转换成二进制后，是形如这样的数字：$aa&hellip;aa01&hellip;11$，从右向左数，原来的任意多个$0$都变成$1$，原来的第一个$1$，变成$0$，字母$a$部分不变。对$x$ 和 $x-1$ 进行 按位与 计算，会得到：$aa&hellip;aa00&hellip;00$，从右向左数，原来的第一个$1$变成了$0$，字母a部分不变。所以 $x &amp; (x-1)$相当于消除了 $x$ 从右向左数遇到的第一个$1$。那么，$x$转换成二进制后包含多少个$1$，count函数里的循环就会进行多少次，直到$x$所有的$1$都被“消除”。</p>
<h2 id="位运算例题" class="heading-element"><span>6 位运算例题</span>
  <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e4%be%8b%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="更新二进制位" class="heading-element"><span>6.1 更新二进制位</span>
  <a href="#%e6%9b%b4%e6%96%b0%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%bd%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）</p>
<p>样例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输入: N=(10000000000)2 M=(10101)2 i=2 j=6
</span></span><span class="line"><span class="cl">输出: N=(10001010100)2
</span></span><span class="line"><span class="cl">输入: N=(10000000000)2 M=(11111)2 i=2 j=6
</span></span><span class="line"><span class="cl">输出: N=(10001111100)2</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>结合所学，我们的思路应该就是先将第$i$位到第$j$位全部变为$0$，再将与左移$i$位的$M$进行或操作。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">updateBits</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="c1">// 循环遍历从第 i 位到第 j 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">pos</span> <span class="o">++</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        	<span class="c1">// 将 n 的第 pos 位设为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ~(1 &lt;&lt; pos) 创建一个在第 pos 位为 0 其他位为 1 的掩码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 然后使用按位与运算符（&amp;）来将 n 的第 pos 位设置为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        	<span class="n">n</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 m 左移 i 位，使 m 的低位对齐到 n 的第 i 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 然后使用按位或运算符（|）合并 n 和 m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这样 n 的第 i 到第 j 位就被 m 的相应位所替换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">n</span> <span class="o">|</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="ab问题" class="heading-element"><span>6.2 A+B问题</span>
  <a href="#ab%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>给出两个整数 a 和 b , 求他们的和并以整数（int）的形式返回。<strong>不能使用</strong> <strong>+ 等数学运算符。</strong></p>
<p>样例：</p>
<p>输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a = 1
</span></span><span class="line"><span class="cl">b = 2</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">3</span></span></code></pre></td></tr></table>
</div>
</div><p>输入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a = -1
</span></span><span class="line"><span class="cl">b = 1</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>这题我们可以利用异或操作来实现，因为异或操作有一个别名叫不进位加法。那么进位操作我们实际上就可以通过$a&amp;b$来实现，因为$a&amp;b$得到的都是$a$和$b$上都有的$1$，我们再左移即得到的是进位之后的结果，所以$a+b=(a\wedge b)+(a&amp;b&laquo;1)$。通过这样模拟竖式加法操作即可。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aplusb</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="c1">// 当没有进位需要处理时循环结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        	<span class="c1">// temp_a 存储 a 和 b 的按位异或结果，这相当于不带进位的加法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">temp_a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// temp_b 存储 a 和 b 的按位与结果并左移一位，这相当于计算进位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 因为只有两个位都是1时才会产生进位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">temp_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// 更新 a 为不带进位的加法结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">a</span> <span class="o">=</span> <span class="n">temp_a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">			<span class="c1">// 更新 b 为进位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">b</span> <span class="o">=</span> <span class="n">temp_b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当没有进位时，a 中存储了最终结果，返回 a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="o1时间检测2的幂次" class="heading-element"><span>6.3 O(1)时间检测2的幂次</span>
  <a href="#o1%e6%97%b6%e9%97%b4%e6%a3%80%e6%b5%8b2%e7%9a%84%e5%b9%82%e6%ac%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>用 O(<em>1</em>) 时间检测整数 <em>n</em> 是否是 <em>2</em> 的幂次。</p>
<p>样例</p>
<p><code>n=4</code>，返回 <code>true</code>;</p>
<p><code>n=5</code>，返回 <code>false</code>.</p>
<p>挑战</p>
<p>O(<em>1</em>) 时间复杂度</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>首先我们知道$2^k$是大于$0$的，这里我们需要特判，同理，$2^k$的二进制表示中只有$1$个$1$，故我们可以利用$x&amp;(x-1)$来消除唯一的$1$判断是否等于$0$即可。</p>
</li>
<li>
<p><strong>AC代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">checkPowerOf2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查 n 是否大于 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 2 的幂必须是正数，因为 0 和负数都不是 2 的幂
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 检查 n 和 n - 1 的按位与操作是否为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果 n 是 2 的幂，则其二进制表示中只有一个 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 例如 2 (10), 4 (100), 8 (1000)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此 n &amp; (n - 1) 将得到 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>HDU 4507 恨7不成妻 （数位DP套路题）</title><link>https://hezephyr.github.io/posts/03.hdu-4507-%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB-%E6%95%B0%E4%BD%8Ddp%E5%A5%97%E8%B7%AF%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</link><pubDate>Thu, 13 May 2021 22:02:01 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.hdu-4507-%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB-%E6%95%B0%E4%BD%8Ddp%E5%A5%97%E8%B7%AF%E9%A2%98%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</guid><description><![CDATA[<p>不会数位$DP$的这里指路一篇介绍非常详细的数位$DP$的$blog$:<a href="https://unique-pure.github.io/pages/243023/"target="_blank" rel="external nofollow noopener noreferrer">点这里。<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<ul>
<li>
<p><strong>链接</strong>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4507"target="_blank" rel="external nofollow noopener noreferrer">恨7不成妻<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
</li>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>单身!
依然单身！
吉哥依然单身！
DS级码农吉哥依然单身！
所以，他生平最恨情人节，不管是214还是77，他都讨厌！
吉哥观察了214和77这两个数，发现：
$2+1+4=7$　
$7+7=7<em>2$
$77=7</em>11$
最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！什么样的数和7有关呢？如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关——
　　　1、整数中某一位是7；
　　　2、整数的每一位加起来的和是7的整数倍；
　　　3、这个整数是7的整数倍；</p>
<p>　现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。
　Input
　输入数据的第一行是case数T(1 &lt;= T &lt;= 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 &lt;= L &lt;= R &lt;= 10^18)。
　Output
　请计算[L,R]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。
　Sample Input</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">10</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl"><span class="mi">17</span> <span class="mi">17</span></span></span></code></pre></td></tr></table>
</div>
</div><p>　Sample Output</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">236</span>
</span></span><span class="line"><span class="cl"><span class="mi">221</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>根据题意我们做出预处理，利用闫式$DP$分析法分析如下：</p>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2f5f90205e029c3471d7dc4d0dea96de.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>以上只是简单分析，我们还并没有真正的进行状态转移和计算，那么根据题意，首先是需要知道整数的每一位加起来的和是$7$的整数倍以及该整数是$7$的整数倍，这个好处理，在我们的前面的题中有类似的题型，这已经在我们的$f$数组的第三维和第四维了。所以难点就在于怎么处理整数的平方和。我们看下面的公式推导：</p>
<p><font color="red">我们用$jA$来表示$i$位数，而其中的$A$为$i-1$位数。设这个状态有$t$个符合要求的数，分别是$A_1$~$A_t$。</font> 那么，平方和易得为：</p>
<p>$(jA_1)^2+(jA_2)^2+(jA_3)^2+&hellip;+(jA_{t-1})^2+(jA_t)^2$</p>
<p>（我们分割表示将$A$提取出来。）</p>
<p>$=(j<em>10^{i-1}+A_1)^2+(j</em>10^{i-1}+A_2)^2+(j<em>10^{i-1}+A_3)^2+&hellip;+(j</em>10^{i-1}+A_{t-1})^2+(j*10^{i-1}+A_t)^2$</p>
<p>（平方和公式）</p>
<p>$=t*(j<em>10^{i-1})^2+2</em>(j<em>10^{i-1})</em>(A_1+&hellip;+A_t)+(A_1^2+&hellip;+A^2)$</p>
<p>这样，在这个式子中，由于$j$已知，所以我们发现$f$数组需要保存三个值。$A$的$0$次方之和，也就是符合要求的数，$A$的$1$次方之和，也就是符合要求的除去$j$的$i-1$位数相加，$A$的$2$次方之和，也就是符合要求的除去$j$的$i-1$位数平方相加。我们分别用$s_0,s_1,s_2$</p>
<p>分别代表上述的三个值。</p>
<p>那么这里我们需要怎么求$s_1$，如下：</p>
<p>注：这里的$s_1$为$i+1$位的$s_1$，而它存储的就是$i$位的$A$。</p>
<p>$jA_1+&hellip;+jA_t$</p>
<p>$=j*10^{i-1}+(A_1+&hellip;+A_t)$</p>
<p>所以我们的$f$应该是一个结构体数组，它需要存取$s_0,s_1,s_2$。那么预处理根据上述分析其实就简单了。那么就按照数位$DP$的套路解决这道题即可。需要注意这道题好多坑点，多取模，足够细心才可以解决。（调$Bug$调了好久。快绝望了。）</p>
<ul>
<li><strong>代码</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:恨7不成妻
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 21:19
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">ll</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//需要满足三个性质。
</span></span></span><span class="line"><span class="cl"><span class="c1">//1.不含7.
</span></span></span><span class="line"><span class="cl"><span class="c1">//2.各位数字之和模7不为0.an-1+...+a0%7!=0. 
</span></span></span><span class="line"><span class="cl"><span class="c1">//3.该数模7不为0.an-1*pow(10,n-1)+...+a0+pow(10,0)%7!=0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">F</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">s0</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">;</span><span class="c1">//s0为符合要求的数。s1为符合要求的数1次方之和，s2为符合要求的数的2次方之和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">f</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">10</span><span class="p">][</span><span class="mi">7</span><span class="p">][</span><span class="mi">7</span><span class="p">];</span><span class="c1">//f[i][j][k][u]表示总共有i位数且最高位是j，该数值模7为k，各位数数字之和模7为u的所有数的s0,s1,s2.
</span></span></span><span class="line"><span class="cl"><span class="c1">//进行初始化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">t</span><span class="p">;</span><span class="c1">//测试数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ll</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ll</span> <span class="n">power7</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">power9</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="c1">//power7[i]存储10^i余7的余数，power9[i]存储10^i余P的余数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ll</span> <span class="nf">mod</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">,</span><span class="n">ll</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="n">y</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">%</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//确定初始值，位数为1的情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//根据性质排除不符合要求的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">F</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="o">%</span><span class="mi">7</span><span class="p">][</span><span class="n">j</span><span class="o">%</span><span class="mi">7</span><span class="p">];</span><span class="c1">//这里用引用减少代码量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">v</span><span class="p">.</span><span class="n">s0</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">s1</span><span class="o">+=</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">s2</span><span class="o">+=</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//辅助作用，表示10的i-1次方。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">power</span><span class="o">*=</span><span class="mi">10</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span><span class="c1">//排除不符合要求的数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">u</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span><span class="n">u</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">q</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">q</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//枚举i-1的最高位。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">F</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">u</span><span class="p">],</span><span class="n">y</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">q</span><span class="p">][</span><span class="n">mod</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">power</span><span class="o">%</span><span class="mi">7</span><span class="p">),</span><span class="mi">7</span><span class="p">)][</span><span class="n">mod</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">j</span><span class="p">,</span><span class="mi">7</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//s0,s1,s2都是通过公式就算得到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">x</span><span class="p">.</span><span class="n">s0</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">s0</span><span class="o">+</span><span class="n">y</span><span class="p">.</span><span class="n">s0</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">x</span><span class="p">.</span><span class="n">s1</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">s1</span><span class="o">+</span><span class="mi">1LL</span><span class="o">*</span><span class="n">j</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="n">y</span><span class="p">.</span><span class="n">s0</span><span class="o">%</span><span class="n">P</span><span class="o">+</span><span class="n">y</span><span class="p">.</span><span class="n">s1</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">x</span><span class="p">.</span><span class="n">s2</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">s2</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">                            <span class="mi">1LL</span><span class="o">*</span><span class="n">j</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="n">y</span><span class="p">.</span><span class="n">s0</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="n">j</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">                            <span class="mi">1LL</span><span class="o">*</span><span class="n">y</span><span class="p">.</span><span class="n">s1</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="mi">2</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="n">j</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">+</span><span class="n">y</span><span class="p">.</span><span class="n">s2</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//这里处理为了方便以及降低时间复杂度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">power7</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">power9</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">power7</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">power7</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">%</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">power9</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">power9</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">F</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span><span class="kt">int</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//因为f[i][j][k][u]是本身模7等于k，且各位数之和模7等于u的，所以我们需要找出符合条件的集合。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="n">s0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span><span class="n">x</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span><span class="n">y</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">k</span><span class="o">||</span><span class="n">y</span><span class="o">==</span><span class="n">u</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">F</span> <span class="n">v</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">s0</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">s0</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">s0</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">s1</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">s1</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">s1</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">s2</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">s2</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">s2</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="n">s0</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">ll</span> <span class="nf">dp</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//0的平方和为0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">temp</span><span class="o">=</span><span class="n">n</span><span class="o">%</span><span class="n">P</span><span class="p">;</span><span class="c1">//备份一个n，供后面判断n使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">),</span><span class="n">n</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">last_a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">last_b</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//这里我们需要存储前缀的本身值和前缀的个位数之和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//答案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//走左分支。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//我们需要将符合条件的数筛出来，这里要用到一个get函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//求得本身模7不等于a，并且各位数之和模7不等b的集合，此时就可以使用预处理出来的结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="o">-</span><span class="n">last_a</span><span class="o">*</span><span class="n">power7</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="mi">7</span><span class="p">),</span><span class="n">u</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="o">-</span><span class="n">last_b</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">F</span> <span class="n">v</span><span class="o">=</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//cout&lt;&lt;v.s0&lt;&lt;&#34; &#34;&lt;&lt;v.s1&lt;&lt;&#34; &#34;&lt;&lt;v.s2&lt;&lt;endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//根据公式求解s2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//j就是last_a.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ans</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">ans</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="mi">1LL</span><span class="o">*</span><span class="p">(</span><span class="n">last_a</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">last_a</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power9</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power9</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">s0</span><span class="o">%</span><span class="n">P</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="mi">1LL</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">last_a</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="p">(</span><span class="n">power9</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="n">P</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">s1</span><span class="o">%</span><span class="n">P</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">                <span class="n">v</span><span class="p">.</span><span class="n">s2</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//cout&lt;&lt;ans&lt;&lt;endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断x。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//走右分支更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">last_a</span><span class="o">=</span><span class="n">last_a</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">last_b</span><span class="o">+=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断自己本身是否符合要求。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">&amp;&amp;</span><span class="n">last_a</span><span class="o">%</span><span class="mi">7</span><span class="o">&amp;&amp;</span><span class="n">last_b</span><span class="o">%</span><span class="mi">7</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">ans</span><span class="o">+</span><span class="n">temp</span><span class="o">*</span><span class="n">temp</span><span class="o">%</span><span class="n">P</span><span class="p">,</span><span class="n">P</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">mod</span><span class="p">(</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">P</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">1
</span></span></span><span class="line"><span class="cl"><span class="cm">1 1000000000000000000
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>数位DP学习整理</title><link>https://hezephyr.github.io/posts/01.%E6%95%B0%E4%BD%8Ddp/</link><pubDate>Wed, 12 May 2021 18:20:58 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E6%95%B0%E4%BD%8Ddp/</guid><description><![CDATA[<h2 id="数位dp介绍" class="heading-element"><span>1 数位DP介绍</span>
  <a href="#%e6%95%b0%e4%bd%8ddp%e4%bb%8b%e7%bb%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>数位DP往往都是这样的题型，给定一个闭区间$[l,r]$，让你求这个区间中满足某种条件的数的总数。而这个区间可能很大，简单的暴力代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="n">ans</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们发现，若区间长度超过$1e8$，我们暴力枚举就会超时了，而数位$DP$则可以解决这样的题型。数位$DP$实际上就是在数位上进行$DP$。</p>
<h2 id="数位dp解法" class="heading-element"><span>2 数位DP解法</span>
  <a href="#%e6%95%b0%e4%bd%8ddp%e8%a7%a3%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>数位$DP$就是换一种暴力枚举的方式，使得新的枚举方式符合$DP$的性质，然后预处理好即可。我们来看：我们可以用$f(n)$表示$[0,n]$的所有满足条件的个数，那么对于$[l,r]$我们就可以用$[l,r]\iff f(r)-f(l-1)$，相当于前缀和思想。那么也就是说我们只要求出$f(n)$即可。那么数位$DP$关键的思想就是从树的角度来考虑。将数拆分成位，从高位到低位开始枚举。我们可以视$N$为$n$位数，那么我们拆分$N:a_{n}、a_{n-1}&hellip;a_1$。那么我们就可以开始分解建树，如下。之后我们就可以预处理再求解$f(n)$了，个人认为求解$f(n)$是最难的一步。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/cfc37954b97e29aa1d848925105fec1b.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>听完是不是有点绕，我们可以来点题目练习一下，做完就会发现了数位$DP$的套路了。</p>
<h2 id="数位dp经典例题" class="heading-element"><span>3 数位DP经典例题</span>
  <a href="#%e6%95%b0%e4%bd%8ddp%e7%bb%8f%e5%85%b8%e4%be%8b%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="31-度的数量httpswwwacwingcomactivitycontent11" class="heading-element"><span>3.1 <a href="https://www.acwing.com/activity/content/11/"target="_blank" rel="external nofollow noopener noreferrer">3.1 度的数量<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#31-%e5%ba%a6%e7%9a%84%e6%95%b0%e9%87%8fhttpswwwacwingcomactivitycontent11" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>求给定区间$ [X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。例如，设 $X=15,Y=20,K=2,B=2$，则有且仅有下列三个数满足题意：
$17=2^4+2^0$
$18=2^4+2^1$
$20=2^4+2^2$
输入格式
第一行包含两个整数 X 和 Y，接下来两行包含整数 $K$ 和 $B$。
输出格式
只包含一个整数，表示满足条件的数的个数。
数据范围
$1≤X≤Y≤2^{31}−1,$
$1≤K≤20,$
$2≤B≤10$
输入样例：
15 20
2
2
输出样例：
3</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>此题实际上就是将十进制数转化为$B$进制数，判断位数上的值是否为$1$。那么我们可以视$N$为$n$位数，那么我们拆分$N:a_{n}、a_{n-1}&hellip;a_1$。从树的角度考虑：我们设$N=76543210,B=10$，那么我们从高位往最低位开始枚举如下；枚举$a_n$时，我们有两种选择：</p>
<ol>
<li>走右边分支，那么我们填$7(a_n)$，而题目要求每一位只能填$1$或者$0$,而$a_n&gt;1$，所以不是合法方案，我们直接剔除。</li>
<li>走左边分支，那么我们可以填$0$~$6$，即$0-{a_n}-1$，那么由于每一位只能填$1$或者$0$，所以我们累加这两种选择的方案。</li>
</ol>
<p>记住，走到了左边分支是可以直接累加的。</p>
<p>所以我们实际上还是要做一个预处理的，我们用$f[i][j]$表示还剩下$i$位没有填，且需要填写$j$个$1$的方案数。那么在$(i,j)$这个状态，我们可以选择填$1$，那么接下来的状态就是$f[i-1][j-1]$，而如果填$0$，那么接下来的状态就是$f[i-1][j]$，那么状态转移方程就是$f[i][j]=f[i-1][j]+f[i][j-1]$。而初始状态即是当$j=0$时，$f[i][0]=1$。这样我们就可以预处理$f$数组了。</p>
<p>处理完之后我们就可以直接模拟做了。</p>
</li>
<li>
<p><strong>代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:度的数量
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 11:23
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">35</span><span class="p">][</span><span class="mi">35</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//首先我们先预处理f数组。其中f[i][j]表示剩下还有i个没填，需要填写j个1的方案数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">35</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//求解f(n)。我们需要避免n为0的情况，这里需要特判。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span><span class="c1">//将n分割，存储位数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span><span class="o">/=</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//答案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//前面的信息，这里代表的是前面分支选取了多少个1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//说明x&gt;0，我们可以选择左边分支填0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="n">last</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//当x&gt;1我们才可以枚举左边分支填1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//如果还可以填1的话。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span><span class="c1">//因为右边分支只能为0或1，所以不符合条件。break。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//当x=1就可以进入右边的分支继续讨论。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">last</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">last</span><span class="o">&gt;</span><span class="n">k</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//考虑到最后一位，如果符合条件那么末位填0也算一种方案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">&amp;&amp;</span><span class="n">last</span><span class="o">==</span><span class="n">k</span><span class="p">)</span><span class="n">ans</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="o">&gt;&gt;</span><span class="n">k</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="32-计数问题httpswwwacwingcomproblemcontent340" class="heading-element"><span>3.2 <a href="https://www.acwing.com/problem/content/340/"target="_blank" rel="external nofollow noopener noreferrer">3.2 计数问题<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#32-%e8%ae%a1%e6%95%b0%e9%97%ae%e9%a2%98httpswwwacwingcomproblemcontent340" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼90∼9 的出现次数。</p>
<p>例如，$a=1024，b=1032$，则 a 和 b 之间共有 99 个数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1024 1025 1026 1027 1028 1029 1030 1031 1032</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <code>0</code> 出现 10次，<code>1</code> 出现 10 次，<code>2</code> 出现 7 次，<code>3</code> 出现 3 次等等…</p>
<p>输入格式</p>
<p>输入包含多组测试数据。</p>
<p>每组测试数据占一行，包含两个整数 a 和 b。</p>
<p>当读入一行为 <code>0 0</code> 时，表示输入终止，且该行不作处理。</p>
<p>输出格式</p>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>每个结果包含十个用空格隔开的数字，第一个数字表示 <code>0</code> 出现的次数，第二个数字表示 <code>1</code> 出现的次数，以此类推。</p>
<p>数据范围</p>
<p>$0&lt;a,b&lt;1000000000&lt;a,b&lt;100000000$</p>
<p>输入样例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="mi">44</span> <span class="mi">497</span>
</span></span><span class="line"><span class="cl"><span class="mi">346</span> <span class="mi">542</span>
</span></span><span class="line"><span class="cl"><span class="mi">1199</span> <span class="mi">1748</span>
</span></span><span class="line"><span class="cl"><span class="mi">1496</span> <span class="mi">1403</span>
</span></span><span class="line"><span class="cl"><span class="mi">1004</span> <span class="mi">503</span>
</span></span><span class="line"><span class="cl"><span class="mi">1714</span> <span class="mi">190</span>
</span></span><span class="line"><span class="cl"><span class="mi">1317</span> <span class="mi">854</span>
</span></span><span class="line"><span class="cl"><span class="mi">1976</span> <span class="mi">494</span>
</span></span><span class="line"><span class="cl"><span class="mi">1001</span> <span class="mi">1960</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="mi">0</span></span></span></code></pre></td></tr></table>
</div>
</div><p>输出样例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">85</span> <span class="mi">185</span> <span class="mi">185</span> <span class="mi">185</span> <span class="mi">190</span> <span class="mi">96</span> <span class="mi">96</span> <span class="mi">96</span> <span class="mi">95</span> <span class="mi">93</span>
</span></span><span class="line"><span class="cl"><span class="mi">40</span> <span class="mi">40</span> <span class="mi">40</span> <span class="mi">93</span> <span class="mi">136</span> <span class="mi">82</span> <span class="mi">40</span> <span class="mi">40</span> <span class="mi">40</span> <span class="mi">40</span>
</span></span><span class="line"><span class="cl"><span class="mi">115</span> <span class="mi">666</span> <span class="mi">215</span> <span class="mi">215</span> <span class="mi">214</span> <span class="mi">205</span> <span class="mi">205</span> <span class="mi">154</span> <span class="mi">105</span> <span class="mi">106</span>
</span></span><span class="line"><span class="cl"><span class="mi">16</span> <span class="mi">113</span> <span class="mi">19</span> <span class="mi">20</span> <span class="mi">114</span> <span class="mi">20</span> <span class="mi">20</span> <span class="mi">19</span> <span class="mi">19</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="mi">107</span> <span class="mi">105</span> <span class="mi">100</span> <span class="mi">101</span> <span class="mi">101</span> <span class="mi">197</span> <span class="mi">200</span> <span class="mi">200</span> <span class="mi">200</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl"><span class="mi">413</span> <span class="mi">1133</span> <span class="mi">503</span> <span class="mi">503</span> <span class="mi">503</span> <span class="mi">502</span> <span class="mi">502</span> <span class="mi">417</span> <span class="mi">402</span> <span class="mi">412</span>
</span></span><span class="line"><span class="cl"><span class="mi">196</span> <span class="mi">512</span> <span class="mi">186</span> <span class="mi">104</span> <span class="mi">87</span> <span class="mi">93</span> <span class="mi">97</span> <span class="mi">97</span> <span class="mi">142</span> <span class="mi">196</span>
</span></span><span class="line"><span class="cl"><span class="mi">398</span> <span class="mi">1375</span> <span class="mi">398</span> <span class="mi">398</span> <span class="mi">405</span> <span class="mi">499</span> <span class="mi">499</span> <span class="mi">495</span> <span class="mi">488</span> <span class="mi">471</span>
</span></span><span class="line"><span class="cl"><span class="mi">294</span> <span class="mi">1256</span> <span class="mi">296</span> <span class="mi">296</span> <span class="mi">296</span> <span class="mi">296</span> <span class="mi">287</span> <span class="mi">286</span> <span class="mi">286</span> <span class="mi">247</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9cff4c573361692ac8f6cef1b47a916-20231125213409021.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们需要预处理$f$数组，那么我们可以用$f[i,j,u]$表示$i$位，最高位为$j$的数拥有$u$的个数。那么如果$j$不等于$u$时，则$f[i][j][u]+=f[i-1][k][u],0\leq k \leq 9$。这个应该不难理解，因为这个状态就是由之前的状态得到的。 而当$j$等于$u$时，那么同样也可以由之前的$9$个状态得到。为$f[i][j][u]+=f[i-1][k][u],0\leq k \leq 9$。记住，我们是还没有计算最高位的$u$个数的，因为最高位本身就为$u$，也是一种可能，所以我们需要加上。那么总共有$10^{i-1}$多的数，所以增加的u的数量为$10^{i-1}$。初始状态就是$f[1][i][i]=1$，到这，我们的$f$数组就初始化完了，那么接下来。就是拆位分支的数位$DP$套路讨论了，这里不在叙述，代码附详细注释。</p>
</li>
<li>
<p><strong>代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:计数问题
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 13:12
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span><span class="c1">//预处理f数组。其中f[i][j][u]表示i位最高位为j的数拥有u的个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">u</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">u</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//判断j是否等于u。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">u</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">+=</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">u</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">ll</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1~n,求x的出现次数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="n">u</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span><span class="c1">//特判n是否为0.根据u的值确定返回值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span><span class="c1">//存储分割后的位数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">),</span><span class="n">n</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//last记录前面u出现的次数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//答案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//左边分支，0~x。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//由于此题不能有前导0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">u</span><span class="p">];</span><span class="c1">//注意这里i需要+1，因为我们i下标从0开始。而位数从1开始。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//走左边分支，那么我们需要加上前面的个数。注意这里需要乘上x，因为左边分支有x中选择。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ans</span><span class="o">+=</span><span class="n">x</span><span class="o">*</span><span class="n">last</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">u</span><span class="p">)</span><span class="n">last</span><span class="o">++</span><span class="p">;</span><span class="c1">//记录last。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span><span class="n">ans</span><span class="o">+=</span><span class="n">last</span><span class="p">;</span><span class="c1">//加上这个数本身含有的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//由于我们前面都是枚举n位数的，我们还需要统计所有0~n-1位数的方案数量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//例如000011是不合法的，但11是合法的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//这一步确实很容易忽略，没办法，数位DP就是这么难。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">u</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">l</span><span class="o">||</span><span class="n">r</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&gt;</span><span class="n">r</span><span class="p">)</span><span class="n">swap</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">==</span><span class="mi">9</span><span class="o">?</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="nl">endl</span><span class="p">:</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="33-数字游戏httpswwwacwingcomactivitycontent11" class="heading-element"><span>3.3 <a href="https://www.acwing.com/activity/content/11/"target="_blank" rel="external nofollow noopener noreferrer">3.3 数字游戏<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#33-%e6%95%b0%e5%ad%97%e6%b8%b8%e6%88%8fhttpswwwacwingcomactivitycontent11" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>科协里最近很流行数字游戏。</p>
<p>某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。</p>
<p>现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。</p>
<p><strong>输入格式</strong>
输入包含多组测试数据。</p>
<p>每组数据占一行，包含两个整数 a 和 b。</p>
<p><strong>输出格式</strong>
每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。</p>
<p><strong>数据范围</strong>
$1≤ a ≤ b ≤2^{31}−1$</p>
<p><strong>样例输入</strong>
1 9
1 19
<strong>样例输出</strong>
9
18</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>同样的套路， 先预处理$f$数组，我们用$f[i][j]$表示$i$位数，且最高位为$j$的不降数方案数。那么我们来列写一下状态转移方程，对于$f[i][j]$，要满足不降数的要求，则$f[i-1][k]$，$k$需满足$j \leq k \leq 9$，那么自然$f[i][j]=\sum_{k=j}^9 f[i-1][k]$。而初始状态自然是$f[1][j]=1$。预处理完之后，我们就好做了，直接按数位$DP$的思想处理即可。代码附详细注释。</p>
</li>
<li>
<p><strong>代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:数字游戏
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 14:57
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">11</span><span class="p">];</span><span class="c1">//预处理f数组。其中f[i][j]表示i位数，且最高位为j的不降数方案数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1~n，这里我们需要特判n=0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span><span class="c1">//存储分割位数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">),</span><span class="n">n</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//last存储上一位的最大值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//答案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//走左边的分支。因为要保持不降序，所以我们j&gt;=last。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">last</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="c1">//注意是i+1位。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">last</span><span class="o">&gt;</span><span class="n">x</span><span class="p">)</span><span class="k">break</span><span class="p">;</span><span class="c1">//说明上一位比x大，不能构成降序了，直接退出。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">last</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="c1">//走右分支了，更新last。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span><span class="n">ans</span><span class="o">++</span><span class="p">;</span><span class="c1">//全部枚举完了，自身也同样构成了一种方案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="34-windy数httpswwwluogucomcnproblemp2657" class="heading-element"><span>3.4 <a href="https://www.luogu.com.cn/problem/P2657"target="_blank" rel="external nofollow noopener noreferrer">3.4 windy数<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#34-windy%e6%95%b0httpswwwluogucomcnproblemp2657" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>windy 定义了一种 windy 数。</p>
<p>不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 <em>a</em> 和 <em>b</em> ，总共有多少个 windy 数？</p>
<p><strong>输入格式</strong></p>
<p>输入只有一行两个整数，分别表示 <em>a</em> 和 <em>b</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个整数表示答案。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 10</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出 #1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">9</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输入 #2</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">25 50</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出 #2</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">20</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>说明/提示</strong></p>
<p><strong>数据规模与约定</strong></p>
<p>对于全部的测试点，保证 $1 \leq a \leq b \leq 2 \times 10^9$。</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>同样，我们先进行预处理$f$数组，其中$f[i][j]$表示$i$位，其中最高位为$j$的方案数。那么根据题意，状态转移方程即为$f[i][j]=\sum_{}f[i-1][k]$，其中$0 \leq k \leq 9 \space and \space abs(k-j)&gt;=2$。而初始状态即为$dp[1][i]=1$。预处理完之后就好处理了，这里不再提供思路，请大家自己画出树结构并完成此题。</p>
</li>
<li>
<p><strong>代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:windy数
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 15:43
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span><span class="c1">//f数组。其中f[i][j]表示i位，其中最高位为j的方案数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//特判n为0的情况，避免对之后操作造成影响。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span><span class="c1">//存储分割位数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">last</span><span class="o">=-</span><span class="mi">2</span><span class="p">;</span><span class="c1">//存储上一位的值。这里初值为-2,是因为我们需要确定1可以。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//答案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">),</span><span class="n">n</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//左分支。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">last</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//说明符合要求。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">last</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span><span class="k">break</span><span class="p">;</span><span class="c1">//不满足要去。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">last</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span><span class="n">ans</span><span class="o">++</span><span class="p">;</span><span class="c1">//枚举到最后一位，自身也形成了一种方案。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//特殊枚举有前导0的数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="35-数字游戏httpswwwacwingcomactivitycontent11" class="heading-element"><span>3.5 <a href="https://www.acwing.com/activity/content/11/"target="_blank" rel="external nofollow noopener noreferrer">3.5 数字游戏Ⅱ<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#35-%e6%95%b0%e5%ad%97%e6%b8%b8%e6%88%8fhttpswwwacwingcomactivitycontent11" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>由于科协里最近真的很流行数字游戏。</p>
<p>某人又命名了一种取模数，这种数字必须满足各位数字之和$modN$为 0。</p>
<p>现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。</p>
<p>数据范围
$1≤a,b≤2^{31}−1$,
$1≤N&lt;100$
样例
输入
1 19 9</p>
<p>输出
2</p>
</blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>虽然这道题看起来很复杂，但是本质还是还是数位DP的套路，只不过现在性质是满足各位数字之和$mod N$为0。那么此题实际上困难点在于预处理，我们发现预处理这其实就是一个$dp$，我们用闫式$DP$分析法分析如下：
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/d9a440fdaf5a847c7cdc37227b76acf5.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>我们得到这个$f$数组有什么用呢？我们发现，如果我现在已知前面的位数相加为$last$，在左分支处，由于后面的数可以随便枚举，所以我们利用这个性质直接累加$f[i+1][j][mod(-last,p)]$即可得到种类数。故此按照数位$DP$步骤易解。</p>
</li>
<li>
<p><strong>代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:数字游戏Ⅱ
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 18:23
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">12</span><span class="p">][</span><span class="mi">12</span><span class="p">][</span><span class="mi">110</span><span class="p">];</span><span class="c1">//f[i][j][k]表示i位数，最高位是j，其模n的余数是k的方案数。
</span></span></span><span class="line"><span class="cl"><span class="c1">//预处理也是一个dp过程。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">mod</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//由于c++中的%负数会得到负数，所以我们需要做一个偏移。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="n">y</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">%</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//预处理f数组。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">%</span><span class="n">p</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">p</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">x</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="n">mod</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">,</span><span class="n">p</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span><span class="c1">//存储切出来的位数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">),</span><span class="n">n</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//last存储前面数字之和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//走左边分支。为了凑成模n余0，则接下来的所有位数相加+last模n为0，所以我们来个-last即可。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">mod</span><span class="p">(</span><span class="o">-</span><span class="n">last</span><span class="p">,</span><span class="n">p</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">last</span><span class="o">+=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">&amp;&amp;</span><span class="n">last</span><span class="o">%</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">ans</span><span class="o">++</span><span class="p">;</span><span class="c1">//判断本身是否符合条件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="36-不要62httpacmhdueducnshowproblemphppid2089" class="heading-element"><span>3.6 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089"target="_blank" rel="external nofollow noopener noreferrer">3.6 不要62<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#36-%e4%b8%8d%e8%a6%8162httpacmhdueducnshowproblemphppid2089" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p><strong>题面</strong></p>
<blockquote>
<p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。
杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。
不吉利的数字为所有含有4或62的号码。例如：
62315 73418 88914
都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。
你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p>
<p>Input</p>
<p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p>
<p>Output</p>
<p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p>
<p>Sample Input</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 100
</span></span><span class="line"><span class="cl">0 0</span></span></code></pre></td></tr></table>
</div>
</div><p>Sample Output</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">80</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>解题思路</strong></p>
<p>这道题相对来说比较简单，因为预处理这一部分我们很容易想到。用$f[i][j]$表示$i$位数字且最高位为$j$的方案数。那么我们排除掉特殊情况进行状态转移即可。代码附详细注释。</p>
</li>
<li>
<p><strong>代码</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@filename:不要62
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@author: pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@csdn:unique_pursuit
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@email: 2825841950@qq.com
</span></span></span><span class="line"><span class="cl"><span class="cm">  *@created: 2021-05-12 19:56
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">11</span><span class="p">];</span><span class="c1">//f[i][j]表示i位数且最高位为j的方案数。
</span></span></span><span class="line"><span class="cl"><span class="c1">//那么我们来对这个进行分析，对于f[i][j]这个状态，我们根据题意我们转移的f[i-1][k]必须满足k!=4,j!=4.
</span></span></span><span class="line"><span class="cl"><span class="c1">//并且jk!=62.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//排除4的情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">((</span><span class="n">j</span><span class="o">==</span><span class="mi">6</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span><span class="o">||</span><span class="n">k</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span><span class="c1">//存储分割位数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//last保存上一位的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">),</span><span class="n">n</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//走左边分支，我们需要判断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">4</span><span class="o">||</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">2</span><span class="o">&amp;&amp;</span><span class="n">last</span><span class="o">==</span><span class="mi">6</span><span class="p">))</span><span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="o">+=</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">4</span><span class="o">||</span><span class="p">(</span><span class="n">last</span><span class="o">==</span><span class="mi">6</span><span class="o">&amp;&amp;</span><span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">))</span><span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">last</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span><span class="n">ans</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">l</span><span class="o">||</span><span class="n">r</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">dp</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="37-恨7不成妻httpacmhdueducnshowproblemphppid4507" class="heading-element"><span>3.7 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4507"target="_blank" rel="external nofollow noopener noreferrer">3.7 恨7不成妻<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></span>
  <a href="#37-%e6%81%a87%e4%b8%8d%e6%88%90%e5%a6%bbhttpacmhdueducnshowproblemphppid4507" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>由于此题太过变态，已单开一篇blog讲解： <a href="https://unique-pure.github.io/pages/243024/"target="_blank" rel="external nofollow noopener noreferrer">点这里<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。</p>
<h2 id="数位dp总结" class="heading-element"><span>4 数位DP总结</span>
  <a href="#%e6%95%b0%e4%bd%8ddp%e6%80%bb%e7%bb%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>做了这么多的题，我们发现数位$DP$确实是有套路的，难点就在于预处理，通常就是要用$DP$来预处理，这里推荐大家学一下闫式$DP$分析法。预处理完之后，就可以套路做题了。当然，学$DP$一定要多刷题，所以请各位一定要多多刷题哦！</p>
]]></description></item><item><title>树状数组详解(一维+二维+差分+前缀和+公式优化)</title><link>https://hezephyr.github.io/posts/02.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/</link><pubDate>Tue, 27 Apr 2021 19:58:24 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/</guid><description><![CDATA[<h2 id="问题引入" class="heading-element"><span>1 问题引入</span>
  <a href="#%e9%97%ae%e9%a2%98%e5%bc%95%e5%85%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>有这样一个问题:现在有这样一个数列$a$，你需要进行下面两种操作：</p>
<ul>
<li>将某一个数加上 $x$</li>
<li>求出某区间$[l,r]$每一个数的和</li>
</ul>
<p>数列长度为$n( 1\leq n \leq 10^5)$，操作总数为$p(1\leq p \leq 10^5)$，时间限制为$1s$，如果是你你该如何处理？</p>
<p>我们先来看看暴力能否出奇迹，<font color="red">对于单点修改操作，我们确实能在$O(1)$的时间完成，而对于区间求和操作，那么我们累加求和的时间复杂度为$O(r-l+1)$，在最坏的情况下，高达$O(n)$</font> ，这样算下来，处理这个问题需要$O(np)$的时间复杂度，$1s$是处理不完的。</p>
<p>那么，区间求和前缀和又是否可以呢？我们发现，如果用前缀和处理实际上就是让区间求和变为$O(1)$，而让单点修改就变为$O(n)$了，这样并没有任何变化。所以暴力做法肯定是不行的。</p>
<p>学过线段树的同学一定知道怎么写这道题，没学过的可以去学习下，这里指路一篇$blog$:<a href="https://blog.csdn.net/hzf0701/article/details/107859659?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161943932916780271515336%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161943932916780271515336&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-107859659.nonecase&amp;utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91"target="_blank" rel="external nofollow noopener noreferrer">线段树入门<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p>但是，这道题用线段树未免也太大材小用了,况且线段树的代码量也十分多，所以树状数组就出现了，代码量少，简单易实现。我们继续往下看。</p>
<h2 id="树状数组单点修改区间查询" class="heading-element"><span>2 树状数组（单点修改，区间查询）</span>
  <a href="#%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e5%8d%95%e7%82%b9%e4%bf%ae%e6%94%b9%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><strong>树状数组简单剖析</strong></li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png" alt="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png?size=large 2x" data-title="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20240728144649066.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>其中$A$数组是原数组，而$C$数组就是树状数组。为什么要一开始就放图呢？我们来发现一下它们的规律：</p>
<p>$C1 = A1$
$C2 = A1+A2$
$C3 = A3$
$C4 = A1+A2+A3+A4$
$C5 = A5$
$C6 = A5+A6$
$C7 = A7$
$C8 = A1+A2+A3+A4+A5+A6+A7+A8$</p>
<p>我们不难发现：$C[i] = A[i - 2^k+1] + A[i - 2^k+2] + &hellip; + A[i];$， //$k$为$i$的二进制中从最低位到高位连续零的长度，<font color="red">换句话说，$C[i]$管辖了包括$A[i]$自己的前$2^k$个元素</font> ，这样的好处是什么呢？我们发现，如果对某个元素更改了，那么我们只需要更改管辖了这个元素的$C$，那么如果对某个区间$[l,r]$求和，那么我们相当于求$SUM[r]-SUM[l-1]$，而求$SUM[i]$也特别简单，我们只需要求$i$这个点管辖的区间和$C[i]$并统计，再往前跳到未被$i$管辖的区间累加$C$即可，直到到达数组头部。也就是$SUM[i] = C[i] + C[i-2^{k_1 }]+ C[(i - 2^k_1) - 2^k_2] + &hellip;..；$。</p>
<ul>
<li><strong>lowbit函数求解$2^k$</strong></li>
</ul>
<p>那么关键的一个问题来了，我们怎么求$2^k$，我们知道$k$为$i$的二进制中从最低位到高位连续零的长度，所以$2^k=i&amp;(i-1)$，这里不予证明。求$2^k$一般用一个函数来描述，即$lowbit$。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>add函数：单点修改</strong></p>
<p>对于单点修改，我们实际上很好处理，只需要将管辖这个点的$C$全部加上$x$即可，如下：</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">pos</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">+=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pos</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>getSum函数：区间求和</strong></p>
<p>区间求和就是上文中利用的原理，我们很容易就能实现，我们首先要能求前$i$个元素的和，如下：</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">pos</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="o">+=</span><span class="n">c</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">pos</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>​		那么，$[l,r]$区间的和自然易得，即为：<code>getSum(r)-getSum(l-1)</code>。</p>
<ul>
<li>
<p><strong>时间复杂度分析</strong></p>
<p>不难，发现，树状数组实际上就是一棵树，其有$n$个结点，那么易知在单点修改和区间求和的问题处理上都能在$O(log_2n)$的时间内完成。所以总体时间复杂度为$O(nlog_2n)$，是非常有效的。</p>
</li>
</ul>
<h2 id="差分树状数组区间修改单点查询" class="heading-element"><span>3 差分树状数组（区间修改，单点查询）</span>
  <a href="#%e5%b7%ae%e5%88%86%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e5%8c%ba%e9%97%b4%e4%bf%ae%e6%94%b9%e5%8d%95%e7%82%b9%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>原理</strong></p>
<p>我们首先要知道差分数组是什么，和前缀和数组其实离不开关系，$c[i]=SUM[i]-SUM[i-1]$，其中原数组相当于可以看成是存储了相邻两个前缀和的差值，那么映射到差分数组（因为原数组可以看成是存储了差分数组的前缀和）我们可以看成就是存储了相邻两个数之间的差值，即$d[i]=c[i]-c[i-1]$，而$d[1]=c[1]-c[0]=c[1]$，所以我们利用这个关系可以推导出:$a[i]=d[1]+d[2]+&hellip;+d[i]$，那么我们就是将单点查询转化为区间求和了，那么如果对于区间修改呢？对于差分数组，假设修改区间$[l,r]$，让这个区间每个元素$+x$，我们只需要更改$d[l]=d[l]+x$，$d[r+1]=d[r+1]-x$，这样我们保证只会影响到$[l,r]$这个区间的元素。<font color="red">故我们通过差分把这个区间修改、单点查询的问题转化为单点修改区间查询的问题，那么我们存储的树状数组实际和是哪个存储是差分数组的树状数组。</font></p>
</li>
</ul>
<h2 id="差分树状数组公式优化区间修改区间查询" class="heading-element"><span>4 差分树状数组+公式优化（区间修改，区间查询）</span>
  <a href="#%e5%b7%ae%e5%88%86%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e5%85%ac%e5%bc%8f%e4%bc%98%e5%8c%96%e5%8c%ba%e9%97%b4%e4%bf%ae%e6%94%b9%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>原理</strong></p>
<p>刚刚结束了利用差分实现区间修改，单点查询，而对于区间查询，这确实也是个问题。如果我们知道了区间查询，实际上这种类型的题我们就没必要使用线段树去写了，直接用树状数组就可以解决。我们来看，实际上还是利用差分数组，那么如何将区间查询的时间复杂度也变为$O(log_2n)$呢，区间查询的基础是快速求出数组$a[1:n]$的前缀和，而显然数组$a[1:n]$的前缀和为
$$a[1]+a[2]+&hellip;+a[i]=d[1]<em>i+d[2]</em>(i-1)+&hellip;+d[i]<em>1=d[1]</em>(i+1)+d[2]<em>(i+1)+&hellip;+d[i]</em>(i+1)-(d[1]*1+d[2]*2+&hellip;+d[i]<em>i)\
=(i+1)</em>(d[1]+d[2]+&hellip;+d[i])-(d[1]*1+d[2]*2+&hellip;+d[i]*i)$$
，所以我们就可以在原来的数组$c[i]$记录$d[i]$的基础上。再开一个数组记录$d[i]*i$即可。这样，我们就实现了区间查询。</p>
</li>
</ul>
<h2 id="二维树状数组单点修改区间查询" class="heading-element"><span>5 二维树状数组（单点修改，区间查询）</span>
  <a href="#%e4%ba%8c%e7%bb%b4%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e5%8d%95%e7%82%b9%e4%bf%ae%e6%94%b9%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>解释</strong></p>
<p>数组$C[x]$记录了的是右端点为$x$、长度为$lowbit(x)$的区间的区间和。那么我们也可以类似地定义$C[x][y]$记录的是右下角为$(x,y)$，高为 $lowbit(x)$，宽为$lowbit(y) $的区间的区间和。那么按照一维树状数组去处理即可，这里给出这三个函数。</p>
</li>
<li>
<p><strong>$lowbit$函数</strong></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">&amp;</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>$add$函数</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//在(x,y)处增加value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">y</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">+=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">j</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>$getSum$函数</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果求解[x1,y1]~[x2,y2]之间的和，那么就是getSum(x2,y2)-getSum(x2,y1)-getSum(x1,y2)+getSum(x1,y1).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">y</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">-=</span><span class="n">lowbit</span><span class="p">(</span><span class="n">j</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="o">+=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二维差分树状数组区间修改单点查询" class="heading-element"><span>6 二维差分树状数组（区间修改，单点查询）</span>
  <a href="#%e4%ba%8c%e7%bb%b4%e5%b7%ae%e5%88%86%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e5%8c%ba%e9%97%b4%e4%bf%ae%e6%94%b9%e5%8d%95%e7%82%b9%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>二维差分树状数组推导</strong></p>
<p>处理这个问题，我们首先要知道二维差分数组怎么表示，那么还是和二维前缀和数组联系起来，即$c[i,j]=SUM[i,j]-SUM[i-1,j]-SUM[i,j-1]+SUM[i-1,j-1]$，原数组实际上就可以看做是存储了$(i,j)$的前缀和与$(i-1,j)$和$(i,j-1)$的前缀和的差值。 <font color="red">那么映射到二维差分数组即是$d[i,j]=c[i,j]-c[i-1,j]-c[i,j-1]+c[i-1,j-1]$，其中$d[1,1]=c[1,1]$，那么$c[n][m]=\sum_{i=1}^{n}\sum_{j=1}^{m}d[i][j]$，所以对于区间修改，我们是给$(x_1,y_1),(x_2,y_2)$之间形成的矩阵加上$x$，那么实际上我们只需要变动四个点，$d[x_1][x_2]+=x,d[x_1][y_2]-=x,d[x_2][y_1]-=x,d[x_2][y_2]+=x$</font> ，那么这样就和一维差分数组一样了，区间修改单点查询问题我们利用二维差分数组就可以转化为单点修改区间查询了，我们的树状数组则是建立二维差分树状数组。那么这样这三个函数同理也很简单的就可以写出来了。</p>
</li>
</ul>
<h2 id="二维差分树状数组公式推导区间修改区间查询" class="heading-element"><span>7 二维差分树状数组+公式推导（区间修改，区间查询）</span>
  <a href="#%e4%ba%8c%e7%bb%b4%e5%b7%ae%e5%88%86%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84%e5%85%ac%e5%bc%8f%e6%8e%a8%e5%af%bc%e5%8c%ba%e9%97%b4%e4%bf%ae%e6%94%b9%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p><strong>推导</strong></p>
<p>和一维的一样，如果我们需要求解$(x_1,y_1)$和$(x_2,y_2)$形成矩阵的和，同时又要实现区间修改，那么在原有的二维差分树状数组是行不通的，那么我们就需要将区间查询的时间复杂度也降为$log_2n$，我们知道$SUM[i][j]=\sum_{x=1}^i\sum_{y=1}^ja[x][y]$，而$a[x][y]=\sum_{u=1}^x\sum_{v=1}^yd[u][v]$，则$SUM[i][j]=\sum_{x=1}^i\sum_{y=1}^j\sum_{u=1}^x\sum_{v=1}^yd[u][v]$，由于这个公式非常复杂，所以我们可以按照一维差分树状数组那样来统计$d[u][v]$出现了多少次，我们发现，从$a[1][1]$到$a[i][j]$，$d[1][1]$都需要出现一次，则$d[1][1]$出现了$i\times j$次，那么同理$d[1][2]$出现了$i*(j-1)$次，其余同等规律。所以
$$SUM[i][j]=\sum_{x=1}^i\sum_{y=1}^jd[x][y]<em>(i+1-x)</em>(j+1-y)$$</p>
<p>，我们同样可以将这样拆分成四个部分，即
$$SUM[i][j]=(i+1)<em>(j+1)\sum_{x=1}^i\sum_{y=1}^jd[x][y]-(j+1)</em>\sum_{x=1}^i\sum_{y=1}^jx<em>d[x][y]-(i+1) \sum_{x=1}^i\sum_{y=1}^jy</em>d[x][y]+\sum_{x=1}^i\sum_{y=1}^jx<em>y</em>d[x][y]
$$。所以我们只需要在原来$C1[i][j]$记录$d[i][j]$的基础上，再开三个树状数组记录$d[i][j]*i,d[i][j]*j,d[i][j]*ij$即可。这样就可以通过数组$a[i][j]$的差分数组$d[i][j]$来得到$a[i][j]$的前缀和数组$SUM[i][j]$了。</p>
</li>
</ul>
]]></description></item><item><title>Kruskal算法详解</title><link>https://hezephyr.github.io/posts/03.kruskal%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</link><pubDate>Tue, 11 Aug 2020 16:15:34 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.kruskal%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</guid><description><![CDATA[<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Kruskal算法是一种用来查找最小生成树（$MST$）的算法，由Joseph Kruskal在1956年发表。求最小生成树的算法常用有两种：Kruskal算法和Prim算法。这里指路一篇Prim算法的详解blog：<a href="https://blog.csdn.net/hzf0701/article/details/107927858"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/hzf0701/article/details/107927858<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>。与Prim算法不同的是，该算法的核心思想是归并边，而Prim算法的核心思想是归并点。这里我们会在后面的实现过程中看到。</p>
<h2 id="构造过程" class="heading-element"><span>2 构造过程</span>
  <a href="#%e6%9e%84%e9%80%a0%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>假设连通网$N=(V,E)$，将$N$中的边按权值从小到大的顺序排列。
①初始状态为只有$n$个顶点而无边的非连通图$T=(V,{})$，图中每个顶点自成一个连通分量。
②在$E$中选择权值最小的边，若该边依附的顶点落在$T$中不同的连通分量上（即不形成回路），则将此边将入到$T$中，否则舍去此边而选择下一条权值最小的边。
③重复②，直到$T$中所有的顶点都在同一连通分量上为止。</p>
<p>这个算法的构造过程十分简洁明了，那么为什么这样的构造过程能否形成最小生成树呢？我们来看第二个步骤，因为我们选取的边的顶点是不同的连通分量，且边权值是最小的，所以我们保证加入的边都不使得$T$有回路，且权值也最小。这样最后当所有的连通分量都相同时，即所有的顶点都在生成树中被连接成功了，我们构造成的树也就是最小生成树了。</p>
<h2 id="示例" class="heading-element"><span>3 示例</span>
  <a href="#%e7%a4%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322333.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="算法实现" class="heading-element"><span>4 算法实现</span>
  <a href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>步骤：
①将存储边的数组temp按权值从小到大排序，注意进行运算符重载。
②初始化连通分量数组$verx$。
③依次查看数组temp的边，循环执行以下操作。</p>
<ul>
<li>依次从排好序的数组temp中选出一条边$(u,v)$；</li>
<li>在$verx$中分别查找$u$和$v$所在的连通分量$v_1和v_2$，进行判断。
<ul>
<li>如果$v_1$和$v_2$不等，说明所选的两个顶点分别属于不同的连通分量，则将此边存入最小生成树$tree$，并合并$v_1$和$v_2$这个两个连通分量。</li>
<li>如果$v_1$和$v_2$相等，则说明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;bits/stdc++.h&gt; </span><span class="c1">//POJ不支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define rep(i,a,n) for (int i=a;i&lt;=n;i++)</span><span class="c1">//i为循环变量，a为初始值，n为界限值，递增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define per(i,a,n) for (int i=a;i&gt;=n;i--)</span><span class="c1">//i为循环变量， a为初始值，n为界限值，递减。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define pb push_back
</span></span></span><span class="line"><span class="cl"><span class="cp">#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define fi first
</span></span></span><span class="line"><span class="cl"><span class="cp">#define se second
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mp make_pair
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span><span class="c1">//无穷大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span><span class="c1">//最大值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">,</span> <span class="n">ll</span><span class="o">&gt;</span>  <span class="n">pll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">pii</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//*******************************分割线，以上为自定义代码模板***************************************//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">edge</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span><span class="c1">//边的起始顶点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">e</span><span class="p">;</span><span class="c1">//边的终端顶点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span><span class="c1">//边权值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">edge</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">w</span><span class="o">&lt;</span><span class="n">a</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">edge</span> <span class="n">temp</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//临时数组存储边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">verx</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//辅助数组，判断是否连通。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">edge</span> <span class="n">tree</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//最小生成树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span><span class="c1">//n*n的图，m条边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span><span class="c1">//统计生成结点个数，若不满足n个，则生成失败。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span><span class="p">;</span><span class="c1">//最小生成树权值总和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">print</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//打印最小生成树函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;最小生成树的权值总和为：&#34;</span><span class="o">&lt;&lt;</span><span class="n">sum</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="s">&#34;边权值为&#34;</span><span class="o">&lt;&lt;</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Kruskal</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">verx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="c1">//这里表示各顶点自成一个连通分量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sort</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">temp</span><span class="o">+</span><span class="n">m</span><span class="p">);</span><span class="c1">//将边按权值排列。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">v1</span><span class="o">=</span><span class="n">verx</span><span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">s</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">v2</span><span class="o">=</span><span class="n">verx</span><span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">v1</span><span class="o">!=</span><span class="n">v2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">tree</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">s</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">s</span><span class="p">;</span><span class="n">tree</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="p">;</span><span class="n">tree</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">w</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">;</span><span class="c1">//并入最小生成树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//合并v1和v2的两个分量，即两个集合统一编号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">verx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">v2</span><span class="p">)</span><span class="n">verx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">v1</span><span class="p">;</span> <span class="c1">//默认集合编号为v2的改为v1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span><span class="o">+=</span><span class="n">tree</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//结束双层for循环之后得到tree即是最小生成树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//freopen(&#34;in.txt&#34;, &#34;r&#34;, stdin);//提交的时候要注释掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">IOS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">u</span><span class="o">&gt;&gt;</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">s</span><span class="o">=</span><span class="n">u</span><span class="p">;</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">v</span><span class="p">;</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Kruskal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法分析" class="heading-element"><span>5 算法分析</span>
  <a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于有$m$条边和$n$个顶点的图。在$for$循环中最耗时的操作就是合并两个不同的连通分量，第一个循环语句的频度为$m$，第二个循环由于存在$if$语句，所以平均频度是$log_2n$，所以该算法的平均时间复杂度为$O(mlog_2n)$，故和Prim算法相比
此算法适合用于稀疏图。</p>
<h2 id="测试" class="heading-element"><span>6 测试</span>
  <a href="#%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>以示例数据为测试样例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">7</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">4</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">3</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">5</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">5</span> <span class="mi">15</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">6</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="mi">7</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="mi">6</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="mi">5</span> <span class="mi">5</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试结果如图：
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214322630.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>线段树入门</title><link>https://hezephyr.github.io/posts/01.%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</link><pubDate>Fri, 07 Aug 2020 12:17:56 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</guid><description><![CDATA[<p>前言：理解线段树着实花了我很多时间，主要之前一直有个误区，<strong>就是对线段树中存储的信息，我认为只能是区间和，可万万没想到呀，它还可以是别的东西：区间最小值、区间最大值等等呀</strong>，我表示&#x1f464;(已黑化)，好了，言归正传，博主是完全理解了线段树之后才有勇气写这篇文章的，所以我是根据一个完全初学者到理解线段树的过程来写下这篇文章的，不会像其他文章一下难以理解，当然，本文也只是我学习整理的，如果有错误的话，还请评论区留言或私信我，共同进步。</p>
<p>线段树讲解共有两篇，这一篇为入门，另一篇为进阶。</p>
<h2 id="什么是线段树" class="heading-element"><span>1 什么是线段树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e6%ae%b5%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>线段树的基本概念</p>
<p>在深入学习线段树之前，我们首先要了解线段树是什么？线段树本质也是一颗二叉搜索树，也被认为是区间树（即每个结点都有一段区间，我们也认为是线段）。那有小伙伴可能就要问了，什么是二叉搜索树？二叉搜索树顾名思义：<font color="red">前提是一颗二叉树，它的每个结点度都小于等于2，即每个结点最多有两个子树。其次就是搜索，这是关键，我们这个线段树在其中都有一个区间，那么搜索即是可以在这个区间上搜索你想要的值，这就是搜索</font>，其中，每个结点存储的信息是由你来定的，如果你想求区间和，那么就可以存储区间和，如果你想求区间最大值，那么你可以存储区间最大值，只要可行，你都可以进行你想要的操作。</p>
<hr>
</li>
<li>
<p>线段树的注意事项</p>
<ol>
<li>
<p>在给定了大小给定了叶子结点数目的时候这个线段树就已经确定了，我们不能进行添加和删除元素，不是说不能对已有叶子结点赋值，是不能对其进行扩大或者减小。因为在大多数情况中，<strong>对于线段树来说，区间本身都是固定的，不考虑新增和删除元素。所以用数组存储的话，直接用静态数组就好了，不用动态数组</strong>。</p>
</li>
<li>
<p>线段树的大小一定要开叶子结点数目（即原有点对点的数据数组大小）的四倍。<strong>例如叶子结点数目是maxn，那么我们通常会开线段树的大小为maxn&laquo;2。因为线段树也是一颗完全二叉树，当最大的时候可能是满二叉树</strong>。我们来证明一下，我们这样想：最深一层的数目是n，则此线段树的高度为$\lceil$$\log_2n\rceil$,我们可知$\lceil$$\log_2n\rceil$ $\leq$ $log_2n+1$。那么我们通过然后通过等比数列求和公式（$\frac{a_1(1-q^x)}{1-q}$）求得二叉树的节点个数，具体公式为$\frac{1*(1-2^x)}{1-2}$，（$x$为树的层数，为树的高度$+1$），化简可得$2^{log_2n+1+1}-1$,整理之后即为$4n$（近似计算忽略掉-1)</p>
</li>
<li>
<p><strong>我们进行乘除法运算的时候要使用位运算（&laquo;  &raquo;一定要仔细理解这两个运算符），而避免使用基本的数学运算</strong>，因为我们会频繁使用结点坐标更新，用位运算会更快一点，而且还可以防WR。</p>
</li>
<li>
<p>在表示坐标的时候，若一个结点下标为i，那么它的父节点就是i&raquo;1。如果这个结点是这个父节点的左孩子，那么右孩子下标就是i+1。如果这个结点是父节点的右孩子，那么左孩子的下标就是i-1。那个这个结点的左孩子下标就是i&laquo;1，右孩子下标就是(i&laquo;1)=1（<font color="red">这里一定要使用括号改变运算符优先级，因为位运算的优先级属实低。</font>）</p>
</li>
<li>
<p><strong>要根据你想解决的问题来设置结点的数据信息。区间求和和区间最值所进行的是不太一样的，所更改的信息也都要注意，但都是一个本质，就是从下往上更新，到达根节点就退出</strong>。</p>
</li>
<li>
<p>线段树不一定是满二叉树，也就是说线段树的叶子结点不一定是在最后一层。线段树也不一定是完全二叉树（切记！）。但我们可以把线段树看成是满二叉树，对于不存在的结点我们视为空就行。</p>
</li>
</ol>
</li>
<li>
<p>线段树能解决的问题</p>
<p>线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。<font color="red">使用一维线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)</font>。线段树更可以扩充到二维线段树（矩阵树）和三维线段树（空间树），这里我们不作讲解。（其实博主也暂时不会&#x1f604;）</p>
</li>
</ul>
<p>你问我线段树算什么东西？今天我就告诉你，<font color="red">单点、区间朴素查询处理做的我线段树能做！单点、区间朴素查询没有的速度我有！这就是线段树</font>。（战术后仰）</p>
<h2 id="线段树的基本内容" class="heading-element"><span>2 线段树的基本内容</span>
  <a href="#%e7%ba%bf%e6%ae%b5%e6%a0%91%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%86%85%e5%ae%b9" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>我们先看一颗线段树：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20180418142000345.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20180418142000345.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20180418142000345.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20180418142000345.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20180418142000345.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20180418142000345.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>不然发现线段树的特点，<strong>每个结点都有一个值和区间</strong>，每个结点的左右孩子都存储了父结点的一半的区间，且它们的序号是按照层次顺序编号的。<font color="red">在日常处理中，我们通常是使用结构体数组来作为线段树的存储结构，因为这样我们就可以利用下标的关系来找到父节点和孩子结点了</font>。例如我们已知一个结点的下标为i，那么：</p>
<ul>
<li>
<p>对于父结点：i&raquo;1（这个进行的操作其实就是i/2，前面提到，这样会快很多）</p>
<p>具体证明也很简单，把线段树看成一个完全二叉树（空结点也当作使用）对于任意一个结点i来说，它所在此二叉树的$log_2i$ 层，则此层共有$2^{log2(i)}$个结点，同样对于k的左子树那层来说有$2^{log_2{k}+1}$个结点，则结点k和左子树间隔了$2<em>2^{log_2(i)}-i + 2</em>(i-2^{log_2(k)})$个结点，然后这就很简单就得到$k+2<em>2^{log_2(k)}-k + 2</em>(k-2^{log2(k)}) = 2*k$的关系了吧，右子树也就等于左子树结点+1。</p>
</li>
<li>
<p>对于左孩子结点：左孩子下标：i&laquo;1（这些是同理的，即是由父结点推孩子结点。）</p>
</li>
<li>
<p>对于右孩子结点：右孩子下标：i&laquo;1|1</p>
</li>
</ul>
<p>了解了这些关系，我们是有能力去建立一颗线段树的，因为线段树也是树，所以我们自然可以利用递归的思想去建树，不会很难，我也写全了注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span><span class="c1">//最大值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span><span class="p">;</span>  <span class="c1">//左端点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">right</span><span class="p">;</span> <span class="c1">//右端点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span><span class="c1">//代表区间[left,right]的信息，可以是区间和，也可以是区间最值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">node</span><span class="p">[</span><span class="n">maxn</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">];</span><span class="c1">//这里我们要开4倍大小，防止数据溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">father</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//存储原来数据在线段树中的下标，易于从下向上更新区间数据。例如father[i]表示原来的第i个数据在线段树中的下标，这些在线段树中都是叶子结点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">BuildTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="p">;</span><span class="c1">//存储各自结点的区间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>                     <span class="c1">//初始化为0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">){</span>                    <span class="c1">//说明已经到了叶子结点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">father</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="c1">//存储下标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">BuildTree</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">,(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//递归初始化左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">BuildTree</span><span class="p">((</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">);</span><span class="c1">//递归初始化右子树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们的线段树就建好了。我们来看线段树有哪些基本操作吧。</p>
<h2 id="线段树的基本操作" class="heading-element"><span>3 线段树的基本操作</span>
  <a href="#%e7%ba%bf%e6%ae%b5%e6%a0%91%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">我们这里以结点的值value代表区间和来处理</font>。</p>
<h3 id="点更新" class="heading-element"><span>3.1 点更新</span>
  <a href="#%e7%82%b9%e6%9b%b4%e6%96%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这很好办，有没有注意我们是使用了一个father数组，如果我在原数组中修改第i个元素的值，我们是直接可以<code>node[father[i]].value=w</code>，这就是我们使用father数组的好处，那你可能会问了，我们这样是不是要使用三个数组？<strong>大可不必，我们没必要给原有数据开一个数组存放，因为我们本身就已经把数据放在线段树中了，不管线段树中存放的是区间和还是区间最值，对于叶子结点来说，它就是本身</strong>。那么我们加入了点，自然也要更新整棵树，那有关这个叶子结点到根节点的路径自然全部都是要更新的，我们则是从下往上利用递归思想来更新的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">UpdateTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">ri</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ri</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fi</span><span class="o">=</span><span class="n">ri</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span><span class="c1">//获得父结点下标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">node</span><span class="p">[</span><span class="n">fi</span><span class="p">].</span><span class="n">value</span><span class="o">=</span><span class="n">node</span><span class="p">[</span><span class="n">fi</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span><span class="o">+</span><span class="n">node</span><span class="p">[</span><span class="n">fi</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span><span class="p">;</span><span class="c1">//两段区间总和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">UpdateTree</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="区间查询" class="heading-element"><span>3.2 区间查询</span>
  <a href="#%e5%8c%ba%e9%97%b4%e6%9f%a5%e8%af%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们有了线段树，可却不对它进行相关查询，那这颗线段树也只是精致的花瓶而已。我们最重要的就是进行区间查询，现在如果我想知道某个区间和的话，我们应该怎样来处理呢？我们知道根节点是存放了整个区间的信息，然后它的孩子结点则存放了它一半区间的信息，这样则显而易见，我们从根节点开始自上往下查询即可。我们本着下面的思想就一目了然了。</p>
<p><strong>1、如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</strong></p>
<p><strong>2、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</strong></p>
<p><strong>3、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</strong></p>
<p>OK，整活。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//区间查询，调用函数时为QueryTree(1,l,r)，即从根节点自上往下查询。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">QueryTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span><span class="o">&amp;&amp;</span><span class="n">r</span><span class="o">==</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果刚好就是这个区间，我们直接返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sum</span><span class="o">+=</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//说明部分包含左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&lt;=</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//说明全包含在左子树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">sum</span><span class="o">+=</span><span class="n">QueryTree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span><span class="o">+=</span><span class="n">QueryTree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;=</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//说明部分包含右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&gt;=</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//说明全包含在右子树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">sum</span><span class="o">+=</span><span class="n">QueryTree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span><span class="o">+=</span><span class="n">QueryTree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> <span class="c1">//返回求得的区间和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>区间查询不断二分，易知时间复杂度为O($log_2n$)。</p>
<p>线段树的基本操作就是这些，当然，这只是入门，灵活使用线段树以及更深层次的利用线段树的道路还很长，我们一起加油！</p>
<hr>
<p>主函数部分测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">freopen</span><span class="p">(</span><span class="s">&#34;in.txt&#34;</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span><span class="c1">//提交的时候要注释掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="c1">//打消iostream中输入输出缓存，节省时间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">BuildTree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span><span class="p">[</span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">value</span><span class="o">=</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">UpdateTree</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">ch</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">ch</span><span class="o">==</span><span class="sc">&#39;Q&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">QueryTree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">node</span><span class="p">[</span><span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]].</span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">UpdateTree</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="mi">6</span> <span class="mi">5</span> 
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">3</span> <span class="mi">8</span> <span class="mi">23</span> <span class="mi">1</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="mi">1</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="n">S</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="mi">1</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="n">S</span> <span class="mi">3</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="mi">1</span> <span class="mi">6</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试结果：
<a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125212953328.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125212953328.png?size=small" data-sub-html="<h2>在这里插入图片描述</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125212953328.png" alt="在这里插入图片描述" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125212953328.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125212953328.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125212953328.png?size=large 2x" data-title="在这里插入图片描述" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>Dijkstra算法教程</title><link>https://hezephyr.github.io/posts/02.dijkstra%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</link><pubDate>Wed, 29 Jul 2020 16:15:34 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.dijkstra%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</guid><description><![CDATA[<p><strong>PS：此算法不能用于求负权图，要求所有边的权重都为非负值。</strong></p>
<hr>
<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。这是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。<strong>迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止</strong>。</p>
</blockquote>
<hr>
<h2 id="算法思想与原理" class="heading-element"><span>2 算法思想与原理</span>
  <a href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3%e4%b8%8e%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>dijkstra算法思想是基于贪心算法思想的。<strong>所谓贪心算法即始终保持当前迭代解为当前最优解。<strong>意思就是在已知的条件下或是当前拥有的全部条件下保证最优解，若在此后的迭代中由于加入了新的条件使得产生了更优解则替代此前的最优解。通过不断的迭代不断保证每次迭代的结果都是当前</strong>最优解</strong>，那么当迭代到最后一轮时得到的就会是<strong>全局最优解</strong>。 由于下一轮迭代会参考上一轮的最优解，因此<strong>每一轮的迭代的工作量基本一致</strong>，降低了整体工作的复杂性。</p>
</blockquote>
<p>在最短路径的问题中，局部最优解即<strong>当前的最短路径</strong>或者说是在当前的已知条件下起点到其余各点的最短距离。关键就在于已知条件，这也是Dijkstra算法最精妙的地方。我们来解释一下。</p>
<p>对于Dijkstra算法，我们假设初始集合（也就是初始条件）不存在任何顶点的，即所有顶点之间是不存在任何路径的，即我们认为所有顶点之间的距离都是无穷大。那么开始加入新的条件，因为我们已知源点距源点距离最小，所以加入进去，并加入它的边，<strong>在该条件下，更新该源点到其余顶点的最短距离，选出没有加入到已知集合的距源点距离最小的点，此点最短距离也被确定了（因为其他路径都比这条路径大，无法通过其他路径间接到达这个顶点使得路径更小），然后加入该点与其余还未加入已知条件顶点的边，并以该点迭代刷新最短距离</strong>。再重复以上操作，直至所有顶点都加入已知条件集合。</p>
<hr>
<h2 id="具体步骤" class="heading-element"><span>3 具体步骤</span>
  <a href="#%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ol>
<li>选择起点$start$与终点$end$；</li>
<li>所有点除起点外加入未知集合，并将起点加入已知集合，即至标志位为真，意为已确定该点到源点的最短路径；</li>
<li>初始化计算，更新起点与其他各点的耗费$dis(start,n)$;</li>
<li>在未知集合中，选择dis(start,n)中值最小的点x，将x加入已知集合。</li>
<li><strong>对于剩余顶点中，计算$dis(start,n)&gt;dis(start,x)+dis(x,n)$
若真则$dis(start,n)=dis(start,x)+dis(x,n)$，此时start与n点路径经过x点。循环直至goal点加入已知列表，取得$dis(start,goal)$即为最短距离。</strong></li>
</ol>
<hr>
<h2 id="动态展示" class="heading-element"><span>4 动态展示</span>
  <a href="#%e5%8a%a8%e6%80%81%e5%b1%95%e7%a4%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20210322130709747-20231125215629571-20231125215643983.gif?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20210322130709747-20231125215629571-20231125215643983.gif?size=small" data-sub-html="<h2>dijkstra</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20210322130709747-20231125215629571-20231125215643983.gif" alt="dijkstra" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20210322130709747-20231125215629571-20231125215643983.gif?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20210322130709747-20231125215629571-20231125215643983.gif?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/20210322130709747-20231125215629571-20231125215643983.gif?size=large 2x" data-title="dijkstra" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="一般代码实现以邻接矩阵为例" class="heading-element"><span>5 一般代码实现（以邻接矩阵为例）</span>
  <a href="#%e4%b8%80%e8%88%ac%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e4%bb%a5%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e4%b8%ba%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="基本数据" class="heading-element"><span>5.1 基本数据</span>
  <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span><span class="o">=</span><span class="mh">0x3f3f3f3f</span><span class="p">;</span> <span class="c1">//代表无穷大。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span><span class="c1">//最大顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span><span class="c1">//n个顶点，m条边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//判断是否确定到源点的最终最短距离。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">graph</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//带权图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//顶点到源点的最短距离。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span><span class="n">goal</span><span class="p">;</span><span class="c1">//起点与目标点。
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化" class="heading-element"><span>5.2 初始化</span>
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">visited</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="c1">//初始化dis数组。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="dijkstra算法核心" class="heading-element"><span>5.3 dijkstra算法核心</span>
  <a href="#dijkstra%e7%ae%97%e6%b3%95%e6%a0%b8%e5%bf%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//源点为源点start。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">minn</span><span class="p">;</span><span class="c1">//记录每趟最短路径中最小的路径值。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span><span class="c1">//记录得到的minn所对应的下标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">init</span><span class="p">();</span><span class="c1">//调用初始化函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//将n个顶点依次加入判断。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">minn</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">minn</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">minn</span><span class="o">=</span><span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">				<span class="n">pos</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">visited</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span><span class="c1">//我们将此点并入已知集合。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dis</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">+</span><span class="n">graph</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">				<span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dis</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">+</span><span class="n">graph</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dis</span><span class="p">[</span><span class="n">goal</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出目标点到源点的最短路径长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="主函数与头文件等" class="heading-element"><span>5.4 主函数与头文件等</span>
  <a href="#%e4%b8%bb%e5%87%bd%e6%95%b0%e4%b8%8e%e5%a4%b4%e6%96%87%e4%bb%b6%e7%ad%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;bits/stdc++.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">memset</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">inf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">u</span><span class="o">&gt;&gt;</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//			graph[u][v]=w;//有向图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span><span class="c1">//无向图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">start</span><span class="o">&gt;&gt;</span><span class="n">goal</span><span class="p">;</span><span class="c1">//输入起点与终点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">dijkstra</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="拓展" class="heading-element"><span>6 拓展</span>
  <a href="#%e6%8b%93%e5%b1%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如果你学会了dijkstra，那恭喜你成功突破了一关。但是，没有优化的dijkstra算法时间复杂度为$O(n^2)$，如果顶点很多边很少呢等等卡邻接矩阵的题，那么建议你还是要学一下dijkstra的优化版了。详情点击：<a href="https://blog.csdn.net/hzf0701/article/details/107674290?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163080838116780269879915%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=163080838116780269879915&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-107674290.pc_v2_rank_blog_default&amp;utm_term=dijkstra&amp;spm=1018.2226.3001.4450"target="_blank" rel="external nofollow noopener noreferrer">Dijkstra算法优化~~你一定可以看懂的四种进阶优化<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
]]></description></item><item><title>Prim算法详解</title><link>https://hezephyr.github.io/posts/04.prim%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</link><pubDate>Wed, 29 Jul 2020 11:34:35 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/04.prim%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</guid><description><![CDATA[<h2 id="最小生成树mst" class="heading-element"><span>1 最小生成树（MST）</span>
  <a href="#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91mst" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在一给定的无向图$G = (V, E)$ 中，$(u, v)$代表连接顶点$u$ 与顶点 $v$ 的边，而 $w(u, v)$ 代表此边的权重，<strong>若存在 $T$ 为 $E$ 的子集且为无循环图，使得 $w(T)$ 最小，则此 $T$ 为 $G$ 的最小生成树</strong>，因为$T$是由图$G$产生的。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/2020081109252713.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>最小生成树其实是最小权重生成树的简称。我们称求取该生成树的问题成为最小生成树问题。<font color="red">一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和</font>。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为<strong>最小生成森林</strong>。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/format%2Cpng-20231125214418948.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如图，这个是一个平面图，图中黑色线描述的就是最小生成树，它的权值之和小于其他的生成树。</p>
<p>那么，我们如何来求最小生成树呢，由最小生成树的定义我们可以知道构建最小生成树是可以利用贪心算法去实现的，我们接下来介绍的两种算法也都是利用贪心算法去求得$MST$的。<strong>因为贪心算法的策略就是在每一步尽可能多的选择中选择最优的，在当前看是最好的选择</strong>，这种策略虽然一般不能在全局中寻找到最优解，但是对于最小生成树问题来说，它的确可以找到一颗权重最小的树。</p>
<h2 id="prim算法" class="heading-element"><span>2 Prim算法</span>
  <a href="#prim%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="简介" class="heading-element"><span>2.1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>普里姆算法（Prim&rsquo;s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。（来源于维基百科）</p>
<h3 id="具体步骤" class="heading-element"><span>2.2 具体步骤</span>
  <a href="#%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>Prim算法是利用贪心算法实现的，我们确定根节点，从这个结点出发。普里姆算法按照以下步骤<font color="red">逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点</font>。下面描述我们<font color="red">假设$N=(V,E)$是连通网，$TE$是$N$上最小生成树中边的集合</font>。</p>
<p>①  $U={u_0}(u_0∈V) ,TE= {}$。</p>
<p>​    ②  在所有$u∈U,v∈(V-U)$的边$(u,v)∈E$找到一条权值最小的边$(u_0,v_0)$并入集合$TE$，同时$v_0$并入集合$U$。</p>
<p>③  重复②步骤，知道$U=V$为止。</p>
<p>此时$TE$中必有$n-1$条边，则$T=(V,TE)$即为我们求得的$N$的最小生成树。</p>
<h3 id="算法示例图" class="heading-element"><span>2.3 算法示例图</span>
  <a href="#%e7%ae%97%e6%b3%95%e7%a4%ba%e4%be%8b%e5%9b%be" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214359908.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="算法实现" class="heading-element"><span>2.4 算法实现</span>
  <a href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们如果对Dijkstra算法很熟悉的话，Prim算法也很好实现了，它们都是利用了一样的思路，但却不相同。<font color="red">我们用利用$lowcost$数组来表示到集合中最近的距离，用$closest$数组来表示最小生成树的边。怎么来表示呢？我们用顶点来形容边，也就是说我们要求的就是$closet$数组。其中$closest[i]$表示的值就是与$i$顶点相邻边的顶点序号</font>。具体看代码（附带打印最小生成树代码）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;bits/stdc++.h&gt; </span><span class="c1">//POJ不支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define rep(i,a,n) for (int i=a;i&lt;=n;i++)</span><span class="c1">//i为循环变量，a为初始值，n为界限值，递增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define per(i,a,n) for (int i=a;i&gt;=n;i--)</span><span class="c1">//i为循环变量， a为初始值，n为界限值，递减。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define pb push_back
</span></span></span><span class="line"><span class="cl"><span class="cp">#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define fi first
</span></span></span><span class="line"><span class="cl"><span class="cp">#define se second
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mp make_pair
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span><span class="c1">//无穷大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">;</span><span class="c1">//最大值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">ll</span><span class="p">,</span> <span class="n">ll</span><span class="o">&gt;</span>  <span class="n">pll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">pii</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//*******************************分割线，以上为自定义代码模板***************************************//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span><span class="c1">//图的大小和边数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">graph</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">lowcost</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">closest</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//lowcost[i]表示i到距离集合最近的距离，closest[i]表示i与之相连边的顶点序号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span><span class="p">;</span><span class="c1">//计算最小生成树的权值总和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Prim</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化操作，获取基本信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">lowcost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">lowcost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">closest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">minn</span><span class="p">,</span><span class="n">pos</span><span class="p">;</span><span class="c1">//距离集合最近的边，pos代表该点的终边下标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">minn</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//找出距离点集合最近的边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">lowcost</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">lowcost</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">minn</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">minn</span><span class="o">=</span><span class="n">lowcost</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">pos</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">minn</span><span class="o">==</span><span class="n">inf</span><span class="p">)</span><span class="k">break</span><span class="p">;</span><span class="c1">//说明没有找到。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sum</span><span class="o">+=</span><span class="n">minn</span><span class="p">;</span><span class="c1">//计算最小生成树的权值之和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">lowcost</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//加入点集合。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//由于点集合中加入了新的点，我们要去更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">lowcost</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">graph</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">lowcost</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="n">lowcost</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">closest</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">pos</span><span class="p">;</span><span class="c1">//改变与顶点j相连的顶点序号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">sum</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//closest数组就是我们要的最小生成树。它代表的就是边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//打印最小生成树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//等于s自然不算，故除去这个为n-1条边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="o">=</span><span class="n">closest</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">temp</span><span class="o">&lt;&lt;</span><span class="s">&#34;-&gt;&#34;</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34;边权值为：&#34;</span><span class="o">&lt;&lt;</span><span class="n">graph</span><span class="p">[</span><span class="n">temp</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//freopen(&#34;in.txt&#34;, &#34;r&#34;, stdin);//提交的时候要注释掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">IOS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">memset</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">inf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span><span class="c1">//初始化。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">;</span><span class="c1">//临时变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">u</span><span class="o">&gt;&gt;</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//视情况而论，我这里以无向图为例。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//任取根结点，我这里默认取1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Prim</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//打印最小生成树。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="算法分析" class="heading-element"><span>2.5 算法分析</span>
  <a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于此算法，我们图中有$n$个顶点，则第一个进行初始化的循环语句的频度为$n$,第二个循环语句的频度为$n$，<font color="red">但其中第二个循环中有两个内循环：第一个是在$lowcost$中求最小值，其频度为$n$，第二个是重新选择具有最小权值的边，频度为$n$</font>，由此我们可知Prim算法的时间复杂度为$O(n^2)$，与图中的边数无关，故十分适合于稠密图。</p>
<h3 id="测试" class="heading-element"><span>2.6 测试</span>
  <a href="#%e6%b5%8b%e8%af%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们用示例来测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="mi">7</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">4</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">3</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">5</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">5</span> <span class="mi">15</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">6</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="mi">7</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="mi">6</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="mi">5</span> <span class="mi">5</span></span></span></code></pre></td></tr></table>
</div>
</div><p>测试结果如图：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png?size=small" data-sub-html="<h2>https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png" alt="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png?size=large 2x" data-title="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6ZjA3MDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231125214400441.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>Floyd算法教程</title><link>https://hezephyr.github.io/posts/01.floyd%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 27 Jul 2020 16:15:34 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.floyd%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B/</guid><description><![CDATA[<h2 id="简介" class="heading-element"><span>1 简介</span>
  <a href="#%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，可以正确处理有向图或无向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。</p>
<h2 id="算法原理" class="heading-element"><span>2 算法原理</span>
  <a href="#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在给出的一张具有权值图中，我们已知每个顶点v与每个顶点u中的最短距离(即使无法到达，我们也认为是有距离的，但距离为无穷大）。对于最短距离表示，我们用<code>dis[v][u]</code>来表示顶点v到顶点u的最短距离，一开始没进行任何操作时，则表示他们的最短距离，就是顶点v到达顶点u的直接距离。</p>
<p>OK，那么如果我现在有一个中转站（中转顶点temp），我先从顶点v到达顶点temp，再从顶点temp到达顶点u，则这段距离我们可以表示为<code>dis[v][temp]+dis[temp][u]</code>，如果这段距离比我们目前的直接到达方式更小的话，那么我们不就可以更新我们的最短距离<code>dis[v][u]</code>了吗？那么temp这个中转顶点可以是图中的所有顶点，如果我们不断把所有顶点插入作为中转顶点，再不断更新最短距离，最后，得到的<code>dis[n][n]</code>自然是多源点之间的最短路径了。我们由上述推导也可求得我们的状态转移方程<code>dis[v][u]=min(dis[v][u],dis[v][temp]+dis[temp][u])</code>，这就是Floyd算法的思想与原理，不断插入中转顶点，利用动态规划思想来实现。</p>
<p>这里我们还要记录最短路径的方案，针对有些要求最短路径方案的题，我们用<code>path[v][u]</code>的值来记录顶点v到顶点u的中转顶点，若为-1则表示无中转顶点。</p>
<h2 id="邻接矩阵解题模板" class="heading-element"><span>3 邻接矩阵解题模板</span>
  <a href="#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e8%a7%a3%e9%a2%98%e6%a8%a1%e6%9d%bf" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>存储结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span><span class="c1">//maxn表示图的最大顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">graph</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="c1">//图的实际顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//最短距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span><span class="o">=</span><span class="mh">0x3f3f3f3f</span><span class="p">;</span><span class="c1">//代表无穷大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">path</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//记录中转顶点
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//Floyd算法核心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">floyd</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//顶点数目。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span><span class="c1">//循环变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">memset</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span><span class="n">inf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dis</span><span class="p">));</span><span class="c1">//调用这个函数需包含memory.h头文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">memset</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//初始化dis。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//不断插点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//对图中所有点之间的最短距离进行更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span><span class="c1">//记录中转顶点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="c1">//更新。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">   	    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们现在来输出最短路径，由于我们记录了中转顶点，那么我们可以借助我们求得的<code>path数组</code>来实现。如果<code>path[i][j]</code>的值不为-1的话，说明这个值就为中转顶点，可这样最短路径就求出来了吗？显然不是，我们还要继续判断i和k之间以及k和j之间有没有中转顶点。我们可以利用递归思想来实现这个方法输出最短路径。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_path</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//说明没有中转顶点，直接返回.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">print_path</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="c1">//寻找i和k之间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">print_path</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">);</span><span class="c1">//寻找k和j之间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最后，再设置一个打印我们所求的结果的方法，比较简单，核心就是上面两个函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_result</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">inf</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">//我们先前说过，无法到达我们设置距离为无穷大，则他们之前没有路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34;和&#34;</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="s">&#34;之间没有路径&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34;和&#34;</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="s">&#34;的最短路径为&#34;</span><span class="o">&lt;&lt;</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;路径方案为：&#34;</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="n">print_path</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="邻接表解题模板" class="heading-element"><span>4 邻接表解题模板</span>
  <a href="#%e9%82%bb%e6%8e%a5%e8%a1%a8%e8%a7%a3%e9%a2%98%e6%a8%a1%e6%9d%bf" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>存储结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">arc</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//边的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">adjust</span><span class="p">;</span><span class="c1">//该边所指向的顶点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span><span class="c1">//该边的权值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">arc</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//指向一条边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">arc</span><span class="p">,</span><span class="o">*</span><span class="n">arclink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">vex</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">arclink</span> <span class="n">firstarc</span><span class="p">;</span><span class="c1">//该顶点的第一条边。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">vex</span><span class="p">,</span><span class="n">vexs</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">graph</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vexs</span> <span class="n">adj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arcnum</span><span class="p">;</span><span class="c1">//边数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">vexnum</span><span class="p">;</span><span class="c1">//顶点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">graph</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">graph</span> <span class="n">G</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>//初始化操作就不在这写了，最短距离还是用<code>dis[maxn][maxn]</code>表示，中转站顶点用<code>path[maxn][maxn]</code>毕竟我们的核心是解决Floyd算法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">floyd</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化dis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">)</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">));</span><span class="c1">//初始化path数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">arclink</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="c1">//辅助作用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">=</span><span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstarc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//此操作是为了记录所有顶点之间的距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">adjust</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">wight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//到了这一步，就跟上面的是一样了，因为我们已经得到了dis数组和path数组的值了。下面利用dp并记录中转顶点，同种套路。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>二分查找的奇技淫巧</title><link>https://hezephyr.github.io/posts/01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Tue, 21 Jan 2020 16:15:34 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description><![CDATA[<h2 id="二分搜索升天词" class="heading-element"><span>1 二分搜索升天词</span>
  <a href="#%e4%ba%8c%e5%88%86%e6%90%9c%e7%b4%a2%e5%8d%87%e5%a4%a9%e8%af%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>转自：<a href="https://zhuanlan.zhihu.com/p/79553968"target="_blank" rel="external nofollow noopener noreferrer">labuladong<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/v2-a56776ec0125789e6169e715f3a4a22d_720w.webp?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/v2-a56776ec0125789e6169e715f3a4a22d_720w.webp?size=small" data-sub-html="<h2>二分搜索升天词</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/v2-a56776ec0125789e6169e715f3a4a22d_720w.webp" alt="二分搜索升天词" srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/v2-a56776ec0125789e6169e715f3a4a22d_720w.webp?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/v2-a56776ec0125789e6169e715f3a4a22d_720w.webp?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/v2-a56776ec0125789e6169e715f3a4a22d_720w.webp?size=large 2x" data-title="二分搜索升天词" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="手写二分查找模板" class="heading-element"><span>2 手写二分查找模板</span>
  <a href="#%e6%89%8b%e5%86%99%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e6%a8%a1%e6%9d%bf" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>二分模板一共有两个，分别适用于不同情况。
算法思路：假设目标值在闭区间$[l, r]$中， 每次将区间长度缩小一半，当$l = r$时，我们就找到了目标值。</p>
<h3 id="版本1" class="heading-element"><span>2.1 版本1</span>
  <a href="#%e7%89%88%e6%9c%ac1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>当我们将区间$[l, r]$划分成$[l, mid]$和$[mid + 1, r]$时，其更新操作是$r = mid$或者$l = mid + 1$;，计算$mid$时不需要加$1$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">binary_search_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="版本2" class="heading-element"><span>2.2 版本2</span>
  <a href="#%e7%89%88%e6%9c%ac2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>当我们将区间$[l, r]$划分成$[l, mid-1]$和$[mid, r]$时，其更新操作是$r = mid - 1$或者$l = mid$;，此时为了防止死循环，计算$mid$时需要加$1$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">binary_search_2</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// check为判断函数，我们自己手写的规则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="利用c自带的lower_bound和upper_bound函数" class="heading-element"><span>3 利用C++自带的lower_bound和upper_bound函数</span>
  <a href="#%e5%88%a9%e7%94%a8c%e8%87%aa%e5%b8%a6%e7%9a%84lower_bound%e5%92%8cupper_bound%e5%87%bd%e6%95%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="自带函数源码" class="heading-element"><span>3.1 自带函数源码</span>
  <a href="#%e8%87%aa%e5%b8%a6%e5%87%bd%e6%95%b0%e6%ba%90%e7%a0%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><code>lower_bound</code>：返回一个迭代器，迭代器指向[first, last)不小于val的第一个元素。<strong>如果范围内的所有元素比较小于val，则函数返回last。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardIterator</span> <span class="n">lower_bound</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ForwardIterator</span> <span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span> <span class="n">count</span><span class="p">,</span> <span class="n">step</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">count</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">step</span><span class="o">=</span><span class="n">count</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">advance</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">step</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="o">&lt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">// or: if (comp(*it,val)), for version (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">first</span><span class="o">=++</span><span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">count</span><span class="o">-=</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="n">count</span><span class="o">=</span><span class="n">step</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>upper_bound</code>：返回一个迭代器，迭代器指向[first, last)大于val的第一个元素。<strong>如果范围内的所有元素比较都不大于val，则函数返回last。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardIterator</span> <span class="n">upper_bound</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ForwardIterator</span> <span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span> <span class="n">count</span><span class="p">,</span> <span class="n">step</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">step</span><span class="o">=</span><span class="n">count</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">advance</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">step</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span><span class="o">&lt;*</span><span class="n">it</span><span class="p">))</span>                 <span class="c1">// or: if (!comp(val,*it)), for version (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span> <span class="n">first</span><span class="o">=++</span><span class="n">it</span><span class="p">;</span> <span class="n">count</span><span class="o">-=</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="n">count</span><span class="o">=</span><span class="n">step</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>根据源码，我们很容易就可以使用它们，不用自己手写了，但如果需要自定义比较规则，实际上就是需要我们实现一个check函数即可。</p>
<h3 id="进阶自定义比较规则" class="heading-element"><span>3.2 进阶—自定义比较规则</span>
  <a href="#%e8%bf%9b%e9%98%b6%e8%87%aa%e5%ae%9a%e4%b9%89%e6%af%94%e8%be%83%e8%a7%84%e5%88%99" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在 C++ 中有很多情况下，我们需要自定义比较器，无非就是三种情况：</p>
<ol>
<li>对一个自定义的 <code>struct</code> 重写它的 <code>operator &lt;</code> 方法</li>
<li>定义一个``Comparator`函数</li>
<li>定义一个<code>Comparator</code>结构体对象</li>
</ol>
<ul>
<li>
<p><strong>自定义结构体</strong></p>
<p>如果我们自定义了一个<code>struct</code>，然后想要对其排序又不想额外写一个比较器，那么最好实现它的 <code>operaotr &lt;</code> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">node</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="c1">// 注意这两个const，必须要加上，否则会报错，前者const是能接收非const和const的实参，后者const是表明该函数不会修改类成员变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们就可以使用了。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="s">&#34;111&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">node</span><span class="p">(</span><span class="s">&#34;111&#34;</span><span class="p">))</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>函数比较器</strong></p>
<p>可以通过编写一个外部的比较器函数，实现 <code>&lt;</code> 功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;111&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>函数对象比较器</strong></p>
<p>所谓函数对象是指实现了 <code>operator ()</code> 的类或者结构体。可以用这样的一个对象来代替函数作为比较器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">cmper</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;111&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmper</span><span class="p">());</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></description></item></channel></rss>