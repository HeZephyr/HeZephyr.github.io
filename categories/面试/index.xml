<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>面试 - 分类 | ZephyrHe</title><link>https://hezephyr.github.io/categories/%E9%9D%A2%E8%AF%95/</link><description>面试 - 分类 | ZephyrHe</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>unique.hzf@gmail.com (HeZephyr)</managingEditor><webMaster>unique.hzf@gmail.com (HeZephyr)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Sun, 02 Jun 2024 19:45:50 +0000</lastBuildDate><atom:link href="https://hezephyr.github.io/categories/%E9%9D%A2%E8%AF%95/" rel="self" type="application/rss+xml"/><item><title>计算机网络 面试题目总结</title><link>https://hezephyr.github.io/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</link><pubDate>Sun, 02 Jun 2024 19:45:50 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="基础" class="heading-element"><span>1 基础</span>
  <a href="#%e5%9f%ba%e7%a1%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="计算机网络体系结构" class="heading-element"><span>1.1 计算机网络体系结构</span>
  <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型包括 OSI 七层模型、TCP/IP 四层模型和五层体系结构。<font color="red">OSI 是理论上的网络通信模型，TCP/IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。</font></p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/计算机网络体系结构.png?size=small" data-sub-html="<h2>image-20240601203255272</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png" alt="image-20240601203255272" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84.png?size=large 2x" data-title="image-20240601203255272" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="说说-osi-七层模型" class="heading-element"><span>1.2 说说 OSI 七层模型？</span>
  <a href="#%e8%af%b4%e8%af%b4-osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>OSI七层模型是一个用来描述计算机网络体系结构的标准模型。它将网络通信划分为七个抽象层，每一层都负责特定的功能，从物理连接到应用程序。这些层从下到上分别是：</p>
<ol>
<li>物理层（Physical Layer）：负责传输比特流，并管理物理介质。</li>
<li>数据链路层（Data Link Layer）：处理帧的传输，通过物理地址进行寻址。</li>
<li>网络层（Network Layer）：负责数据包的路由和转发，实现不同网络之间的通信。</li>
<li>传输层（Transport Layer）：提供端到端的可靠数据传输，包括错误检测、流量控制和分段重组。</li>
<li>会话层（Session Layer）：负责建立、管理和终止会话连接，以及数据的同步和恢复。</li>
<li>表示层（Presentation Layer）：处理数据的格式化和表示，确保不同系统的数据格式能够互相理解。</li>
<li>应用层（Application Layer）：提供用户与网络服务的接口，包括各种应用程序和协议，如HTTP、FTP和SMTP。</li>
</ol>
<h3 id="说说-tcpip-四层模型" class="heading-element"><span>1.3 说说 TCP/IP 四层模型？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcpip-%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP/IP 合并了 OSI 的部分层次，专注于高效的网络通信实践，更具实用性。</p>
<ol>
<li>网络接口层（Network Interface Layer）：对应于 OSI 模型的物理层和数据链路层。负责数据帧的物理传输，包括硬件地址寻址（MAC 地址），数据封装和解封装，错误检测和纠正等。</li>
<li>网际层（Internet Layer）对应于 OSI 模型的网络层。主要协议是 IP，负责数据包的寻址和路由。这一层还包括 ICMP 协议。</li>
<li>传输层（Transport Layer）：对应于 OSI 模型的传输层。负责提供端到端的数据传输服务，包括数据分割、流量控制、错误恢复等。主要的协议有 TCP 和 UDP</li>
<li>应用层（Application Layer）：对应于 OSI 模型的会话层、表示层和应用层。包括所有与网络有关的高级协议，如 HTTP、FTP、SMTP 等。</li>
</ol>
<h3 id="说说五层体系结构" class="heading-element"><span>1.4 说说五层体系结构？</span>
  <a href="#%e8%af%b4%e8%af%b4%e4%ba%94%e5%b1%82%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>是对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p>
<ul>
<li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li>
<li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li>
<li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li>
<li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li>
<li>物理层：电缆、光纤、无线电频谱、网络适配器等。</li>
</ul>
<h3 id="说一下每一层对应的网络协议有哪些" class="heading-element"><span>1.5 说一下每一层对应的网络协议有哪些？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e6%af%8f%e4%b8%80%e5%b1%82%e5%af%b9%e5%ba%94%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
  <thead>
      <tr>
          <th style="text-align: center">OSI七层网络模型</th>
          <th style="text-align: center">TCP/IP四层模型</th>
          <th style="text-align: center">对应的网络协议</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">应用层</td>
          <td style="text-align: center">应用层</td>
          <td style="text-align: center">HTTP、DNS、FTP、NFS、WAIS、SMIP、Telnet、SNMP</td>
      </tr>
      <tr>
          <td style="text-align: center">表示层</td>
          <td style="text-align: center">应用层</td>
          <td style="text-align: center">TIFF、GIF、JPEG、PICT</td>
      </tr>
      <tr>
          <td style="text-align: center">会话层</td>
          <td style="text-align: center">应用层</td>
          <td style="text-align: center">RPC、SQL、NFS、NetBIOS、names、AppleTalk</td>
      </tr>
      <tr>
          <td style="text-align: center">传输层</td>
          <td style="text-align: center">传输层</td>
          <td style="text-align: center">TCP、UDP</td>
      </tr>
      <tr>
          <td style="text-align: center">网络层</td>
          <td style="text-align: center">网络层</td>
          <td style="text-align: center">IP、ICMP、ARP、RAPP、RIP、IPX</td>
      </tr>
      <tr>
          <td style="text-align: center">数据链路层</td>
          <td style="text-align: center">网络接口层</td>
          <td style="text-align: center">FDDI、Frame Relay、HDLC、PPP</td>
      </tr>
      <tr>
          <td style="text-align: center">物理层</td>
          <td style="text-align: center">网络接口层</td>
          <td style="text-align: center">EIA/TIA-232、EIA/TIA-499</td>
      </tr>
  </tbody>
</table>
<h3 id="数据在各层之间是怎么传输的呢" class="heading-element"><span>1.6 数据在各层之间是怎么传输的呢？</span>
  <a href="#%e6%95%b0%e6%8d%ae%e5%9c%a8%e5%90%84%e5%b1%82%e4%b9%8b%e9%97%b4%e6%98%af%e6%80%8e%e4%b9%88%e4%bc%a0%e8%be%93%e7%9a%84%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。</p>
<ul>
<li>发送方的应用进程向接收方的应用进程传送数据</li>
<li>AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li>
<li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li>
<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>
<li>最后的物理层，进行比特流的传输</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=small" data-sub-html="<h2>数据在各层之间的传输</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg" alt="数据在各层之间的传输" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg?size=large 2x" data-title="数据在各层之间的传输" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p><font color="red">这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</font></p>
<h2 id="网络综合" class="heading-element"><span>2 网络综合</span>
  <a href="#%e7%bd%91%e7%bb%9c%e7%bb%bc%e5%90%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="从浏览器地址栏输入-url-到显示主页的过程" class="heading-element"><span>2.1 从浏览器地址栏输入 URL 到显示主页的过程</span>
  <a href="#%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%9c%b0%e5%9d%80%e6%a0%8f%e8%be%93%e5%85%a5-url-%e5%88%b0%e6%98%be%e7%a4%ba%e4%b8%bb%e9%a1%b5%e7%9a%84%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>从在浏览器地址栏输入 URL 到显示主页的过程包括多个步骤，涵盖了 DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 响应、浏览器处理响应并渲染页面等多个环节。</p>
<ol>
<li><strong>DNS 解析</strong>：浏览器发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址。</li>
<li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接（通常是通过 443 端口进行 SSL 加密的 HTTPS 连接）。这一步涉及到 TCP 的三次握手过程，确保双方都准备好进行数据传输。</li>
<li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求消息，包括请求行（如 GET / HTTP/1.1）、请求头（包含用户代理、接受的内容类型等信息）和请求体（如果有）；将请求发送到服务器。</li>
<li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理（可能包括数据库查询等），生成 HTTP 响应消息；响应消息包括状态行（如 HTTP/1.1 200 OK）、响应头（内容类型、缓存控制等信息）和响应体（请求的资源内容）。</li>
<li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li>
<li><strong>断开连接</strong>：TCP 四次挥手，连接结束</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=small" data-sub-html="<h2>image-20240601205448054</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png" alt="image-20240601205448054" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/input_url_example.png?size=large 2x" data-title="image-20240601205448054" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="各个过程都使用了哪些协议" class="heading-element"><span>2.2 各个过程都使用了哪些协议？</span>
  <a href="#%e5%90%84%e4%b8%aa%e8%bf%87%e7%a8%8b%e9%83%bd%e4%bd%bf%e7%94%a8%e4%ba%86%e5%93%aa%e4%ba%9b%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>DNS:获取域名对应的IP</li>
<li>TCP:与服务器建立连接和断开连接</li>
<li>IP：使用TCP协议时，网络层需要使用IP协议。</li>
<li>OPSF：IP数据包在路由器之间，路由选择使用OPSF协议</li>
<li>ARP：路由器再与服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议</li>
<li>HTTP：TCP连接建立完成之后，使用HTTP协议传递HTTP报文</li>
</ul>
<h3 id="说说-dns-的解析过程" class="heading-element"><span>2.3 说说 DNS 的解析过程？</span>
  <a href="#%e8%af%b4%e8%af%b4-dns-%e7%9a%84%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DNS 的全称是 <strong>Domain Name System</strong>，也就是域名解析系统，它可以将域名映射到对应的 IP 地址上，比如说我们访问 <code>www.google.com</code>，实际上访问的是谷歌的一台服务器，它的 IP 地址是 <code>xxx.xxx.xxx.xxx</code>。可以通过 IP 地址直接访问服务器，但不方便记忆，所以就有了域名系统。域名到 IP 之间的映射，就需要 DNS 来完成。</p>
<p>假设我们在浏览器地址栏里键入了<code>www.google.com</code>：</p>
<ol>
<li>浏览器会首先检查自己的缓存中是否有这个域名对应的 IP 地址，如果有，直接返回；如果没有，进入下一步。</li>
<li>检查本地 DNS 缓存是否有该域名的记录。</li>
<li>如果没有，向<strong>根域名服务器</strong>发送请求，根域名服务器将请求指向更具体的服务，如 <code>com</code> 顶级域名服务器。</li>
<li>顶级域名服务器再将请求指向权限域名服务器，通常由域名注册机构直接管理，所以机构会提供对应的 DNS 解析服务，将域名和谷歌服务器绑定起来。</li>
<li>最终，浏览器使用获得的 IP 地址发起一个 HTTP 请求到目标服务器，然后该服务器返回所请求的网页内容。</li>
</ol>
<h3 id="说说-websocket-与-socket-的区别" class="heading-element"><span>2.4 说说 WebSocket 与 Socket 的区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-websocket-%e4%b8%8e-socket-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>
<p>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>
</li>
<li>
<p><strong>WebSocket</strong>: 是一种网络协议，属于应用层协议。它是在单个 TCP 连接上进行全双工通信的协议，设计用于浏览器和服务器之间的通信，用来解决 <strong>http 不支持持久化连接</strong>的问题。</p>
</li>
<li>
<p>Socket 一个是<strong>网络编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</p>
</li>
<li>
<p><strong>Socket</strong>工作在传输层，可以基于 TCP 或 UDP 协议。它需要开发者自己处理数据的发送和接收、连接的建立和断开等低层次的细节。</p>
</li>
<li>
<p><strong>WebSocket</strong>工作在应用层，<strong>依赖于 TCP 协议</strong>。<font color="red">WebSocket 在初次连接时通过 HTTP 请求进行握手，一旦连接建立，后续的数据传输都在 WebSocket 协议上进行</font>，浏览器和服务器都可以主动向对方发送数据，保持连接直到显式断开。</p>
</li>
<li>
<p><strong>Socket</strong>传输的是字节流，需要开发者自行定义数据的格式和协议。<strong>WebSocket</strong>传输的是文本帧或二进制帧，协议本身定义了消息的格式，能够直接发送 JSON 或二进制数据，方便开发者使用。</p>
</li>
</ul>
<h3 id="说一下你了解的端口及对应的服务" class="heading-element"><span>2.5 说一下你了解的端口及对应的服务？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e4%bd%a0%e4%ba%86%e8%a7%a3%e7%9a%84%e7%ab%af%e5%8f%a3%e5%8f%8a%e5%af%b9%e5%ba%94%e7%9a%84%e6%9c%8d%e5%8a%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
  <thead>
      <tr>
          <th style="text-align: left">端口</th>
          <th style="text-align: center">服务</th>
          <th style="text-align: center">用途</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">21</td>
          <td style="text-align: center">FTP(文件传输协议)</td>
          <td style="text-align: center">用于在计算机之间传输文件</td>
      </tr>
      <tr>
          <td style="text-align: left">22</td>
          <td style="text-align: center">SSH</td>
          <td style="text-align: center">用于远程登录、文件传输和命令行界面交互</td>
      </tr>
      <tr>
          <td style="text-align: left">23</td>
          <td style="text-align: center">Telnet(远程登录服务)</td>
          <td style="text-align: center">允许用户从一台计算机登录到另一台计算机</td>
      </tr>
      <tr>
          <td style="text-align: left">53</td>
          <td style="text-align: center">DNS域名解析服务</td>
          <td style="text-align: center">将域名转换为IP地址以便访问网站</td>
      </tr>
      <tr>
          <td style="text-align: left">80</td>
          <td style="text-align: center">HTTP超文本传输协议</td>
          <td style="text-align: center">用于在万维网上交换信息</td>
      </tr>
      <tr>
          <td style="text-align: left">443</td>
          <td style="text-align: center">HTTPS</td>
          <td style="text-align: center">提供安全的HTTP通信</td>
      </tr>
      <tr>
          <td style="text-align: left">1080</td>
          <td style="text-align: center">SOCKS</td>
          <td style="text-align: center">用于在计算机之间安全地传输数据。它通过代理服务器来隐藏原始的IP地址和端口号，从而提供匿名性和安全性</td>
      </tr>
      <tr>
          <td style="text-align: left">3306</td>
          <td style="text-align: center">MySQL默认端口号</td>
          <td style="text-align: center">用于MySQL数据库服务器上的数据访问</td>
      </tr>
  </tbody>
</table>
<h2 id="http" class="heading-element"><span>3 HTTP</span>
  <a href="#http" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说-http-常用的状态码及其含义" class="heading-element"><span>3.1 说说 HTTP 常用的状态码及其含义？</span>
  <a href="#%e8%af%b4%e8%af%b4-http-%e5%b8%b8%e7%94%a8%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81%e5%8f%8a%e5%85%b6%e5%90%ab%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 响应状态码是由服务器返回给客户端，用于表示对请求的响应结果。</p>
<p>这些状态码分为五个不同的类别，每个类别用一个数字开头，共有三位数：</p>
<ul>
<li>1XX：<strong>信息性状态码</strong>，临时的响应，客户端应继续请求。</li>
<li>2XX：<strong>成功状态码</strong>，请求已成功被服务器接收。</li>
<li>3XX：<strong>重定向状态码</strong>，用来重定向。</li>
<li>4XX：<strong>客户端错误状态码</strong>，请求可能出错。</li>
<li>5XX：<strong>服务器错误状态码</strong>，服务器在尝试处理请求时发生了错误。</li>
</ul>
<p>常见HTTP状态码如下：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">状态码</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">101 <strong>Switching Protocols</strong></td>
          <td style="text-align: center">切换请求协议</td>
      </tr>
      <tr>
          <td style="text-align: center">200 <strong>OK</strong></td>
          <td style="text-align: center">请求成功</td>
      </tr>
      <tr>
          <td style="text-align: center">301 <strong>Moved Permanently</strong></td>
          <td style="text-align: center">请求资源永久移动，返回新URI</td>
      </tr>
      <tr>
          <td style="text-align: center">302 <strong>Found</strong></td>
          <td style="text-align: center">请求资源临时移动，继续使用原有URI</td>
      </tr>
      <tr>
          <td style="text-align: center">400 <strong>Bad Request</strong></td>
          <td style="text-align: center">客户端请求的语法错误，服务端无法理解</td>
      </tr>
      <tr>
          <td style="text-align: center">401 <strong>Unauthorized</strong></td>
          <td style="text-align: center">当前请求需要认证</td>
      </tr>
      <tr>
          <td style="text-align: center">403 <strong>Forbidden</strong></td>
          <td style="text-align: center">服务器拒绝请求，客户端无权访问该资源</td>
      </tr>
      <tr>
          <td style="text-align: center">404 <strong>Not Found</strong></td>
          <td style="text-align: center">请求的资源在服务器上不存在</td>
      </tr>
      <tr>
          <td style="text-align: center">500 <strong>Internal Server Error</strong></td>
          <td style="text-align: center">服务器内部错误</td>
      </tr>
  </tbody>
</table>
<h3 id="http-有哪些请求方式" class="heading-element"><span>3.2 HTTP 有哪些请求方式？</span>
  <a href="#http-%e6%9c%89%e5%93%aa%e4%ba%9b%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 协议定义了多种请求方式，用以指示请求的目的。常见的请求方式有 GET、POST、DELETE、PUT。<font color="red">在正确实现的条件下，GET、HEAD、PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是</font>（每次发送 POST 请求，服务器可能会生成新的资源 ID 或处理生成的唯一值（如订单号、事务 ID）。因此，重复发送 POST 请求会导致创建多个不同的资源或多次执行某个操作）。</p>
<ul>
<li><strong>GET</strong>：请求检索指定的资源。应该只用于获取数据，并且是幂等的，即多次执行相同的 GET 请求应该返回相同的结果，并且不会改变资源的状态。</li>
<li><strong>POST</strong>：向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。可能会创建新的资源或修改现有资源。</li>
<li><strong>DELETE</strong>：删除指定的资源。</li>
<li><strong>PUT</strong>：用于替换指定的资源。如果指定的资源不存在，创建一个新资源。</li>
<li><strong>HEAD</strong>：类似于 GET 请求，但只请求响应头信息，不会返回响应体。常用于检查资源是否存在以及资源的元数据（如检查链接是否有效）。</li>
<li><strong>OPTIONS</strong>：请求服务器返回该资源所支持的所有 HTTP 方法。常用于检查服务器的功能或资源的通信选项。</li>
<li><strong>PATCH</strong>：用于对资源进行部分修改，而不是完全替代资源。</li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试和诊断。</li>
<li><strong>CONNECT</strong>：用于将请求连接转换为透明的 TCP/IP 隧道，通常用于 HTTPS 通过代理服务器的请求。</li>
</ul>
<h3 id="http-的-get-方法可以实现写操作吗" class="heading-element"><span>3.3 HTTP 的 GET 方法可以实现写操作吗?</span>
  <a href="#http-%e7%9a%84-get-%e6%96%b9%e6%b3%95%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e5%86%99%e6%93%8d%e4%bd%9c%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>严格来说，HTTP 的 GET 方法不应该用于实现写操作，因为它设计为一种安全的、幂等的读取操作。GET 请求的主要作用是从服务器获取资源，而不应对服务器上的数据进行任何修改。</p>
<p>但是，实际上，有些 Web 应用可能会滥用 GET 请求进行写操作，例如通过在 URL 中传递参数来修改服务器上的数据。这种做法是不推荐的，主要有以下几个原因：</p>
<ol>
<li><strong>安全性</strong>：GET 请求会将参数包含在 URL 中，这使得敏感数据容易暴露，且容易受到攻击（如 CSRF 攻击）。</li>
<li><strong>缓存问题</strong>：GET 请求通常会被缓存，而缓存的 GET 请求不应引发服务器状态的变化。如果 GET 请求用于写操作，可能会导致缓存的副作用。</li>
<li><strong>幂等性和安全性</strong>：HTTP 标准要求 GET 请求是幂等的（多次相同的请求应产生相同的结果）和安全的（不应对服务器状态产生副作用）。使用 GET 实现写操作违背了这些原则。</li>
</ol>
<h3 id="说一下-get-和-post-的区别" class="heading-element"><span>3.4 说一下 GET 和 POST 的区别？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b-get-%e5%92%8c-post-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>
<p>从 HTTP 报文层面：</p>
<ul>
<li>
<p>GET 请求：将请求参数放在 URL 中，因此 URL 的长度有限制。数据在 URL 中传输，不安全，容易被窃取。</p>
</li>
<li>
<p>POST 请求：将请求参数放在请求体中，没有长度限制。数据在报文体中传输，相对更安全。</p>
</li>
</ul>
</li>
<li>
<p>从幂等性和安全性：</p>
<ul>
<li>
<p>GET 请求：</p>
<ul>
<li>幂等性：多次请求不会改变服务器状态，每次结果相同。</li>
<li>安全性：不会对服务器资源进行修改。</li>
</ul>
</li>
<li>
<p>POST 请求：</p>
<ul>
<li>
<p>不幂等：每次请求可能导致服务器状态变化（如创建资源）。</p>
</li>
<li>
<p>不安全：请求会对服务器资源进行修改。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>从其他层面：</p>
<ul>
<li>GET 请求：能够被缓存，减轻服务器负担。能够保存在浏览器的浏览记录里。URL 可以保存为浏览器书签。</li>
<li>POST 请求：<font color="red">不能被缓存，不保存在浏览器历史记录里</font>。URL 不便于保存为书签。</li>
</ul>
</li>
</ol>
<h3 id="get-的长度限制是多少" class="heading-element"><span>3.5 GET 的长度限制是多少？</span>
  <a href="#get-%e7%9a%84%e9%95%bf%e5%ba%a6%e9%99%90%e5%88%b6%e6%98%af%e5%a4%9a%e5%b0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 中的 GET 方法是通过 URL 传递数据的，<font color="red">但是 URL 本身其实并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器</font>。</p>
<p>例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。</p>
<p>这个长度限制也不是针对数据部分，而是针对整个 URL。</p>
<h3 id="http-请求的过程与原理" class="heading-element"><span>3.6 HTTP 请求的过程与原理？</span>
  <a href="#http-%e8%af%b7%e6%b1%82%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%8e%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 全称是超文本传输协议（HyperText Transfer Protocol），是一个基于请求与响应模式的应用层协议，基于 TCP/IP 协议传输数据。</p>
<p>HTTP 遵循标准的客户端-服务器模型，客户端打开连接以发出请求，然后等待它收到服务器端响应。</p>
<ul>
<li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li>
<li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li>
<li>服务器收到请求后，会根据请求的信息处理请求。</li>
<li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li>
<li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li>
</ul>
<p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。<font color="red">这个过程是同步的</font>，也就是说，客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</p>
<h3 id="说一下-http-的报文结构" class="heading-element"><span>3.7 说一下 HTTP 的报文结构？</span>
  <a href="#%e8%af%b4%e4%b8%80%e4%b8%8b-http-%e7%9a%84%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP 的报文结构可以分为两类：请求报文和响应报文。两者在结构上相似，都包含了<strong>起始行</strong>、<strong>头部</strong>和<strong>消息正文</strong>。</p>
<ul>
<li>
<p><strong>请求报文结构</strong></p>
<ol>
<li>
<p><strong>请求行 (Request Line)</strong></p>
<ul>
<li><strong>方法 (Method)</strong>：如 GET、POST、PUT、DELETE 等。</li>
<li><strong>请求目标 (Request-URI)</strong>：即请求的资源路径。</li>
<li><strong>HTTP 版本 (HTTP-Version)</strong>：如 HTTP/1.1。</li>
</ul>
</li>
<li>
<p><strong>请求头部 (Request Headers)</strong></p>
<ul>
<li>包含多个首部字段，每个字段由字段名和字段值组成。</li>
<li>用于提供客户端信息、请求的资源信息等。</li>
</ul>
<p><strong>常见请求头</strong>：</p>
<ul>
<li><code>Host</code>：请求的主机名和端口。</li>
<li><code>User-Agent</code>：发起请求的客户端信息。</li>
<li><code>Accept</code>：客户端可接受的响应内容类型。</li>
<li><code>Content-Type</code>：请求体的媒体类型。</li>
<li><code>Authorization</code>：认证信息。</li>
</ul>
</li>
<li>
<p><strong>空行</strong>：用于分隔请求头部和请求主体。</p>
</li>
<li>
<p><strong>请求主体 (Request Body)</strong>：包含实际要发送给服务器的数据，仅在 POST、PUT 等方法中存在。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="err">GET</span> <span class="err">/index.html</span> <span class="err">HTTP/1.1</span>
</span></span><span class="line"><span class="cl"><span class="nf">Host</span><span class="o">:</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
</span></span><span class="line"><span class="cl"><span class="nf">User-Agent</span><span class="o">:</span> <span class="n">Mozilla</span>/5.0
</span></span><span class="line"><span class="cl"><span class="nf">Accept</span><span class="o">:</span> <span class="n">text</span>/<span class="n">html</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>响应报文结构</strong></p>
<ol>
<li>
<p><strong>状态行 (Status Line)</strong></p>
<ul>
<li>
<p><strong>HTTP 版本 (HTTP-Version)</strong>：如 HTTP/1.1。</p>
</li>
<li>
<p><strong>状态码 (Status Code)</strong>：如 200、404、500 等。</p>
</li>
<li>
<p><strong>原因短语 (Reason-Phrase)</strong>：对状态码的简短描述。</p>
</li>
</ul>
</li>
<li>
<p><strong>响应头部 (Response Headers)</strong></p>
<ul>
<li>包含多个首部字段，每个字段由字段名和字段值组成。</li>
<li>用于提供服务器信息、响应的资源信息等。</li>
</ul>
<p><strong>常见响应头</strong>：</p>
<ul>
<li><code>Date</code>：响应生成的日期和时间。</li>
<li><code>Content-Type</code>：响应体的媒体类型。</li>
<li><code>Content-Length</code>：响应体的长度。</li>
<li><code>Set-Cookie</code>：设置 HTTP Cookie。</li>
</ul>
</li>
<li>
<p><strong>空行</strong>：用于分隔响应头部和响应主体。</p>
</li>
<li>
<p><strong>响应主体 (Response Body)</strong>：包含实际要返回给客户端的数据。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="err">HTTP/1.1</span> <span class="err">200</span> <span class="err">OK</span>
</span></span><span class="line"><span class="cl"><span class="nf">Date</span><span class="o">:</span> <span class="n">Mon</span><span class="p">,</span> 27 <span class="n">Jul</span> 2009 12:28:53 <span class="n">GMT</span>
</span></span><span class="line"><span class="cl"><span class="nf">Content-Type</span><span class="o">:</span> <span class="n">text</span>/<span class="n">html</span>
</span></span><span class="line"><span class="cl"><span class="nf">Content-Length</span><span class="o">:</span> 138
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">&lt;html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;body&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;h1&gt;Hello,</span> <span class="err">World!&lt;/h1&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;/body&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">&lt;/html&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="uri-和-url-有什么区别" class="heading-element"><span>3.8 URI 和 URL 有什么区别?</span>
  <a href="#uri-%e5%92%8c-url-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
  <thead>
      <tr>
          <th style="text-align: center"><strong>属性</strong></th>
          <th style="text-align: center"><strong>URI</strong></th>
          <th style="text-align: center"><strong>URL</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><strong>定义</strong></td>
          <td style="text-align: center">统一资源标识符，用于标识一个资源</td>
          <td style="text-align: center">统一资源定位符，提供资源的定位方法</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>组成部分</strong></td>
          <td style="text-align: center"><code>[scheme:][//authority][path][?query][#fragment]</code></td>
          <td style="text-align: center"><code>scheme://authority/path[?query][#fragment]</code>（必须包含scheme（协议），authority（域名/IP），路径）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>例子</strong></td>
          <td style="text-align: center"><code>urn:isbn:0451450523</code>（为URN，不是URL，但是URI）</td>
          <td style="text-align: center"><code>https://www.example.com/index.html</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>子集</strong></td>
          <td style="text-align: center">可以是 URL 或 URN</td>
          <td style="text-align: center">是 URI 的子集</td>
      </tr>
  </tbody>
</table>
<h3 id="说下-http101120-的区别" class="heading-element"><span>3.9 说下 HTTP1.0，1.1，2.0 的区别？</span>
  <a href="#%e8%af%b4%e4%b8%8b-http101120-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><strong>HTTP1.0</strong> 默认短连接，HTTP 1.1 默认长连接，HTTP 2.0 采用<strong>多路复用</strong>。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><strong>特性</strong></th>
          <th style="text-align: center"><strong>HTTP/1.0</strong></th>
          <th style="text-align: center"><strong>HTTP/1.1</strong></th>
          <th style="text-align: center"><strong>HTTP/2.0</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><strong>连接管理</strong></td>
          <td style="text-align: center">短连接（默认每个请求/响应对后都关闭连接）</td>
          <td style="text-align: center">长连接（默认 keep-alive）</td>
          <td style="text-align: center">多路复用（同一连接多请求）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Host 头部</strong></td>
          <td style="text-align: center">不支持</td>
          <td style="text-align: center">支持</td>
          <td style="text-align: center">支持</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>缓存控制</strong></td>
          <td style="text-align: center">简单的 Expires 头部</td>
          <td style="text-align: center">复杂的 Cache-Control 头部</td>
          <td style="text-align: center">同 HTTP/1.1</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>传输编码</strong></td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">支持分块传输编码</td>
          <td style="text-align: center">二进制分帧</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>请求方法</strong></td>
          <td style="text-align: center">GET, POST</td>
          <td style="text-align: center">GET, POST, PUT, DELETE, OPTIONS 等</td>
          <td style="text-align: center">同 HTTP/1.1</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>头部压缩</strong></td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">HPACK 压缩（减少了冗余头部信息的带宽消耗）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>服务器推送</strong></td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">支持</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>流优先级</strong></td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">支持</td>
      </tr>
  </tbody>
</table>
<h3 id="http3-了解吗" class="heading-element"><span>3.10 HTTP/3 了解吗？</span>
  <a href="#http3-%e4%ba%86%e8%a7%a3%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTP/2.0 基于 TCP 协议，而 HTTP/3.0 则基于 QUIC 协议，Quick UDP Connections，直译为快速 UDP 网络连接。</p>
<p>基于 TCP 的 HTTP/2.0，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输的过程中，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据。</p>
<p>而基于 UDP 的 QUIC 协议可以更彻底解决了 HTTP/2 中的队头阻塞问题，让不同的流之间真正的实现相互独立传输，互不干扰。同时，QUIC 协议在传输的过程中就完成了 TLS 加密握手，更直接了。</p>
<p>目前使用最广泛的是哪个HTTP版本还是是 HTTP/2，在 2022 年 1 月达到峰值，占所有网站的 46.9%。</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=small" data-sub-html="<h2>w3techs：使用趋势</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png" alt="w3techs：使用趋势" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/use_trend_example.png?size=large 2x" data-title="w3techs：使用趋势" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="http-如何实现长连接在什么时候会超时" class="heading-element"><span>3.11 HTTP 如何实现长连接？在什么时候会超时？</span>
  <a href="#http-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e8%b6%85%e6%97%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>什么是 HTTP 的长连接？</strong></p>
<ul>
<li>HTTP 分为长连接和短连接，<strong>本质上说的是 TCP 的长短连接</strong>。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法。</li>
<li>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</li>
</ul>
</blockquote>
<p>通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<code>keep-alive</code>，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p>
<p>在什么时候会超时呢？</p>
<ul>
<li>
<p>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，<strong>也可以在 HTTP 的 header 里面设置超时时间</strong></p>
</li>
<li>
<p>TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">tcp_keepalive_intvl = 15
</span></span><span class="line"><span class="cl">tcp_keepalive_probes = 5
</span></span><span class="line"><span class="cl">tcp_keepalive_time = 1800</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="说说-http-与-https-有哪些区别" class="heading-element"><span>3.12 说说 HTTP 与 HTTPS 有哪些区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-http-%e4%b8%8e-https-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li>HTTPS 是 HTTP 的增强版，<font color="red">在 HTTP 的基础上加入了 SSL/TLS 协议，确保数据在传输过程中是加密的</font>。SSL/TLS 需要向 CA（证书权威机构）申请数字证书，用于验证服务器的身份。</li>
<li>HTTP 的默认端⼝号是 <strong>80</strong>，URL 以<code>http://</code>开头；HTTPS 的默认端⼝号是 <strong>443</strong>，URL 以<code>https://</code>开头。</li>
</ol>
<h3 id="为什么要用-https解决了哪些问题" class="heading-element"><span>3.13 为什么要用 HTTPS？解决了哪些问题？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-https%e8%a7%a3%e5%86%b3%e4%ba%86%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用 HTTPS 主要是为了解决 HTTP 传输过程中的一些安全问题，<font color="red">因为 HTTP 是明文传输，所以 HTTPS 在 HTTP 的基础上加入了 SSL/TLS 协议</font>。</p>
<p>HTTPS 主要解决了以下几个问题：</p>
<ul>
<li><strong>窃听风险</strong>：第三方可以截获传输的数据包，获取敏感信息。</li>
<li><strong>篡改风险</strong>：第三方可以在传输过程中篡改数据包，修改数据。</li>
<li><strong>冒充风险</strong>：第三方可以冒充服务器，与客户端通信。</li>
</ul>
<h3 id="https-工作流程是怎样的" class="heading-element"><span>3.14 HTTPS 工作流程是怎样的？</span>
  <a href="#https-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTPS 的连接建立在 SSL/TLS 握手之上，工作流程如下图所示：</p>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=small" data-sub-html="<h2>image-20240601233926542</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png" alt="image-20240601233926542" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/HTTPS_workload_Example.png?size=large 2x" data-title="image-20240601233926542" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。</p>
<p>HTTPS 在不同阶段会使用不同的加密方式：</p>
<ul>
<li>非对称加密：在握手阶段使用，特别是在密钥交换过程中。非对称加密使用公钥和私钥，其中公钥可以公开，私钥保密。客户端使用公钥加密信息，服务器使用私钥解密。</li>
<li>对称加密：在完成握手后，所有的数据传输都使用对称加密。对称加密使用相同的密钥进行加密和解密，这种加密方式比非对称加密更快。</li>
</ul>
<h3 id="https-会加密-url-吗" class="heading-element"><span>3.15 HTTPS 会加密 URL 吗？</span>
  <a href="#https-%e4%bc%9a%e5%8a%a0%e5%af%86-url-%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>HTTPS 通过 SSL/TLS 协议确保了客户端与服务器之间交换的数据被加密，这包括 HTTP 头部和正文。而 URL 是 HTTP 头部的一部分，因此这部分信息也是加密的。但因为涉及到 SSL 握手的过程，所以域名信息会被暴露出来，需要注意。</p>
<h3 id="客户端怎么去校验证书的合法性" class="heading-element"><span>3.16 客户端怎么去校验证书的合法性？</span>
  <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e6%80%8e%e4%b9%88%e5%8e%bb%e6%a0%a1%e9%aa%8c%e8%af%81%e4%b9%a6%e7%9a%84%e5%90%88%e6%b3%95%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>首先，所有的证书都是由 CA 机构签发的，CA 机构是一个受信任的第三方机构，它会对证书的申请者进行身份验证，然后签发证书，它具有极高的可信度。</p>
<p>客户端（通常是浏览器，通常会集成 CA 的公钥信息）在校验证书的合法性时，主要通过以下步骤来校验证书的合法性。</p>
<ul>
<li>浏览器会读取证书的所有者、有效期、颁发者等信息，先校验网站域名是否一致，然后校验证书的有效期是否过期；</li>
<li>浏览器开始查找内置的 CA，与服务器返回证书中的颁发者进行对比，确认是否为合法机构；</li>
<li>如果是，从内部植入的 CA 公钥解密 Certificate 的 Signature 内容，得到⼀个 Hash 值 H2；</li>
<li>使⽤同样的 Hash 算法获取证书的 Hash 值 H1，⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则告警。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=small" data-sub-html="<h2>三分恶面渣逆袭：证书签名和客户端校验-来源参考</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png" alt="三分恶面渣逆袭：证书签名和客户端校验-来源参考" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/CA_Example_1.png?size=large 2x" data-title="三分恶面渣逆袭：证书签名和客户端校验-来源参考" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="如何理解-http-协议是无状态的" class="heading-element"><span>3.17 如何理解 HTTP 协议是无状态的？</span>
  <a href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-http-%e5%8d%8f%e8%ae%ae%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这个<code>无状态</code>的的<code>状态</code>值的是什么？是客户端的状态，所以字面意思，就是 HTTP 协议中服务端不会保存客户端的任何信息。</p>
<p>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p>
<blockquote>
<p><strong>那有什么办法记录状态呢？</strong></p>
<p>主要有两个办法，Session 和 Cookie。</p>
</blockquote>
<h3 id="说说-session-和-cookie-有什么联系和区别" class="heading-element"><span>3.18 说说 Session 和 Cookie 有什么联系和区别?</span>
  <a href="#%e8%af%b4%e8%af%b4-session-%e5%92%8c-cookie-%e6%9c%89%e4%bb%80%e4%b9%88%e8%81%94%e7%b3%bb%e5%92%8c%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器（<font color="red">通过 HTTP 请求头的 <code>Cookie</code> 字段在客户端和服务器之间传递</font>）。服务端可以根据这个 Cookie 判断用户的身份和状态。Cookie可以设置过期时间。如果不设置过期时间，则 Cookie 在会话结束（浏览器关闭）时失效。可以通过设置 <code>Expires</code> 或 <code>Max-Age</code> 属性来定义 Cookie 的持久性。</li>
<li>Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。<font color="red">不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上（客户端只保存 Session ID）</font>。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。Session一般在用户会话结束时（例如关闭浏览器、超时）失效。服务器端可以配置 Session 的过期时间。</li>
</ul>
<p>Session 和 Cookie 联系：依赖于 Cookie 来传递 Session ID（通常是服务器在创建 Session 时设置一个 Cookie 来存储 Session ID）。</p>
<p>Session 和 Cookie 的使用场景也不同：</p>
<ul>
<li><strong>Cookie</strong>：适用于存储用户偏好、登录状态等较小的数据，可以跨页面持久化数据。<font color="red">常用于记录用户信息、跟踪用户行为等</font>。</li>
<li><strong>Session</strong>：适用于存储用户会话中的临时信息，如购物车、登录状态等。<font color="red">更适合需要较高安全性的场景，因为数据存储在服务器端</font>。</li>
</ul>
<blockquote>
<p><strong>分布式环境下 Session 怎么处理呢？</strong></p>
<p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。</p>
<p>可以使用 Redis 等分布式缓存来存储 Session，在多台服务器之间共享。</p>
</blockquote>
<blockquote>
<p><strong>客户端无法使用 Cookie 怎么办？</strong></p>
<p>有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。</p>
<p>这时候怎么办？SessionID 怎么存？怎么传给服务端呢？首先是 SessionID 的存储，可以使用客户端的本地存储，比如浏览器的 sessionStorage。</p>
<p>接下来怎么传呢？</p>
<ul>
<li>拼接到 URL 里：直接把 SessionID 作为 URL 的请求参数</li>
<li>放到请求头里：把 SessionID 放到请求的 Header 里，比较常用。</li>
</ul>
</blockquote>
<h2 id="tcp" class="heading-element"><span>4 TCP</span>
  <a href="#tcp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="详细说一下-tcp-的三次握手机制" class="heading-element"><span>4.1 详细说一下 TCP 的三次握手机制？</span>
  <a href="#%e8%af%a6%e7%bb%86%e8%af%b4%e4%b8%80%e4%b8%8b-tcp-%e7%9a%84%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP（Transmission Control Protocol）是一个<font color="red">面向连接的、可靠的、基于字节流的传输层协议</font>。TCP 通过三次握手机制来建立连接，确保双方准备就绪并能可靠地进行通信。以下是三次握手的详细过程：</p>
<ol start="11">
<li>
<p>第一次握手</p>
<ul>
<li><strong>客户端</strong>：发送一个带有 SYN 标志的 TCP 报文段（称为 SYN 报文段），并选择一个初始序列号 <code>seq = x</code>。</li>
<li><strong>服务器</strong>：收到这个 SYN 报文段后，服务器处于 “SYN_RCVD” 状态。</li>
<li><strong>目的</strong>：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。</li>
</ul>
<p><strong>报文内容</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">客户端 --&gt; 服务器: SYN, <span class="nv">seq</span> <span class="o">=</span> x</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第二次握手</p>
<ul>
<li><strong>服务器</strong>：服务器收到 SYN 报文段后，回复一个带有 SYN 和 ACK 标志的 TCP 报文段（称为 SYN-ACK 报文段）。该报文段中包含服务器选择的初始序列号 <code>seq = y</code>，以及对客户端序列号 <code>x</code> 的确认 <code>ack = x + 1</code>。</li>
<li><strong>客户端</strong>：收到这个 SYN-ACK 报文段后，客户端处于 “ESTABLISHED” 状态。</li>
<li><strong>目的</strong>：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。</li>
</ul>
<p>报文内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">服务器 --&gt; 客户端: SYN, ACK, <span class="nv">seq</span> <span class="o">=</span> y, <span class="nv">ack</span> <span class="o">=</span> x + <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第三次握手</p>
<ul>
<li><strong>客户端</strong>：客户端收到 SYN-ACK 报文段后，回复一个带有 ACK 标志的 TCP 报文段（称为 ACK 报文段）。该报文段中包含对服务器序列号 <code>y</code> 的确认 <code>ack = y + 1</code>。</li>
<li><strong>服务器</strong>：收到这个 ACK 报文段后，服务器处于 “ESTABLISHED” 状态，连接建立完成。</li>
<li><strong>目的</strong>：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。</li>
</ul>
<p><strong>报文内容</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">客户端 --&gt; 服务器: ACK, <span class="nv">seq</span> <span class="o">=</span> x + 1, <span class="nv">ack</span> <span class="o">=</span> y + <span class="m">1</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP三次握手.png" alt="image-20240602101211701" style="zoom: 33%;" />
<h3 id="tcp-握手为什么是三次为什么不能是两次不能是四次" class="heading-element"><span>4.2 TCP 握手为什么是三次，为什么不能是两次？不能是四次？</span>
  <a href="#tcp-%e6%8f%a1%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e6%ac%a1%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e6%98%af%e4%b8%a4%e6%ac%a1%e4%b8%8d%e8%83%bd%e6%98%af%e5%9b%9b%e6%ac%a1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>使用三次握手可以建立一个可靠的连接。这一过程的目的是确保双方都知道对方已准备好进行通信，并同步双方的序列号，从而保持数据包的顺序和完整性。</p>
<p>两次握手无法确保连接的可靠性。具体原因如下：</p>
<ol>
<li><strong>旧的重复报文干扰</strong>：在两次握手情况下，旧的 SYN 报文可能会被错误地当作新的连接请求。如果服务器发送 SYN-ACK 报文后客户端没有响应，服务器会认为连接失败，但实际上客户端可能已经收到了 SYN-ACK 报文，这样就会导致服务器资源浪费和连接不一致。</li>
<li><strong>确认机制不完整</strong>：两次握手不能保证双方都能正确接收到对方的确认报文。服务器无法确认客户端是否收到了自己的 SYN-ACK 报文，而客户端也无法确认服务器是否收到了自己的 SYN 报文。</li>
</ol>
<p>四次握手在正常情况下是多余的，会增加连接建立的复杂性和开销。三次握手已经足够保证连接的可靠性和正确性：</p>
<ol>
<li><strong>增加复杂性和开销</strong>：四次握手会增加额外的一个报文传输，使得连接建立的过程变得复杂，不必要地增加了传输的延迟和开销。</li>
<li><strong>三次握手足够可靠</strong>：三次握手已经可以确保双方都能确认连接的建立，并且可以避免旧的重复报文的干扰，再增加一次握手并不会带来额外的安全性或可靠性提升。</li>
</ol>
<h3 id="三次握手中每一次没收到报文会发生什么情况" class="heading-element"><span>4.3 三次握手中每一次没收到报文会发生什么情况？</span>
  <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%b8%ad%e6%af%8f%e4%b8%80%e6%ac%a1%e6%b2%a1%e6%94%b6%e5%88%b0%e6%8a%a5%e6%96%87%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在TCP三次握手的过程中，每一次没收到报文都会触发重传机制，并最终导致连接建立失败。具体情况如下：</p>
<ol>
<li>
<p>第一次握手：客户端发送 SYN 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果客户端发送的 SYN 报文没有收到服务器的 SYN-ACK 报文（比如报文丢失或服务器没有响应）。</p>
</li>
<li>
<p><strong>处理</strong>：客户端会进行超时重传。客户端在发送 SYN 报文后会启动一个定时器，如果在一定时间内没有收到服务器的响应（SYN-ACK 报文），客户端会重传 SYN 报文。</p>
</li>
<li>
<p><strong>结果</strong>：重传次数达到一定次数（通常是三次）后，客户端会放弃连接，报错并关闭连接请求。</p>
</li>
</ul>
</li>
<li>
<p>第二次握手：服务器发送 SYN-ACK 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果服务器发送的 SYN-ACK 报文没有收到客户端的 ACK 报文（比如报文丢失或客户端没有响应）。</p>
</li>
<li>
<p><strong>处理</strong>：服务器会进行超时重传。服务器在发送 SYN-ACK 报文后也会启动一个定时器，如果在一定时间内没有收到客户端的 ACK 报文，服务器会重传 SYN-ACK 报文。</p>
</li>
<li>
<p><strong>结果</strong>：重传次数达到一定次数后，服务器会放弃连接，报错并关闭连接请求。</p>
</li>
</ul>
</li>
<li>
<p>第三次握手：客户端发送 ACK 报文</p>
<ul>
<li>
<p><strong>情况</strong>：如果客户端发送的 ACK 报文没有收到服务器的确认（ACK 报文本身一般不会单独确认，但此处假设服务器未能进入 ESTABLISHED 状态）。</p>
</li>
<li>
<p><strong>处理</strong>：服务器会因为没有收到 ACK 报文而保持在 SYN-RECEIVED 状态，并可能最终超时并关闭连接。</p>
</li>
<li>
<p><strong>结果</strong>：客户端会认为连接已经建立，并进入 ESTABLISHED 状态，但如果服务器超时关闭连接，客户端在尝试发送数据时会发现连接无法使用，从而报错并关闭连接。</p>
</li>
</ul>
</li>
</ol>
<h3 id="第二次握手传回了-ack为什么还要传回-syn" class="heading-element"><span>4.4 第二次握手传回了 ACK，为什么还要传回 SYN？</span>
  <a href="#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bc%a0%e5%9b%9e%e4%ba%86-ack%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%a6%81%e4%bc%a0%e5%9b%9e-syn" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ACK 标志是为了告诉客户端，它发送的 SYN 报文已经被服务器正确接收。</p>
<p>而传回 SYN 是为了告诉客户端，服务器也希望建立连接，并且响应的确实是客户端发送的报文。</p>
<h3 id="第-3-次握手可以携带数据吗" class="heading-element"><span>4.5 第 3 次握手可以携带数据吗？</span>
  <a href="#%e7%ac%ac-3-%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%8f%af%e4%bb%a5%e6%90%ba%e5%b8%a6%e6%95%b0%e6%8d%ae%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>第 3 次握手是可以携带数据的。此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>
<p>但实际应用中通常不会携带数据，因为在第三次握手中发送数据可能会引发安全和可靠性问题。此时连接还未完全建立，发送数据可能导致数据丢失或安全漏洞。</p>
<p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p>
<h3 id="说说半连接队列和-syn-flood-攻击的关系" class="heading-element"><span>4.6 说说半连接队列和 SYN Flood 攻击的关系？</span>
  <a href="#%e8%af%b4%e8%af%b4%e5%8d%8a%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97%e5%92%8c-syn-flood-%e6%94%bb%e5%87%bb%e7%9a%84%e5%85%b3%e7%b3%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p>半连接队列（Half-Open Connection Queue）是指在 TCP 三次握手过程中，服务器在收到客户端的 SYN 报文后，返回 SYN-ACK 报文并等待客户端的 ACK 报文确认连接的这段时间内，服务器为每个未完成的连接分配的资源队列。</p>
<p><font color="red">SYN Flood 攻击是指攻击者发送大量的 SYN 报文请求与服务器建立连接，但在服务器返回 SYN-ACK 报文后，攻击者不发送最终的 ACK 报文完成握手</font>。这样，服务器的半连接队列会被大量未完成的连接占满，导致服务器资源耗尽，无法处理正常的连接请求，进而造成拒绝服务（Denial of Service，DoS）。</p>
<p>因此，SYN Flood 攻击的核心在于利用半连接队列的有限资源，通过大量伪造的连接请求使服务器无法处理合法用户的连接。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/SYN_Flood_Example.png" alt="2fad1ef85054585e10ddeed7a3346a26" style="zoom:50%;" />
<blockquote>
<p><strong>那有什么应对方案呢？</strong></p>
<p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p>
<ul>
<li><strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li>
<li><strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li>
<li><strong>缩短 SYN-ACK 超时时间</strong>：调整系统的 SYN-ACK 超时时间，使未完成的连接请求能够更快地被清理出队列。</li>
<li><strong>分布式拒绝服务防护（DDoS Protection Services）</strong>：使用专业的 DDoS 防护服务，如 Cloudflare、Akamai 等，这些服务可以在网络边缘过滤恶意流量，减轻服务器的压力。</li>
</ul>
</blockquote>
<h3 id="说说-tcp-四次挥手的过程" class="heading-element"><span>4.7 说说 TCP 四次挥手的过程？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e7%9a%84%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 四次挥手是指 TCP 连接终止时所进行的四个步骤，数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起（通常是客户端），具体过程如下：</p>
<ol>
<li><strong>第一次挥手：FIN 报文</strong>：
<ul>
<li>客户端发送一个 FIN 报文段，表明它已经完成了数据发送，请求关闭连接。客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>报文段格式：<code>FIN=1, seq=x</code>。</li>
</ul>
</li>
<li><strong>第二次挥手：ACK 报文</strong>：
<ul>
<li>服务器接收到 FIN 报文后，返回一个 ACK 报文段，确认收到了关闭请求。发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li>报文段格式：<code>ACK=1, ack=x+1</code>。</li>
<li>此时，服务器可能还需要继续发送数据，因此连接处于半关闭状态。</li>
</ul>
</li>
<li><strong>第三次挥手：FIN 报文</strong>：
<ul>
<li>服务端在完成数据发送后，发送一个 FIN 报文段，表明它也已经完成了数据发送，请求关闭连接。发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li>
<li>报文段格式：<code>FIN=1, seq=y</code>。</li>
</ul>
</li>
<li><strong>第四次挥手：ACK 报文</strong>：
<ul>
<li>客户端接收到 FIN 报文后，返回一个 ACK 报文段，确认收到了关闭请求，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
<li>报文段格式：<code>ACK=1, ack=y+1</code>。</li>
<li>此时，连接正式关闭，双方都完成了连接的释放。</li>
</ul>
</li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP_Close_Example.png" alt="image-20240602130755941" style="zoom: 67%;" />
<h3 id="tcp-挥手为什么需要四次呢" class="heading-element"><span>4.8 TCP 挥手为什么需要四次呢？。</span>
  <a href="#tcp-%e6%8c%a5%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%9b%9b%e6%ac%a1%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h3 id="tcp-四次挥手过程中为什么需要等待-2msl-才进入-closed-关闭状态" class="heading-element"><span>4.9 TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</span>
  <a href="#tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%ad%89%e5%be%85-2msl-%e6%89%8d%e8%bf%9b%e5%85%a5-closed-%e5%85%b3%e9%97%ad%e7%8a%b6%e6%80%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN</strong> 报文段的确认。服务端会超时重传这个 <strong>FIN</strong> 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<blockquote>
<p><strong>为什么等待的时间是 2MSL？</strong></p>
<p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>
</blockquote>
<h3 id="保活计时器有什么用" class="heading-element"><span>4.10 保活计时器有什么用？</span>
  <a href="#%e4%bf%9d%e6%b4%bb%e8%ae%a1%e6%97%b6%e5%99%a8%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer），用于在长时间闲置的 TCP 连接中检测对端是否仍然存活，<strong>并防止连接因为长时间没有活动而被认为是不活跃的而被关闭</strong>。</p>
<p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="close-wait-和-time-wait-的状态和意义" class="heading-element"><span>4.11 <code>CLOSE-WAIT</code> 和 <code>TIME-WAIT</code> 的状态和意义？</span>
  <a href="#close-wait-%e5%92%8c-time-wait-%e7%9a%84%e7%8a%b6%e6%80%81%e5%92%8c%e6%84%8f%e4%b9%89" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>CLOSE-WAIT 状态有什么意义？</strong></p>
</blockquote>
<p>服务端收到客户端关闭连接的请求并确认之后，就会进入 CLOSE-WAIT 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而<font color="red"> CLOSE-WAIT 状态就是为了保证服务端在关闭连接之前将待发送的数据处理完</font>。</p>
<blockquote>
<p><strong>TIME-WAIT 有什么意义？</strong></p>
</blockquote>
<p>TIME-WAIT 状态发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入 TIME-WAIT 状态。</p>
<ul>
<li><strong>防⽌旧连接的数据包</strong></li>
<li><strong>保证连接正确关闭</strong></li>
</ul>
<h3 id="time_wait-状态过多会导致什么问题怎么解决" class="heading-element"><span>4.12 <code>TIME_WAIT</code> 状态过多会导致什么问题？怎么解决？</span>
  <a href="#time_wait-%e7%8a%b6%e6%80%81%e8%bf%87%e5%a4%9a%e4%bc%9a%e5%af%bc%e8%87%b4%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>TIME_WAIT 状态过多会导致什么问题?</strong></p>
</blockquote>
<p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p>
<blockquote>
<p><strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>HTTP 没有使用长连接</li>
<li>HTTP 长连接超时</li>
<li>HTTP 长连接的请求数量达到上限</li>
</ul>
</blockquote>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ol>
<li><strong>端口资源耗尽</strong>：每个处于 <code>TIME_WAIT</code> 状态的连接都会占用一个本地端口。如果 <code>TIME_WAIT</code> 状态的连接过多，可能会导致可用的本地端口资源耗尽，新的连接请求无法分配端口，从而导致服务不可用。</li>
<li><strong>内存和资源占用</strong>：<code>TIME_WAIT</code> 状态的连接会占用一定的系统内存和资源。如果连接过多，会导致系统资源被大量占用，影响服务器的性能和其他应用的运行。</li>
</ol>
<blockquote>
<p><strong>怎么解决 TIME_WAIT 状态过多？</strong></p>
</blockquote>
<ul>
<li>服务器可以设置 <code>SO_REUSEADDR</code> 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li>
<li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li>
</ul>
<h3 id="说说-tcp-报文头部的格式" class="heading-element"><span>4.13 说说 TCP 报文头部的格式？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e6%8a%a5%e6%96%87%e5%a4%b4%e9%83%a8%e7%9a%84%e6%a0%bc%e5%bc%8f" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>一个 TCP 报文段主要由报文段头部（Header）和数据两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mathematica" data-lang="mathematica"><span class="line"><span class="cl"><span class="w">  </span><span class="mi">0</span><span class="w">                   </span><span class="mi">1</span><span class="w">                   </span><span class="mi">2</span><span class="w">                   </span><span class="mi">3</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">          </span><span class="n">Source</span><span class="w"> </span><span class="n">Port</span><span class="w">          </span><span class="o">|</span><span class="w">       </span><span class="n">Destination</span><span class="w"> </span><span class="n">Port</span><span class="w">        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                        </span><span class="n">Sequence</span><span class="w"> </span><span class="n">Number</span><span class="w">                        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                    </span><span class="n">Acknowledgment</span><span class="w"> </span><span class="n">Number</span><span class="w">                      </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">Data</span><span class="w"> </span><span class="o">|</span><span class="n">Reser</span><span class="o">-|</span><span class="w">       </span><span class="n">Flags</span><span class="w">     </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Offset</span><span class="o">|</span><span class="n">ved</span><span class="w">   </span><span class="o">|</span><span class="w">       </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="o">|</span><span class="w">        </span><span class="n">Window</span><span class="w">                </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="p">(</span><span class="mi">4</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w">   </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">bits</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">       </span><span class="n">Checksum</span><span class="w">                </span><span class="o">|</span><span class="w">     </span><span class="n">Urgent</span><span class="w"> </span><span class="n">Pointer</span><span class="w">            </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                       </span><span class="n">Options</span><span class="w"> </span><span class="p">(</span><span class="n">if</span><span class="w"> </span><span class="n">any</span><span class="p">)</span><span class="w">                        </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                                                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                        </span><span class="n">data</span><span class="w">                                   </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">|</span><span class="w">                                                               </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>源端口号</strong>（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。</li>
<li><strong>目标端口号</strong>（Destination Port）：也是 16 位，用于标识接收端的应用程序。</li>
<li><strong>序列号</strong>（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。</li>
<li><strong>确认号</strong>（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。</li>
<li><strong>数据偏移</strong>（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。</li>
<li><strong>保留</strong>（Reserved）：6 位，为将来使用预留，目前必须置为 0。</li>
<li><strong>控制位</strong>（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。</li>
<li><strong>窗口大小</strong>（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。</li>
<li><strong>校验和</strong>（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。</li>
<li><strong>紧急指针</strong>（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/TCP_Data_Format_Example.png" alt="1f7ade5afa610376a72553a7d32f622c" style="zoom:50%;" />
<h3 id="tcp-是如何保证可靠性的" class="heading-element"><span>4.14 TCP 是如何保证可靠性的？</span>
  <a href="#tcp-%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e6%80%a7%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP（传输控制协议）通过多种机制来确保数据传输的可靠性。以下是TCP保证可靠性的主要方法：</p>
<ol>
<li><strong>连接管理（Connection Management）</strong>：TCP 使用三次握手（Three-Way Handshake）建立连接和四次挥手（Four-Way Handshake）关闭连接，确保连接的建立和释放过程可靠、无误。</li>
<li><strong>校验和（Checksum）</strong>：TCP 报文段包含一个校验和字段，用于验证报文段在传输过程中是否被损坏。发送方计算并填充校验和，接收方根据接收到的数据重新计算校验和并进行验证，确保数据的完整性。</li>
<li><strong>序列号（Sequence Numbers）</strong>：TCP 为每个字节分配一个序列号。发送方和接收方使用序列号来确保数据按照正确的顺序接收并重组，防止数据丢失或重复。</li>
<li><strong>确认应答（Acknowledgments, ACKs）</strong>：TCP 使用确认应答机制来确认数据的接收。接收方在收到数据后，会发送一个带有确认号的ACK报文段，告知发送方已成功接收到的数据。<strong>这种机制确保了数据的传递和确认</strong>。</li>
<li><strong>拥塞控制（Congestion Control）</strong>：TCP 通过慢启动、拥塞避免、快重传和快恢复等算法来防止网络拥塞，保证数据传输的稳定性和可靠性。</li>
<li><strong>流量控制（Flow Control）</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</li>
<li><strong>重传机制（Retransmission）</strong>：发送方在发送数据后会启动一个计时器。如果在指定时间内未收到对应的ACK报文段，发送方会认为该数据包丢失并进行重传。TCP还使用快速重传机制，当收到三个重复的ACK时，立即重传相应的数据包。</li>
<li><strong>最大消息长度（Maximum Message Length）</strong>：在建立 TCP 连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</li>
</ol>
<h3 id="说说-tcp-的流量控制" class="heading-element"><span>4.15 说说 TCP 的流量控制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，以确保接收方能够及时处理数据而不会因为数据过多而溢出缓冲区，这就是<strong>流量控制</strong>。</p>
<p>TCP 的流量控制主要通过滑动窗口（Sliding Window）机制来实现。示例如下：</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Flow_Control_Example_1.png" alt="97365f7a32a87ad913ceca13f1325e10_720" style="zoom:50%;" />
<h3 id="详细说说-tcp-的滑动窗口" class="heading-element"><span>4.16 详细说说 TCP 的滑动窗口？</span>
  <a href="#%e8%af%a6%e7%bb%86%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。而滑动窗口允许发送方在未接收到 ACK 确认之前可以发送多个数据段，以提高网络的利用率和传输效率，同时避免了发送方过度发送导致接收方缓冲区溢出。</p>
<p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>
<ul>
<li>已发送且已收到 ACK 确认</li>
<li>已发送但未收到 ACK 确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=small" data-sub-html="<h2>18481a6fdea7f130edac0e46840cc015_720</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png" alt="18481a6fdea7f130edac0e46840cc015_720" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Send_Window_Example_1.png?size=large 2x" data-title="18481a6fdea7f130edac0e46840cc015_720" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>蓝色框里就是发送窗口。SND.WND 表示发送窗口的大小，SND.NXT表示下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号；SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</p>
<p>接收方的滑动窗口包含三大部分，如下：</p>
<ul>
<li>已成功接收并确认</li>
<li>未收到数据但可以接收</li>
<li>未收到数据并不可以接收的数据</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=small" data-sub-html="<h2>154b2bfeb394bbae15f76d48be668ca6_720</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png" alt="154b2bfeb394bbae15f76d48be668ca6_720" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Receive_Window_Example_1.png?size=large 2x" data-title="154b2bfeb394bbae15f76d48be668ca6_720" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>蓝色框内，就是接收窗口。REV.WND 表示接收窗口的大小；REV.NXT表示下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</p>
<p>发送方和接收方通过 ACK 确认报文段来协商窗口大小。发送方根据接收方的接收窗口大小来调整自己的发送窗口大小，以确保不会发送超出接收方能力的数据量。</p>
<h3 id="了解-nagle-算法和延迟确认吗" class="heading-element"><span>4.17 了解 Nagle 算法和延迟确认吗？</span>
  <a href="#%e4%ba%86%e8%a7%a3-nagle-%e7%ae%97%e6%b3%95%e5%92%8c%e5%bb%b6%e8%bf%9f%e7%a1%ae%e8%ae%a4%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>Nagle 算法和延迟确认是干什么的？</strong></p>
</blockquote>
<p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p>
<p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p>
<ul>
<li><strong>Nagle 算法</strong>：当应用程序发送数据时，Nagle 算法会先将数据放入缓冲区，并等待一定的时间（称为 Nagle 算法定时器），<strong>以便将多个小数据包合并成一个大数据包一起发送</strong>。只有当缓冲区中的数据量达到一定阈值（Nagle 算法的最小传输单元）或者定时器超时时，才会触发数据的发送。<font color="red">Nagle 算法主要用于避免发送大量小数据包的情况，从而减少网络的拥塞，提高网络的性能和效率</font>。</li>
<li><strong>延迟确认</strong>：当接收方收到数据时，不会立即发送 ACK 确认报文，而是等待一段时间（一般是等待 200 毫秒左右），以便将多个 ACK 合并成一个 ACK 一起发送。如果在延迟时间内收到新的数据包，则会立即发送 ACK 报文，以确认收到的数据。<font color="red">延迟确认主要用于减少确认报文的数量，避免网络中出现过多的 ACK 报文，从而减少网络的负载和提高网络的吞吐量</font>。</li>
</ul>
<p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p>
<h3 id="说说-tcp-的拥塞控制" class="heading-element"><span>4.18 说说 TCP 的拥塞控制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>什么是拥塞控制？不是有了流量控制吗？</strong></p>
</blockquote>
<p>前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。</p>
<p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤&hellip;.</p>
<p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p>
<p>于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p>
<p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，调节所要发送数据的量。</p>
<blockquote>
<p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong></p>
</blockquote>
<p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p>
<p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
<p>拥塞窗⼝ cwnd 变化的规则：</p>
<ul>
<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>但⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<blockquote>
<p><strong>拥塞控制有哪些常用算法？</strong></p>
</blockquote>
<p>拥塞控制主要有这几种常用算法：</p>
<ul>
<li><strong>慢启动</strong>：先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据）</li>
<li><strong>拥塞避免</strong>：在拥塞避免阶段，TCP的拥塞窗口以线性增长的方式增加，而不是指数级增长</li>
<li><strong>快重传</strong>：发送方不必等待超时计时器的到期，而是立即进行快速重传，重传丢失的数据包</li>
<li><strong>快恢复</strong>：快恢复算法用于在收到重复ACK时，迅速调整拥塞窗口大小以恢复传输速度</li>
</ul>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Congestion_Control_Example_1.png" alt="f2bf90ccdfa385562fd6f475cc4f692f_720" style="zoom:50%;" />
<h3 id="说说-tcp-的重传机制" class="heading-element"><span>4.19 说说 TCP 的重传机制？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 的重传机制是确保数据传输可靠性的重要部分之一。它通过在发送方定时器超时或者接收到连续的重复确认时触发，重新发送丢失或者未确认的数据段，以确保数据能够在网络中正确传输。以下是 TCP 的重传机制的主要原理：</p>
<ol>
<li><strong>超时重传</strong>：当发送方发送数据后，在等待一定时间内未收到确认 ACK 报文时，触发超时重传机制，重新发送未确认的数据段。超时时间通常根据网络往返时间（RTT）动态调整，以适应网络延迟的变化。</li>
<li><strong>快速重传</strong>：当发送方接收到连续的重复 ACK 报文时，表明接收方已经成功接收了一些数据，但有一个或多个数据段丢失。<font color="red">为了尽快重传丢失的数据段，发送方立即触发快速重传机制，重新发送丢失的数据段，而不必等待超时定时器的到期</font>。</li>
<li><strong>带选择确认的重传（SACK）</strong>：选择确认（SACK）为了解决应该重传多少个包的问题，允许接收方在确认报文中指示出连续的数据段中哪些已经成功接收，哪些丢失了。发送方可以根据 SACK 报文中指示的丢失数据段信息，选择性地进行重传，而不是重传整个窗口内的所有未确认数据段。</li>
<li><strong>重复 SACK</strong>：是在 SACK 的基础上做了一些扩展，在接收方收到连续的重复数据段时，会生成多个相同的 SACK 报文，用于指示哪些数据段已经成功接收。主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</li>
</ol>
<h3 id="说说-tcp-的粘包和拆包" class="heading-element"><span>4.20 说说 TCP 的粘包和拆包？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e7%9a%84%e7%b2%98%e5%8c%85%e5%92%8c%e6%8b%86%e5%8c%85" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分。</p>
<p><strong>粘包</strong>指的是在 TCP 连接中，发送方发送的多个数据包在接收方接收时被合并成一个数据包。这种情况通常发生在以下几种场景中：</p>
<ol>
<li>发送方发送数据过于频繁，发送的数据量较小，多个小数据包在发送时被合并成一个数据包。Nagle 算法的作用使得发送方在网络未确认前将小数据包合并发送。</li>
<li>接收方读取数据不及时，一次性读取多个数据包。</li>
</ol>
<p><strong>拆包</strong>指的是一个完整的数据包在接收方接收时被拆分成了多个数据包。这种情况通常发生在以下几种场景中：</p>
<ol>
<li>网络传输过程中，由于 MTU（最大传输单元）的限制，一个大的数据包被拆分成多个小的数据包进行传输。</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ol>
<blockquote>
<p><strong>那怎么解决呢？</strong></p>
</blockquote>
<ul>
<li>发送端将每个数据包封装为固定长度；</li>
<li>在数据尾部增加特殊字符进行分割；</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小；</li>
<li>设计特定的应用层协议，包含数据包头部（例如，标识符、长度字段、校验和等）和数据部分。接收方根据协议解析数据包。</li>
</ul>
<h3 id="如果已经建立了连接但是服务端的进程崩溃会发生什么服务器断电呢" class="heading-element"><span>4.21 如果已经建立了连接，但是服务端的进程崩溃会发生什么？服务器断电呢？</span>
  <a href="#%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%e4%bd%86%e6%98%af%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%b4%a9%e6%ba%83%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%96%ad%e7%94%b5%e5%91%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<p>当服务器断电时，情况会有所不同：客户端在尝试与服务器通信时，会发现连接中断，通常会收到一个错误（如 <code>ECONNRESET</code> 或 <code>ETIMEDOUT</code>），客户端的应用程序需要处理这个错误，并可能尝试重新建立连接或采取其他应对措施。</p>
<h3 id="如果已经建立了连接但是客户端突然出现故障了怎么办" class="heading-element"><span>4.22 如果已经建立了连接，但是客户端突然出现故障了怎么办？</span>
  <a href="#%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%e4%bd%86%e6%98%af%e5%ae%a2%e6%88%b7%e7%ab%af%e7%aa%81%e7%84%b6%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h3 id="服务器出现大量-close_wait-状态的原因有哪些" class="heading-element"><span>4.23 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span>
  <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f-close_wait-%e7%8a%b6%e6%80%81%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%9c%89%e5%93%aa%e4%ba%9b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CLOSE_WAIT 状态是【被动关闭方】才会有的状态，而且如果【被动关闭方】没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因是：2，3，4，6步没有做</p>
<h2 id="udp" class="heading-element"><span>5 UDP</span>
  <a href="#udp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说-tcp-和-udp-的区别" class="heading-element"><span>5.1 说说 TCP 和 UDP 的区别？</span>
  <a href="#%e8%af%b4%e8%af%b4-tcp-%e5%92%8c-udp-%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><table>
  <thead>
      <tr>
          <th style="text-align: center">特性</th>
          <th style="text-align: center">TCP</th>
          <th style="text-align: center">UDP</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">连接</td>
          <td style="text-align: center">面向连接，传输数据前需建立连接</td>
          <td style="text-align: center">无需连接，立即传输数据</td>
      </tr>
      <tr>
          <td style="text-align: center">服务对象</td>
          <td style="text-align: center">一对一的两点服务</td>
          <td style="text-align: center">支持一对一、一对多、多对多的交互通信</td>
      </tr>
      <tr>
          <td style="text-align: center">可靠性</td>
          <td style="text-align: center">可靠交付，数据无差错、不丢失、不重复、按序到达</td>
          <td style="text-align: center">尽最大努力交付，不保证可靠交付数据</td>
      </tr>
      <tr>
          <td style="text-align: center">拥塞控制、流量控制</td>
          <td style="text-align: center">有拥塞控制和流量控制机制</td>
          <td style="text-align: center">无拥塞控制和流量控制机制，发送速率不受网络拥堵影响</td>
      </tr>
      <tr>
          <td style="text-align: center">首部开销</td>
          <td style="text-align: center">首部长度较长（20 字节—60字节）</td>
          <td style="text-align: center">首部只有 8 字节，且固定不变，开销较小</td>
      </tr>
      <tr>
          <td style="text-align: center">传输方式</td>
          <td style="text-align: center">字节流式传输，无边界，保证顺序和可靠</td>
          <td style="text-align: center">数据段报文传输，有边界，可能丢包和乱序</td>
      </tr>
      <tr>
          <td style="text-align: center">分片</td>
          <td style="text-align: center">在传输层进行分片，丢失分片时只重传丢失部分</td>
          <td style="text-align: center">在 IP 层进行分片，接收后在 IP 层组装再传给传输层</td>
      </tr>
      <tr>
          <td style="text-align: center">应用场景</td>
          <td style="text-align: center">文件传输、邮件传输</td>
          <td style="text-align: center">即时通讯、域名转换</td>
      </tr>
  </tbody>
</table>
<h3 id="为什么-qq-采用-udp-协议" class="heading-element"><span>5.2 为什么 QQ 采用 UDP 协议？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-qq-%e9%87%87%e7%94%a8-udp-%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>首先，QQ 并不是完全基于 UDP 实现。<font color="red">比如在使用 QQ 进行文件传输等活动的时候，就会使用 TCP 作为可靠传输的保证</font>。</li>
<li>使用 UDP 进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP 是一个全双工协议，需要建立连接，所以网络开销也会相对大。</li>
<li>如果使用 QQ 语音和 QQ 视频的话，UDP 的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li>
<li>由于 QQ 的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用 UDP 协议与客户端进行通讯才能保证这种超大规模的服务</li>
</ul>
<p>简单总结一下：UDP 协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。<strong>QQ 采用的通信协议以 UDP 为主，辅以 TCP 协议</strong>。</p>
<h3 id="udp-协议为什么不可靠" class="heading-element"><span>5.3 UDP 协议为什么不可靠？</span>
  <a href="#udp-%e5%8d%8f%e8%ae%ae%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e5%8f%af%e9%9d%a0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>UDP 在传输数据之前不需要先建立连接，远地主机的运输层在接收到 UDP 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="dns-为什么要用-udp" class="heading-element"><span>5.4 DNS 为什么要用 UDP?</span>
  <a href="#dns-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-udp" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>更准确地说，DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。<font color="red">即在需要可靠传输或处理大数据包的特定场景下，DNS 也会使用 TCP 以确保传输的可靠性和完整性</font>。</p>
<p>当客户端想 DNS 服务器查询域名（域名解析）的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，用 UDP 传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="你会如何设计qq中的网络协议" class="heading-element"><span>5.5 你会如何设计QQ中的网络协议？</span>
  <a href="#%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1qq%e4%b8%ad%e7%9a%84%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>首先，我们要实现登录功能，这是使用 QQ 的第一步，为了保证账号和密码的安全性，我们可以选择 TCP + SSL/TLS 协议来进行登录。</p>
<p>因为 TCP 协议是一种可靠的传输协议，能够保证数据的完整性，而 SSL/TLS 能够对通信进行加密，保证数据的安全性。</p>
<p>接下来，我们需要考虑消息传递的实时性，如语音视频通话等，这时候我们可以选择 UDP 协议。UDP 的传输速度更快，对于实时性服务来说，速度是最重要的。</p>
<h3 id="udp如何尽量保证消息的不丢失" class="heading-element"><span>5.6 UDP如何尽量保证消息的不丢失</span>
  <a href="#udp%e5%a6%82%e4%bd%95%e5%b0%bd%e9%87%8f%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e7%9a%84%e4%b8%8d%e4%b8%a2%e5%a4%b1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对于 TCP 协议来说，如果数据包在传输过程中丢失，TCP 协议会自动进行重传。</p>
<p>而对于 UDP 协议来说，我们可以通过应用层的重传机制来保证消息的不丢失。当接收方收到消息后，返回一个确认信息给发送方，如果发送方在一定时间内没有收到确认信息，就重新发送消息。</p>
<p>同时，每个消息都附带一个唯一的序列号，接收方根据序列号判断是否有消息丢失，如果发现序列号不连续，就可以要求发送方重新发送。这样还可以防止消息重复。</p>
<p>当然了，消息持久化也很重要，可以将消息保存在服务器或者本地的数据库中，即使在网络中断或者其他异常情况下，也能从数据库中恢复消息。</p>
<h2 id="quic" class="heading-element"><span>6 QUIC</span>
  <a href="#quic" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="quic是如何实现可靠传输的udp如何实现可靠传输" class="heading-element"><span>6.1 QUIC是如何实现可靠传输的？（UDP如何实现可靠传输？）</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%e7%9a%84udp%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><font color="red">把TCP可靠传输的特性（序号，确认应答，超时重传，流量控制）在应用层实现一遍。</font></p>
<ul>
<li><strong>基于UDP</strong>：QUIC 建立在 UDP 之上，通过在 UDP 数据报中封装自己的数据包来实现可靠传输。</li>
<li><strong>可靠传输</strong>：QUIC 提供了类似于 TCP 的可靠传输机制，包括序列号、确认应答、重传和流量控制。</li>
<li><strong>多路复用</strong>：QUIC 支持多条独立的流，解决了 TCP 的队头阻塞问题。</li>
<li><strong>拥塞控制</strong>：QUIC 实现了拥塞控制算法，确保高效的数据传输。</li>
</ul>
<h3 id="quic是如何解决tcp队头阻塞问题的" class="heading-element"><span>6.2 QUIC是如何解决TCP队头阻塞问题的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3tcp%e9%98%9f%e5%a4%b4%e9%98%bb%e5%a1%9e%e9%97%ae%e9%a2%98%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>TCP的队头阻塞（Head-of-Line Blocking）问题是指在数据传输过程中，如果某个数据包丢失了，后续的数据包即使已经到达接收方，也无法被处理，因为接收方必须按顺序处理数据包。</p>
<p>QUIC通过以下机制解决了这个问题：</p>
<ol>
<li><strong>多路复用</strong>：QUIC允许多个独立的流在同一个连接中传输，每个流都有自己的序列号和确认机制。这意味着即使某个流的数据包丢失了，也不会影响其他流的数据传输。</li>
<li><strong>独立流处理</strong>：接收方可以独立处理每个流的数据包，即使某个流的数据包丢失了，接收方仍然可以处理其他流的数据包，避免了队头阻塞。</li>
</ol>
<h3 id="quic是如何做流量控制的" class="heading-element"><span>6.3 QUIC是如何做流量控制的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>QUIC的流量控制机制与TCP类似，但更为灵活和高效：</p>
<ol>
<li><strong>流级别的流量控制</strong>：每个流都有自己的流量控制窗口，发送方在发送数据之前，必须确保数据大小不超过接收方为该流设定的窗口大小。</li>
<li><strong>连接级别的流量控制</strong>：除了流级别的流量控制，QUIC还支持连接级别的流量控制，限制整个连接上的未确认数据总量，防止网络拥塞。</li>
<li><strong>动态调整窗口大小</strong>：QUIC可以根据网络状况动态调整流量控制窗口的大小，提高数据传输的效率和适应性。</li>
</ol>
<h3 id="quic是如何迁移连接的" class="heading-element"><span>6.4 QUIC是如何迁移连接的？</span>
  <a href="#quic%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%81%e7%a7%bb%e8%bf%9e%e6%8e%a5%e7%9a%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p>
<p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
<p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过以下机制：</p>
<ol>
<li><strong>连接ID</strong>：QUIC为每个连接分配一个唯一的连接ID，连接ID与客户端和服务器的IP地址和端口无关。因此，即使客户端的IP地址或端口发生变化，只要连接ID不变，连接仍然有效。</li>
<li><strong>路径验证</strong>：在迁移连接时，QUIC会验证新的路径是否可用，确保数据能够通过新路径传输。</li>
<li><strong>迁移过程</strong>：当客户端检测到网络变化（例如，从WiFi切换到移动网络）时，会通知服务器新的地址和端口。服务器验证新的路径后，继续通过新的路径传输数据。</li>
<li><strong>无缝切换</strong>：通过连接ID和路径验证机制，QUIC实现了连接的无缝迁移，避免了因网络变化导致的连接中断和数据丢失。</li>
</ol>
<h2 id="ip" class="heading-element"><span>7 IP</span>
  <a href="#ip" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="ip-协议的定义和作用" class="heading-element"><span>7.1 IP 协议的定义和作用？</span>
  <a href="#ip-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>IP 协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在<strong>网际层</strong>，主要目的就是为了提高网络的可扩展性。</p>
<p>通过<strong>网际协议 IP</strong>，可以把参与互联的，性能各异的网络<strong>看作一个统一的网络</strong>。</p>
<p>和传输层 TCP 相比，IP 协议是一种无连接/不可靠、尽力而为的数据包传输服务，和 TCP 协议一起构成了 TCP/IP 协议的核心。</p>
<blockquote>
<p><strong>IP 协议有哪些作用？</strong></p>
</blockquote>
<p>IP 协议主要有以下几个作用：</p>
<ul>
<li><strong>寻址和路由</strong>：在 IP 数据报中携带源 IP 地址和目的 IP 地址来表示该数据包的源主机和目标主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至目标主机。</li>
<li><strong>分段和重组</strong>：IP 数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP 协议通过给每个 IP 数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的 IP 数据报。</li>
<li><strong>差错处理</strong>：虽然 IP 是尽力而为的协议，不保证数据报一定到达目的地，但它包含一些基本的差错处理机制，例如校验和（checksum），用于检测数据报头部的错误。</li>
<li><strong>控制信息</strong>：IP 头部包含了多个字段，用于控制和管理数据报的传输，如生存时间（TTL，Time to Live）字段，防止数据报在网络中无限循环。</li>
</ul>
<blockquote>
<p><strong>传输层协议和网络层协议有什么区别？</strong></p>
</blockquote>
<p><font oclor="red">网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。</font></p>
<h3 id="ip-地址有哪些分类" class="heading-element"><span>7.2 IP 地址有哪些分类？</span>
  <a href="#ip-%e5%9c%b0%e5%9d%80%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%86%e7%b1%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>IP地址（Internet Protocol Address）是用于标识网络中设备的唯一地址。IP地址有两种版本：IPv4和IPv6。IPv4是目前最广泛使用的版本，IPv6是为解决IPv4地址耗尽问题而设计的新版本。</p>
<p>IPv4地址是32位长的二进制数，通常表示为四个十进制数（每个数对应8位）之间用点分隔（例如，192.168.1.1）。IPv4地址可以按其用途和结构分为A，B，C，D，E五大类：</p>
<ul>
<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位，主要用于大型网络；</li>
<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位，主要用于中型网络；</li>
<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位，主要用于小型网络；</li>
<li>D 类地址 (224~239)：以 1110 开头，保留为多播地址，用于一对多通信；</li>
<li>E 类地址 (240~255)：以 1111 开头，保留位为将来使用，用于实验和研究。</li>
</ul>
<p>IPv4有以下特殊地址：</p>
<ul>
<li><strong>本地回环地址（Loopback Address）</strong>：127.0.0.0 到 127.255.255.255，用于主机自我测试，通常使用127.0.0.1。</li>
<li><strong>广播地址（Broadcast Address）</strong>：用于将信息发送到网络上的所有设备。例如，192.168.1.255。</li>
<li>私有地址（Private Address）：用于局域网（LAN）内部通信，不可在互联网上使用。包括以下范围：
<ul>
<li>A类：10.0.0.0 到 10.255.255.255</li>
<li>B类：172.16.0.0 到 172.31.255.255</li>
<li>C类：192.168.0.0 到 192.168.255.255</li>
</ul>
</li>
</ul>
<p>IPv6地址是128位长的二进制数，通常表示为八组十六进制数之间用冒号分隔（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。IPv6地址类型主要有以下几种：</p>
<ul>
<li><strong>单播地址（Unicast Address）</strong>：标识单一接口的地址。
<ul>
<li>全球单播地址（Global Unicast Address）：类似于IPv4的公有地址。</li>
<li>链路本地地址（Link-Local Address）：仅在单一链路上有效，前缀为fe80::/10。</li>
<li>站点本地地址（Site-Local Address）：类似于IPv4的私有地址，但已被弃用，前缀为fec0::/10。</li>
</ul>
</li>
<li><strong>多播地址（Multicast Address）</strong>：用于一对多通信，前缀为ff00::/8。</li>
<li><strong>任播地址（Anycast Address）</strong>：分配给多个接口，但数据包仅发送到距离最近的接口</li>
</ul>
<h3 id="域名和-ip-的关系一个-ip-可以对应多个域名吗一个域名可以对应多个ip吗" class="heading-element"><span>7.3 域名和 IP 的关系？一个 IP 可以对应多个域名吗？一个域名可以对应多个IP吗？</span>
  <a href="#%e5%9f%9f%e5%90%8d%e5%92%8c-ip-%e7%9a%84%e5%85%b3%e7%b3%bb%e4%b8%80%e4%b8%aa-ip-%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ba%94%e5%a4%9a%e4%b8%aa%e5%9f%9f%e5%90%8d%e5%90%97%e4%b8%80%e4%b8%aa%e5%9f%9f%e5%90%8d%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ba%94%e5%a4%9a%e4%b8%aaip%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>域名（Domain Name）</strong>：人类可读的地址，用于标识和访问网站及其他网络资源（例如，<code>www.example.com</code>）。</li>
<li><strong>IP地址（Internet Protocol Address）</strong>：计算机可读的地址，用于标识网络中的设备（例如，<code>192.168.1.1</code>）。</li>
</ul>
<p>域名和IP地址之间是通过DNS（Domain Name System）来进行映射和解析的。</p>
<p>一个域名可以对应多个 IP，但这种情况 DNS 做负载均衡的，在用户访问过程中，一个域名只能对应一个 IP。</p>
<p>而一个IP却可以对应多个域名，是一对多的关系。</p>
<h3 id="ipv4-地址不够如何解决" class="heading-element"><span>7.4 IPV4 地址不够如何解决？</span>
  <a href="#ipv4-%e5%9c%b0%e5%9d%80%e4%b8%8d%e5%a4%9f%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>DHCP：动态主机配置协议，<font color="red">动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用</font>。</li>
<li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效地分配 IPv4 的地址空间，但无法从根本上解决地址耗尽的问题。</li>
<li>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题，<font color="red">然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT 方法可以将该主机 IP 地址转换为全球 IP 地址</font>。该协议能够有效解决 IP 地址不足的问题。</li>
<li>IPv6：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个 IP 地址也够用，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>
</ul>
<h3 id="说下-arp-协议的工作过程" class="heading-element"><span>7.5 说下 ARP 协议的工作过程？</span>
  <a href="#%e8%af%b4%e4%b8%8b-arp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ARP（Address Resolution Protocol，地址解析协议）是用于将IP地址解析为对应物理网络地址（如MAC地址）的协议，主要在IPv4网络中使用。它在局域网（LAN）中起到了关键作用，使设备能够通过IP地址找到对应的硬件地址，从而实现数据帧在局域网中的正确传输。</p>
<ol>
<li><strong>ARP请求</strong>：当主机 A 要发送数据给主机 B 时，首先会在自己的 ARP 缓存中查找主机 B 的 MAC 地址。如果没有找到，主机 A 会向网络中广播一个 ARP 请求数据包，请求网络中的所有主机告诉它们的 MAC 地址；这个请求包含了请求设备和目标设备的 IP 和 MAC 地址。</li>
<li><strong>ARP应答</strong>：网络中的所有主机都会收到这个 ARP 请求，但只有主机 B 会回复 ARP 应答，告诉主机 A 自己的 MAC 地址。并且主机 B 会将主机 A 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中，以便下次通信时直接使用。</li>
<li><strong>数据传输</strong>：在获得主机B的MAC地址后，主机A（也会将主机 B 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中）就可以将目标MAC地址设置为主机B的MAC地址，从而正确地构建以太网帧并发送到局域网中，这些数据帧会通过交换机或集线器等网络设备正确地传送到主机B。</li>
</ol>
<h3 id="为什么既有-ip-地址又有-mac-地址" class="heading-element"><span>7.6 为什么既有 IP 地址，又有 MAC 地址？</span>
  <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%97%a2%e6%9c%89-ip-%e5%9c%b0%e5%9d%80%e5%8f%88%e6%9c%89-mac-%e5%9c%b0%e5%9d%80" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p><strong>MAC 地址和 IP 地址都有什么作用？</strong></p>
</blockquote>
<ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>
</ul>
<blockquote>
<p><strong>为什么有了 MAC 地址还需要 IP 地址？</strong></p>
</blockquote>
<p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是最多共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256T 的内存，显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<blockquote>
<p><strong>为什么有了 IP 地址还需要 MAC 地址？</strong></p>
</blockquote>
<ul>
<li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候，或者在分配 IP 的过程中。我们需要 MAC 地址来区分不同的设备。</li>
<li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li>
</ul>
<h3 id="icmp-协议的功能" class="heading-element"><span>7.7 ICMP 协议的功能？</span>
  <a href="#icmp-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8a%9f%e8%83%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ICMP（Internet Control Message Protocol，网际控制报文协议） 是用于在IP网络中传递控制和错误信息的协议。它是在网络层（OSI模型的第三层）之上运行的协议，主要用于在IP网络中进行诊断、错误报告和控制消息的传递。ICMP协议的功能包括但不限于以下几点：</p>
<ul>
<li><strong>错误报告</strong>：ICMP用于向发送者报告网络层发生的错误，例如目标不可达、超时、路由器发生故障等。</li>
<li><strong>路由器发现</strong>：ICMP可用于路由器的发现和配置，例如路由器通告消息（Router Advertisement）和路由器请求消息（Router Solicitation）。</li>
<li><strong>Ping测试</strong>：ICMP的Echo请求和Echo应答消息被用于Ping测试，以测试主机之间的连通性和延迟。</li>
<li><strong>TTL过期</strong>：ICMP的TTL（Time to Live）过期消息用于报告数据包在网络中被丢弃的情况，通常由于数据包在转发过程中超过了其TTL值。</li>
<li><strong>片段超时</strong>：ICMP的片段超时消息用于报告IP数据报在传输过程中被丢弃的情况，通常由于数据包片段未能在超时时间内到达目的地而被丢弃。</li>
<li><strong>重定向</strong>：ICMP的重定向消息用于告知发送者修改其路由表以改进数据包的转发效率。</li>
<li><strong>MTU探测</strong>：ICMP的路径MTU探测（Path MTU Discovery）用于发现通向目标主机的最大传输单元（MTU）以避免分片。</li>
<li><strong>多播/任播测试</strong>：ICMP用于进行多播和任播地址的测试和诊断。</li>
</ul>
<p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 ICMP 的。</p>
<p><font color="red">在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</font></p>
<p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p>
<h3 id="ping的工作原理" class="heading-element"><span>7.8 ping的工作原理</span>
  <a href="#ping%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>ping，<strong>Packet Internet Groper</strong>，一个网络工具，主要用来测试网络连接的可达性和延迟。</p>
<p>ping 的过程主要基于 ICMP（Internet Control Message Protocol，互联网控制消息协议）实现，其基本过程包括：</p>
<ol>
<li>当执行 Ping 命令，如<code>ping www.google.com</code>，Ping 首先解析域名获取 IP 地址，然后向目标 IP 发送一个 ICMP Echo Request 消息。</li>
<li>当目标 IP 收到 ICMP Echo Request 消息后，它会生成一个 ICMP Echo Reply 消息并返回，即 Ping 响应消息。</li>
<li>发起 Ping 命令的设备接收到 ICMP Echo Reply 消息后，计算并显示从发送 Echo Request 到接收到 Echo Reply 的时间（通常称为往返时间 RTT，Round-Trip Time），以及可能的丢包情况。</li>
</ol>
<p>Ping 通常会发送多个请求，以便提供平均响应时间和丢包率等信息，以便我们了解网络连接的质量。</p>
<h3 id="断网了还能ping通127001吗" class="heading-element"><span>7.9 断网了，还能ping通127.0.0.1吗？</span>
  <a href="#%e6%96%ad%e7%bd%91%e4%ba%86%e8%bf%98%e8%83%bdping%e9%80%9a127001%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>通常情况下，即使网络连接断开，也可以通过回环接口（Loopback Interface）ping通本地主机的回环地址127.0.0.1。回环地址是本地主机自身的虚拟网络接口，用于在本地主机内部进行通信，不经过物理网络设备，因此即使网络断开也可以正常工作。</p>
<p>回环接口是网络协议栈中的一个虚拟接口，用于模拟数据在网络中的传输。当数据发送到回环地址时，操作系统会将数据直接传输给回环接口，然后再从回环接口发送到目标地址，实现了数据的回环传输。</p>
<h3 id="和-localhost-以及-0000-有区别吗" class="heading-element"><span>7.10 和 localhost 以及 0.0.0.0 有区别吗</span>
  <a href="#%e5%92%8c-localhost-%e4%bb%a5%e5%8f%8a-0000-%e6%9c%89%e5%8c%ba%e5%88%ab%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol>
<li><strong>127.0.0.1</strong>：127.0.0.1是回环地址（Loopback Address），通常用于本地主机内部进行通信。当数据发送到127.0.0.1时，操作系统会将数据传输给回环接口，然后再从回环接口发送到目标地址，实现了数据的回环传输。127.0.0.1始终指向本地主机自身，不会通过网络传输，用于测试本地主机的网络协议栈是否正常工作以及网络服务是否可用。</li>
<li><strong>localhost</strong>：localhost是一个主机名（Hostname），通常映射到回环地址127.0.0.1。当在计算机上使用localhost时，实际上是在使用回环地址127.0.0.1，用于访问本地主机上的网络服务。localhost是一个常见的网络标识符，用于指代本地主机。</li>
<li><strong>0.0.0.0</strong>：0.0.0.0是一个特殊的IP地址，通常用于表示任意主机或任意地址。当服务器配置为监听0.0.0.0时，表示它将接受来自任何IP地址的连接，可以用于在所有可用网络接口上监听服务。在某些情况下，0.0.0.0也用于指示目标地址未指定或未知。</li>
</ol>
<h2 id="网络安全" class="heading-element"><span>8 网络安全</span>
  <a href="#%e7%bd%91%e7%bb%9c%e5%ae%89%e5%85%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="说说有哪些安全攻击" class="heading-element"><span>8.1 说说有哪些安全攻击？</span>
  <a href="#%e8%af%b4%e8%af%b4%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%94%bb%e5%87%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>络安全攻击主要分为两种类型，<strong>被动攻击</strong>和<strong>主动攻击</strong></p>
<ul>
<li><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。<font color="red">由于攻击者没有修改数据，使得这种攻击很难被检测到。</font></li>
<li><strong>主动攻击</strong>：直接对现有的数据和服务造成影响，常见的主动攻击类型有：
<ul>
<li><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</li>
<li><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</li>
<li><strong>拒绝服务 Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</li>
</ul>
</li>
</ul>
<h3 id="dns-劫持了解吗" class="heading-element"><span>8.2 DNS 劫持了解吗？</span>
  <a href="#dns-%e5%8a%ab%e6%8c%81%e4%ba%86%e8%a7%a3%e5%90%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DNS劫持是一种网络攻击，通过篡改DNS（Domain Name System）解析结果来劫持用户的网络流量。DNS劫持攻击者会修改DNS解析请求或响应，将用户重定向到恶意网站或者欺骗页面。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/DNS_Attack_Example.png" alt="03e093a40b15980c362ca54c98199b29" style="zoom:50%;" />
<p>DNS劫持可以通过多种方式实现，其中包括：</p>
<ol>
<li><strong>本地DNS劫持</strong>：攻击者在受害者计算机或网络中植入恶意软件，使其修改本地主机的DNS设置，将合法的DNS服务器替换为攻击者控制的恶意DNS服务器。</li>
<li><strong>路由器DNS劫持</strong>：攻击者入侵路由器或者通过社会工程手段获取路由器管理权限，然后修改路由器的DNS设置，使其指向恶意DNS服务器。</li>
<li><strong>ISP级别的DNS劫持</strong>：攻击者控制了受害者所使用的ISP（Internet Service Provider，互联网服务提供商）的DNS服务器，通过篡改ISP的DNS解析结果来实现DNS劫持。</li>
<li><strong>中间人攻击</strong>：攻击者通过中间人攻击拦截DNS请求或响应，然后篡改其中的域名解析结果，将用户重定向到恶意网站或者欺骗页面。</li>
</ol>
<blockquote>
<p><strong>怎么应对 DNS 劫持？</strong></p>
</blockquote>
<ul>
<li>直接通过 IP 地址访问网站，避开 DNS 劫持</li>
<li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选 DNS 服务器的地址固定为 8.8.8.8。</li>
</ul>
<h3 id="什么是-csrf-攻击如何避免" class="heading-element"><span>8.3 什么是 CSRF 攻击？如何避免？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-csrf-%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种网络安全攻击，<font color="red">利用用户在已认证的Web应用程序上的身份验证信息执行未经授权的操</font>作。攻击者通过诱使受害者在访问包含恶意代码的网页时，触发向目标网站发送请求的行为，从而在用户不知情的情况下执行攻击者预先设定的操作，如转账、更改密码等。</p>
<p>CSRF攻击通常包含以下步骤：</p>
<ol>
<li>攻击者准备好一个包含恶意请求的页面，例如一个钓鱼网站或者注入了恶意代码的广告。</li>
<li>受害者在已经登录的情况下访问了包含恶意请求的页面。</li>
<li>受害者的浏览器自动发送了被伪造的请求到目标网站，由于受害者已经在目标网站登录，因此请求被认为是合法的，从而执行了攻击者的操作。</li>
</ol>
<p>要防止CSRF攻击，可以采取以下措施：</p>
<ol>
<li><strong>使用CSRF Token</strong>：在Web应用程序中引入CSRF Token，确保每个请求都包含一个随机生成的Token，并在服务端验证Token的有效性。攻击者无法获取到有效的CSRF Token，因此无法伪造有效的请求。</li>
<li><strong>检查Referer头</strong>：Web应用程序可以检查请求的Referer头，确保请求来自合法的来源。但需要注意的是，Referer头可能会被篡改或者缺失，因此不能单独依赖Referer头来防止CSRF攻击。</li>
<li><strong>限制敏感操作</strong>：对于涉及到敏感操作的请求，应该要求用户输入额外的身份验证信息，例如密码、验证码等，以增加攻击者执行CSRF攻击的难度。</li>
<li><strong>使用SameSite属性</strong>：在设置Cookie时，可以使用SameSite属性来限制Cookie的发送，防止第三方网站携带Cookie发送CSRF攻击。可以将Cookie设置为SameSite=Strict或者SameSite=Lax，以限制Cookie仅在同源请求中发送。</li>
<li><strong>定期审查和更新代码</strong>：定期审查和更新Web应用程序的代码，修补已知的安全漏洞，并遵循安全最佳实践，以减少CSRF攻击的风险。</li>
<li><strong>添加校验 token</strong>：以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li>
</ol>
<h3 id="什么是-dosddosdrdos-攻击" class="heading-element"><span>8.4 什么是 DoS、DDoS、DRDoS 攻击？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-dosddosdrdos-%e6%94%bb%e5%87%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>DoS（Denial of Service，拒绝服务）攻击、DDoS（Distributed Denial of Service，分布式拒绝服务）攻击和DRDoS（Distributed Reflection Denial of Service，分布式反射拒绝服务）攻击都是针对网络服务的攻击手法，旨在使目标系统无法正常提供服务，从而导致服务不可用或严重受损。</p>
<ol>
<li><strong>DoS 攻击</strong>：DoS攻击是由单个攻击者发起的攻击，通过向目标系统发送大量的请求或者恶意数据包，耗尽目标系统的资源（如带宽、处理能力、存储空间等），从而使正常用户无法访问或使用目标系统的服务。DoS攻击可以采用多种手段实现，包括网络层攻击（如SYN Flood、UDP Flood）、应用层攻击（如HTTP Flood、Slowloris攻击）等。</li>
<li><strong>DDoS 攻击</strong>：DDoS攻击是由多个攻击者协同发起的攻击，通过分布在全球各地的大量“僵尸”计算机（也称为“肉鸡”或“僵尸网络”）向目标系统发送大量的请求或者恶意数据包，造成目标系统过载，从而使其无法正常提供服务。DDoS攻击通常规模更大、更难以应对，因为攻击流量来自于多个来源，并且攻击者可以很容易地控制和伪装攻击流量的来源。</li>
<li><strong>DRDoS 攻击</strong>：DRDoS攻击是一种利用第三方系统的资源反射攻击目标系统的攻击方式。攻击者向第三方系统发送请求，伪装成目标系统的IP地址，并请求返回大量的响应数据，这些响应数据会发送到目标系统，造成目标系统的过载。DRDoS攻击利用了第三方系统的反射响应特性，使攻击者能够轻易地放大攻击流量，并且很难追溯到攻击者的真实身份。</li>
</ol>
<blockquote>
<p><strong>如何防范 DDoS?</strong></p>
</blockquote>
<p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。瓷碗，负载均衡，CDN 等技术都能有效对抗 DDos 攻击。</p>
<h3 id="什么是-xss-攻击如何避免" class="heading-element"><span>8.5 什么是 XSS 攻击，如何避免?</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af-xss-%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的网络安全攻击，攻击者通过在受害者的浏览器中注入恶意脚本，来执行恶意操作。这些脚本通常以HTML、JavaScript等形式存在，可以窃取用户的会话信息、篡改网页内容、重定向用户到恶意网站等。XSS攻击通常分为以下几种类型：</p>
<ol>
<li><strong>存储型 XSS</strong>：攻击者将恶意脚本存储到目标网站的数据库中，当用户访问包含恶意脚本的页面时，脚本会从服务器端加载并执行。</li>
<li><strong>反射型 XSS</strong>：攻击者将恶意脚本作为参数或者URL的一部分，发送给目标用户，当用户点击恶意链接时，脚本会在用户的浏览器中执行。</li>
<li><strong>DOM-based XSS</strong>：攻击者利用客户端的DOM环境，通过修改页面的DOM结构来执行恶意脚本。</li>
</ol>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/typical_XSS_Example.png" alt="一个典型的 XSS" style="zoom:50%;" />
<blockquote>
<p><strong>如何应对 XSS 攻击？</strong></p>
</blockquote>
<ul>
<li>对输入进行过滤，过滤标签等，只允许合法值。</li>
<li>HTML 转义</li>
<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以 script 开头的非法链接。</li>
<li>限制输入长度</li>
<li>将Cookie设置为HttpOnly标志，可以防止JavaScript访问Cookie，从而减少XSS攻击的风险。</li>
</ul>
<h3 id="对称加密与非对称加密有什么区别" class="heading-element"><span>8.6 对称加密与非对称加密有什么区别？</span>
  <a href="#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e4%b8%8e%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>对称加密和非对称加密是两种常见的加密算法，它们之间有几个关键区别：</p>
<ol>
<li><strong>密钥数量</strong>：
<ul>
<li>对称加密使用相同的密钥来加密和解密数据，因此只需要一个密钥。发送方使用该密钥将数据加密，接收方使用相同的密钥将数据解密。</li>
<li>非对称加密使用一对密钥：公钥和私钥。公钥用于加密数据，私钥用于解密数据。因此，发送方使用接收方的公钥来加密数据，接收方使用自己的私钥来解密数据。</li>
</ul>
</li>
<li><strong>密钥分发</strong>：
<ul>
<li>对称加密需要确保加密和解密双方都安全地共享相同的密钥。这意味着必须在通信双方之间建立一个安全的渠道来传输密钥，否则密钥可能会被窃取或篡改。</li>
<li>非对称加密不需要在通信双方之间共享密钥。接收方将自己的公钥公开发布，发送方使用该公钥加密数据，接收方使用自己的私钥解密数据。因此，不需要建立安全的通道来传输密钥。</li>
</ul>
</li>
<li><strong>性能</strong>：
<ul>
<li>对称加密通常比非对称加密更快速，因为它使用的密钥较少，加密和解密过程更简单。</li>
<li>非对称加密通常比对称加密更慢，因为它使用更复杂的数学运算来加密和解密数据。</li>
</ul>
</li>
<li><strong>适用场景</strong>：
<ul>
<li>对称加密通常用于加密大量数据，如传输文件或通信内容。</li>
<li>非对称加密通常用于加密小块数据，如数字签名、SSL/TLS握手过程等。</li>
</ul>
</li>
</ol>
]]></description></item><item><title>数据结构与算法 面试题目总结</title><link>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 20:13:44 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<h2 id="排序算法" class="heading-element"><span>1 排序算法</span>
  <a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><table>
  <thead>
      <tr>
          <th style="text-align: center">排序算法</th>
          <th style="text-align: center">平均时间复杂度</th>
          <th style="text-align: center">最差时间复杂度</th>
          <th style="text-align: center">空间复杂度</th>
          <th style="text-align: center">数据对象稳定性</th>
          <th style="text-align: center">算法基本思路</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">冒泡排序</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">反复交换相邻逆序的元素，直到没有逆序对</td>
      </tr>
      <tr>
          <td style="text-align: center">选择排序</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">数组不稳定、链表稳定</td>
          <td style="text-align: center">反复选择未排序部分中的最小（大）元素，放在已排序部分的末尾</td>
      </tr>
      <tr>
          <td style="text-align: center">插入排序</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">逐一选择未排序元素，将其插入到已排序部分的正确位置</td>
      </tr>
      <tr>
          <td style="text-align: center">快速排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(\log_2 n)$$</td>
          <td style="text-align: center">不稳定</td>
          <td style="text-align: center">选择基准，将数组分为小于和大于基准的两部分，递归排序</td>
      </tr>
      <tr>
          <td style="text-align: center">堆排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">不稳定</td>
          <td style="text-align: center">构建最大（小）堆，将堆顶元素与末尾元素交换，调整堆</td>
      </tr>
      <tr>
          <td style="text-align: center">归并排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">递归地将数组分为两部分，分别排序后合并</td>
      </tr>
      <tr>
          <td style="text-align: center">希尔排序</td>
          <td style="text-align: center">$$O(n \log_2 n)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">$$O(1)$$</td>
          <td style="text-align: center">不稳定</td>
          <td style="text-align: center">分组进行插入排序，逐渐减少间隔，直到间隔为1</td>
      </tr>
      <tr>
          <td style="text-align: center">计数排序</td>
          <td style="text-align: center">$$O(n + m)$$</td>
          <td style="text-align: center">$$O(n + m)$$</td>
          <td style="text-align: center">$$O(n + m)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">统计每个元素的出现次数，根据计数对元素进行排序</td>
      </tr>
      <tr>
          <td style="text-align: center">桶排序</td>
          <td style="text-align: center">$$O(n)$$</td>
          <td style="text-align: center">$$O(n)$$</td>
          <td style="text-align: center">$$O(m)$$</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">将元素分配到不同的桶中，分别排序后合并</td>
      </tr>
      <tr>
          <td style="text-align: center">基数排序</td>
          <td style="text-align: center">$$O(k \cdot n)$$</td>
          <td style="text-align: center">$$O(n^2)$$</td>
          <td style="text-align: center">取决于实现</td>
          <td style="text-align: center">稳定</td>
          <td style="text-align: center">逐位排序，从最低有效位到最高有效位进行</td>
      </tr>
  </tbody>
</table>
<h2 id="栈与队列的区别" class="heading-element"><span>2 栈与队列的区别</span>
  <a href="#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；</li>
<li>栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。</li>
<li>队列先进先出，栈先进后出。</li>
<li>栈只能在表尾插入删除，队列在表尾插入表头删除。</li>
<li>应用场景不同：
<ul>
<li>栈：括号问题的求解等</li>
<li>队列：计算机系统中各种资源的管理等。</li>
</ul>
</li>
<li>遍历速度不同：
<ul>
<li>队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快；</li>
<li>栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。</li>
</ul>
</li>
</ul>
<h2 id="两个栈实现一个队列" class="heading-element"><span>3 两个栈实现一个队列</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e9%98%9f%e5%88%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个栈来实现一个队列，可以有效地利用栈的特性（后进先出）来模拟队列的特性（先进先出）。我们可以使用两个栈来分离入队和出队操作，具体实现步骤如下：</p>
<ul>
<li><strong>栈1</strong>（<code>stack1</code>）用于处理入队操作。</li>
<li><strong>栈2</strong>（<code>stack2</code>）用于处理出队操作。</li>
</ul>
<ol>
<li>入队列：直接压入元素至<code>stack1</code>即可</li>
<li>出队列：如果<code>stack2</code>不为空，把<code>stack2</code>中的栈顶元素直接弹出。否则，把<code>stack1</code>的所有元素全部弹出压入<code>stack2</code>中，再弹出<code>stack2</code>的栈顶元素</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stack1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">stack1</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Queue is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="两个队列实现栈" class="heading-element"><span>4 两个队列实现栈</span>
  <a href="#%e4%b8%a4%e4%b8%aa%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e6%a0%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用两个队列来实现一个栈，可以利用队列的特性（先进先出）来模拟栈的特性（后进先出）。我们可以使用两个队列来分离入栈和出栈操作，具体实现步骤如下：</p>
<ul>
<li><strong>队列1</strong>（<code>queue1</code>）用于存储元素。</li>
<li><strong>队列2</strong>（<code>queue2</code>）作为辅助队列用于操作元素。</li>
</ul>
<ol>
<li><strong>入栈操作</strong>：将元素直接入队到<code>queue1</code>中。</li>
<li><strong>出栈操作</strong>：
<ul>
<li>将<code>queue1</code>中的所有元素（除了最后一个）逐个出队并入队到<code>queue2</code>中。</li>
<li>最后一个元素是栈顶元素，将其出队。</li>
<li>交换<code>queue1</code>和<code>queue2</code>，以保持<code>queue1</code>始终为主队列。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;Stack is empty&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">queue1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="链表与数组的区别" class="heading-element"><span>5 链表与数组的区别</span>
  <a href="#%e9%93%be%e8%a1%a8%e4%b8%8e%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>数组静态分配内存，链表动态分配内存；。</li>
</ul>
<ul>
<li>数组在内存中连续，链表不连续。</li>
<li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)。</li>
<li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li>
<li><font color="red">数组元素在栈区，链表元素在堆区</font>。</li>
</ul>
<h2 id="什么是堆" class="heading-element"><span>6 什么是堆？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。</p>
<p><strong>最大堆的根结点中的元素在整个堆中是最大的；</strong></p>
<p><strong>最小堆的根结点中的元素在整个堆中是最小的。</strong></p>
<h2 id="什么是二叉排序树" class="heading-element"><span>7 什么是二叉排序树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ol>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<h2 id="什么是平衡二叉树" class="heading-element"><span>8 什么是平衡二叉树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ol>
<p><font color="red">平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进</font>。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。</p>
<p>旋转是平衡二叉树维护平衡性的核心操作，包括以下几种：</p>
<ul>
<li>单右旋转（Right Rotation）：用于修复左子树过高的情况。</li>
<li>单左旋转（Left Rotation）：用于修复右子树过高的情况。</li>
<li>双旋转（Double Rotation）：包括先左后右旋转和先右后左旋转，用于修复特定的不平衡情况。</li>
</ul>
<h2 id="什么是b树" class="heading-element"><span>9 什么是B树</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%afb%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>B树是一种自平衡的多路查找树，其中每个节点可以有多个子节点和多个键。B树具有以下特性：</p>
<ul>
<li><strong>节点包含多个键和子节点</strong>：每个节点可以存储多个键和子节点。节点中的键按照递增顺序存储。</li>
<li><strong>根节点至少有两个子节点</strong>（如果不是叶节点）。</li>
<li><strong>内部节点的子节点数受限</strong>：一个内部节点至少有$$[m/2]$$个子节点，最多有 $$m$$个子节点（这里的$m$是B树的阶）。</li>
<li><strong>所有叶子节点处于同一层</strong>：B树的所有叶子节点都在同一层，保证树的平衡性。</li>
</ul>
<p>B树的性质如下：</p>
<ul>
<li><strong>平衡性</strong>：B树是自平衡的，所有叶子节点处在同一层，树的高度通常较小，因而能够保证较快的搜索、插入和删除操作。</li>
<li><strong>高效的磁盘I/O操作</strong>：由于节点可以包含多个键和子节点，B树通常用于磁盘存储中，减少磁盘I/O操作的次数。</li>
<li><strong>时间复杂度</strong>：搜索、插入和删除操作的时间复杂度均为$O(\log n)$，其中$n$是树中的键的总数。</li>
</ul>
<p>B树的操作如下：</p>
<ul>
<li><strong>搜索</strong>：从根节点开始，根据当前节点中的键范围，递归或迭代地选择相应的子节点进行搜索，直到找到目标键或到达叶子节点。</li>
<li>插入：
<ul>
<li>在叶子节点插入新键。</li>
<li>如果叶子节点已满，则进行分裂操作，将中间键提升到父节点，并将叶子节点分裂为两个节点。</li>
<li>如果父节点也满，则递归进行分裂，直到树根。</li>
</ul>
</li>
<li>删除：
<ul>
<li>从树中删除键。</li>
<li>如果删除键导致节点下溢（键数少于$[m/2]$），则进行合并或借用操作，以保持B树的平衡性。</li>
</ul>
</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small" data-sub-html="<h2>clip_image020</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png" alt="clip_image020" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/b_tree_example.png?size=large 2x" data-title="clip_image020" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="trie-树" class="heading-element"><span>10 Trie 树</span>
  <a href="#trie-%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/trie1.png" alt="字典树(Trie) - OI Wiki" style="zoom:50%;" />
<h2 id="b树" class="heading-element"><span>11 B+树</span>
  <a href="#b%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><font color="red">B+树通常用于数据库和操作系统的文件系统中</font>，B+树的结构如下：</p>
<ul>
<li><strong>根节点（Root Node）</strong>：B+树的根节点可以是叶子节点，也可以是内部节点。</li>
<li><strong>内部节点（Internal Nodes）</strong>：存储键值用于导航，不存储实际数据。每个内部节点包含若干个键和指向子节点的指针。</li>
<li><strong>叶子节点（Leaf Nodes）</strong>：存储所有的实际数据，并且包含指向相邻叶子节点的指针，形成一个双向链表。</li>
</ul>
<p>B+树的性质：</p>
<ul>
<li><strong>有序性</strong>：所有键按升序排列。</li>
<li><strong>平衡性</strong>：树的所有叶子节点处于同一层级，保证了平衡性。</li>
<li><strong>多路性</strong>：每个节点可以有多个子节点，具体数量由树的阶（order）决定。</li>
</ul>
<p>B+树的操作：</p>
<ul>
<li><strong>查找（Search）</strong>：从根节点开始，依次比较键值，沿着指向子节点的指针递归查找，直到找到目标叶子节点。</li>
<li><strong>插入（Insert）</strong>：将新键插入适当的叶子节点，如果叶子节点满了，则分裂叶子节点并将中间键上移到父节点，递归进行分裂直到树恢复平衡。</li>
<li><strong>删除（Delete）</strong>：从叶子节点删除键，如果删除导致节点键数目不足，则进行节点合并或键重新分配，直到树恢复平衡。</li>
</ul>
<p>B+树的优点：</p>
<ul>
<li><strong>高效的范围查询</strong>：由于所有数据都存储在叶子节点中，并且叶子节点形成双向链表，B+树能够高效地进行范围查询（range query）。</li>
<li><strong>高存储利用率</strong>：内部节点只存储键，数据存储在叶子节点中，节点分裂和合并更加高效。</li>
<li><strong>低树高（Tree Height）</strong>：B+树的多路性使得其树高较低，查找、插入和删除操作的时间复杂度为$O(\log_mn$，其中$m$为树的阶。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small" data-sub-html="<h2>ds-bplus-tree2</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg" alt="ds-bplus-tree2" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/ds_bplus_tree2.jpg?size=large 2x" data-title="ds-bplus-tree2" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是红黑树" class="heading-element"><span>12 什么是红黑树？</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%a2%e9%bb%91%e6%a0%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>红黑树（为了解决平衡树在插入、删除等操作需要频繁调整的情况）是一种自平衡的二叉查找树（BST），广泛用于计算机科学中实现高效的数据存储和检索。它通过在每个节点上附加一个颜色属性（红或黑）来保持树的平衡，从而确保树的高度在对数级别，提供较好的时间复杂度性能。</p>
<p>红黑树的性质：</p>
<ol>
<li><strong>每个结点不是红色就是黑色；</strong></li>
<li><strong>根节点是黑色的</strong>；</li>
<li><strong>叶子节点（NIL节点）是黑色</strong>：红黑树中的叶子节点，即树尾端的所有NULL节点，都是黑色的。</li>
<li><strong>红色节点的父节点和子节点必须是黑色的，即不能有两个连续的红色节点。</strong></li>
<li><strong>从任一节点到其每个叶子的所有路径包含相同数量的黑色节点</strong>：这保证了没有一条路径会比其他路径长出太多，从而确保了树的平衡。</li>
</ol>
<p>红黑树的操作：红黑树的操作包括插入、删除和查找，基本的操作步骤与普通的二叉查找树类似，但在维护平衡性方面有所不同。</p>
<ol>
<li>
<p>插入操作</p>
<ol>
<li>
<p><strong>普通BST插入</strong>：按二叉查找树的插入规则，将新节点插入适当位置。</p>
</li>
<li>
<p><strong>节点染色为红色</strong>：新插入的节点初始为红色。</p>
</li>
<li>
<p><strong>调整平衡</strong>：通过旋转和重新染色来保持红黑树的性质。</p>
<ul>
<li>
<p><strong>情况1：插入节点的父节点是黑色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：插入节点的父节点是红色</strong>：根据叔节点的颜色，有不同的调整方法，包括重新染色和旋转。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>删除操作</p>
<ol>
<li>
<p><strong>普通BST删除</strong>：按二叉查找树的删除规则，找到并删除节点。</p>
</li>
<li>
<p><strong>调整平衡</strong>：删除节点后可能破坏红黑树的性质，需要通过旋转和重新染色来恢复平衡。</p>
<ul>
<li>
<p><strong>情况1：删除节点是红色</strong>：不需要进一步操作。</p>
</li>
<li>
<p><strong>情况2：删除节点是黑色</strong>：通过双重黑色节点的概念和调整，包括重新染色和旋转，来恢复红黑树的平衡。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>红黑树的优点：</p>
<ul>
<li><strong>自平衡</strong>：通过颜色属性和旋转操作，红黑树可以保持平衡，确保基本操作的时间复杂度为$$O(\log n)$$。</li>
<li><strong>高效查找</strong>：由于平衡性，红黑树在最坏情况下的高度为$$2\log(n+1)$$，保证了查找操作的高效性。</li>
<li><strong>高效插入和删除</strong>：插入和删除操作在进行平衡调整时，旋转和重新染色的成本较低，确保了高效性。</li>
</ul>
<p>红黑树广泛应用于许多计算机系统和软件中，包括：</p>
<ul>
<li><strong>关联容器</strong>：C++的STL中的map和set，Java的TreeMap和TreeSet都基于红黑树实现。</li>
<li><strong>内存管理</strong>：Linux内核中的内存管理使用红黑树来管理空闲内存块。</li>
<li><strong>数据库索引</strong>：一些数据库系统使用红黑树作为索引结构，实现高效的数据检索。</li>
</ul>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png" alt="img" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Red_Black_Tree_Example.png?size=large 2x" data-title="img" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="什么是哈希表哈希表的实现方式怎么避免哈希冲突" class="heading-element"><span>13 什么是哈希表？哈希表的实现方式？怎么避免哈希冲突</span>
  <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%93%88%e5%b8%8c%e8%a1%a8%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e6%80%8e%e4%b9%88%e9%81%bf%e5%85%8d%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>哈希表（Hash Table，也叫散列表），是根据键值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把键值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<p>哈希函数也称为散列函数，它接受一个键作为输入，并将其映射到哈希表的一个位置上。理想的哈希函数应该能够将键均匀地分布到哈希表的不同位置上，同时具有良好的计算效率。常见的哈希函数包括取余法、乘法哈希法、MD5、SHA等。选择合适的哈希函数取决于应用场景和性能要求。</p>
<p>当两个不同的键经过哈希函数映射后得到相同的位置时，就会发生哈希冲突。为了解决这个问题，常见的冲突解决方法包括：</p>
<ol>
<li><strong>开放定址法（Open Addressing）</strong>：当发生冲突时，顺序地查找下一个可用的位置，直到找到一个空槽位。常见的开放定址法包括线性探测、二次探测、双重哈希等。</li>
<li><strong>链地址法（Chaining）</strong>（最常用）：将哈希表的每个槽位都连接一个链表（或其他数据结构），当发生冲突时，将冲突的元素插入到对应位置的链表中。这样，相同哈希值的元素都存储在同一个链表中。</li>
<li><strong>再哈希法（Rehashing）</strong>：使用另一个哈希函数计算新的哈希值，然后再次查找空槽位。这样可以减少冲突的概率，提高哈希表的性能。</li>
<li><strong>建立公共溢出区</strong>：将哈希表的一部分空间作为溢出区，当发生冲突时，将冲突的元素存储在溢出区中。这样，哈希表的主要部分仍然保持较低的负载因子，提高了性能。</li>
</ol>
<p><a class="lightgallery" href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small" data-sub-html="<h2>image-20240601201150022</h2>"><img loading="lazy" src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png" alt="image-20240601201150022" srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/hashmap_example.png?size=large 2x" data-title="image-20240601201150022" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
]]></description></item><item><title>C/C++ 面试题目总结</title><link>https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/</link><pubDate>Sat, 01 Jun 2024 16:11:20 +0000</pubDate><author>HeZephyr</author><guid>https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/</guid><description><![CDATA[<ol>
<li>
<p>const知道吗？解释其作用</p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
</li>
<li>
<p>宏定义 #define 和 const 常量</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">宏定义 #define</th>
          <th style="text-align: center">const 常量</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">宏定义，相当于字符替换         |</td>
          <td style="text-align: center">常量声明    |</td>
      </tr>
      <tr>
          <td style="text-align: center"><font color="red">预处理器处理</font> |</td>
          <td style="text-align: center">编译器处理   |</td>
      </tr>
      <tr>
          <td style="text-align: center">无类型安全检查             |</td>
          <td style="text-align: center">有类型安全检查 |</td>
      </tr>
      <tr>
          <td style="text-align: center">不分配内存               |</td>
          <td style="text-align: center">要分配内存   |</td>
      </tr>
      <tr>
          <td style="text-align: center"><font color="red">存储在代码段</font> |</td>
          <td style="text-align: center">存储在数据段  |</td>
      </tr>
      <tr>
          <td style="text-align: center">可通过 <code>#undef</code> 取消          |</td>
          <td style="text-align: center">不可取消    |</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>static的作用</p>
<ol>
<li>修饰普通变量，<font color="red">修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间</font>，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，<font color="red">表明函数的作用范围</font>，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，<font color="red">修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员</font>。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，<font color="red">但是在 static 函数内不能访问非静态成员</font>。</li>
</ol>
</li>
<li>
<p>说说this指针</p>
<ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，<strong>编译程序先将对象的地址赋给 <code>this</code> 指针</strong>，然后调用成员函数，<font color="red">每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针</font>。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用<code>this</code>指针：
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>说说inline内联函数</p>
<p>相当于把内联函数里面的内容写在调用内联函数处，即不用执行进入函数的步骤，直接执行函数体；相当于宏，却比宏多了类型检查，真正具有函数特性；编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数（但虚函数也可以是内联函数，但是当虚函数表现出多态性时不能内联）。</p>
<p>优点：</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点：</p>
<ol start="4">
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。<font color="red">内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器</font>。</li>
</ol>
</li>
<li>
<p>说说volatile关键字</p>
<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以<font color="red">使用 volatile 告诉编译器不应对这样的对象进行优化</font>。</li>
<li>volatile 关键字声明的变量，<font color="red">每次访问时都必须从内存中取出值</font>（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
</li>
<li>
<p>说说assert()</p>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p><code>static_assert</code> 是一个编译时断言，用于在编译期间检查常量表达式是否为 <code>true</code>。它定义在 C++11 及更高版本的标准中。<code>static_assert</code> 通常用于模板编程和常量表达式中，以确保某些编译时条件成立。与 <code>assert</code> 不同的是，<code>static_assert</code> 在编译时进行检查，因此它不会影响运行时性能。</p>
</li>
<li>
<p>说说sizeof()</p>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
</li>
<li>
<p><code>#pragma pack(n)</code></p>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐，<code>#pragma pack(pop)</code>  恢复对齐状态</p>
</li>
<li>
<p><code>extern &quot;C&quot;</code></p>
<p>被 <code>extern</code> 限定的函数或变量是 <code>extern</code> 类型的，被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和链接的</p>
</li>
<li>
<p>C++ 中 struct 和 class</p>
<p>总的来说，<font color="red">struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体</font>。</p>
<p>最本质的一个区别就是默认的访问控制，struct 默认的数据访问控制是 public 的，class 默认的成员变量访问控制是 private 的。</p>
</li>
<li>
<p>union 联合</p>
<p>联合（union）是一种节省空间的特殊的类，<font color="red">一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值</font>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
</li>
<li>
<p>C 实现 C++ 类</p>
<p><font color="red">C 实现 C++ 的面向对象特性（封装、继承、多态）</font></p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
</li>
<li>
<p>explicit（显式）关键字</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li>
</ul>
</li>
<li>
<p>friend 友元类和友元函数</p>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
</li>
<li>
<p>谈谈using</p>
<p>using 关键字在 C++ 中有多种用途，主要包括类型别名、引入命名空间中的标识符。并且C++11 引入了别名模板，可以使用 <code>using</code> 创建模板的别名。</p>
<p>尽量少使用 using 指示：<code>using namespace std;</code>，会污染命名空间</p>
</li>
<li>
<p><code>::</code> 范围解析运算符</p>
<ol>
<li>
<p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>         <span class="c1">// 全局（::）的 count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>       <span class="c1">// 测试 1：设置全局的 count 的值为 12
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>   <span class="c1">// 类 A 的 count（A::count）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈<code>decltype</code>关键字</p>
<p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类，返回值为所属类型。语法：<code>decltype ( expression )</code></p>
</li>
<li>
<p>谈谈引用</p>
<p>在 C++ 中，引用（reference）是一种为已存在的变量创建别名的机制。引用可以让你通过另一个名字访问同一个变量。C++ 中的引用主要分为以下几种类型：</p>
<ol>
<li>
<p>左值引用（L-value References）：左值引用用于引用内存中已经存在的对象，通常用于函数参数传递和返回值。</p>
</li>
<li>
<p>右值引用（R-value References）：右值引用在 C++11 引入（<code>int&amp;&amp; rvalueRef = 10</code>），主要用于引用临时对象（右值），支持移动语义和完美转发，优化性能。</p>
</li>
<li>
<p>引用折叠（Reference Collapsing）：引用折叠是一种复杂的规则，决定了多层引用的结果。它在模板编程和完美转发中非常重要。</p>
<p><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code>
<code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></p>
</li>
</ol>
</li>
<li>
<p>成员初始化列表
好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：
<ul>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈面向对象</p>
<p>面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范式，基于“对象”的概念，用于组织代码和数据。OOP 提供了一种更自然和直观的方法来解决复杂的软件问题，使程序设计更加模块化和可维护。面向对象的三大特性：</p>
<ol>
<li><strong>封装（Encapsulation）</strong> ：封装是将数据和操作数据的方法捆绑在一起，形成一个自包含的单元—对象。<font color="red">封装通过定义类中的私有成员变量和公有成员函数，隐藏内部实现细节，只暴露必要的接口。封装提高了代码的安全性和可维护性</font>。</li>
<li><strong>继承（Inheritance）</strong> ：继承是一种机制，<font color="red">通过创建一个新的类（子类），该类可以继承一个或多个已有类（基类）的属性和方法，从而实现代码的重用和扩展</font>。继承支持多态性，并且使得代码更具层次性。</li>
<li><strong>多态（Polymorphism）</strong>：多态是指一个函数或方法可以有多种不同的表现形式。<font color="red">在C++中多态主要通过虚函数和函数重载实现，使得不同的对象可以用统一的接口进行操作，从而提高代码的灵活性和扩展性</font>。</li>
</ol>
</li>
<li>
<p>C++多态</p>
<p>C++ 多态分类及实现：</p>
<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
<li>
<p>谈谈虚析构函数</p>
<p>虚析构函数（Virtual Destructor）是面向对象编程中一个重要的概念，特别是在 C++ 中。它的主要目的是确保在通过基类指针删除派生类对象时，派生类的析构函数能够正确调用，从而防止资源泄漏和未定义行为。</p>
</li>
<li>
<p>在C++中，希望一个类不能被实例化，可以怎么做？</p>
<ol>
<li>
<p><strong>将类声明为抽象基类（Abstract Base Class, ABC）：</strong> <font color="red">如果一个类至少有一个纯虚函数，那么这个类就是抽象基类，无法被实例化</font>。纯虚函数是在基类中声明但不定义的虚函数，它在基类中的声明形式如下：<code>virtual void func() = 0;</code>。纯虚函数使得派生类必须提供自己的实现，否则派生类也将成为抽象基类。</p>
<p>如果其中没有其他合适的函数，可以把析构函数定义为纯虚析构函数</p>
</li>
<li>
<p><strong>声明类的构造函数为protected或private：</strong> 如果一个类的构造函数被声明为<code>protected</code>或<code>private</code>，那么在类的外部就不能直接调用这个构造函数来创建类的对象。只有类本身和它的友元函数或类可以访问它的私有或保护成员。</p>
</li>
</ol>
</li>
<li>
<p>虚函数、纯虚函数</p>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。而纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
</li>
<li>
<p>谈谈虚函数指针、虚函数表</p>
<p>虚函数指针是存储在对象中的特殊指针，用于指向对象的虚函数表。<font color="red">每个对象都有一个虚函数指针，它指向对象的虚函数表的首地址。</font>通过虚函数指针，可以在运行时动态地调用适当的虚函数。</p>
<p>虚函数表是存储在内存中的一张表格，用于存储类的虚函数地址。<font color="red">每个类（含有虚函数的类）都有一个对应的虚函数表，其中存放了该类所有虚函数的地址</font>。虚函数表是在编译阶段创建的，每个类的虚函数表在程序运行时都会存在于内存中。</p>
<p>虚函数指针指向虚函数表的首地址，通过虚函数指针可以访问到对象的虚函数表。当调用对象的虚函数时，编译器会使用虚函数指针找到对象的虚函数表，然后根据函数在虚函数表中的索引找到相应的虚函数地址，并进行调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Base::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Derived::foo()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span><span class="o">*</span> <span class="n">vptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="o">**</span><span class="p">)</span><span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取虚函数表中第一个虚函数地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">funcAddr</span> <span class="o">=</span> <span class="n">vptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 转换为函数指针并调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">funcAddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">func</span><span class="p">();</span> <span class="c1">// 调用 Derived::foo()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">basePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>谈谈虚继承</p>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，<font color="red">每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）</font>（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
</li>
<li>
<p>虚继承、虚函数</p>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：
<ul>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li><font color="red">虚基类表存储的是虚基类相对直接继承类的偏移</font></li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的抽象类、接口类、聚合类</p>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>谈谈C++中的模板机制</p>
<p>在C++中，模板（Template）是一种通用的代码生成机制，允许程序员编写通用的代码来处理不同类型的数据，而不需要为每种数据类型编写特定的代码。模板是C++中强大的特性之一，它提高了代码的重用性、可读性和可维护性。</p>
<ol>
<li>
<p>类模板（Class Templates）：类模板是一种用于创建通用类的模板，允许类中的数据成员和成员函数的类型参数化。通过类模板，可以定义一个通用的类，可以处理多种不同类型的数据。</p>
</li>
<li>
<p>函数模板（Function Templates）：函数模板是一种用于创建通用函数的模板，允许函数中的参数类型参数化。通过函数模板，可以定义一个通用的函数，可以处理多种不同类型的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">maximum</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板特化（Template Specialization）：模板特化是指针对某些特定的类型，为模板定义一个特殊的实现。当模板在处理特定类型时需要特殊的行为时，可以使用模板特化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Stack&lt;std::string&gt;::pop(): empty stack&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">element</span> <span class="o">=</span> <span class="n">elements</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">elements</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>模板参数（Template Parameters）：模板参数是在定义模板时指定的参数，它可以是类型参数或非类型参数。类型参数指定了模板中的数据类型，而非类型参数可以是整数、指针等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>C++的new/delete和malloc/delete有什么区别？</p>
<p>C++中的<code>new</code>和<code>malloc()</code>都用于在堆上动态分配内存，但它们之间有一些重要的区别：</p>
<ol>
<li><code>new</code> 是C++中的关键字，可以为指定的类型动态分配内存，并返回相应类型的指针。而<code>malloc()</code>是C标准库函数，它返回<code>void*</code>类型的指针，需要手动进行类型转换，将其转换为所需类型的指针。这样的操作在C++中不够安全，可能导致编译器无法检测到的类型错误。</li>
<li><code>new</code> 分配内存时会调用对象的构造函数，确保对象被正确初始化。<code>malloc()</code> 只是简单地分配一块内存，并不会调用对象的构造函数。</li>
<li><code>new</code> 可以根据所需类型的大小自动计算要分配的内存空间大小，无需手动计算。而<code>malloc()</code> 需要手动指定要分配的内存空间大小，需要调用<code>sizeof</code>函数来计算所需的字节数。</li>
<li>在内存分配失败时，<code>new</code> 会抛出异常（<code>std::bad_alloc</code>），需要使用异常处理机制来处理。而<code>malloc()</code> 分配内存失败时会返回空指针（<code>NULL</code>），需要手动检查返回值并进行错误处理。</li>
<li>使用<code>new</code>分配的内存需要使用<code>delete</code>关键字进行释放，而使用<code>malloc()</code>分配的内存需要使用<code>free()</code>函数进行释放。</li>
</ol>
<p>本质：<code>new / new[]</code>：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。<code>delete/delete[]</code>：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p>
</li>
<li>
<p>delete this 合法吗？</p>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
</li>
<li>
<p>C++如何定义一个只能在堆上（栈上）生成对象的类？</p>
<ul>
<li>只能在堆上：将析构函数设置为私有。C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li>
<li>只能在栈上：将 new 和 delete 重载为私有。在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li>
</ul>
</li>
<li>
<p>介绍一下C++的智能指针</p>
<p>C++中的智能指针是一种特殊的指针对象，可以自动管理动态分配的内存，避免内存泄漏和悬空指针等常见问题。智能指针通过包装原始指针，提供了自动释放内存的机制，从而简化了内存管理的工作。常见的智能指针包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>（<code>auto_ptr</code>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。）。</p>
<ol>
<li><code>std::unique_ptr</code>是一种独占式智能指针，即同一时间只能有一个<code>std::unique_ptr</code>拥有某个对象的所有权。当<code>std::unique_ptr</code>超出作用域或被显式释放时，它所管理的对象会被自动释放。不能复制或赋值给其他<code>std::unique_ptr</code>，但可以通过<code>std::move()</code>来转移所有权。<font color="red">适用于需要严格所有权管理的情况，例如资源管理类对象</font>。</li>
<li><code>std::shared_ptr</code>是一种共享式智能指针，可以拥有多个<code>std::shared_ptr</code>共享同一个对象。使用引用计数来跟踪对象的引用次数，当引用次数为0时，对象会被自动释放。可以复制和赋值给其他<code>std::shared_ptr</code>，引用计数会增加。<font color="red">适用于需要多个指针共享同一资源的情况，例如多个对象共享一个动态分配的对象</font>。</li>
<li><code>std::weak_ptr</code>是一种弱引用智能指针，它不会增加对象的引用计数，也不会影响对象的生命周期。用于解决<code>std::shared_ptr</code>的循环引用问题，通过打破循环引用，<strong>防止内存泄漏</strong>。可以通过<code>lock()</code>方法获取一个指向被管理对象的<code>std::shared_ptr</code>，如果对象已经被释放，则返回空指针。</li>
</ol>
</li>
<li>
<p>谈谈C++的强制类型转换</p>
<p>在C++中，有四种主要的强制类型转换方式：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。用法：<code>static_cast&lt;typename&gt;(object)</code></p>
<ol>
<li>
<p><code>static_cast</code>用于进行静态类型转换，通常用于较为安全的转换，例如基本数据类型之间的转换、类层次结构中的向上转换（派生类指针转为基类指针）和向下转换（基类指针转为派生类指针）等。<font color="red">静态转换在编译时进行，不提供运行时类型检查</font>。</p>
</li>
<li>
<p><code>dynamic_cast</code>用于进行动态类型转换，用于安全地在类层次结构中进行向上或向下转换，并且提供了运行时类型检查。当进行向下转换时，如果指针不指向有效的派生类对象，则返回空指针。<font color="red">只能用于具有虚函数的类（即多态类）之间的转换。</font></p>
</li>
<li>
<p><code>const_cast</code>用于添加或删除对象的const属性、volatile属性，<font color="red">主要用于消除类型的const限制</font>。注意：不应该用于修改本来就不可修改的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 去除const属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// 合法，修改了const对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>reinterpret_cast</code>用于进行底层的重新解释转换，例如将一个指针转换为一个整数，或者一个整数转换为一个指针。这种转换非常危险，可能会导致未定义的行为，因此应该尽量避免使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// 将int指针转换为void指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">newXPtr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 将void指针转换为int指针
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>谈谈运行时类型信息 (RTTI)</p>
<p>运行时类型信息（RTTI, Runtime Type Information）是C++提供的一种机制，用于在运行时识别对象的类型。RTTI允许程序在运行时获取关于对象类型的信息，主要包括两个关键特性：<code>typeid</code>操作符和<code>dynamic_cast</code>操作符。</p>
<ol>
<li><code>typeid</code>操作符用于获取表达式或对象的类型信息。<code>typeid</code>返回一个<code>std::type_info</code>对象，该对象包含了类型的信息，可以通过其成员函数来获取类型名等信息。</li>
<li><code>dynamic_cast</code>用于多态类型的转换</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnotherDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 成功转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">AnotherDerived</span><span class="o">*</span> <span class="n">ad</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">AnotherDerived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 转换失败，返回nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is a Derived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b is not an AnotherDerived&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>RTTI通常用于以下场景：</p>
<ul>
<li><strong>安全类型转换</strong>：在复杂的类层次结构中，使用<code>dynamic_cast</code>进行安全的向下转换，确保类型转换的正确性。</li>
<li><strong>类型检查</strong>：使用<code>typeid</code>进行类型检查，调试和记录对象的实际类型信息，帮助诊断问题。</li>
</ul>
</li>
<li>
<p>谈谈C++中怎么处理异常</p>
<p>在C++中，异常处理是一种机制，用于捕获和处理程序运行过程中发生的错误或异常情况，从而避免程序崩溃。C++通过<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现异常处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能抛出异常的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理标准库异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Standard exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理整型异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Integer exception: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理其他所有类型的异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unknown exception caught&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>throw</code>表达式用于抛出异常，可以抛出任何类型的对象。</p>
<p>C++允许用户定义自己的异常类，通常继承自<code>std::exception</code>，并重写<code>what()</code>方法来提供异常信息。</p>
</li>
<li>
<p>STL容器</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">容器</th>
          <th style="text-align: center">底层数据结构</th>
          <th style="text-align: center">时间复杂度</th>
          <th style="text-align: center">有无序</th>
          <th style="text-align: center">可不可重复</th>
          <th style="text-align: center">其他</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">array</td>
          <td style="text-align: center">数组</td>
          <td style="text-align: center">随机读改 O(1)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">支持随机访问，大小固定，不能动态调整</td>
      </tr>
      <tr>
          <td style="text-align: center">vector</td>
          <td style="text-align: center">数组</td>
          <td style="text-align: center">随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">支持随机访问，动态调整大小，使用连续内存存储，插入删除效率视位置而定</td>
      </tr>
      <tr>
          <td style="text-align: center">deque</td>
          <td style="text-align: center">双端队列</td>
          <td style="text-align: center">头尾插入、头尾删除 O(1)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问，但随机访问效率略低于vector</td>
      </tr>
      <tr>
          <td style="text-align: center">forward_list</td>
          <td style="text-align: center">单向链表</td>
          <td style="text-align: center">插入、删除 O(1)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">不支持随机访问，只能单向遍历，适用于只需前向访问和修改的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">list</td>
          <td style="text-align: center">双向链表</td>
          <td style="text-align: center">插入、删除 O(1)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">不支持随机访问，支持双向遍历，适用于频繁插入和删除的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">stack</td>
          <td style="text-align: center">deque / list</td>
          <td style="text-align: center">顶部插入、顶部删除 O(1)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">适用于后进先出（LIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
      </tr>
      <tr>
          <td style="text-align: center">queue</td>
          <td style="text-align: center">deque / list</td>
          <td style="text-align: center">尾部插入、头部删除 O(1)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">适用于先进先出（FIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td>
      </tr>
      <tr>
          <td style="text-align: center">priority_queue</td>
          <td style="text-align: center">vector + max-heap</td>
          <td style="text-align: center">插入、删除 O(log2n)</td>
          <td style="text-align: center">有序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">使用最大堆实现，适用于需要动态获取最大元素的场景，底层使用vector存储</td>
      </tr>
      <tr>
          <td style="text-align: center">set</td>
          <td style="text-align: center">红黑树</td>
          <td style="text-align: center">插入、删除、查找 O(log2n)</td>
          <td style="text-align: center">有序</td>
          <td style="text-align: center">不可重复</td>
          <td style="text-align: center">自动排序且元素唯一，适用于需要有序且无重复元素的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">multiset</td>
          <td style="text-align: center">红黑树</td>
          <td style="text-align: center">插入、删除、查找 O(log2n)</td>
          <td style="text-align: center">有序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">自动排序，允许重复元素，适用于需要有序且可重复元素的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">map</td>
          <td style="text-align: center">红黑树</td>
          <td style="text-align: center">插入、删除、查找 O(log2n)</td>
          <td style="text-align: center">有序</td>
          <td style="text-align: center">不可重复</td>
          <td style="text-align: center">键值对存储，键唯一，自动按键排序，适用于需要按键有序访问且键唯一的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">multimap</td>
          <td style="text-align: center">红黑树</td>
          <td style="text-align: center">插入、删除、查找 O(log2n)</td>
          <td style="text-align: center">有序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">键值对存储，键可重复，自动按键排序，适用于需要按键有序访问且键可重复的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">unordered_set</td>
          <td style="text-align: center">哈希表</td>
          <td style="text-align: center">插入、删除、查找 O(1) 最差 O(n)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">不可重复</td>
          <td style="text-align: center">使用哈希表实现，元素唯一，无序存储，适用于快速查找和插入的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">unordered_multiset</td>
          <td style="text-align: center">哈希表</td>
          <td style="text-align: center">插入、删除、查找 O(1) 最差 O(n)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">使用哈希表实现，允许重复元素，无序存储，适用于需要快速查找和插入且元素可重复的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">unordered_map</td>
          <td style="text-align: center">哈希表</td>
          <td style="text-align: center">插入、删除、查找 O(1) 最差 O(n)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">不可重复</td>
          <td style="text-align: center">键值对存储，键唯一，使用哈希表实现，无序存储，适用于需要快速按键查找和插入的场景</td>
      </tr>
      <tr>
          <td style="text-align: center">unordered_multimap</td>
          <td style="text-align: center">哈希表</td>
          <td style="text-align: center">插入、删除、查找 O(1) 最差 O(n)</td>
          <td style="text-align: center">无序</td>
          <td style="text-align: center">可重复</td>
          <td style="text-align: center">键值对存储，键可重复，使用哈希表实现，无序存储，适用于需要快速按键查找和插入且键可重复的场景</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
]]></description></item></channel></rss>