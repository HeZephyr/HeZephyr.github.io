<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>页 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成可变大小的块，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。
因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为分页，它可以追溯到一个早期且重要的系统，Atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为页面。相应地，我们将物理内存视为一组固定大小的槽（称为页框）；每个框都可以包含一个虚拟内存页；每个进程都需要页表来将虚拟地址转换为物理地址。。我们的挑战：

关键：如何使用页面虚拟化内存 ?
如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？"><meta name=keywords content='OS'><meta itemprop=name content="页"><meta itemprop=description content="有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成可变大小的块，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。
因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为分页，它可以追溯到一个早期且重要的系统，Atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为页面。相应地，我们将物理内存视为一组固定大小的槽（称为页框）；每个框都可以包含一个虚拟内存页；每个进程都需要页表来将虚拟地址转换为物理地址。。我们的挑战：
关键：如何使用页面虚拟化内存 ? 如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？"><meta itemprop=datePublished content="2024-04-25T22:38:48+00:00"><meta itemprop=dateModified content="2024-10-26T03:13:14+00:00"><meta itemprop=wordCount content="5565"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/13.%E9%A1%B5/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="页"><meta property="og:description" content="有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成可变大小的块，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。
因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为分页，它可以追溯到一个早期且重要的系统，Atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为页面。相应地，我们将物理内存视为一组固定大小的槽（称为页框）；每个框都可以包含一个虚拟内存页；每个进程都需要页表来将虚拟地址转换为物理地址。。我们的挑战：
关键：如何使用页面虚拟化内存 ? 如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-25T22:38:48+00:00"><meta property="article:modified_time" content="2024-10-26T03:13:14+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="页"><meta name=twitter:description content="有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成可变大小的块，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。
因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为分页，它可以追溯到一个早期且重要的系统，Atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为页面。相应地，我们将物理内存视为一组固定大小的槽（称为页框）；每个框都可以包含一个虚拟内存页；每个进程都需要页表来将虚拟地址转换为物理地址。。我们的挑战：
关键：如何使用页面虚拟化内存 ? 如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/13.%E9%A1%B5/><link rel=prev href=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/><link rel=next href=https://hezephyr.github.io/posts/14.%E5%BF%AB%E8%A1%A8/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"页","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/13.%E9%A1%B5\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":5565,"url":"https:\/\/hezephyr.github.io\/posts\/13.%E9%A1%B5\/","datePublished":"2024-04-25T22:38:48+00:00","dateModified":"2024-10-26T03:13:14+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>页</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><span class=active title=页>页</span></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ class=collection-nav-item rel=prev title=空闲空间管理><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>13/39</span><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ class=collection-nav-item rel=next title=快表><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>页</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-04-25 22:38:48"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-04-25>2024-04-25</time></span>&nbsp;<span title="更新于 2024-10-26 03:13:14"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-10-26>2024-10-26</time></span>&nbsp;<span title="5565 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5600 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 12 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=页>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#示例一个简单的分页>示例：一个简单的分页</a></li><li><a href=#页表存储在哪>页表存储在哪？</a></li><li><a href=#页表中到底有什么>页表中到底有什么？</a></li><li><a href=#分页也太慢>分页：也太慢</a></li><li><a href=#内存跟踪>内存跟踪</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><p>有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成<font color=red>可变大小的块</font>，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。</p><p>因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为<font color=red>分页</font>，它可以追溯到一个早期且重要的系统，Atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为<font color=red>页面</font>。相应地，我们将物理内存视为一组固定大小的<font color=red>槽（称为页框）</font>；每个框都可以包含一个虚拟内存页；每个进程都需要<font color=red>页表</font>来将虚拟地址转换为物理地址。。我们的挑战：</p><blockquote><center>关键：如何使用页面虚拟化内存 ?</center><p>如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？</p></blockquote><h2 id=示例一个简单的分页 class=heading-element><span>1 示例：一个简单的分页</span>
<a href=#%e7%a4%ba%e4%be%8b%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e5%88%86%e9%a1%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>为了更清楚地说明这种方法，让我们来看一个简单的例子。下图展示了一个很小的地址空间，总大小只有 64 字节，有四个 16 字节的页面（虚拟页面 0、1、2 和 3）。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-1.png?size=small" data-sub-html="<h2>image-20240401184253614</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-1.png alt=image-20240401184253614 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-1.png?size=large 2x" data-title=image-20240401184253614 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>当然，真实的地址空间要大得多，通常为 32 位，因此有 4GB 的地址空间，甚至 64 位。</p><p>如下图所示，物理内存也由许多固定大小的槽组成，在本例中是 8 个页框（对于 128 字节的物理内存来说，也小得离谱）。虚拟地址空间的页面被放置在整个物理内存的不同位置；该图还显示操作系统自身使用一些物理内存。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-2.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-2.png?size=small" data-sub-html="<h2>image-20240401184650191</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-2.png alt=image-20240401184650191 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-2.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-2.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Simple-Page-Example-2.png?size=large 2x" data-title=image-20240401184650191 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>正如我们将看到的，分页比我们以前的方法有许多优点。最重要的改进可能是灵活性：通过完全开发的分页方法，系统将能够有效地支持地址空间的抽象，无论进程如何使用地址空间；例如，我们不会对堆和栈的增长方向以及它们的使用方式做出假设。</p><p>另一个优点是分页提供的可用空间管理的简单性。例如，当操作系统希望将我们微小的 64 字节地址空间放入我们的八页物理内存中时，它只会找到四个空闲页；也许操作系统为此保留了所有空闲页面的空闲列表，并且只从该列表中获取前四个空闲页面。在示例中，操作系统已将地址空间 (AS) 的虚拟页 0 放置在物理页 3 中，将 AS 的虚拟页 1 放置在物理页7 中，将页 2 放置在物理页 5 中，将页 3 放置在物理页 2 中。 页框 1 、4 和 6 目前空闲。</p><p>为了记录地址空间的每个虚拟页在物理内存中的位置，操作系统通常会为每个进程保存一个名为<font color=red>页表</font>的数据结构。页表的主要作用是存储地址空间中每个虚拟页的地址转换，从而让我们知道每个页位于物理内存中的位置。对于我们的简单示例，页表将具有以下四个条目：（虚拟页 0 → 物理页3）、（VP 1 → PF 7）、（VP 2 → PF 5）和（VP 3 → PF 2）。</p><p>重要的是要记住，这个页表是一个每个进程的数据结构（我们讨论的大多数页表结构都是每个进程的结构；我们将提到一个例外，即<font color=red>反向页表</font>）。如果在上面的示例中运行另一个进程，则操作系统必须为其管理不同的页表，因为它的虚拟页面显然映射到不同的物理页面（除非有任何共享正在进行）。</p><p>现在，我们知道足够多以执行地址转换示例。让我们想象一下具有微小地址空间（64字节）的进程正在执行内存访问：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>movl</span> <span class=err>&lt;</span><span class=no>virtual</span> <span class=no>address</span><span class=err>&gt;</span><span class=p>,</span> <span class=nv>%eax</span></span></span></code></pre></td></tr></table></div></div><p>具体来说，让我们注意将数据从地址<code>&lt;virtual address></code>显式加载到寄存器 eax 中（从而忽略之前必须发生的指令获取）。</p><p>为了转换进程生成的虚拟地址，我们必须首先将其分为两个部分：<font color=red>虚拟页号（Vitrual page number,VPN）和页面内的偏移量</font>。对于此示例，由于进程的虚拟地址空间为 64 字节，因此我们的虚拟地址总共需要 6 位 ($2^6 = 64$)。因此，我们的虚拟地址可以概念化如下：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-conceptualized.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-conceptualized.png?size=small" data-sub-html="<h2>image-20240401192124164</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-conceptualized.png alt=image-20240401192124164 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-conceptualized.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-conceptualized.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-conceptualized.png?size=large 2x" data-title=image-20240401192124164 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>其中，Va5是虚拟地址的最高位，Va0是最低位。因为我们知道页面大小（16字节），则前两位代表虚拟页号，后四位代表页面偏移量。在 64 字节地址空间中，页面大小为 16 字节；因此我们需要能够选择 4 个页面，地址的前 2 位就可以做到这一点。因此，我们有一个 2 位虚拟页码 (VPN)。剩余的位则表示页面偏移量。</p><p>当进程生成虚拟地址时，操作系统和硬件必须结合起来将其转换为有意义的物理地址。例如，假设上述加载到虚拟地址 21：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>movl</span> <span class=mi>21</span><span class=p>,</span> <span class=nv>%eax</span></span></span></code></pre></td></tr></table></div></div><p>将“21”转换为二进制形式，我们得到“010101”，因此我们可以检查这个虚拟地址并查看它如何分解为虚拟页号（VPN）和偏移量：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-example-5.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-example-5.png?size=small" data-sub-html="<h2>image-20240401192754374</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-example-5.png alt=image-20240401192754374 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-example-5.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-example-5.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-example-5.png?size=large 2x" data-title=image-20240401192754374 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>因此，虚拟地址“21”位于虚拟页“01”（或1）的第5（“0101”）字节。有了虚拟页号，我们现在可以索引页表并找到虚拟页 1 所在的物理页。在上面的页表中，物理页号 (Physical page number, PPN)（有时也称为物理帧号或 PFN）为 7（二进制 111）。因此，我们可以通过用 PPN 替换 VPN 来转换这个虚拟地址，然后向物理内存加载数据，如下图所示。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-translation-example-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-translation-example-1.png?size=small" data-sub-html="<h2>image-20240401193152226</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-translation-example-1.png alt=image-20240401193152226 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-translation-example-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-translation-example-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual-address-translation-example-1.png?size=large 2x" data-title=image-20240401193152226 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>请注意，偏移量保持不变（即，它没有被转换），因为偏移量只是告诉我们我们想要页面中的哪个字节。我们的最终物理地址是 1110101（十进制为 117），这正是我们希望加载获取数据的位置。</p><h2 id=页表存储在哪 class=heading-element><span>2 页表存储在哪？</span>
<a href=#%e9%a1%b5%e8%a1%a8%e5%ad%98%e5%82%a8%e5%9c%a8%e5%93%aa class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>页表可以变得非常大，比我们之前讨论的小分段表或基址/边界对大得多。例如，想象一个典型的 32 位地址空间，具有 4KB 页面。该虚拟地址分为 20 位 VPN 和 12 位偏移量（回想一下，1KB 页面大小需要 10 位，只需再添加两位即可达到 4KB）。</p><p>20 位 VPN 意味着操作系统必须为每个进程管理 $2^{20}$ 个转换（大约一百万个）；假设每个页表项 (page table entry, PTE) 需要 4 个字节来保存物理转换以及任何其他有用的内容，那么每个页表需要 4MB 的巨大内存！那是相当大的。现在假设有 100 个进程正在运行：这意味着操作系统需要 400MB 内存来用于所有这些地址转换！即使在机器拥有千兆字节内存的现代，将大量内存用于地址转换似乎也有点疯狂，不是吗？我们甚至没有考虑对于 64 位地址空间来说这样的页表有多大；那太可怕了，也许会把你完全吓跑。</p><p>由于页表太大，我们没有在MMU中保留任何特殊的片上硬件来存储当前运行进程的页表。相反，我们将每个进程的页表存储在内存中的某个位置。现在我们假设页表位于操作系统管理的物理内存中，下图是操作系统内存中页表的图片。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example-Page-Table.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example-Page-Table.png?size=small" data-sub-html="<h2>image-20240401200708977</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example-Page-Table.png alt=image-20240401200708977 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example-Page-Table.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example-Page-Table.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Example-Page-Table.png?size=large 2x" data-title=image-20240401200708977 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=页表中到底有什么 class=heading-element><span>3 页表中到底有什么？</span>
<a href=#%e9%a1%b5%e8%a1%a8%e4%b8%ad%e5%88%b0%e5%ba%95%e6%9c%89%e4%bb%80%e4%b9%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>让我们来谈谈页表的组织结构。页表只是一种数据结构，用于将虚拟地址（或实际上是虚拟页码）映射到物理地址（物理页号）。因此，任何数据结构都可以使用。最简单的形式称为<font color=red>线性页表</font>，它只是一个数组。操作系统根据虚拟页码（VPN）对数组进行索引，并查找该索引下的页表项（PTE），以找到所需的物理页号（PFN）。目前，我们将假设这种简单的线性结构；在后面的章节中，我们将使用更高级的数据结构来帮助解决分页中的一些问题。</p><p>至于每个 PTE 的内容，我们有许多不同的bit位值得在一定程度上了解。<strong>有效位</strong>通常用于指示特定转换是否有效。例如，当程序开始运行时，其地址空间的一端是代码和堆，另一端是栈。中间所有未使用的空间都会被标记为无效，如果进程试图访问这些内存，就会向操作系统发出中断，操作系统很可能会终止进程。因此，有效位对于支持稀疏地址空间至关重要；只需将地址空间中所有未使用的页面标记为无效，我们就无需为这些页面分配物理页号，从而节省了大量内存。</p><p>我们还可以使用<strong>保护位</strong>来表明是否可以读取、写入或执行页面。同样，如果以这些位不允许的方式访问页面，就会向操作系统发出中断。</p><p>还有一些其他的位也很重要，但我们现在就不多说了。<strong>存在位</strong>表示该页面是在物理内存中还是在磁盘上（即已被换出）。当我们研究如何将部分地址空间交换到磁盘以支持比物理内存更大的地址空间时，我们将进一步了解这一机制；交换允许操作系统通过将很少使用的页面移动到磁盘来释放物理内存。**脏位（dirty bit）**也很常见，表示页面进入内存后是否被修改过。</p><p><strong>参考位（又称访问位）<strong>有时用于跟踪页面是否被访问过，它有助于确定哪些页面受欢迎，因此应保留在内存中；在</strong>页面替换</strong>过程中，这种知识至关重要。</p><p>下图显示了 x86 架构中的一个页表条目示例。它包含一个存在位 (P)；一个读/写位 (R/W)，用于确定是否允许写入该页面；一个用户/监管者位 (U/S)，用于确定用户模式进程是否可以访问该页面；几个位（PWT、PCD、PAT 和 G），用于确定这些页面的硬件缓存工作方式；一个已访问位 (A) 和一个脏位 (D)；最后是物理页号（PFN）本身。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/An-x86-Page-Table-Entry.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/An-x86-Page-Table-Entry.png?size=small" data-sub-html="<h2>image-20240401201712524</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/An-x86-Page-Table-Entry.png alt=image-20240401201712524 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/An-x86-Page-Table-Entry.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/An-x86-Page-Table-Entry.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/An-x86-Page-Table-Entry.png?size=large 2x" data-title=image-20240401201712524 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=分页也太慢 class=heading-element><span>4 分页：也太慢</span>
<a href=#%e5%88%86%e9%a1%b5%e4%b9%9f%e5%a4%aa%e6%85%a2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>对于内存中的页表，我们已经知道它们可能过大。事实证明，它们也会拖慢运行速度。举个简单的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>movl</span> <span class=mi>21</span><span class=p>,</span> <span class=nv>%eax</span></span></span></code></pre></td></tr></table></div></div><p>同样，我们只检查对地址 21 的显式引用，而不用担心取指令。在这个例子中，我们假设硬件为我们执行地址转换。为了获取所需的数据，系统必须首先将虚拟地址（21）转换为正确的物理地址（117）。因此，在从地址 117 获取数据之前，系统必须首先从进程的页表中获取正确的页表条目，执行转换，然后从物理内存加载数据。</p><p>为此，硬件必须知道当前运行进程的页表在哪里。现在我们假设单个页表基址寄存器包含页表起始位置的物理地址。为了找到所需 PTE 的位置，硬件将执行以下功能：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>VPN</span> <span class=o>=</span> <span class=p>(</span><span class=n>VirtualAddress</span> <span class=o>&amp;</span> <span class=n>VPN_MASK</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>SHIFT</span>
</span></span><span class=line><span class=cl><span class=n>PTEAddr</span> <span class=o>=</span> <span class=n>PageTableBaseRegister</span> <span class=o>+</span> <span class=p>(</span><span class=n>VPN</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>PTE</span><span class=p>))</span></span></span></code></pre></td></tr></table></div></div><p>在我们的示例中，<code>VPN_MASK</code> 将设置为 0x30（十六进制 30，或二进制 110000），它从完整虚拟地址中挑选出 VPN 位； <code>SHIFT</code> 设置为 4（偏移量中的位数），以便我们将 VPN 位向下移动以形成正确的整数虚拟页号。例如，对于虚拟地址21（010101），掩码将该值变成010000；根据需要，移位会将其变为 01 或虚拟页 1。然后，我们使用该值作为页表基址寄存器指向的 PTE 数组的索引。</p><p>一旦知道这个物理地址，硬件就可以从内存中获取 PTE，提取 PFN，并将其与虚拟地址的偏移量连接起来，形成所需的物理地址。具体来说，可以认为 PFN 通过 SHIFT 左移，然后与偏移量按位或运算形成最终地址，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>offset</span> <span class=o>=</span> <span class=n>VirtualAddress</span> <span class=o>&amp;</span> <span class=n>OFFSET_MASK</span>
</span></span><span class=line><span class=cl><span class=n>PhysAddr</span> <span class=o>=</span> <span class=p>(</span><span class=n>PFN</span> <span class=o>&lt;&lt;</span> <span class=n>SHIFT</span><span class=p>)</span> <span class=o>|</span> <span class=n>offset</span></span></span></code></pre></td></tr></table></div></div><p>最后，硬件可以从内存中取出所需的数据并将其放入寄存器eax中。程序现在已成功从内存加载一个值！</p><p>总而言之，我们现在描述每个内存引用上发生的情况的初始协议。下面这段代码显示了基本方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Extract the VPN from the virtual address</span>
</span></span><span class=line><span class=cl><span class=n>VPN</span> <span class=o>=</span> <span class=p>(</span><span class=n>VirtualAddress</span> <span class=o>&amp;</span> <span class=n>VPN_MASK</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>SHIFT</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Form the address of the page-table entry (PTE)</span>
</span></span><span class=line><span class=cl><span class=n>PTEAddr</span> <span class=o>=</span> <span class=n>PTBR</span> <span class=o>+</span> <span class=p>(</span><span class=n>VPN</span> <span class=o>*</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>PTE</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Fetch the PTE</span>
</span></span><span class=line><span class=cl><span class=n>PTE</span> <span class=o>=</span> <span class=n>AccessMemory</span><span class=p>(</span><span class=n>PTEAddr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Check if process can access the page</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>PTE</span><span class=o>.</span><span class=n>Valid</span> <span class=o>==</span> <span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>RaiseException</span><span class=p>(</span><span class=n>SEGMENTATION_FAULT</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>CanAccess</span><span class=p>(</span><span class=n>PTE</span><span class=o>.</span><span class=n>ProtectBits</span><span class=p>)</span> <span class=o>==</span> <span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>RaiseException</span><span class=p>(</span><span class=n>PROTECTION_FAULT</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=c1># Access is OK: form physical address and fetch it</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=n>VirtualAddress</span> <span class=o>&amp;</span> <span class=n>OFFSET_MASK</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysAddr</span> <span class=o>=</span> <span class=p>(</span><span class=n>PTE</span><span class=o>.</span><span class=n>PFN</span> <span class=o>&lt;&lt;</span> <span class=n>PFN_SHIFT</span><span class=p>)</span> <span class=o>|</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>    <span class=n>Register</span> <span class=o>=</span> <span class=n>AccessMemory</span><span class=p>(</span><span class=n>PhysAddr</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>对于每个内存引用（无论是指令获取还是显式加载或存储），分页要求我们执行一次额外的内存引用，以便首先从页表中获取。这是很多工作！额外的内存引用成本高昂，在这种情况下可能会使进程减慢两倍或更多。</p><p>现在您有望看到我们必须解决两个真正的问题。如果没有仔细设计硬件和软件，页表会导致系统运行速度过慢，并且占用过多的内存。虽然这似乎是满足我们内存虚拟化需求的一个很好的解决方案，但必须首先克服这两个关键问题。</p><h2 id=内存跟踪 class=heading-element><span>5 内存跟踪</span>
<a href=#%e5%86%85%e5%ad%98%e8%b7%9f%e8%b8%aa class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在结束之前，我们现在通过一个简单的内存访问示例来演示使用分页时发生的所有结果内存访问。我们感兴趣的代码片段（在 C 语言中，在名为 array.c 的文件中）如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>array</span><span class=p>[</span><span class=mi>1000</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>我们编译 array.c 并使用以下命令运行它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gcc -o array array.c -Wall -O
</span></span><span class=line><span class=cl>./array</span></span></code></pre></td></tr></table></div></div><p>当然，为了真正理解内存访问此代码片段（它只是初始化一个数组）会产生什么，我们必须知道（或假设）更多的事情。首先，我们必须反汇编生成的二进制文件（在 Linux 上使用 objdump，在 Mac 上使用 otool）以查看使用哪些汇编指令来初始化循环中的数组。这是生成的汇编代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>0</span><span class=nf>x1024</span> <span class=no>movl</span> <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%edi</span><span class=p>,</span><span class=nv>%eax</span><span class=p>,</span><span class=mi>4</span><span class=p>)</span> <span class=c1>#Power of CISC! edi+eax*4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>0</span><span class=nf>x1028</span> <span class=no>incl</span> <span class=nv>%eax</span> <span class=c1>#Increase counter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>0</span><span class=nf>x102c</span> <span class=no>cmpl</span> <span class=no>$0x03e8</span><span class=p>,</span><span class=nv>%eax</span> <span class=c1>#Check if last element
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>0</span><span class=nf>x1030</span> <span class=no>jne</span> <span class=mi>0x1024</span> <span class=err>#</span><span class=no>Implicit</span> <span class=p>(</span><span class=no>eflags</span><span class=p>)</span> <span class=no>Zero</span> <span class=no>bit</span> <span class=no>access</span></span></span></code></pre></td></tr></table></div></div><p>如果您了解一点 x86，该代码实际上很容易理解。第一条指令将值零（显示为 $0x0）移动到数组位置的虚拟内存地址中；该地址是通过获取 %edi 的内容并添加 %eax 乘以四来计算的。因此，%edi 保存数组的基地址，而 %eax 保存数组索引 (i)；我们乘以四，因为该数组是整数数组，每个整数大小为四个字节。</p><p>第二条指令递增 %eax 中保存的数组索引，第三条指令将该寄存器的内容与十六进制值 0x03e8 或十进制 1000 进行比较。如果比较显示两个值还不相等（这就是 jne 指令测试的结果），第四条指令跳回循环顶部。</p><p>为了了解该指令序列访问哪些内存（在虚拟和物理级别），我们必须假设代码片段和数组在虚拟内存中的位置，以及页表的内容和位置。对于此示例，我们假设虚拟地址空间大小为 64KB（小得不切实际）。我们还假设页面大小为 1KB。</p><p>我们现在需要知道的是页表的内容及其在物理内存中的位置。假设我们有一个线性（基于数组）页表，并且它位于物理地址 1KB (1024)。</p><p>至于其内容，我们只需要担心在本示例中映射了几个虚拟页面。首先，代码所在的虚拟页面。由于页面大小为 1KB，因此虚拟地址 1024 驻留在虚拟地址空间的第二页上（VPN=1，因为 VPN=0 是第一页）。我们假设该虚拟页面映射到物理帧 4 (VPN 1 → PFN 4)。</p><p>接下来是数组本身。它的大小是 4000 字节（1000 个整数），我们假设它驻留在虚拟地址 40000 到 44000（不包括最后一个字节）。此十进制范围的虚拟页面为 VPN=39 &mldr; VPN=42。因此，我们需要这些页面的映射。我们假设以下虚拟到物理映射为示例：(VPN 39 → PFN 7)、(VPN 40 → PFN 8)、(VPN 41 → PFN 9)、(VPN 42 → PFN 10)。</p><p>我们现在准备跟踪程序的内存引用。当它运行时，每个指令获取都会生成两个内存引用：一个到页表以查找指令所在的物理页，另一个到指令本身以将其获取到 CPU 进行处理。此外，还有一个以 mov 指令形式出现的显式内存引用；这首先增加了另一个页表访问（将数组虚拟地址转换为正确的物理地址），然后才是数组访问本身。</p><p>下图描述了前五个循环迭代的整个过程。最下面的图以黑色显示 y 轴上的指令内存引用（左边是虚拟地址，右边是实际物理地址）；中间的图以深灰色显示数组访问（同样是左边是虚拟地址，右边是物理地址）；最后，最上面的图以浅灰色显示页表内存访问（只是物理访问，因为本例中的页表位于物理内存中）。整个跟踪的 x 轴显示了循环前五次迭代的内存访问；每个循环有 10 次内存访问，其中包括四次指令取回、一次内存显式更新和五次页表访问，以转换这四次取回和一次显式更新。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Memory-Trace-Example-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Memory-Trace-Example-1.png?size=small" data-sub-html="<h2>image-20240401224435986</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Memory-Trace-Example-1.png alt=image-20240401224435986 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Memory-Trace-Example-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Memory-Trace-Example-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Memory-Trace-Example-1.png?size=large 2x" data-title=image-20240401224435986 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ class=collection-nav-item rel=prev title=空闲空间管理><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>空闲空间管理</span>
</a><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ class=collection-nav-item rel=next title=快表><span>快表</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-10-26 03:13:14">更新于 2024-10-26&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/13.%E9%A1%B5/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/13.%e9%a1%b5.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_develop/_system/ostep/13.%e9%a1%b5.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20%E9%A1%B5&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E9%A1%B5%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/13.%E9%A1%B5/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/13.%e9%a1%b5.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/13.%E9%A1%B5/ data-title=页 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/13.%E9%A1%B5/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/13.%E9%A1%B5/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/13.%E9%A1%B5/ data-title=页><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/13.%E9%A1%B5/ data-title=页><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ class=post-nav-item rel=prev title=快表><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>快表</a>
<a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ class=post-nav-item rel=next title=空闲空间管理>空闲空间管理<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>