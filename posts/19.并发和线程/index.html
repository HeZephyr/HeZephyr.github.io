<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>并发和线程 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="到目前为止，我们已经看到了操作系统执行的基本抽象的发展。我们已经了解了如何将单个物理 CPU 转变为多个虚拟 CPU，从而实现多个程序同时运行的错觉。我们还了解了如何为每个进程创建一个大的、私有的虚拟内存；当操作系统确实在物理内存（有时是磁盘）上秘密复用地址空间时，地址空间的这种抽象使每个程序的行为就好像它拥"><meta name=keywords content='OS'><meta itemprop=name content="并发和线程"><meta itemprop=description content="到目前为止，我们已经看到了操作系统执行的基本抽象的发展。我们已经了解了如何将单个物理 CPU 转变为多个虚拟 CPU，从而实现多个程序同时运行的错觉。我们还了解了如何为每个进程创建一个大的、私有的虚拟内存；当操作系统确实在物理内存（有时是磁盘）上秘密复用地址空间时，地址空间的这种抽象使每个程序的行为就好像它拥"><meta itemprop=datePublished content="2024-05-11T20:35:49+00:00"><meta itemprop=dateModified content="2024-09-03T12:31:54+00:00"><meta itemprop=wordCount content="5353"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="并发和线程"><meta property="og:description" content="到目前为止，我们已经看到了操作系统执行的基本抽象的发展。我们已经了解了如何将单个物理 CPU 转变为多个虚拟 CPU，从而实现多个程序同时运行的错觉。我们还了解了如何为每个进程创建一个大的、私有的虚拟内存；当操作系统确实在物理内存（有时是磁盘）上秘密复用地址空间时，地址空间的这种抽象使每个程序的行为就好像它拥"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-11T20:35:49+00:00"><meta property="article:modified_time" content="2024-09-03T12:31:54+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="并发和线程"><meta name=twitter:description content="到目前为止，我们已经看到了操作系统执行的基本抽象的发展。我们已经了解了如何将单个物理 CPU 转变为多个虚拟 CPU，从而实现多个程序同时运行的错觉。我们还了解了如何为每个进程创建一个大的、私有的虚拟内存；当操作系统确实在物理内存（有时是磁盘）上秘密复用地址空间时，地址空间的这种抽象使每个程序的行为就好像它拥"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/><link rel=prev href=https://hezephyr.github.io/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/><link rel=next href=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"并发和线程","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":5353,"url":"https:\/\/hezephyr.github.io\/posts\/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B\/","datePublished":"2024-05-11T20:35:49+00:00","dateModified":"2024-09-03T12:31:54+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>并发和线程</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><span class=active title=并发和线程>并发和线程</span></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ class=collection-nav-item rel=prev title=完整VM系统><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>19/39</span><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ class=collection-nav-item rel=next title=线程API><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>并发和线程</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-05-11 20:35:49"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-11>2024-05-11</time></span>&nbsp;<span title="更新于 2024-09-03 12:31:54"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-09-03>2024-09-03</time></span>&nbsp;<span title="5353 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5400 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 11 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=并发和线程>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#为什么要使用线程>为什么要使用线程</a></li><li><a href=#示例线程创建>示例：线程创建</a></li><li><a href=#为什么情况会变得更糟共享数据>为什么情况会变得更糟：共享数据</a></li><li><a href=#问题的核心不受控制的调度>问题的核心：不受控制的调度</a></li><li><a href=#对原子性的渴望>对原子性的渴望</a></li><li><a href=#另一个问题等待另一个线程>另一个问题：等待另一个线程</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><p>到目前为止，我们已经看到了操作系统执行的基本抽象的发展。我们已经了解了如何将单个物理 CPU 转变为多个虚拟 CPU，从而实现多个程序同时运行的错觉。我们还了解了如何为每个进程创建一个大的、私有的虚拟内存；当操作系统确实在物理内存（有时是磁盘）上秘密复用地址空间时，地址空间的这种抽象使每个程序的行为就好像它拥有自己的内存一样。</p><p>在本文中，我们为单个正在运行的进程引入了一种新的抽象：线程。我们通常认为程序中只有一个执行点（即从一台 PC 获取指令并执行），而多线程程序则有多个执行点（即多台 PC，每台 PC 获取指令并执行）。也许我们可以换个角度来理解，每个线程都很像一个独立的进程，<font color=red>但有一点不同：它们共享相同的地址空间，因此可以访问相同的数据</font>。</p><p>因此，单个线程的状态与进程的状态非常相似。它有一个程序计数器 (PC)，用于跟踪程序从何处获取指令。每个线程都有自己的一组用于计算的私有寄存器；因此，如果有两个线程在单个处理器上运行，则当从运行一个线程 (T1) 切换到运行另一个线程 (T2) 时，必须进行上下文切换。线程之间的上下文切换与进程之间的上下文切换非常相似，因为在运行T2之前必须保存T1的寄存器状态并恢复T2的寄存器状态。对于进程，我们将状态保存到进程控制块（PCB）；现在，我们需要一个或多个线程控制块（TCB）来存储进程的每个线程的状态。不过，与进程相比，我们在线程之间执行的上下文切换有一个主要区别：<font color=red>地址空间保持不变（即无需切换我们正在使用的页表）</font>。</p><p>线程与进程的另一个主要区别与栈有关。在我们对传统进程（我们现在可以称之为单线程进程）地址空间的简单模型中，只有一个栈，通常位于地址空间的底部，如下图所示（左）。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Stack-Of-The-Relevant-Thread.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Stack-Of-The-Relevant-Thread.png?size=small" data-sub-html="<h2>image-20240406102345691</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Stack-Of-The-Relevant-Thread.png alt=image-20240406102345691 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Stack-Of-The-Relevant-Thread.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Stack-Of-The-Relevant-Thread.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Stack-Of-The-Relevant-Thread.png?size=large 2x" data-title=image-20240406102345691 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>但是，在多线程进程中，每个线程都是独立运行的，当然也会调用各种例程来完成自己的工作。地址空间中的堆栈不是单一的，而是每个线程都有一个。假设我们有一个多线程进程，其中有两个线程，那么产生的地址空间看起来就不一样了（上图右）。</p><p>从图中可以看到，在整个进程的地址空间中分布着两个栈。因此，任何栈分配的变量、参数、返回值以及其他我们放在栈上的东西都将被放在有时被称为<strong>线程本地存储</strong>的地方，即相关线程的栈中。</p><p>你可能还会注意到，这破坏了我们美丽的地址空间布局。以前，栈和堆可以独立增长，只有当地址空间空间不足时才会出现问题。在这里，我们不再有这样好的情况了。幸运的是，这通常没有问题，因为栈一般不需要很大（大量使用递归的程序除外）。</p><h2 id=为什么要使用线程 class=heading-element><span>1 为什么要使用线程</span>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在了解线程的细节和编写多线程程序时可能遇到的一些问题之前，让我们先回答一个更简单的问题。为什么要使用线程？</p><p>事实证明，使用线程至少有两个主要原因。第一个原因很简单：<font color=red>并行性</font>。想象一下，你正在编写一个对大型数组执行操作的程序，例如，将两个大型数组相加，或将数组中每个元素的值递增一定量。如果只在单个处理器上运行，任务就很简单：只需执行每个操作即可完成。但是，如果在多处理器系统上执行程序，则可以通过使用处理器分别执行部分操作来大大加快这一过程。将标准的单线程程序转换为能在多个 CPU 上完成此类工作的程序的任务称为并行化，而在每个 CPU 上使用一个线程来完成这项工作是使程序在现代硬件上运行得更快的一种自然而典型的方法。</p><p>第二个原因比较微妙：<font color=red>避免因 I/O 速度慢而导致程序进程受阻</font>。想象一下，你正在编写一个执行不同类型 I/O 的程序：等待发送或接收消息，等待显式磁盘 I/O 完成，甚至（隐式）等待页面故障完成。与其等待，你的程序可能希望做其他事情，包括利用 CPU 进行计算，甚至发出更多 I/O 请求。使用线程是避免卡死的一种自然方法；当程序中的一个线程在等待（即等待 I/O 时被阻塞）时，CPU 调度器可以切换到其他线程，这些线程已经准备好运行并做一些有用的事情。线程可以使 I/O 与单个程序中的其他活动<strong>重叠</strong>，就像跨程序进程的多编程一样；因此，许多基于服务器的现代应用程序（网络服务器、数据库管理系统等）在其实现中都使用了线程。</p><p>当然，在上述任何一种情况下，你都可以使用多进程来代替线程。不过，线程共享地址空间，因此很容易共享数据，因此是构建这类程序时的自然选择。而对于逻辑上独立的任务，几乎不需要共享内存中的数据结构，进程则是更合理的选择。</p><h2 id=示例线程创建 class=heading-element><span>2 示例：线程创建</span>
<a href=#%e7%a4%ba%e4%be%8b%e7%ba%bf%e7%a8%8b%e5%88%9b%e5%bb%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>让我们来了解一些细节。假设我们想运行一个程序，创建两个线程，每个线程都做一些独立的工作，在本例中就是打印 &ldquo;A &ldquo;或 &ldquo;B&rdquo;，代码如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common_threads.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mythread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;main: begin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=s>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=s>&#34;B&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;main: end</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>主程序创建了两个线程，每个线程都将运行函数 <code>mythread()</code>，但使用不同的参数（字符串 A 或 B）。线程创建后，可能会立即开始运行（取决于调度程序的奇思妙想）；也可能处于 &ldquo;就绪 &ldquo;状态，但不是 &ldquo;运行 &ldquo;状态，因此尚未运行。当然，在多处理器上，线程甚至可以同时运行，但我们先不要担心这种可能性。</p><p>创建两个线程（我们暂且称其为 T1 和 T2）后，主线程调用 <code>pthread_join()</code>，等待特定线程完成。它会这样做两次，从而确保 T1 和 T2 运行并完成，最后才允许主线程再次运行；当主线程运行时，它会打印 <code>"main: end"</code>并退出。总的来说，这次运行共使用了三个线程：<font color=red>主线程、T1 和 T2</font>。</p><p>让我们来看看这个小程序可能的执行顺序。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Possible-Outcomes-Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Possible-Outcomes-Example.png?size=small" data-sub-html="<h2>image-20240406105430536</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Possible-Outcomes-Example.png alt=image-20240406105430536 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Possible-Outcomes-Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Possible-Outcomes-Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Possible-Outcomes-Example.png?size=large 2x" data-title=image-20240406105430536 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>在执行图中，时间向下递增，每一列表示不同线程（主线程、线程 1 或线程 2）运行的时间。</p><p>正如你所看到的，一种理解线程创建的方法是，它有点像函数调用；不过，系统并不是首先执行函数，然后返回给调用者，而是为被调用的例程创建一个新的执行线程，它独立于调用者运行，可能在从创建返回之前运行，但也可能更晚。下一步运行什么由操作系统调度程序决定，虽然调度程序很可能实现了某种合理的算法，但很难知道在任何给定时间内会运行什么。</p><h2 id=为什么情况会变得更糟共享数据 class=heading-element><span>3 为什么情况会变得更糟：共享数据</span>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%bc%9a%e5%8f%98%e5%be%97%e6%9b%b4%e7%b3%9f%e5%85%b1%e4%ba%ab%e6%95%b0%e6%8d%ae class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>我们上面展示的简单线程示例很有用，它展示了线程是如何创建的，以及它们是如何根据调度程序的决定以不同顺序运行的。但它没有向你展示线程在访问共享数据时是如何交互的。</p><p>让我们想象一个简单的例子：两个线程希望更新一个全局共享变量，代码如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common_threads.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>max</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>volatile</span> <span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// shared global variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mythread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>letter</span> <span class=o>=</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span> <span class=c1>// stack (private per thread) 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s: begin [addr of i: %p]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>letter</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>max</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>counter</span> <span class=o>=</span> <span class=n>counter</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// shared: only one
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s: done</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>letter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>                                                                             
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>                    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;usage: main-first &lt;loopcount&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>max</span> <span class=o>=</span> <span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;main: begin [counter = %d] [%x]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>counter</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	   <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>counter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=s>&#34;A&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=s>&#34;B&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// join waits for the threads to finish
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;main: done</span><span class=se>\n</span><span class=s> [counter: %d]</span><span class=se>\n</span><span class=s> [should: %d]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	   <span class=n>counter</span><span class=p>,</span> <span class=n>max</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>首先，<code>Pthread create()</code> 只需调用 <code>pthread create()</code>，并确保返回代码为 0；如果不是，<code>Pthread create()</code> 只需打印一条信息并退出。其次，我们不再为工作线程使用两个独立的函数体，而是只使用一段代码，并向线程传递一个参数（在本例中是一个字符串），这样我们就可以让每个线程在其消息前打印不同的字母。</p><p>最后，也是最重要的一点，我们现在可以看看每个工作线程要做什么：在共享变量计数器中添加一个数字，并在一个循环中执行 1000 万次（1e7）。因此，我们想要的最终结果是：20,000,000。</p><p>现在我们编译并运行程序，看看它的运行情况。不幸的是，当我们运行这段代码时，即使在单个处理器上，我们也不一定能得到期望的结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>❯ make shared_data
</span></span><span class=line><span class=cl>gcc -o shared_data shared_data.c -Wall
</span></span><span class=line><span class=cl>❯ ./shared_data <span class=m>10000000</span>
</span></span><span class=line><span class=cl>main: begin <span class=o>[</span><span class=nv>counter</span> <span class=o>=</span> 0<span class=o>]</span> <span class=o>[</span>2b2c000<span class=o>]</span>
</span></span><span class=line><span class=cl>A: begin <span class=o>[</span>addr of i: 0x16d362fac<span class=o>]</span>
</span></span><span class=line><span class=cl>B: begin <span class=o>[</span>addr of i: 0x16d3eefac<span class=o>]</span>
</span></span><span class=line><span class=cl>A: <span class=k>done</span>
</span></span><span class=line><span class=cl>B: <span class=k>done</span>
</span></span><span class=line><span class=cl>main: <span class=k>done</span>
</span></span><span class=line><span class=cl> <span class=o>[</span>counter: 10306439<span class=o>]</span>
</span></span><span class=line><span class=cl> <span class=o>[</span>should: 20000000<span class=o>]</span></span></span></code></pre></td></tr></table></div></div><p>我们可以多运行几次，可以发现不仅每次运行都是错误的，而且得出的结果也不一样！还有一个大问题：为什么会出现这种情况？</p><h2 id=问题的核心不受控制的调度 class=heading-element><span>4 问题的核心：不受控制的调度</span>
<a href=#%e9%97%ae%e9%a2%98%e7%9a%84%e6%a0%b8%e5%bf%83%e4%b8%8d%e5%8f%97%e6%8e%a7%e5%88%b6%e7%9a%84%e8%b0%83%e5%ba%a6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>要理解为什么会出现这种情况，我们必须了解编译器为更新<code>counter</code>而生成的代码序列。在本例中，我们希望简单地向<code>counter</code>添加一个数字 (1)。因此，这样做的代码序列可能是这样的（在 x86 中）；</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>mov</span> <span class=mi>0x8049a1c</span><span class=p>,</span> <span class=nv>%eax</span>
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=no>$0x1</span><span class=p>,</span> <span class=nv>%eax</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nv>%eax</span><span class=p>,</span> <span class=mi>0x8049a1c</span></span></span></code></pre></td></tr></table></div></div><p>本例假设变量计数器位于地址 0x8049a1c。在这个三条指令序列中，首先使用 x86 mov 指令获取地址处的内存值，并将其放入寄存器 eax。然后执行 add 指令，将 eax 寄存器的内容加上 1 (0x1)，最后将 eax 的内容存储回相同地址的内存中。</p><p>假设两个线程中的一个（线程 1）进入了代码的这一区域，并准备将<code>counter</code>递增 1。它将<code>counter</code>的值（假设一开始是 50）加载到寄存器 eax 中。因此，线程 1 的寄存器 eax=50。然后在寄存器中加一，因此 eax=51 。</p><p>现在，不幸的事情发生了：定时器中断触发，操作系统将当前运行线程的状态（PC、包括 eax 在内的寄存器等）保存到线程的 TCB 中。现在更糟的事情发生了：线程 2 被选中运行，它也进入了这段代码。它也执行了第一条指令，获取了<code>counter</code>的值并将其放入 eax（记住：<font color=red>每个线程在运行时都有自己的专用寄存器；寄存器由上下文切换代码虚拟化，用于保存和恢复寄存器</font>）。此时计数器的值仍然是 50，因此线程 2 的 eax=50。假设线程 2 执行了接下来的两条指令，将 eax 递增 1（因此 eax=51），然后将 eax 的内容保存到<code>counter</code>（地址 0x8049a1c）中。这样，全局变量计数器现在的值是 51。</p><p>最后，进行另一次上下文切换，线程 1 恢复运行。回想一下，线程 1 刚刚执行了 mov 和 add 指令，现在即将执行最后一条 mov 指令。还记得 eax=51。因此，执行了最后一条 mov 指令，并将值保存到内存中；计数器再次被设置为 51。</p><p>简单地说，发生的情况是这样的：<code>counter</code>递增的代码运行了两次，但<code>counter</code>从 50 开始，现在只等于 51。这个程序的 &ldquo;正确 &ldquo;版本应该是变量<code>counter</code>等于 52。</p><p>让我们看一下详细的执行跟踪，以便更好地理解这个问题。在这个示例中，假设上述代码加载到内存地址 100，就像下面的序列一样（注意：x86 有可变长度指令；mov 指令占用 5 字节内存，而 add 指令只占用 3 字节内存）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>100</span> <span class=nf>mov</span> <span class=mi>0x8049a1c</span><span class=p>,</span> <span class=nv>%eax</span>
</span></span><span class=line><span class=cl><span class=err>105</span> <span class=nf>add</span> <span class=no>$0x1</span><span class=p>,</span> <span class=nv>%eax</span>
</span></span><span class=line><span class=cl><span class=err>108</span> <span class=nf>mov</span> <span class=nv>%eax</span><span class=p>,</span> <span class=mi>0x8049a1c</span></span></span></code></pre></td></tr></table></div></div><p>如下图所示，假设计数器的起始值为 50，并跟踪此示例以确保了解发生了什么。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Problem-Up-Close-And-Personal.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Problem-Up-Close-And-Personal.png?size=small" data-sub-html="<h2>image-20240406122802826</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Problem-Up-Close-And-Personal.png alt=image-20240406122802826 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Problem-Up-Close-And-Personal.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Problem-Up-Close-And-Personal.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The-Problem-Up-Close-And-Personal.png?size=large 2x" data-title=image-20240406122802826 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>我们在这里演示的称为竞争条件（或更具体地说，数据竞争）：结果取决于代码的执行时机。如果运气不好（即上下文切换发生在执行过程中的不适时点），我们就会得到错误的结果。事实上，我们每次都可能得到不同的结果；因此，我们将这种结果称为不确定结果，而不是我们习惯于计算机中的良好确定性计算，即不知道输出是什么，并且在不同的运行中它确实可能会有所不同。</p><p>由于执行此代码的多个线程可能会导致竞争条件，因此我们将此代码称为<font color=red>临界区</font>。临界区是访问共享变量（或更一般地说，共享资源）的一段代码，并且不能由多个线程同时执行。</p><p>对于这段代码，我们真正想要的是我们所说的<strong>互斥</strong>。这一属性保证如果一个线程在临界区内执行，其他线程将被阻止这样做。</p><h2 id=对原子性的渴望 class=heading-element><span>5 对原子性的渴望</span>
<a href=#%e5%af%b9%e5%8e%9f%e5%ad%90%e6%80%a7%e7%9a%84%e6%b8%b4%e6%9c%9b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>解决这个问题的一种方法是使用功能更强大的指令，只需一步就能完成我们需要完成的任何工作，从而消除不适时中断的可能性。例如，如果我们有这样一条超级指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>memory-add</span> <span class=mi>0x8049a1c</span><span class=p>,</span> <span class=no>$0x1</span></span></span></code></pre></td></tr></table></div></div><p>假设该指令向内存位置添加一个值，并且硬件保证它以原子方式执行；当指令执行时，它将根据需要执行更新。它不能在指令中间被中断，因为这正是我们从硬件得到的保证：当中断发生时，要么指令根本没有运行，要么已经运行完成；没有中间状态。</p><p>在这种情况下，“原子”意味着“作为一个单元”，有时我们将其视为“全部或无”。我们想要的是原子地执行三个指令序列：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>mov</span> <span class=mi>0x8049a1c</span><span class=p>,</span> <span class=nv>%eax</span>
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=no>$0x1</span><span class=p>,</span> <span class=nv>%eax</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nv>%eax</span><span class=p>,</span> <span class=mi>0x8049a1c</span></span></span></code></pre></td></tr></table></div></div><p>正如我们所说，如果我们有一条指令来执行此操作，我们只需发出该指令即可完成。但一般情况下，我们不会有这样的指令。想象一下我们正在构建一个并发 B 树，并希望更新它；我们真的希望硬件支持“B 树原子更新”指令吗？可能不是，至少在健全的指令集中是这样。</p><p>因此，我们要做的是向硬件请求一些有用的指令，根据这些指令我们可以构建一组我们称之为同步原语的通用指令。通过使用这种硬件支持，并结合操作系统的一些帮助，我们将能够构建以同步和受控方式访问临界区的多线程代码，从而可靠地产生正确的结果，尽管并发执行具有挑战性。</p><h2 id=另一个问题等待另一个线程 class=heading-element><span>6 另一个问题：等待另一个线程</span>
<a href=#%e5%8f%a6%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98%e7%ad%89%e5%be%85%e5%8f%a6%e4%b8%80%e4%b8%aa%e7%ba%bf%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>本章在讨论并发问题时，将线程间的交互设定为只有一种类型，即访问共享变量和需要支持临界区的原子性。事实证明，还有另一种常见的交互，即一个线程必须等待另一个线程完成某些操作后才能继续。例如，当一个线程执行磁盘 I/O 并进入休眠状态时，就会出现这种交互；当 I/O 完成后，该线程需要从沉睡中被唤醒，以便继续运行。有时，多个线程的操作应该是同步的。许多线程在数值问题中并行执行迭代， 所有线程应立即开始下一次迭代（屏障） ，此睡眠/唤醒周期将由条件变量控制。</p><blockquote><center font-color=red>关键并发术语：临界区、竞争条件、不确定性、互斥</center><p>这四个术语对于并发代码非常重要</p><ul><li><strong>临界区</strong>是访问共享资源（通常是变量或数据结构）的一段代码。</li><li>如果多个执行线程大致同时进入临界区，则会出现<strong>竞争条件</strong>（或数据竞争）。两者都尝试更新共享数据结构，导致不符合期望的结果。</li><li>不确定程序由一个或多个竞争条件组成；程序的输出每次运行都会有所不同，具体取决于运行的线程。因此，结果是不确定性的，这与我们通常从计算机系统中期望的情况不同。</li><li>为了避免这些问题，线程应该使用某种互斥原语；这样做可以保证只有一个线程进入临界区，从而避免竞争，并产生确定性的程序输出。</li></ul></blockquote></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ class=collection-nav-item rel=prev title=完整VM系统><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>完整VM系统</span>
</a><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ class=collection-nav-item rel=next title=线程API><span>线程API</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-09-03 12:31:54">更新于 2024-09-03&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/19.%e5%b9%b6%e5%8f%91%e5%92%8c%e7%ba%bf%e7%a8%8b.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_develop/_system/ostep/19.%e5%b9%b6%e5%8f%91%e5%92%8c%e7%ba%bf%e7%a8%8b.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/19.%e5%b9%b6%e5%8f%91%e5%92%8c%e7%ba%bf%e7%a8%8b.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ data-title=并发和线程 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ data-title=并发和线程><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ data-title=并发和线程><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ class=post-nav-item rel=prev title=线程API><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>线程API</a>
<a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ class=post-nav-item rel=next title=完整VM系统>完整VM系统<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.133.1"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>