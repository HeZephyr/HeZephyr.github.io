<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version) | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="1 介绍
  
    
  
大型应用在分布式系统中遭遇多重挑战，如并发控制、故障恢复、网络不稳定及服务器时钟异步等。形式化验证则是一种严格确立系统正确性的方法，帮助处理边缘情况。"><meta name=keywords content='分布式系统'><meta itemprop=name content="【论文阅读笔记】Grove: a Separation-Logic Library for Verifying Distributed Systems (Extended Version)"><meta itemprop=description content="1 介绍 大型应用在分布式系统中遭遇多重挑战，如并发控制、故障恢复、网络不稳定及服务器时钟异步等。形式化验证则是一种严格确立系统正确性的方法，帮助处理边缘情况。"><meta itemprop=datePublished content="2024-08-30T00:00:00+00:00"><meta itemprop=dateModified content="2024-10-20T05:30:47+00:00"><meta itemprop=wordCount content="5667"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="分布式系统"><meta property="og:url" content="https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="【论文阅读笔记】Grove: a Separation-Logic Library for Verifying Distributed Systems (Extended Version)"><meta property="og:description" content="1 介绍 大型应用在分布式系统中遭遇多重挑战，如并发控制、故障恢复、网络不稳定及服务器时钟异步等。形式化验证则是一种严格确立系统正确性的方法，帮助处理边缘情况。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-20T05:30:47+00:00"><meta property="article:tag" content="分布式系统"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="【论文阅读笔记】Grove: a Separation-Logic Library for Verifying Distributed Systems (Extended Version)"><meta name=twitter:description content="1 介绍 大型应用在分布式系统中遭遇多重挑战，如并发控制、故障恢复、网络不稳定及服务器时钟异步等。形式化验证则是一种严格确立系统正确性的方法，帮助处理边缘情况。"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/><link rel=prev href=https://hezephyr.github.io/posts/08.mit-6.58406.824-lab3-raft/><link rel=next href=https://hezephyr.github.io/posts/09.mit-6.58406.824-lab4-fault-tolerant-kvservice/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【论文阅读笔记】Grove: a Separation-Logic Library for Verifying Distributed Systems (Extended Version)","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"分布式系统","wordcount":5667,"url":"https:\/\/hezephyr.github.io\/posts\/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove\/","datePublished":"2024-08-30T00:00:00+00:00","dateModified":"2024-10-20T05:30:47+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>论文阅读笔记</span>
<span class=collection-count>11</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0mapreduce/ title="【论文阅读笔记】MapReduce: Simplified Data Processing on Large Clusters">【论文阅读笔记】MapReduce: Simplified Data Processing on Large Clusters</a></li><li class=collection-item><a href=/posts/02.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0gfs/ title="【论文阅读笔记】The Google File System">【论文阅读笔记】The Google File System</a></li><li class=collection-item><a href=/posts/04.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0transformer/ title="【论文阅读笔记】Attention Is All You Need">【论文阅读笔记】Attention Is All You Need</a></li><li class=collection-item><a href=/posts/05.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0deepcad/ title="【论文阅读笔记】DeepCAD: A Deep Generative Network for Computer-Aided Design Models">【论文阅读笔记】DeepCAD: A Deep Generative Network for Computer-Aided Design Models</a></li><li class=collection-item><a href=/posts/06.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0skexgen/ title="【论文阅读笔记】 SkexGen: Autoregressive Generation of CAD Construction Sequences With Disentangled Codebooks">【论文阅读笔记】 SkexGen: Autoregressive Generation of CAD Construction Sequences With Disentangled Codebooks</a></li><li class=collection-item><a href=/posts/07.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0hierarchical-neural-coding-for-controllable-cad-model-generation/ title="【论文阅读笔记】Hierarchical Neural Coding for Controllable CAD Model Generation">【论文阅读笔记】Hierarchical Neural Coding for Controllable CAD Model Generation</a></li><li class=collection-item><a href=/posts/03.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0in-search-of-an-understandable-consensus-algorithm-extended-version/ title="【论文阅读笔记】In Search of an Understandable Consensus Algorithm (Extended Version)">【论文阅读笔记】In Search of an Understandable Consensus Algorithm (Extended Version)</a></li><li class=collection-item><a href=/posts/08.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0zookeeper-wait-free-coordination-for-internet-scale-systems/ title="【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems">【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems</a></li><li class=collection-item><span class=active title="【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)">【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)</span></li><li class=collection-item><a href=/posts/11.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0bigtable/ title="【论文阅读笔记】Bigtable: A Distributed Storage System for Structured Data">【论文阅读笔记】Bigtable: A Distributed Storage System for Structured Data</a></li><li class=collection-item><a href=/posts/10.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0chubby/ title="【论文阅读笔记】The Chubby Lock Service for Loosely-Coupled Distributed Systems">【论文阅读笔记】The Chubby Lock Service for Loosely-Coupled Distributed Systems</a></li></ul><div class=collection-nav-simple><a href=/posts/08.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0zookeeper-wait-free-coordination-for-internet-scale-systems/ class=collection-nav-item rel=prev title="【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>9/11</span><a href=/posts/11.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0bigtable/ class=collection-nav-item rel=next title="【论文阅读笔记】Bigtable: A Distributed Storage System for Structured Data"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a>&ensp;<a href=/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=post-category title="分类 - 论文阅读"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 论文阅读</a> 和 <a href=/collections/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ class=post-collection title="合集 - 论文阅读笔记"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> 论文阅读笔记</a></span></div><div class=post-meta-line><span title="发布于 2024-08-30 00:00:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-08-30>2024-08-30</time></span>&nbsp;<span title="更新于 2024-10-20 05:30:47"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-10-20>2024-10-20</time></span>&nbsp;<span title="5667 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5700 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 12 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#介绍>介绍</a></li><li><a href=#常见组件-grove案例研究>常见组件-Grove案例研究</a><ol><li><a href=#rpc库>RPC库</a></li><li><a href=#复制状态机库>复制状态机库</a></li><li><a href=#vrsm上层应用>vRSM上层应用</a></li></ol></li><li><a href=#grove性能评估>Grove性能评估</a></li><li><a href=#总结>总结</a><ol><li><a href=#grovekv系统>GroveKV系统</a></li><li><a href=#grove核心>Grove核心</a></li></ol></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><h2 id=介绍 class=heading-element><span>1 介绍</span>
<a href=#%e4%bb%8b%e7%bb%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>大型应用在分布式系统中遭遇多重挑战，如并发控制、故障恢复、网络不稳定及服务器时钟异步等。形式化验证则是一种严格确立系统正确性的方法，帮助处理边缘情况。</p><p>租约是分布式系统中的关键技术，用于保证系统某方面在一定时间内不变，GFS、Chubby和DynamoDB都具有类似的机制。例如租约允许领导者高效执行只读查询，无需频繁验证自身领导权，然而，这一机制的有效性验证却是一项艰巨任务。</p><p>Grove，作为前沿的并发分离逻辑（Concurrent Separation Logic, CSL）库，首开先河地解决了基于时间的租约验证问题，包括其与系统重新配置、故障恢复、线程级并发以及不可靠网络通信之间的复杂交互。</p><p>CSL的应用精髓在于，通过将系统状态细分为独立资源，并借助同步原语转移资源所有权，从而实现模块化且精确的推理分析。</p><p>Grove的创新亮点可概括如下：</p><ol><li><strong>时间有界不变性推理</strong>：引入新颖的时间维度，有效解析租约的有效期及其对系统状态的影响。</li><li><strong>扩展Crash Hoare逻辑</strong>：强化逻辑体系，使之能妥善应对分布式环境下的节点崩溃情形。</li><li><strong>抽象机制</strong>：提供工具集，支持对仅附加日志及单调时钟计数器的精准推理，增强系统的时间一致性。</li></ol><p><a href=https://github.com/mit-pdos/perennial target=_blank rel="external nofollow noopener noreferrer">Grove code<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p><h2 id=常见组件-grove案例研究 class=heading-element><span>2 常见组件-Grove案例研究</span>
<a href=#%e5%b8%b8%e8%a7%81%e7%bb%84%e4%bb%b6-grove%e6%a1%88%e4%be%8b%e7%a0%94%e7%a9%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=rpc库 class=heading-element><span>2.1 RPC库</span>
<a href=#rpc%e5%ba%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>RPC是分布式系统的重要构建模块，它允许客户端在远程服务器上调用过程。例如，客户端调用<code>rpcClient.Call("f", args)</code>将在与<code>rpcClient</code>相连的服务器上调用<code>f(args)</code>。RPC库提供的是不可靠的RPC，意味着客户端的一次调用可能导致服务器运行对应的函数一次、零次或多于一次。这是因为底层网络可能会丢弃、重排或复制数据包。应用程序通常不会直接调用RPC，而是使用各种代理（clerk），它们封装了RPC并附加额外的处理（如添加请求ID、重试等）。</p><h3 id=复制状态机库 class=heading-element><span>2.2 复制状态机库</span>
<a href=#%e5%a4%8d%e5%88%b6%e7%8a%b6%e6%80%81%e6%9c%ba%e5%ba%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>vRSM复制由应用程序提供的状态机，具体的接口如下图所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=large" data-thumbnail="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=small" data-sub-html="<h2>image-20240830211745211</h2>"><img loading=lazy src=https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png alt=image-20240830211745211 srcset="https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=small, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=medium 1.5x, https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20240830211745211.png?size=large 2x" data-title=image-20240830211745211 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>vRSM由多个组件实现，每个组件处理状态机复制的不同方面，例如持久性可以与复制协议分开实现。</p><ol><li><p><strong>副本服务器：写入复制</strong></p><ul><li>副本组件管理被复制的状态机的副本。</li><li>主要角色包括主服务器(Primary)和备份服务器(Backup)。主服务器处理来自客户端的写请求，备份服务器则处理读请求。</li><li>主服务器在收到操作后，会先在本地应用，然后复制到所有备份服务器，最后回复客户端。复制操作时，主服务器会生成线程以并发方式向每个备份发送RPC，并使用Go WaitGroup等待所有线程完成，确保操作被所有副本服务器应用。</li></ul></li><li><p><strong>使用configservice重新配置</strong></p><p>利用<code>epochs</code>和<code>configservice</code>来管理服务器的添加或移除。系统通过epoch来跟踪不同的服务器配置。每个epoch对应一组特定的服务器配置，包括一个主服务器和多个备份服务器。时代分为活跃epoch和保留epoch，后者指未实际运行的配置。<code>configservice</code> 负责维护当前系统的最新epoch和配置信息。它允许客户端获取当前配置，并在重新配置过程中提供原子操作以更新配置。</p><p>在重新配置期间，客户端可能向旧配置发送操作，这可能导致新配置中遗漏操作。为解决此问题，重新配置过程首先会封闭旧配置中的一个服务器，使其不再接受写操作，直到进入新的epoch。</p><p><strong>重新配置步骤</strong> 包括：</p><ol><li>原子性地创建新epoch</li><li>从旧配置中获取状态</li><li>在新服务器上初始化状态</li><li>更新configservice中的配置信息</li><li>激活新主服务器。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Reserve a new epoch number for reconfiguration, and return the current configuration (set of servers).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>ReserveEpochAndGetConfig</span><span class=p>()</span> <span class=p>(</span><span class=kt>uint64</span><span class=p>,</span> <span class=p>[]</span><span class=nx>Address</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Return current configuration, used by clients to determine what servers to talk to.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>GetConfig</span><span class=p>()</span> <span class=p>[]</span><span class=nx>Address</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//  Set new configuration, making epoch live, as long as no higher-numbered epoch has been reserved.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>TryWriteConfig</span><span class=p>(</span><span class=nx>epoch</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>config</span> <span class=p>[]</span><span class=nx>Address</span><span class=p>)</span> <span class=nx>Error</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Get a lease for specified epoch, as long as it’s the current epoch, returning the new lease expiration time.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>GetLease</span><span class=p>(</span><span class=nx>epoch</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>(</span><span class=nx>Error</span><span class=p>,</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Reconfigure</span><span class=p>(</span><span class=nx>newServers</span> <span class=p>[]</span><span class=nx>Address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newEpoch</span><span class=p>,</span> <span class=nx>oldServers</span> <span class=o>:=</span> <span class=nx>configClerk</span><span class=p>.</span><span class=nf>ReserveEpochAndGetConfig</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// get state from a server from old config
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>oldClerk</span> <span class=o>:=</span> <span class=nf>MakeClerk</span><span class=p>(</span><span class=nx>oldServers</span><span class=p>[</span><span class=nf>Rand</span><span class=p>()</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>oldServers</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=nx>oldState</span> <span class=o>:=</span> <span class=nx>oldClerk</span><span class=p>.</span><span class=nf>GetStateAndSeal</span><span class=p>(</span><span class=nx>newEpoch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// make clerks to all of the new servers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>newClerks</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>Clerk</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>newServers</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>newServers</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>newClerks</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nf>MakeClerk</span><span class=p>(</span><span class=nx>newServers</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// set state on all the new servers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wg</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>WaitGroup</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>newClerks</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>newClerks</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nf>SetNewEpochState</span><span class=p>(</span><span class=nx>newEpoch</span><span class=p>,</span> <span class=nx>oldState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// write new addresses to config service
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>configClerk</span><span class=p>.</span><span class=nf>TryWriteConfig</span><span class=p>(</span><span class=nx>newEpoch</span><span class=p>,</span> <span class=nx>newServers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// activate the new primary server
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newClerks</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nf>BecomePrimary</span><span class=p>(</span><span class=nx>newEpoch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在网络分区的情况下，configservice通过仅接受最高编号的新epoch来避免创建多个冲突的系统实例。</p></li><li><p><strong>副本服务器：基于租约的读取</strong></p><p>副本服务器（主服务器和备份服务器）利用租约提供线性化读取服务，无需跨服务器通信。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>ApplyReadonly</span><span class=p>(</span><span class=nx>op</span><span class=p>)</span> <span class=nx>Result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span><span class=p>.</span><span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nx>leaseExpiry</span> <span class=p>&gt;</span> <span class=nf>GetTimeRange</span><span class=p>().</span><span class=nx>latest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>e</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>epoch</span>
</span></span><span class=line><span class=cl>        <span class=nx>idx</span><span class=p>,</span> <span class=nx>res</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>stateLogger</span><span class=p>.</span><span class=nf>LocalRead</span><span class=p>(</span><span class=nx>op</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>.</span><span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果在此期间发生重新配置，服务器会通知客户端重试
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nf>waitForCommitted</span><span class=p>(</span><span class=nx>e</span><span class=p>,</span> <span class=nx>op</span><span class=p>,</span> <span class=nx>idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>ErrRetry</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>.</span><span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>ErrRetry</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li><strong>租约机制</strong>：<ul><li>租约防止重新配置时返回过时数据，确保各服务器同步。</li><li>后台线程定期更新租约，承诺配置不变，直至租约到期（如1秒后）。</li></ul></li><li><strong>读取流程</strong>：<ul><li>服务器收到只读请求且租约有效时，根据本地状态计算响应。本地状态包含所有已提交操作，可能含未提交的写操作。</li><li>读取依赖的前序写操作需全部提交，方能向客户端发送结果。</li></ul></li></ul><p>Grove使用类似TrueTime的<code>GetTimeRange()</code>API，提供当前时间的上下限，解决时钟偏移问题。</p></li><li><p><strong>存储库：状态日志器</strong></p><p>副本服务器使用存储库管理持久状态，提供“状态日志器”用于在追加型文件中持久化新操作。状态日志器在内存中缓冲追加操作，后台线程异步追加并同步缓冲区到文件，以提升性能。存储库提供 <code>Wait()</code> 函数，允许等待直到文件的前缀部分被持久化。副本库在回复 RPC 之前使用 <code>Wait()</code> 确保变更被持久存储。</p></li><li><p><strong>基于Paxos的容错配置服务</strong></p><p><strong>Paxos 库</strong>用于处理配置服务自身的服务器故障，是一个简单的基于 Paxos 一致性算法的复制库。Paxos在固定服务器集上运行，仅需要多数服务器处理请求，使用 leader 协调操作，但在 leader 崩溃时允许更换。与主-备份复制的差异：</p><ul><li>Paxos 自行选择新的epoch编号，因为服务器集不会在运行时改变。</li><li>仅要求多数服务器提交操作，新 leader 必须从多数服务器获取最新状态。</li><li>Paxos 较为简单，不使用租约，每次更新都写入整个状态到磁盘，而非追加操作到日志。</li><li>写操作性能较低，但对于配置服务是可接受的；提供快速但弱一致性的读取。</li></ul><p>Paxos提供的接口如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 返回当前Paxos实例中的复制状态。可能过时或未提交，GetConfig 使用 WeakRead 以确保快速响应
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Paxos</span><span class=p>)</span> <span class=nf>WeakRead</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=c1>// 开始一个新的提议过程。它返回当前的复制状态和一个commit回调函数。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Paxos</span><span class=p>)</span> <span class=nf>Begin</span><span class=p>()</span> <span class=p>(</span><span class=nx>oldstate</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>commit</span> <span class=kd>func</span><span class=p>(</span><span class=nx>newstate</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 尝试使当前节点成为领导者。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Paxos</span><span class=p>)</span> <span class=nf>TryBecomingLeader</span><span class=p>()</span></span></span></code></pre></td></tr></table></div></div><p>要执行写操作，如下面这段代码所示，configserver使用<code>Begin()</code>方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 参数args在此处未使用，通常用于接收客户端请求的参数。
</span></span></span><span class=line><span class=cl><span class=c1>// reply 是方法的输出，它将包含操作的结果状态以及预留的新epoch和配置信息。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>ConfigService</span><span class=p>)</span> <span class=nf>ReserveEpochAndGetConfig</span><span class=p>(</span><span class=nx>args</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从Paxos实例开始一个新的提议，获取当前状态和提交函数。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 应该在当前的领导者上调用此方法，否则提议无法成功提交。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>oldstate</span><span class=p>,</span> <span class=nx>commit</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>paxos</span><span class=p>.</span><span class=nf>Begin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 反序列化旧状态，以便修改。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>st</span> <span class=o>:=</span> <span class=nf>unmarshal</span><span class=p>(</span><span class=nx>oldstate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 更新状态中的预留epoch字段，准备进入下一个epoch。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>st</span><span class=p>.</span><span class=nx>reservedEpoch</span> <span class=p>=</span> <span class=nx>st</span><span class=p>.</span><span class=nx>reservedEpoch</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 序列化更新后的状态，准备提交。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>newstate</span> <span class=o>:=</span> <span class=nf>marshal</span><span class=p>(</span><span class=nx>st</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用从Begin获得的提交函数尝试提交新状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 此操作会与其他服务器通信，以确保新状态被复制到大多数服务器。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=o>:=</span> <span class=nf>commit</span><span class=p>(</span><span class=nx>newstate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 检查提交是否成功。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果提交失败，将错误状态编码并写入reply。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=nx>marshal</span><span class=p>.</span><span class=nf>WriteInt</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>STAT_ERROR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果提交成功，将OK状态编码并写入reply。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=nx>marshal</span><span class=p>.</span><span class=nf>WriteInt</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>STAT_OK</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 编码并写入新的预留epoch到reply。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=nx>marshal</span><span class=p>.</span><span class=nf>WriteInt</span><span class=p>(</span><span class=o>*</span><span class=nx>reply</span><span class=p>,</span> <span class=nx>st</span><span class=p>.</span><span class=nx>reservedEpoch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 编码并写入当前配置到reply。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=nx>marshal</span><span class=p>.</span><span class=nf>WriteBytes</span><span class=p>(</span><span class=o>*</span><span class=nx>reply</span><span class=p>,</span> <span class=nf>encode_cfg</span><span class=p>(</span><span class=nx>st</span><span class=p>.</span><span class=nx>config</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>版本化状态机API</strong></p><p>开发者需实现如下所示的版本化状态机接口，以便在 vRSM 上构建应用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>VersionedStateMachine</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Apply</span>		<span class=kd>func</span><span class=p>(</span><span class=nx>op</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>idx</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>Read</span>		<span class=kd>func</span><span class=p>(</span><span class=nx>op</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>uint64</span><span class=p>,</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>SetState</span> 	<span class=kd>func</span><span class=p>(</span><span class=nx>snap</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>idx</span> <span class=kt>uint64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>GetState</span> 	<span class=kd>func</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ul><li>操作执行：<ul><li><code>Apply()</code>：执行应用级别的读写操作。</li><li><code>Read()</code>：对当前内存状态执行应用级别的读操作。</li></ul></li><li>状态管理：<ul><li><code>SetState()</code> 和 <code>GetState()</code>：允许序列化内存状态。</li><li>vRSM 库：负责状态的磁盘检查点和新副本的状态复制。</li></ul></li></ul></li><li><p><strong>vRSM客户端库（clerk）</strong></p><p>vRSM 提供客户端库，简化了通过网络向 vRSM 发送请求的复杂性。Clerk 从配置服务获取并缓存副本服务器地址。</p><p>操作执行：</p><ul><li><code>clerk.Apply(op)</code>：向主服务器发送读写操作。</li><li><code>clerk.Read(op)</code>：向任何副本发送只读操作。</li></ul><p>若服务器不再为主服务器或副本服务器，Clerk 会请求新服务器信息并重试。由于重试，可能导致一个操作被应用许多次，需要更高级库处理操作去重。</p></li><li><p><strong>exactlyonce库</strong></p><p>确保使用 vRSM 的应用操作仅执行一次。组件构成：</p><ul><li>新型 Clerk：包装 vRSM Clerk，通过添加唯一请求 ID 防止操作重复。</li><li>状态机转换器：为应用级状态机添加回复表，追踪已应用请求及其回复。</li></ul><p>操作处理：</p><ul><li>新请求：调用状态机的 <code>Apply()</code> 并存储回复。</li><li>重复请求：不调用状态机，直接返回先前回复。</li><li>只读操作：忽略回复表，直接调用状态机的 <code>Read()</code>。</li></ul></li></ol><h3 id=vrsm上层应用 class=heading-element><span>2.3 vRSM上层应用</span>
<a href=#vrsm%e4%b8%8a%e5%b1%82%e5%ba%94%e7%94%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ol><li><p><strong>vKV实现</strong></p><ul><li><strong>vKV 架构</strong>：基于 vRSM 和 exactlyonce 库实现。</li><li><strong>服务器端</strong>：实现 vRSM 期望的状态机接口。</li><li><strong>客户端</strong>：基于 exactlyonce clerk 实现的 clerk，提供简化的 API（<code>Put</code>、<code>CondPut</code>、<code>Get</code>）。</li><li><strong>实现细节</strong>：vKV 实现简单，包括 (反)序列化方法和内存映射的读写函数。</li><li><strong>性能优化</strong>：vKV 存储键到值的映射以及键的最后修改操作索引，利用 vRSM 的版本化状态机接口提升读取性能。</li></ul></li><li><p><strong>基于租约的客户端缓存-cachekv</strong></p><p>cachekv 库通过在 vKV 中存储数据和租约到期时间实现基于租约的客户端缓存。GetAndCache 函数如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>k</span> <span class=o>*</span><span class=nx>CacheKv</span><span class=p>)</span> <span class=nf>GetAndCache</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>cachetime</span> <span class=kt>uint64</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// first attempt to read from the local cache, and if not cached, call vKV&#39;s Get.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>old</span> <span class=o>:=</span> <span class=nx>k</span><span class=p>.</span><span class=nx>kv</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>new</span> <span class=o>:=</span> <span class=nx>old</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>newExpiration</span> <span class=o>:=</span> <span class=nb>max</span><span class=p>(</span><span class=nf>GetTimeRange</span><span class=p>().</span><span class=nx>latest</span><span class=o>+</span><span class=nx>cachetime</span><span class=p>,</span> <span class=nx>old</span><span class=p>.</span><span class=nx>leaseExpiration</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>new</span><span class=p>.</span><span class=nx>leaseExpiration</span> <span class=p>=</span> <span class=nx>newExpiration</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Try to update the lease expiration time on the backend
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>resp</span> <span class=o>:=</span> <span class=nx>k</span><span class=p>.</span><span class=nx>kv</span><span class=p>.</span><span class=nf>CondPut</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>resp</span> <span class=o>==</span> <span class=s>&#34;ok&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>k</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>k</span><span class=p>.</span><span class=nx>cache</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>cacheValue</span><span class=p>{</span><span class=nx>v</span><span class=p>:</span> <span class=nx>old</span><span class=p>.</span><span class=nx>v</span><span class=p>,</span> <span class=nx>l</span><span class=p>:</span> <span class=nx>newLeaseExpiration</span><span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>k</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>old</span><span class=p>.</span><span class=nx>v</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>它返回指定键的值，并在内部缓存，使用 <code>CondPut</code> （确保仅在租约过期时更改值）原子增加租约持续时间，确保并发修改不会改变值。</p></li><li><p><strong>锁服务</strong></p><p><strong>锁服务接口</strong>基于 vKV 实现，使用 vKV 的 CondPut() 操作实现锁。每个锁对应一个键值对，提供 Acquire() 和 Release() 方法的规范，支持应用实现独占锁。锁服务的规范与传统的并发分离逻辑锁规范不同，简化了资源保护。</p></li><li><p><strong>银行事务</strong></p><p>顶层应用，使用基于 vKV clerk 和锁服务接口构建的事务。</p><ul><li><strong>账户状态存储</strong>：使用 vKV 实例存储账户状态，每个账户余额用一对键值存储。</li><li><strong>并发访问控制</strong>：使用锁服务处理账户的并发访问，每次转账操作获取两个锁，确保并发转账的安全执行。</li><li><strong>审计功能 (Audit)</strong>：获取所有账户的锁，计算总余额，并释放锁。</li><li><strong>容错处理</strong>：若银行节点崩溃，锁服务中的锁将保持锁定状态，恢复需要某种形式的撤销或重做日志，但原型中未实现。</li></ul></li></ol><h2 id=grove性能评估 class=heading-element><span>3 Grove性能评估</span>
<a href=#grove%e6%80%a7%e8%83%bd%e8%af%84%e4%bc%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ol><li><p><strong>实验目的</strong>：</p><ul><li><p>证明 Grove 能够验证现实世界中高性能的分布式系统。</p></li><li><p><font color=red>展示 vKV 原型通过 Grove 验证后能够实现高性能</font>。</p></li><li><p>特别强调租约在 vKV 中实现高性能读取的重要性。</p></li></ul></li><li><p><strong>baseline性能对比</strong>：将vKV与Redis进行比较，后者是高性能键值服务器，以C语言编写。为了使Redis与vKV在持久化保障上可比，Redis开启appendfsync always选项，而vKV运行于单核并禁用备份副本。结果显示，vKV吞吐量为Redis的67%-73%，请求延迟相当，多核下vKV吞吐量更高（例如，8核下YCSB 5%写入情况下，吞吐量提升5.1倍）。</p></li><li><p><strong>重新配置能力</strong>：通过添加新服务器进行系统重配置，同时继续正确处理客户端请求的能力。实验中，主服务器在 10 秒时被杀掉，开始重配置过程。使用 YCSB 工作负载变体，100 个客户端持续写入，100 个客户端持续读取。重配置期间，写入操作会阻塞，但读取可以继续。实验结果显示 vKV 可以在重配置期间继续提供读取服务。</p></li><li><p><strong>租约对读取性能的影响</strong>：<strong>写入密集型工作负载</strong>（50%或100%写入），增加副本会降低性能，因为写入在主服务器遇到更多开销，且其它副本处理的读取不足以抵消成本。对于<strong>读取密集型工作负载</strong>，增加副本可以提升性能，例如，YCSB 5%和0%写入情况下，3台服务器分别达到单服务器1.7倍和2.3倍的吞吐量。</p></li></ol><h2 id=总结 class=heading-element><span>4 总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=grovekv系统 class=heading-element><span>4.1 GroveKV系统</span>
<a href=#grovekv%e7%b3%bb%e7%bb%9f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>GroveKV特点：</p><ul><li>容错、线性化的键值（KV）服务。</li><li>操作（Put/Get）exactlyonce。</li><li>崩溃安全且可重配置。</li></ul><p>要进行重配置，GroveKV使用configservice管理服务器更改。如果没有configservice，类似VMWare-FT的问题，即两个备份可能是网络的彼此分区并且都想成为主分区。这可以通过ZooKeeper之类的配置服务解决。</p><p>lab3也是一个容错KV服务，但GroveKV使用主/备份复制而不是Raft。<strong>关键操作</strong>如下：</p><ol><li>复制：Primary使用goroutines复制到其他服务器，基于RPC。执行操作时需要持有锁。</li><li>重配置：封闭当前的服务器组，从中获取状态副本，安装到新服务器。使用epoch编号处理并发重配置。</li><li>基于租约的读取：服务器不跟任何人协调回复<code>Get</code>请求。</li></ol><h3 id=grove核心 class=heading-element><span>4.2 Grove核心</span>
<a href=#grove%e6%a0%b8%e5%bf%83 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在正式验证领域，Grove 的核心在于证明代码在所有可能场景下均能表现得当，这一过程要求对代码执行的数学模型有深刻理解，以及对系统行为“正确”的明确定义。通过引入机械证明检查器，Grove 大幅降低了开发者在证明过程中犯错的可能性。</p><p>在 Grove 中，规范由前条件和后条件构成，用于描述操作前后的系统状态。以 GroveKV 为例，Put 和 Get 操作的规范不仅限定了操作的预期结果，还明确了数据所有权的转移。</p><p>Concurrent Separation Logic（CSL）是一种针对并发程序的形式化验证方法，Grove 对其进行了创新性的拓展，使之适用于分布式系统。CSL 强调基于资源所有权的代码分析，其中“堆指向”是一个典型的例子，它确保了数据的一致性不受并发访问的影响。</p><p>在 Grove 中，不变量指的是系统运行中必须始终保持为真的属性，而时间有界不变量（tinv）则进一步限制了特定资源的有效期。例如，<code>GetTimeRange</code> 函数允许在租约未到期的情况下，临时访问底层资源，这在处理基于租约的读取时尤为关键。</p><p>尽管正式验证能够显著减少某些类型的错误，但它并非万能药。验证不能保证所有实际中可能遇到的问题都被解决，特别是那些涉及系统活性性的问题，如死锁或饥饿。此外，编写高质量的证明和测试同样需要大量时间和精力，与开发代码无异，甚至有时还需经历重构的过程。</p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/03.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0in-search-of-an-understandable-consensus-algorithm-extended-version/ title="【论文阅读笔记】In Search of an Understandable Consensus Algorithm (Extended Version)">【论文阅读笔记】In Search of an Understandable Consensus Algorithm (Extended Version)</a></li><li><a href=/posts/11.mit6.5840-lab5/ title="【MIT 6.5840(6.824)】 Lab 5:Sharded Key/Value Service 设计实现">【MIT 6.5840(6.824)】 Lab 5:Sharded Key/Value Service 设计实现</a></li><li><a href=/posts/08.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0zookeeper-wait-free-coordination-for-internet-scale-systems/ title="【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems">【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems</a></li><li><a href=/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/ title="【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程">【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程</a></li><li><a href=/posts/05.mit-6.58406.824-lab1mapreduce-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/ title="【MIT 6.5840(6.824)】Lab1:MapReduce 设计实现">【MIT 6.5840(6.824)】Lab1:MapReduce 设计实现</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・论文阅读笔记</span></span></a> 11</div><div class=collection-nav><a href=/posts/08.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0zookeeper-wait-free-coordination-for-internet-scale-systems/ class=collection-nav-item rel=prev title="【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>【论文阅读笔记】ZooKeeper: Wait-Free Coordination for Internet-Scale Systems</span>
</a><a href=/posts/11.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0bigtable/ class=collection-nav-item rel=next title="【论文阅读笔记】Bigtable: A Distributed Storage System for Structured Data"><span>【论文阅读笔记】Bigtable: A Distributed Storage System for Structured Data</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-10-20 05:30:47">更新于 2024-10-20&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_research/09.%e3%80%90%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91Grove.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_research/09.%e3%80%90%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91Grove.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91Grove%3A+a+Separation-Logic+Library+for+Verifying+Distributed+Systems+%28Extended+Version%29&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91Grove%3A+a+Separation-Logic+Library+for+Verifying+Distributed+Systems+%28Extended+Version%29%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_research/09.%e3%80%90%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91Grove.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/ data-title="【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)" data-hashtags=分布式系统><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/ data-hashtag=分布式系统><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/ data-title="【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/09.%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0grove/ data-title="【论文阅读笔记】Grove: A Separation-Logic Library for Verifying Distributed Systems (Extended Version)"><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ class=post-tag title="标签 - 分布式系统">分布式系统</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/09.mit-6.58406.824-lab4-fault-tolerant-kvservice/ class=post-nav-item rel=prev title="【MIT 6.5840(6.824)】 Lab 4:Fault-Tolerant KVService 设计实现"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【MIT 6.5840(6.824)】 Lab 4:Fault-Tolerant KVService 设计实现</a>
<a href=/posts/08.mit-6.58406.824-lab3-raft/ class=post-nav-item rel=next title="【MIT 6.5840(6.824) 】Lab3:Raft 设计实现">【MIT 6.5840(6.824) 】Lab3:Raft 设计实现<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.2"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>