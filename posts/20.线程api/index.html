<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>线程API | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="1 线程创建 编写多线程程序的第一件事就是创建新线程，因此必须有某种线程创建接口。在 POSIX 中，这很容易： 1 2 3 4 5 #include <pthread.h> int pthread_create( pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg); 这个函数声明有四个参数：thread、attr、start_routine 和 arg。第一个参数 thread 是指向 pthread_t 类型结构的指针；我们将使用该结构与线程交互，因此需要将其传递给 pthread_create()"><meta name=keywords content='OS'><meta itemprop=name content="线程API"><meta itemprop=description content="1 线程创建 编写多线程程序的第一件事就是创建新线程，因此必须有某种线程创建接口。在 POSIX 中，这很容易： 1 2 3 4 5 #include <pthread.h> int pthread_create( pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg); 这个函数声明有四个参数：thread、attr、start_routine 和 arg。第一个参数 thread 是指向 pthread_t 类型结构的指针；我们将使用该结构与线程交互，因此需要将其传递给 pthread_create()"><meta itemprop=datePublished content="2024-05-11T20:37:20+00:00"><meta itemprop=dateModified content="2024-07-29T12:45:24+00:00"><meta itemprop=wordCount content="4961"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="线程API"><meta property="og:description" content="1 线程创建 编写多线程程序的第一件事就是创建新线程，因此必须有某种线程创建接口。在 POSIX 中，这很容易： 1 2 3 4 5 #include <pthread.h> int pthread_create( pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg); 这个函数声明有四个参数：thread、attr、start_routine 和 arg。第一个参数 thread 是指向 pthread_t 类型结构的指针；我们将使用该结构与线程交互，因此需要将其传递给 pthread_create()"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-11T20:37:20+00:00"><meta property="article:modified_time" content="2024-07-29T12:45:24+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="线程API"><meta name=twitter:description content="1 线程创建 编写多线程程序的第一件事就是创建新线程，因此必须有某种线程创建接口。在 POSIX 中，这很容易： 1 2 3 4 5 #include <pthread.h> int pthread_create( pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg); 这个函数声明有四个参数：thread、attr、start_routine 和 arg。第一个参数 thread 是指向 pthread_t 类型结构的指针；我们将使用该结构与线程交互，因此需要将其传递给 pthread_create()"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/><link rel=prev href=https://hezephyr.github.io/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/><link rel=next href=https://hezephyr.github.io/posts/21.%E9%94%81/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"线程API","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/20.%E7%BA%BF%E7%A8%8Bapi\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":4961,"url":"https:\/\/hezephyr.github.io\/posts\/20.%E7%BA%BF%E7%A8%8Bapi\/","datePublished":"2024-05-11T20:37:20+00:00","dateModified":"2024-07-29T12:45:24+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>线程API</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><span class=active title=线程API>线程API</span></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ class=collection-nav-item rel=prev title=并发和线程><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>20/39</span><a href=/posts/21.%E9%94%81/ class=collection-nav-item rel=next title=锁><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>线程API</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-05-11 20:37:20"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-11>2024-05-11</time></span>&nbsp;<span title="更新于 2024-07-29 12:45:24"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-07-29>2024-07-29</time></span>&nbsp;<span title="4961 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5000 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 10 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=线程API>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#线程创建>线程创建</a></li><li><a href=#等待线程完成>等待线程完成</a></li><li><a href=#锁>锁</a></li><li><a href=#条件变量>条件变量</a></li><li><a href=#线程api指南>线程API指南</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><h2 id=线程创建 class=heading-element><span>1 线程创建</span>
<a href=#%e7%ba%bf%e7%a8%8b%e5%88%9b%e5%bb%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>编写多线程程序的第一件事就是创建新线程，因此必须有某种线程创建接口。在 POSIX 中，这很容易：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>pthread_create</span><span class=p>(</span>     <span class=kt>pthread_t</span><span class=o>*</span>              <span class=kr>thread</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                  <span class=k>const</span> <span class=kt>pthread_attr_t</span><span class=o>*</span>         <span class=n>attr</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                        <span class=kt>void</span><span class=o>*</span>                   <span class=p>(</span><span class=o>*</span><span class=n>start_routine</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                        <span class=kt>void</span><span class=o>*</span>                   <span class=n>arg</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这个函数声明有四个参数：<code>thread</code>、<code>attr</code>、<code>start_routine</code> 和 <code>arg</code>。第一个参数 <code>thread</code> 是指向 <code>pthread_t</code> 类型结构的指针；我们将使用该结构与线程交互，因此需要将其传递给 <code>pthread_create()</code> 以对其进行初始化。</p><p>第二个参数 <code>attr</code> 用于指定该线程可能具有的任何属性。例如包括设置栈大小或可能有关线程的调度优先级的信息。通过单独调用 <code>pthread_attr_init()</code> 来初始化属性；有关详细信息，请参阅手册页：<code>man pthread_create</code>。然而，在大多数情况下，默认值就可以了，在这种情况下，我们将简单地传递 NULL 值。</p><p>第三个参数是最复杂的，但实际上只是询问：这个线程应该开始在哪个函数中运行？在 C 中，我们将其称为函数指针，这告诉我们预期的内容：函数名称（<code>start_routine</code>），它传递一个类型为 <code>void *</code> 的单个参数（如<code>start_routine</code>后面的括号中所示），以及它返回一个 <code>void *</code> 类型的值（即，一个 void 指针）。如果此例程需要整数参数而不是 void 指针，则声明将如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_create</span><span class=p>(...,</span> <span class=c1>// first two args are the same
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=kt>void</span> <span class=o>*</span>  <span class=p>(</span><span class=o>*</span><span class=n>start_routine</span><span class=p>)(</span><span class=kt>int</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span>     <span class=n>arg</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>如果例程的参数是一个 void 指针，但返回值是一个整数，那么就会是这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_create</span><span class=p>(...,</span> <span class=c1>// first two args are the same
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>start_routine</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                    <span class=kt>void</span> <span class=o>*</span>  <span class=n>arg</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>最后，第四个参数 <code>arg</code> 正是要传递给线程开始执行的函数的参数。你可能会问：为什么我们需要这些 void 指针？答案其实很简单：<font color=red>将 void 指针作为函数<code>start_routine</code>的参数，可以让我们传递任何类型的参数</font>；将它作为返回值，可以让线程返回任何类型的结果。</p><p>还有函数的返回值，如果运行正常，则返回 0（否则为错误代码：EAGAIN、EINVAL、EPERM）。</p><p>让我们看看下面这段代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common_threads.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>myarg_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mythread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>myarg_t</span> <span class=o>*</span><span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=kt>myarg_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>args</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=n>args</span><span class=o>-&gt;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>myarg_t</span> <span class=n>args</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>20</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=nf>pthread_join</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;done</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在这里，我们只是创建了一个线程，它传递了两个参数，并打包成我们自己定义的单一类型（<code>myarg t</code>）。线程创建后，可以简单地将其参数转换为它所期望的类型，从而根据需要解包参数。就是这样！一旦创建了线程，你就真正拥有了另一个活生生的执行实体，它拥有自己的调用栈，与程序中当前存在的所有线程运行在同一地址空间。程序的运行结果如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>❯ make thread_create
</span></span><span class=line><span class=cl>gcc -o thread_create thread_create.c -Wall -Werror -I../include -pthread
</span></span><span class=line><span class=cl>❯ ./thread_create
</span></span><span class=line><span class=cl><span class=m>10</span> <span class=m>20</span>
</span></span><span class=line><span class=cl><span class=k>done</span></span></span></code></pre></td></tr></table></div></div><h2 id=等待线程完成 class=heading-element><span>2 等待线程完成</span>
<a href=#%e7%ad%89%e5%be%85%e7%ba%bf%e7%a8%8b%e5%ae%8c%e6%88%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>上面的例子展示了如何创建一个线程。但是，如果您想等待线程完成，会发生什么情况？你需要做一些特别的事情才能等待完成；特别是，您必须调用例程 <code>pthread_join()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_join</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=kr>thread</span><span class=p>,</span> <span class=kt>void</span> <span class=o>**</span><span class=n>value_ptr</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>此例程需要两个参数。第一个参数的类型是 <code>pthread_t</code>，用于指定等待哪个线程。该变量由线程创建例程初始化（将指针作为参数传递给 <code>pthread create()</code>）；如果保留该变量，就可以用它来等待该线程终止。</p><p>第二个参数是指向你期望返回值的指针。由于该例程可以返回任何值，因此它被定义为返回 void 的指针；由于 <code>pthread_join() </code>例程会改变传入参数的值，因此你需要传入指向该值的指针，而不仅仅是该值本身。</p><p>让我们看下面这段代码，在代码中，再次创建了一个单线程，并通过 <code>myarg_t</code> 结构传递了几个参数。返回值使用 <code>myret_t</code> 类型。一旦线程运行完毕，一直在 <code>pthread_join() </code>例程 中等待的主线程就会返回，我们就可以访问从线程返回的值，即 <code>myret_t</code> 中的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common_threads.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>myarg_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>myret_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mythread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>myarg_t</span> <span class=o>*</span><span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=kt>myarg_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;args %d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>args</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=n>args</span><span class=o>-&gt;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>myret_t</span> <span class=o>*</span><span class=n>rvals</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>myret_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>rvals</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rvals</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rvals</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>rvals</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>myret_t</span> <span class=o>*</span><span class=n>rvals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>myarg_t</span> <span class=n>args</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>20</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>**</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>rvals</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;returned %d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>rvals</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>,</span> <span class=n>rvals</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>rvals</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>关于这个例子，有几点需要注意。首先，很多时候我们不必对参数进行这些痛苦的打包和拆包。例如，如果我们只是创建一个不带参数的线程，我们可以在创建线程时将 NULL 作为参数传递进去。同样，如果我们不关心返回值，也可以将 NULL 传递给 <code>pthread_join()</code>。</p><p>其次，如果我们只传递一个值（如 int），就不必将其打包为参数。</p><p>如下面这段代码所示，在这种情况下，我们不必将参数和返回值打包到结构内部。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;common_threads.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mythread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%lld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=n>value</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>rvalue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>mythread</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>**</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>rvalue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;returned %lld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>rvalue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>第三，我们应该注意，从线程返回值的方式必须非常谨慎。尤其是，千万不要返回指向线程调用栈中分配的指针。如果这样做，你觉得会发生什么？(想想吧！）下面是一段危险代码的示例，它是根据上面的示例修改的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>mythread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>myarg_t</span> <span class=o>*</span><span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=kt>myarg_t</span> <span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>,</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>myret_t</span> <span class=n>r</span><span class=p>;</span> <span class=c1>// ALLOCATED ON STACK: BAD!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在这种情况下，变量 r 被分配到 <code>mythread</code> 的栈中。然而，当它返回时，该值会被自动解除分配（毕竟这就是栈如此易于使用的原因！），因此，将指向已解除分配的变量的指针传回会导致各种糟糕的结果。</p><p>最后，你可能会注意到，使用 <code>pthread_create()</code> 创建线程，然后立即调用 <code>pthread_join()</code> 是一种非常奇怪的创建线程的方法。事实上，有一种更简单的方法可以完成这一任务，那就是<font color=red>过程调用</font>。显然，我们通常要创建不止一个线程并等待它完成，否则使用线程就没有什么意义了。</p><p>我们应该注意，并非所有多线程代码都使用<code>join</code>例程。例如，多线程网络服务器可能会创建许多工作线程，然后使用主线程接受请求并将请求无限期地传递给工作线程。因此，这种长寿命程序可能不需要<code>join</code>。然而，创建线程执行特定任务（并行）的并行程序可能会使用 <code>join</code> 来确保在退出或进入下一阶段计算之前，所有这些工作都已完成。</p><h2 id=锁 class=heading-element><span>3 锁</span>
<a href=#%e9%94%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>除了线程创建和等待线程完成之外，POSIX 线程库提供的下一组最有用的函数可能就是那些通过<strong>锁</strong>为临界区提供互斥的函数了。为此目的使用的最基本的一对例程如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>例程应该易于理解和使用。当您的代码区域是临界区，因此需要受到保护以确保正确操作时，锁非常有用。你大概可以想象代码的样子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 或者不管你的临界区是什么
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>代码的意图如下：如果调用 <code>pthread_mutex_lock()</code> 时没有其他线程持有锁，则该线程将获取锁并进入临界区。如果另一个线程确实持有锁，则尝试获取锁的线程将不会从调用中返回，直到它获得锁（这意味着持有锁的线程已通过unlock调用释放了锁）。当然，在给定时间，许多线程可能会卡在锁获取函数内等待；然而，只有获得锁的线程才应该调用<code>unlock</code>。</p><p>不幸的是，这段代码在两个重要方面被破坏了。第一个问题是<font color=red>缺乏正确的初始化</font>。所有锁都必须正确初始化，以保证它们具有正确的值，从而在调用lock和unlock时按需要工作。</p><p>对于 POSIX 线程，有两种初始化锁的方法。一种方法是使用 <code>PTHREAD_MUTEX_INITIALIZER</code>，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>lock</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>这样做会将锁设置为默认值，从而使锁可用。动态方法（即在运行时）是调用 <code>pthread_mutex_init()</code>，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>assert</span><span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=err>“</span><span class=n>Error</span> <span class=n>in</span> <span class=n>mutex</span> <span class=n>init</span><span class=err>”</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>该例程的第一个参数是锁本身的地址，第二个参数是一组可选属性。传递 NULL 即只需使用默认值即可。两种方法都可以，但我们通常使用动态（后一种）方法。需要注意的是，在使用完锁后，还需要调用 <code>pthread_mutex_destroy()</code>。</p><p>上述代码的第二个问题是，它在调用lock和unlock时没有检查错误代码。就像你在 UNIX 系统中调用的几乎所有库例程一样，这些例程也可能失败！如果你的代码没有正确检查错误代码，失败就会无声无息地发生，在这种情况下，可能会允许多个线程进入临界区段。在最低限度上，应使用包装器来断言例程成功（如下面这段代码所示）；更复杂的（非玩具）程序在出错时不能简单地退出，而应检查失败，并在lock或unlock不成功时采取适当的措施。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Use this to keep your code clean but check for failures
</span></span></span><span class=line><span class=cl><span class=c1>// Only use if exiting program is OK upon failure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Pthread_mutex_lock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=err>“</span><span class=n>Error</span> <span class=n>in</span> <span class=n>acquire</span><span class=err>”</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>lock和unlock例程并不是 <code>pthreads</code> 库中与锁交互的唯一例程。这里还有两个例程可能值得关注：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_trylock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_mutex_timedlock</span><span class=p>(</span><span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>abs_timeout</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>这两个调用用于获取锁。如果锁已被持有，<code>trylock</code> 版本会返回失败；获取锁的 <code>timedlock</code> 版本会在超时或获取锁后返回，以先发生者为准。因此，超时后的 <code>timedlock</code> 会退化为 <code>trylock</code>。一般来说，这两种情况都应该避免；不过，在某些情况下，避免卡在（也许是无限期地）锁获取例程中是有用的。</p><h2 id=条件变量 class=heading-element><span>4 条件变量</span>
<a href=#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>任何线程库的另一个主要组成部分，当然也包括 POSIX 线程，就是<strong>条件变量</strong>的存在。<font color=red>当线程之间必须进行某种信号传递时，如果一个线程正在等待另一个线程做某事，然后才能继续，那么条件变量就非常有用</font>。希望以这种方式进行交互的程序主要使用两个例程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>,</span> <span class=kt>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=kt>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>要使用条件变量，还必须拥有与该条件关联的锁。当调用上述任一例程时，应保持此锁。</p><p>第一个例程 <code>pthread_cond_wait()</code> 使调用线程进入睡眠状态，从而等待其他线程向其发出信号，通常是在程序中的某些内容发生更改而现在正在睡眠的线程可能关心的情况下。典型的用法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>lock</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>pthread_cond_t</span> <span class=n>cond</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>Pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>ready</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>Pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>在此代码中，在初始化相关锁和条件之后，线程检查变量<code>ready</code>是否已设置为非零的值。如果没有，该线程只需调用等待例程即可休眠，直到其他线程将其唤醒。唤醒一个线程的代码如下所示，该代码将在其他线程中运行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>Pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ready</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>Pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>Pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>关于这个代码序列，有几点需要注意。首先，在发送信号时（以及修改全局变量 <code>ready</code> 时），我们始终要确保<code>lock</code>。这样可以确保我们的代码不会意外引入竞争条件。</p><p>其次，你可能会注意到，<code>wait</code> 调用的第二个参数是锁，而 <code>signal</code> 调用只需要一个条件。造成这种差异的原因是，wait 调用除了让调用线程休眠外，还会在让调用者休眠时释放锁。试想一下，如果不这样做，其他线程怎么可能获得锁并发出信号唤醒它呢？不过，在被唤醒后返回之前，<code>pthread_cond_wait()</code> 会重新获取锁，从而确保在等待序列开始时获取锁和结束时释放锁之间的任何时间，等待线程都持有锁。</p><p>最后一个奇怪的现象：等待线程在 while 循环中重新检查条件，而不是简单的 if 语句。因为使用 while 循环是简单安全的做法。虽然它会重新检查条件（可能会增加一点开销），但有些 pthread 实现可能会错误地唤醒等待线程；在这种情况下，如果不重新检查，等待线程就会继续认为条件改变，即使它并没有改变。例如，如果有多个线程在等待，而只有一个线程应该抓取数据（生产者-消费者）。因此，更安全的做法是将唤醒视为可能已发生变化的提示，而不是绝对的事实。</p><p>需要注意的是，有时在两个线程之间使用一个简单的标志来发出信号，而不是使用条件变量和相关的锁，这很有诱惑力。例如，我们可以重写上面的等待代码，在等待代码中看起来更像这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>ready</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span> <span class=c1>// spin
</span></span></span></code></pre></td></tr></table></div></div><p>相关的信号代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ready</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>永远不要这样做，原因如下。首先，它在很多情况下表现不佳（长时间自旋，即持续检查某个条件是否满足，这只会浪费 CPU 周期）。其次，容易出错。使用标志（如上所述）在线程之间进行同步时非常容易出错。</p><h2 id=线程api指南 class=heading-element><span>5 线程API指南</span>
<a href=#%e7%ba%bf%e7%a8%8bapi%e6%8c%87%e5%8d%97 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>当你使用POSIX线程库（或者实际上，任何线程库）构建一个多线程程序时，有一些小但重要的事情需要记住。它们包括：</p><ul><li>**保持简单。**最重要的是，任何涉及线程之间的锁定或信号的代码都应尽可能简单。复杂的线程交互会导致错误。</li><li>**最小化线程交互。**尽量减少线程之间交互的方式。每个交互都应该经过深思熟虑，并用经过验证的方法构建。</li><li>**初始化锁和条件变量。**未初始化将导致代码有时能够正常工作，有时会以非常奇怪的方式失败。</li><li>**检查返回码。**当然，在你所做的任何C和UNIX编程中，你都应该检查每一个返回码，这在这里也是正确的。不这样做将导致奇怪且难以理解的行为。</li><li>**在传递参数给线程和从线程返回值时要小心。**特别是，任何时候你传递指向栈上分配的变量的引用时，你可能在做一些错误的事情。</li><li>**每个线程都有自己的栈。**与上面的观点相关，请记住每个线程都有自己的栈。因此，如果你在某个线程执行的函数中有一个在本地分配的变量，它基本上是私有的，其他线程无法（轻易）访问它。要在线程之间共享数据，这些值必须在堆上或者以其他全局可访问的位置。</li><li>**总是使用条件变量来在线程之间进行信号传递。**虽然使用简单的标志往往很诱人，但不要这样做。</li><li>**使用手册页面。**特别是在Linux上，pthread手册页面非常有信息量。</li></ul></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ class=collection-nav-item rel=prev title=并发和线程><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>并发和线程</span>
</a><a href=/posts/21.%E9%94%81/ class=collection-nav-item rel=next title=锁><span>锁</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-07-29 12:45:24">更新于 2024-07-29&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/20.%e7%ba%bf%e7%a8%8bAPI.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_develop/_system/ostep/20.%e7%ba%bf%e7%a8%8bAPI.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20%E7%BA%BF%E7%A8%8BAPI&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E7%BA%BF%E7%A8%8BAPI%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/20.%e7%ba%bf%e7%a8%8bAPI.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/ data-title=线程API data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/ data-title=线程API><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/20.%E7%BA%BF%E7%A8%8Bapi/ data-title=线程API><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/21.%E9%94%81/ class=post-nav-item rel=prev title=锁><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>锁</a>
<a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ class=post-nav-item rel=next title=并发和线程>并发和线程<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.129.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>