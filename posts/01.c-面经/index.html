<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>C/C++ 面试题目总结 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="const知道吗？解释其作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改； 修饰成员函"><meta name=keywords content='C++'><meta itemprop=name content="C/C++ 面试题目总结"><meta itemprop=description content="const知道吗？解释其作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改； 修饰成员函"><meta itemprop=datePublished content="2024-06-01T16:11:20+00:00"><meta itemprop=dateModified content="2024-07-29T12:45:24+00:00"><meta itemprop=wordCount content="10157"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="C++"><meta property="og:url" content="https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="C/C++ 面试题目总结"><meta property="og:description" content="const知道吗？解释其作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改； 修饰成员函"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-01T16:11:20+00:00"><meta property="article:modified_time" content="2024-07-29T12:45:24+00:00"><meta property="article:tag" content="C++"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="C/C++ 面试题目总结"><meta name=twitter:description content="const知道吗？解释其作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改； 修饰成员函"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/><link rel=prev href=https://hezephyr.github.io/posts/04.gfs/><link rel=next href=https://hezephyr.github.io/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C/C++ 面试题目总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/01.c-%E9%9D%A2%E7%BB%8F\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"C\u002b\u002b","wordcount":10157,"url":"https:\/\/hezephyr.github.io\/posts\/01.c-%E9%9D%A2%E7%BB%8F\/","datePublished":"2024-06-01T16:11:20+00:00","dateModified":"2024-07-29T12:45:24+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>C/C++ 面试题目总结</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>面试</span>
<span class=collection-count>3</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><span class=active title="C/C++ 面试题目总结">C/C++ 面试题目总结</span></li><li class=collection-item><a href=/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/ title="数据结构与算法 面试题目总结">数据结构与算法 面试题目总结</a></li><li class=collection-item><a href=/posts/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/ title="计算机网络 面试题目总结">计算机网络 面试题目总结</a></li></ul><div class=collection-nav-simple><i class="fa-solid fa-angle-left fa-fw collection-nav-item text-secondary" aria-hidden=true></i><span class=text-secondary>1/3</span><a href=/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/ class=collection-nav-item rel=next title="数据结构与算法 面试题目总结"><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>C/C++ 面试题目总结</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E9%9D%A2%E8%AF%95/ class=post-category title="分类 - 面试"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 面试</a>&ensp;<a href=/categories/%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/ class=post-category title="分类 - 技术基础"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 技术基础</a> 和 <a href=/collections/%E9%9D%A2%E8%AF%95/ class=post-collection title="合集 - 面试"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> 面试</a></span></div><div class=post-meta-line><span title="发布于 2024-06-01 16:11:20"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-06-01>2024-06-01</time></span>&nbsp;<span title="更新于 2024-07-29 12:45:24"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-07-29>2024-07-29</time></span>&nbsp;<span title="10157 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 10200 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 21 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="C/C++ 面试题目总结">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><ol><li><p>const知道吗？解释其作用</p><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，既避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol></li><li><p>宏定义 #define 和 const 常量</p><table><thead><tr><th style=text-align:center>宏定义 #define</th><th style=text-align:center>const 常量</th></tr></thead><tbody><tr><td style=text-align:center>宏定义，相当于字符替换 |</td><td style=text-align:center>常量声明 |</td></tr><tr><td style=text-align:center><font color=red>预处理器处理</font> |</td><td style=text-align:center>编译器处理 |</td></tr><tr><td style=text-align:center>无类型安全检查 |</td><td style=text-align:center>有类型安全检查 |</td></tr><tr><td style=text-align:center>不分配内存 |</td><td style=text-align:center>要分配内存 |</td></tr><tr><td style=text-align:center><font color=red>存储在代码段</font> |</td><td style=text-align:center>存储在数据段 |</td></tr><tr><td style=text-align:center>可通过 <code>#undef</code> 取消 |</td><td style=text-align:center>不可取消 |</td></tr></tbody></table></li><li><p>static的作用</p><ol><li>修饰普通变量，<font color=red>修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间</font>，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，<font color=red>表明函数的作用范围</font>，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>修饰成员变量，<font color=red>修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员</font>。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，<font color=red>但是在 static 函数内不能访问非静态成员</font>。</li></ol></li><li><p>说说this指针</p><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，<strong>编译程序先将对象的地址赋给 <code>this</code> 指针</strong>，然后调用成员函数，<font color=red>每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针</font>。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用<code>this</code>指针：<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol></li><li><p>说说inline内联函数</p><p>相当于把内联函数里面的内容写在调用内联函数处，即不用执行进入函数的步骤，直接执行函数体；相当于宏，却比宏多了类型检查，真正具有函数特性；编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数（但虚函数也可以是内联函数，但是当虚函数表现出多态性时不能内联）。</p><p>优点：</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点：</p><ol start=4><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。<font color=red>内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器</font>。</li></ol></li><li><p>说说volatile关键字</p><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以<font color=red>使用 volatile 告诉编译器不应对这样的对象进行优化</font>。</li><li>volatile 关键字声明的变量，<font color=red>每次访问时都必须从内存中取出值</font>（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul></li><li><p>说说assert()</p><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h></code>（C）、<code>&lt;cassert></code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h></code> 之前。</p><p><code>static_assert</code> 是一个编译时断言，用于在编译期间检查常量表达式是否为 <code>true</code>。它定义在 C++11 及更高版本的标准中。<code>static_assert</code> 通常用于模板编程和常量表达式中，以确保某些编译时条件成立。与 <code>assert</code> 不同的是，<code>static_assert</code> 在编译时进行检查，因此它不会影响运行时性能。</p></li><li><p>说说sizeof()</p><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul></li><li><p><code>#pragma pack(n)</code></p><p>设定结构体、联合以及类成员变量以 n 字节方式对齐，<code>#pragma pack(pop)</code> 恢复对齐状态</p></li><li><p><code>extern "C"</code></p><p>被 <code>extern</code> 限定的函数或变量是 <code>extern</code> 类型的，被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和链接的</p></li><li><p>C++ 中 struct 和 class</p><p>总的来说，<font color=red>struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体</font>。</p><p>最本质的一个区别就是默认的访问控制，struct 默认的数据访问控制是 public 的，class 默认的成员变量访问控制是 private 的。</p></li><li><p>union 联合</p><p>联合（union）是一种节省空间的特殊的类，<font color=red>一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值</font>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul></li><li><p>C 实现 C++ 类</p><p><font color=red>C 实现 C++ 的面向对象特性（封装、继承、多态）</font></p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同</li></ul></li><li><p>explicit（显式）关键字</p><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li></ul></li><li><p>friend 友元类和友元函数</p><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul></li><li><p>谈谈using</p><p>using 关键字在 C++ 中有多种用途，主要包括类型别名、引入命名空间中的标识符。并且C++11 引入了别名模板，可以使用 <code>using</code> 创建模板的别名。</p><p>尽量少使用 using 指示：<code>using namespace std;</code>，会污染命名空间</p></li><li><p><code>::</code> 范围解析运算符</p><ol><li><p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>11</span><span class=p>;</span>         <span class=c1>// 全局（::）的 count
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>::</span><span class=n>count</span> <span class=o>=</span> <span class=mi>12</span><span class=p>;</span>       <span class=c1>// 测试 1：设置全局的 count 的值为 12
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>   <span class=c1>// 类 A 的 count（A::count）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>A</span><span class=o>::</span><span class=n>count</span> <span class=o>=</span> <span class=mi>21</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></li><li><p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, World!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></li></ol></li><li><p>谈谈<code>decltype</code>关键字</p><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类，返回值为所属类型。语法：<code>decltype ( expression )</code></p></li><li><p>谈谈引用</p><p>在 C++ 中，引用（reference）是一种为已存在的变量创建别名的机制。引用可以让你通过另一个名字访问同一个变量。C++ 中的引用主要分为以下几种类型：</p><ol><li><p>左值引用（L-value References）：左值引用用于引用内存中已经存在的对象，通常用于函数参数传递和返回值。</p></li><li><p>右值引用（R-value References）：右值引用在 C++11 引入（<code>int&& rvalueRef = 10</code>），主要用于引用临时对象（右值），支持移动语义和完美转发，优化性能。</p></li><li><p>引用折叠（Reference Collapsing）：引用折叠是一种复杂的规则，决定了多层引用的结果。它在模板编程和完美转发中非常重要。</p><p><code>X& &</code>、<code>X& &&</code>、<code>X&& &</code> 可折叠成 <code>X&</code>
<code>X&& &&</code> 可折叠成 <code>X&&</code></p></li></ol></li><li><p>成员初始化列表
好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ul><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ul></li></ul></li><li><p>谈谈面向对象</p><p>面向对象程序设计（Object-Oriented Programming，OOP）是一种程序设计范式，基于“对象”的概念，用于组织代码和数据。OOP 提供了一种更自然和直观的方法来解决复杂的软件问题，使程序设计更加模块化和可维护。面向对象的三大特性：</p><ol><li><strong>封装（Encapsulation）</strong> ：封装是将数据和操作数据的方法捆绑在一起，形成一个自包含的单元—对象。<font color=red>封装通过定义类中的私有成员变量和公有成员函数，隐藏内部实现细节，只暴露必要的接口。封装提高了代码的安全性和可维护性</font>。</li><li><strong>继承（Inheritance）</strong> ：继承是一种机制，<font color=red>通过创建一个新的类（子类），该类可以继承一个或多个已有类（基类）的属性和方法，从而实现代码的重用和扩展</font>。继承支持多态性，并且使得代码更具层次性。</li><li><strong>多态（Polymorphism）</strong>：多态是指一个函数或方法可以有多种不同的表现形式。<font color=red>在C++中多态主要通过虚函数和函数重载实现，使得不同的对象可以用统一的接口进行操作，从而提高代码的灵活性和扩展性</font>。</li></ol></li><li><p>C++多态</p><p>C++ 多态分类及实现：</p><ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li><li><p>谈谈虚析构函数</p><p>虚析构函数（Virtual Destructor）是面向对象编程中一个重要的概念，特别是在 C++ 中。它的主要目的是确保在通过基类指针删除派生类对象时，派生类的析构函数能够正确调用，从而防止资源泄漏和未定义行为。</p></li><li><p>在C++中，希望一个类不能被实例化，可以怎么做？</p><ol><li><p><strong>将类声明为抽象基类（Abstract Base Class, ABC）：</strong> <font color=red>如果一个类至少有一个纯虚函数，那么这个类就是抽象基类，无法被实例化</font>。纯虚函数是在基类中声明但不定义的虚函数，它在基类中的声明形式如下：<code>virtual void func() = 0;</code>。纯虚函数使得派生类必须提供自己的实现，否则派生类也将成为抽象基类。</p><p>如果其中没有其他合适的函数，可以把析构函数定义为纯虚析构函数</p></li><li><p><strong>声明类的构造函数为protected或private：</strong> 如果一个类的构造函数被声明为<code>protected</code>或<code>private</code>，那么在类的外部就不能直接调用这个构造函数来创建类的对象。只有类本身和它的友元函数或类可以访问它的私有或保护成员。</p></li></ol></li><li><p>虚函数、纯虚函数</p><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。而纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见下文虚继承。</li></ul></li><li><p>谈谈虚函数指针、虚函数表</p><p>虚函数指针是存储在对象中的特殊指针，用于指向对象的虚函数表。<font color=red>每个对象都有一个虚函数指针，它指向对象的虚函数表的首地址。</font>通过虚函数指针，可以在运行时动态地调用适当的虚函数。</p><p>虚函数表是存储在内存中的一张表格，用于存储类的虚函数地址。<font color=red>每个类（含有虚函数的类）都有一个对应的虚函数表，其中存放了该类所有虚函数的地址</font>。虚函数表是在编译阶段创建的，每个类的虚函数表在程序运行时都会存在于内存中。</p><p>虚函数指针指向虚函数表的首地址，通过虚函数指针可以访问到对象的虚函数表。当调用对象的虚函数时，编译器会使用虚函数指针找到对象的虚函数表，然后根据函数在虚函数表中的索引找到相应的虚函数地址，并进行调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base::foo()&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>foo</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived::foo()&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>basePtr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Derived</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>basePtr</span><span class=o>-&gt;</span><span class=n>foo</span><span class=p>();</span> <span class=c1>// 调用 Derived::foo()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取虚函数表指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=kt>long</span><span class=o>*</span> <span class=n>vptr</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=o>**</span><span class=p>)</span><span class=n>basePtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取虚函数表中第一个虚函数地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=kt>long</span> <span class=n>funcAddr</span> <span class=o>=</span> <span class=n>vptr</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 转换为函数指针并调用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)()</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=n>funcAddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>();</span> <span class=c1>// 调用 Derived::foo()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>basePtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p>谈谈虚继承</p><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，<font color=red>每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）</font>（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p></li><li><p>虚继承、虚函数</p><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li><font color=red>虚基类表存储的是虚基类相对直接继承类的偏移</font></li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul></li><li><p>谈谈C++中的抽象类、接口类、聚合类</p><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul></li><li><p>谈谈C++中的模板机制</p><p>在C++中，模板（Template）是一种通用的代码生成机制，允许程序员编写通用的代码来处理不同类型的数据，而不需要为每种数据类型编写特定的代码。模板是C++中强大的特性之一，它提高了代码的重用性、可读性和可维护性。</p><ol><li><p>类模板（Class Templates）：类模板是一种用于创建通用类的模板，允许类中的数据成员和成员函数的类型参数化。通过类模板，可以定义一个通用的类，可以处理多种不同类型的数据。</p></li><li><p>函数模板（Function Templates）：函数模板是一种用于创建通用函数的模板，允许函数中的参数类型参数化。通过函数模板，可以定义一个通用的函数，可以处理多种不同类型的数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>maximum</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></li><li><p>模板特化（Template Specialization）：模板特化是指针对某些特定的类型，为模板定义一个特殊的实现。当模板在处理特定类型时需要特殊的行为时，可以使用模板特化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>elements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>push</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>element</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>elements</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>element</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>pop</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>elements</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>out_of_range</span><span class=p>(</span><span class=s>&#34;Stack&lt;std::string&gt;::pop(): empty stack&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>element</span> <span class=o>=</span> <span class=n>elements</span><span class=p>.</span><span class=n>back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>elements</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>element</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li><li><p>模板参数（Template Parameters）：模板参数是在定义模板时指定的参数，它可以是类型参数或非类型参数。类型参数指定了模板中的数据类型，而非类型参数可以是整数、指针等。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Array</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>data</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div></li></ol></li><li><p>C++的new/delete和malloc/delete有什么区别？</p><p>C++中的<code>new</code>和<code>malloc()</code>都用于在堆上动态分配内存，但它们之间有一些重要的区别：</p><ol><li><code>new</code> 是C++中的关键字，可以为指定的类型动态分配内存，并返回相应类型的指针。而<code>malloc()</code>是C标准库函数，它返回<code>void*</code>类型的指针，需要手动进行类型转换，将其转换为所需类型的指针。这样的操作在C++中不够安全，可能导致编译器无法检测到的类型错误。</li><li><code>new</code> 分配内存时会调用对象的构造函数，确保对象被正确初始化。<code>malloc()</code> 只是简单地分配一块内存，并不会调用对象的构造函数。</li><li><code>new</code> 可以根据所需类型的大小自动计算要分配的内存空间大小，无需手动计算。而<code>malloc()</code> 需要手动指定要分配的内存空间大小，需要调用<code>sizeof</code>函数来计算所需的字节数。</li><li>在内存分配失败时，<code>new</code> 会抛出异常（<code>std::bad_alloc</code>），需要使用异常处理机制来处理。而<code>malloc()</code> 分配内存失败时会返回空指针（<code>NULL</code>），需要手动检查返回值并进行错误处理。</li><li>使用<code>new</code>分配的内存需要使用<code>delete</code>关键字进行释放，而使用<code>malloc()</code>分配的内存需要使用<code>free()</code>函数进行释放。</li></ol><p>本质：<code>new / new[]</code>：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。<code>delete/delete[]</code>：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p></li><li><p>delete this 合法吗？</p><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this </code>后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol></li><li><p>C++如何定义一个只能在堆上（栈上）生成对象的类？</p><ul><li>只能在堆上：将析构函数设置为私有。C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li><li>只能在栈上：将 new 和 delete 重载为私有。在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li></ul></li><li><p>介绍一下C++的智能指针</p><p>C++中的智能指针是一种特殊的指针对象，可以自动管理动态分配的内存，避免内存泄漏和悬空指针等常见问题。智能指针通过包装原始指针，提供了自动释放内存的机制，从而简化了内存管理的工作。常见的智能指针包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>（<code>auto_ptr</code>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。）。</p><ol><li><code>std::unique_ptr</code>是一种独占式智能指针，即同一时间只能有一个<code>std::unique_ptr</code>拥有某个对象的所有权。当<code>std::unique_ptr</code>超出作用域或被显式释放时，它所管理的对象会被自动释放。不能复制或赋值给其他<code>std::unique_ptr</code>，但可以通过<code>std::move()</code>来转移所有权。<font color=red>适用于需要严格所有权管理的情况，例如资源管理类对象</font>。</li><li><code>std::shared_ptr</code>是一种共享式智能指针，可以拥有多个<code>std::shared_ptr</code>共享同一个对象。使用引用计数来跟踪对象的引用次数，当引用次数为0时，对象会被自动释放。可以复制和赋值给其他<code>std::shared_ptr</code>，引用计数会增加。<font color=red>适用于需要多个指针共享同一资源的情况，例如多个对象共享一个动态分配的对象</font>。</li><li><code>std::weak_ptr</code>是一种弱引用智能指针，它不会增加对象的引用计数，也不会影响对象的生命周期。用于解决<code>std::shared_ptr</code>的循环引用问题，通过打破循环引用，<strong>防止内存泄漏</strong>。可以通过<code>lock()</code>方法获取一个指向被管理对象的<code>std::shared_ptr</code>，如果对象已经被释放，则返回空指针。</li></ol></li><li><p>谈谈C++的强制类型转换</p><p>在C++中，有四种主要的强制类型转换方式：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。用法：<code>static_cast&lt;typename>(object)</code></p><ol><li><p><code>static_cast</code>用于进行静态类型转换，通常用于较为安全的转换，例如基本数据类型之间的转换、类层次结构中的向上转换（派生类指针转为基类指针）和向下转换（基类指针转为派生类指针）等。<font color=red>静态转换在编译时进行，不提供运行时类型检查</font>。</p></li><li><p><code>dynamic_cast</code>用于进行动态类型转换，用于安全地在类层次结构中进行向上或向下转换，并且提供了运行时类型检查。当进行向下转换时，如果指针不指向有效的派生类对象，则返回空指针。<font color=red>只能用于具有虚函数的类（即多态类）之间的转换。</font></p></li><li><p><code>const_cast</code>用于添加或删除对象的const属性、volatile属性，<font color=red>主要用于消除类型的const限制</font>。注意：不应该用于修改本来就不可修改的对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>);</span>  <span class=c1>// 去除const属性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>  <span class=c1>// 合法，修改了const对象
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><code>reinterpret_cast</code>用于进行底层的重新解释转换，例如将一个指针转换为一个整数，或者一个整数转换为一个指针。这种转换非常危险，可能会导致未定义的行为，因此应该尽量避免使用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>);</span>  <span class=c1>// 将int指针转换为void指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*</span> <span class=n>newXPtr</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>  <span class=c1>// 将void指针转换为int指针
</span></span></span></code></pre></td></tr></table></div></div></li></ol></li><li><p>谈谈运行时类型信息 (RTTI)</p><p>运行时类型信息（RTTI, Runtime Type Information）是C++提供的一种机制，用于在运行时识别对象的类型。RTTI允许程序在运行时获取关于对象类型的信息，主要包括两个关键特性：<code>typeid</code>操作符和<code>dynamic_cast</code>操作符。</p><ol><li><code>typeid</code>操作符用于获取表达式或对象的类型信息。<code>typeid</code>返回一个<code>std::type_info</code>对象，该对象包含了类型的信息，可以通过其成员函数来获取类型名等信息。</li><li><code>dynamic_cast</code>用于多态类型的转换</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AnotherDerived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Derived</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=o>*</span> <span class=n>d</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>  <span class=c1>// 成功转换
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>AnotherDerived</span><span class=o>*</span> <span class=n>ad</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>AnotherDerived</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>  <span class=c1>// 转换失败，返回nullptr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;b is a Derived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ad</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;b is not an AnotherDerived&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>RTTI通常用于以下场景：</p><ul><li><strong>安全类型转换</strong>：在复杂的类层次结构中，使用<code>dynamic_cast</code>进行安全的向下转换，确保类型转换的正确性。</li><li><strong>类型检查</strong>：使用<code>typeid</code>进行类型检查，调试和记录对象的实际类型信息，帮助诊断问题。</li></ul></li><li><p>谈谈C++中怎么处理异常</p><p>在C++中，异常处理是一种机制，用于捕获和处理程序运行过程中发生的错误或异常情况，从而避免程序崩溃。C++通过<code>try</code>、<code>catch</code>和<code>throw</code>关键字来实现异常处理。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 可能抛出异常的代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理标准库异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Standard exception: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=kt>int</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理整型异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Integer exception: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>e</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span> <span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理其他所有类型的异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Unknown exception caught&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><code>throw</code>表达式用于抛出异常，可以抛出任何类型的对象。</p><p>C++允许用户定义自己的异常类，通常继承自<code>std::exception</code>，并重写<code>what()</code>方法来提供异常信息。</p></li><li><p>STL容器</p><table><thead><tr><th style=text-align:center>容器</th><th style=text-align:center>底层数据结构</th><th style=text-align:center>时间复杂度</th><th style=text-align:center>有无序</th><th style=text-align:center>可不可重复</th><th style=text-align:center>其他</th></tr></thead><tbody><tr><td style=text-align:center>array</td><td style=text-align:center>数组</td><td style=text-align:center>随机读改 O(1)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>支持随机访问，大小固定，不能动态调整</td></tr><tr><td style=text-align:center>vector</td><td style=text-align:center>数组</td><td style=text-align:center>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>支持随机访问，动态调整大小，使用连续内存存储，插入删除效率视位置而定</td></tr><tr><td style=text-align:center>deque</td><td style=text-align:center>双端队列</td><td style=text-align:center>头尾插入、头尾删除 O(1)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问，但随机访问效率略低于vector</td></tr><tr><td style=text-align:center>forward_list</td><td style=text-align:center>单向链表</td><td style=text-align:center>插入、删除 O(1)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>不支持随机访问，只能单向遍历，适用于只需前向访问和修改的场景</td></tr><tr><td style=text-align:center>list</td><td style=text-align:center>双向链表</td><td style=text-align:center>插入、删除 O(1)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>不支持随机访问，支持双向遍历，适用于频繁插入和删除的场景</td></tr><tr><td style=text-align:center>stack</td><td style=text-align:center>deque / list</td><td style=text-align:center>顶部插入、顶部删除 O(1)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>适用于后进先出（LIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td></tr><tr><td style=text-align:center>queue</td><td style=text-align:center>deque / list</td><td style=text-align:center>尾部插入、头部删除 O(1)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>适用于先进先出（FIFO）的场景，使用deque或list实现，不用vector的原因是扩容耗时</td></tr><tr><td style=text-align:center>priority_queue</td><td style=text-align:center>vector + max-heap</td><td style=text-align:center>插入、删除 O(log2n)</td><td style=text-align:center>有序</td><td style=text-align:center>可重复</td><td style=text-align:center>使用最大堆实现，适用于需要动态获取最大元素的场景，底层使用vector存储</td></tr><tr><td style=text-align:center>set</td><td style=text-align:center>红黑树</td><td style=text-align:center>插入、删除、查找 O(log2n)</td><td style=text-align:center>有序</td><td style=text-align:center>不可重复</td><td style=text-align:center>自动排序且元素唯一，适用于需要有序且无重复元素的场景</td></tr><tr><td style=text-align:center>multiset</td><td style=text-align:center>红黑树</td><td style=text-align:center>插入、删除、查找 O(log2n)</td><td style=text-align:center>有序</td><td style=text-align:center>可重复</td><td style=text-align:center>自动排序，允许重复元素，适用于需要有序且可重复元素的场景</td></tr><tr><td style=text-align:center>map</td><td style=text-align:center>红黑树</td><td style=text-align:center>插入、删除、查找 O(log2n)</td><td style=text-align:center>有序</td><td style=text-align:center>不可重复</td><td style=text-align:center>键值对存储，键唯一，自动按键排序，适用于需要按键有序访问且键唯一的场景</td></tr><tr><td style=text-align:center>multimap</td><td style=text-align:center>红黑树</td><td style=text-align:center>插入、删除、查找 O(log2n)</td><td style=text-align:center>有序</td><td style=text-align:center>可重复</td><td style=text-align:center>键值对存储，键可重复，自动按键排序，适用于需要按键有序访问且键可重复的场景</td></tr><tr><td style=text-align:center>unordered_set</td><td style=text-align:center>哈希表</td><td style=text-align:center>插入、删除、查找 O(1) 最差 O(n)</td><td style=text-align:center>无序</td><td style=text-align:center>不可重复</td><td style=text-align:center>使用哈希表实现，元素唯一，无序存储，适用于快速查找和插入的场景</td></tr><tr><td style=text-align:center>unordered_multiset</td><td style=text-align:center>哈希表</td><td style=text-align:center>插入、删除、查找 O(1) 最差 O(n)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>使用哈希表实现，允许重复元素，无序存储，适用于需要快速查找和插入且元素可重复的场景</td></tr><tr><td style=text-align:center>unordered_map</td><td style=text-align:center>哈希表</td><td style=text-align:center>插入、删除、查找 O(1) 最差 O(n)</td><td style=text-align:center>无序</td><td style=text-align:center>不可重复</td><td style=text-align:center>键值对存储，键唯一，使用哈希表实现，无序存储，适用于需要快速按键查找和插入的场景</td></tr><tr><td style=text-align:center>unordered_multimap</td><td style=text-align:center>哈希表</td><td style=text-align:center>插入、删除、查找 O(1) 最差 O(n)</td><td style=text-align:center>无序</td><td style=text-align:center>可重复</td><td style=text-align:center>键值对存储，键可重复，使用哈希表实现，无序存储，适用于需要快速按键查找和插入且键可重复的场景</td></tr></tbody></table></li></ol></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/02.c%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%80%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0/ title=如何使用C语言从一定范围内生成随机整数？>如何使用C语言从一定范围内生成随机整数？</a></li><li><a href=/posts/01.c-11%E5%A4%9A%E7%BA%BF%E7%A8%8B-stdthread%E8%AF%A6%E8%A7%A3/ title="C++11多线程 Std::thread详解">C++11多线程 Std::thread详解</a></li><li><a href=/posts/04.gfs/ title="【MIT 6.5840(6.824)学习笔记】GFS">【MIT 6.5840(6.824)学习笔记】GFS</a></li><li><a href=/posts/03.%E6%B5%8B%E8%AF%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/ title="【MIT 6.5840(6.824)学习笔记】 测试分布式系统的线性一致性">【MIT 6.5840(6.824)学习笔记】 测试分布式系统的线性一致性</a></li><li><a href=/posts/02.%E4%BD%BF%E7%94%A8go%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%92%8Crpc%E7%BC%96%E7%A8%8B/ title="【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程">【MIT 6.5840(6.824)学习笔记】使用Go进行线程和RPC编程</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/%E9%9D%A2%E8%AF%95/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・面试</span></span></a> 3</div><div class=collection-nav><a href=/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/ class=collection-nav-item rel=next title="数据结构与算法 面试题目总结"><span>数据结构与算法 面试题目总结</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-07-29 12:45:24">更新于 2024-07-29&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/01.c-%E9%9D%A2%E7%BB%8F/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_interview/01.C++%e9%9d%a2%e7%bb%8f.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_interview/01.C++%e9%9d%a2%e7%bb%8f.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20C%2FC%2B%2B+%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7cC%2FC%2B%2B+%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_interview/01.C++%e9%9d%a2%e7%bb%8f.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/ data-title="C/C++ 面试题目总结" data-hashtags=C++><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/ data-hashtag=C++><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/ data-title="C/C++ 面试题目总结"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/01.c-%E9%9D%A2%E7%BB%8F/ data-title="C/C++ 面试题目总结"><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/c++/ class=post-tag title="标签 - C++">C++</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/ class=post-nav-item rel=prev title="数据结构与算法 面试题目总结"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>数据结构与算法 面试题目总结</a>
<a href=/posts/04.gfs/ class=post-nav-item rel=next title="【MIT 6.5840(6.824)学习笔记】GFS">【MIT 6.5840(6.824)学习笔记】GFS<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.129.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>