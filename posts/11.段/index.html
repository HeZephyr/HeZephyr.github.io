<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>段 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="1 分段：广义基数/边界 到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。 虽然栈和堆之间的空间没有被进程"><meta name=keywords content='OS'><meta itemprop=name content="段"><meta itemprop=description content="1 分段：广义基数/边界 到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。 虽然栈和堆之间的空间没有被进程"><meta itemprop=datePublished content="2024-04-25T22:37:48+00:00"><meta itemprop=dateModified content="2024-07-28T11:19:19+00:00"><meta itemprop=wordCount content="4885"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/11.%E6%AE%B5/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="段"><meta property="og:description" content="1 分段：广义基数/边界 到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。 虽然栈和堆之间的空间没有被进程"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-25T22:37:48+00:00"><meta property="article:modified_time" content="2024-07-28T11:19:19+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="段"><meta name=twitter:description content="1 分段：广义基数/边界 到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。 虽然栈和堆之间的空间没有被进程"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/11.%E6%AE%B5/><link rel=prev href=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/><link rel=next href=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"段","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/11.%E6%AE%B5\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":4885,"url":"https:\/\/hezephyr.github.io\/posts\/11.%E6%AE%B5\/","datePublished":"2024-04-25T22:37:48+00:00","dateModified":"2024-07-28T11:19:19+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/Lruihao/hugo-blog title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>段</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><span class=active title=段>段</span></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ class=collection-nav-item rel=prev title=地址转换><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>11/39</span><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ class=collection-nav-item rel=next title=空闲空间管理><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>段</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-04-25 22:37:48"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-04-25>2024-04-25</time></span>&nbsp;<span title="更新于 2024-07-28 11:19:19"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-07-28>2024-07-28</time></span>&nbsp;<span title="4885 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 4900 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 10 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=段>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#分段广义基数边界>分段：广义基数/边界</a></li><li><a href=#引用段>引用段</a></li><li><a href=#关于栈>关于栈</a></li><li><a href=#支持段共享>支持段共享</a></li><li><a href=#细粒度分段与粗粒度分段>细粒度分段与粗粒度分段</a></li><li><a href=#操作系统支持>操作系统支持</a></li><li><a href=#总结>总结</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><h2 id=分段广义基数边界 class=heading-element><span>1 分段：广义基数/边界</span>
<a href=#%e5%88%86%e6%ae%b5%e5%b9%bf%e4%b9%89%e5%9f%ba%e6%95%b0%e8%be%b9%e7%95%8c class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/waste-space.png alt=image-20240330201709873 style=zoom:67%><p>虽然栈和堆之间的空间没有被进程使用，但当我们将整个地址空间重新定位到物理内存中的某个位置时，它仍然占用物理内存；因此，使用基址和边界寄存器对来虚拟化内存的简单方法是浪费的。当整个地址空间无法放入内存时，它也会使程序的运行变得非常困难；因此，基数和边界并不像我们希望的那样灵活。因此：关键：如何支持大地址空间 我们如何支持大地址空间以及栈和堆之间（可能）有大量可用空间？</p><p>为了解决这个问题，一个想法应运而生，它就是分段。这是一个相当古老的想法，至少可以追溯到 1960 年代初。这个想法很简单：与其在我们的 MMU 中只有一个基址和边界对，为什么不在地址空间的每个逻辑段都有一个基址和边界对呢？段只是特定长度的地址空间的连续部分，在我们的规范地址空间中，我们有三个逻辑上不同的段：代码、栈和堆。分段允许操作系统做的是将每个段放置在物理内存的不同部分，从而避免用未使用的虚拟地址空间填充物理内存。</p><p>让我们看一下例子，假设我们要将下图中的地址空间放入物理内存中。由于每个段都有一个基址和边界对，我们可以将每个段独立地放置在物理内存中。您可以看到 64KB 物理内存，其中包含这三个段（还有 16KB 为操作系统保留）</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segment-space.png alt=image-20240330201827588 style=zoom:67%><p>从图中可以看到，代码段放置在物理地址32KB，大小为2KB，堆段放置在34KB，大小也为2KB。假设对虚拟地址 100（位于代码段中，代码段从地址空间中的虚拟地址0开始。）进行了引用。当发生引用时（例如，在指令获取时），硬件会将基址值添加到该段的偏移量（本例中为 100），以达到所需的物理地址：100 + 32KB，或 32868。然后检查该地址是否在范围内（100小于2KB），发现它在范围内，然后发出对物理内存地址32868的引用。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segment_use_example_1.png alt=image-20240330202113587 style=zoom:67%><p>现在让我们看一下堆中的一个地址，虚拟地址 4200，如下图所示。如果我们只是将虚拟地址 4200 添加到堆基址 (34KB)，我们会得到物理地址 39016，这不是正确的物理地址。我们首先需要做的是将偏移量提取到堆中，即地址引用了该段中的哪个字节。因为堆从虚拟地址 4KB (4096) 开始，所以 4200 的偏移量实际上是 4200 减去 4096，即 104。然后我们将这个偏移量 (104) 添加到基址寄存器物理地址 (34K) 以获得所需的结果：34920。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segment_use_example_2.png alt=image-20240330202559617 style=zoom:67%><p>如果我们尝试引用非法地址，例如超出堆末尾的7KB，如下图所示，该怎么办？您可以想象会发生什么：硬件检测到地址越界，进入操作系统中断，可能导致违规进程终止。现在您知道了所有 C 程序员都害怕的著名术语的由来：<strong>分段违规或分段错误</strong>。</p><blockquote><p>“分段错误”或“违规”是由分段机器上对非法地址的内存访问引起的。有趣的是，这个术语仍然存在，即使在根本不支持分段的机器上也是如此。或者，如果你无法弄清楚为什么你的代码总是出错，那就不那么幽默了。</p></blockquote><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segmen-fault-example-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segmen-fault-example-1.png?size=small" data-sub-html="<h2>image-20240330202930597</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segmen-fault-example-1.png alt=image-20240330202930597 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segmen-fault-example-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segmen-fault-example-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/segmen-fault-example-1.png?size=large 2x" data-title=image-20240330202930597 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=引用段 class=heading-element><span>2 引用段</span>
<a href=#%e5%bc%95%e7%94%a8%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>硬件在转换期间使用段寄存器。它如何知道段中的偏移量以及地址引用哪个段？</p><p>一种常见的方法（有时称为显式方法）是根据虚拟地址的前几位将地址空间分成多个段；该技术用于 VAX/VMS 系统。在上面的例子中，我们有三个部分；因此我们需要两个位来完成我们的任务。如果我们使用 14 位虚拟地址的前两位来选择段，我们的虚拟地址如下所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_1.png?size=small" data-sub-html="<h2>image-20240330203122146</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_1.png alt=image-20240330203122146 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_1.png?size=large 2x" data-title=image-20240330203122146 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>在我们的示例中，如果前两位是 00，则硬件知道虚拟地址位于代码段中，因此使用<strong>代码基址和边界对</strong>将地址重新定位到正确的物理位置。如果前两位是 01，则硬件知道该地址在堆中，因此使用<strong>堆基址和边界</strong>。让我们以上面的示例堆虚拟地址 (4200) 为例并对其进行转换，只是为了确保这一点是清楚的。二进制形式的虚拟地址 4200 可以在这里看到：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_3.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_3.png?size=small" data-sub-html="<h2>image-20240330203317701</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_3.png alt=image-20240330203317701 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_3.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_3.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/virtual_address_example_3.png?size=large 2x" data-title=image-20240330203317701 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>从图中可以看出，前两位 (01) 告诉硬件我们正在引用哪个段。底部 12 位是段中的偏移量：<code>0000 0110 1000</code>，或十六进制 0x068，或十进制 104。因此，硬件只需使用前两位来确定要使用哪个段寄存器，然后将接下来的 12 位作为段中的偏移量。通过将基址寄存器与偏移量相加，硬件得出最终的物理地址。请注意，偏移量也简化了边界检查：我们可以简单地检查偏移量是否小于边界；如果不是，则该地址是非法的。因此，如果基址和边界是数组（每个段一个条目），硬件将执行类似以下操作来获取所需的物理地址：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// get top 2 bits of 14-bit VA
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Segment</span> <span class=o>=</span> <span class=p>(</span><span class=n>VirtualAddress</span> <span class=o>&amp;</span> <span class=n>SEG_MASK</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>SEG_SHIFT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// now get offset
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Offset</span> <span class=o>=</span> <span class=n>VirtualAddress</span> <span class=o>&amp;</span> <span class=n>OFFSET_MASK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>Offset</span> <span class=o>&gt;=</span> <span class=n>Bounds</span><span class=p>[</span><span class=n>Segment</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>RaiseException</span><span class=p>(</span><span class=n>PROTECTION_FAULT</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysAddr</span> <span class=o>=</span> <span class=n>Base</span><span class=p>[</span><span class=n>Segment</span><span class=p>]</span> <span class=o>+</span> <span class=n>Offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Register</span> <span class=o>=</span> <span class=nf>AccessMemory</span><span class=p>(</span><span class=n>PhysAddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在我们的运行示例中，我们可以填写上面常量的值。具体来说，SEG MASK 将设置为 0x3000，SEG SHIFT 设置为 12，OFFSET MASK 设置为 0xFFF。您可能还注意到，当我们使用前两位时，并且只有三个段（代码、堆、栈），地址空间的一个段未被使用。因此，一些系统将代码放在与堆相同的段中，从而仅使用一位来选择要使用的段。</p><p>硬件还有其他方法来确定特定地址位于哪个段。在<strong>隐式</strong>方法中，硬件通过注意地址的形成方式来确定段。例如，如果地址是从程序计数器生成的（即，它是指令提取），则该地址在代码段内；如果地址基于栈或基址指针，则它必须位于栈段中；任何其他地址则都位于堆中。</p><h2 id=关于栈 class=heading-element><span>3 关于栈</span>
<a href=#%e5%85%b3%e4%ba%8e%e6%a0%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>到目前为止，我们遗漏了地址空间的一个重要组成部分：栈。上图中，栈已重新定位到物理地址 28KB，但有一个关键区别：它向后增长。在物理内存中，从28KB开始，增长到26KB，对应虚拟地址16KB到14KB；地址转换必须以不同的方式进行。</p><p>我们首先需要的是一些额外的硬件支持。硬件不仅需要知道基址值和边界值，还需要知道段增长的方式（例如，当段沿正方向增长时设置为 1，当段沿负方向增长时设置为 0）。我们对硬件跟踪内容的更新视图如下表所示：</p><table><thead><tr><th style=text-align:center>Segment</th><th style=text-align:center>Base</th><th style=text-align:center>Size</th><th style=text-align:center>Grows Positive?</th><th style=text-align:center>Protection</th></tr></thead><tbody><tr><td style=text-align:center>Code</td><td style=text-align:center>32K</td><td style=text-align:center>2K</td><td style=text-align:center>1</td><td style=text-align:center>Read-Execute</td></tr><tr><td style=text-align:center>Heap</td><td style=text-align:center>34K</td><td style=text-align:center>2K</td><td style=text-align:center>1</td><td style=text-align:center>Read-Write</td></tr><tr><td style=text-align:center>Stack</td><td style=text-align:center>28K</td><td style=text-align:center>2K</td><td style=text-align:center>0</td><td style=text-align:center>Read-Write</td></tr></tbody></table><p>由于硬件了解段可以向负方向增长，因此硬件现在必须稍微不同地转换此类虚拟地址。让我们举一个栈虚拟地址的例子，并转换它来理解这个过程。</p><p>在此示例中，假设我们希望访问虚拟地址 15KB，该地址应映射到物理地址 27KB。我们的二进制形式的虚拟地址如下所示：<code>11 1100 0000 0000</code>（十六进制0x3C00）。硬件使用前两位 (11) 来指定段，但我们留下了 3KB 的偏移量。为了获得正确的负偏移量，我们必须从 3KB 中减去最大段大小：在本例中，一个段可以是 4KB，因此正确的负偏移量是 3KB 减去 4KB，等于 -1KB。我们只需将负偏移量 (-1KB) 添加到基址 (28KB) 即可得到正确的物理地址：27KB。可以通过确保负偏移的绝对值小于段的大小来计算边界检查。</p><h2 id=支持段共享 class=heading-element><span>4 支持段共享</span>
<a href=#%e6%94%af%e6%8c%81%e6%ae%b5%e5%85%b1%e4%ba%ab class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>随着对分段的支持不断增长，系统设计人员很快意识到，他们可以通过更多的硬件支持来实现新型效率。具体来说，为了节省内存，有时在地址空间之间<strong>共享</strong>某些内存段很有用。特别是，<strong>代码共享</strong>很常见，并且在当今的系统中仍在使用。</p><p>为了支持共享，我们需要硬件以<strong>保护位</strong>的形式提供一些额外的支持。基本支持为每个段添加一些位，指示程序是否可以读取或写入段，或者是否可以执行段内的代码。通过将代码段设置为只读，可以在多个进程之间共享相同的代码，而不必担心损害隔离性；虽然每个进程仍然认为它正在访问自己的私有内存，但操作系统正在秘密共享该进程无法修改的内存，因此保留了这种错觉。</p><p>上表显示了硬件（和操作系统）跟踪的附加信息的示例。可以看到，代码段被设置为读取和执行，因此内存中的同一物理段可以映射到多个虚拟地址空间。</p><p>有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否在范围内之外，硬件还必须检查是否允许特定访问。如果用户进程尝试写入只读段，或从不可执行段执行，则硬件应引发异常，从而让操作系统处理违规进程。</p><h2 id=细粒度分段与粗粒度分段 class=heading-element><span>5 细粒度分段与粗粒度分段</span>
<a href=#%e7%bb%86%e7%b2%92%e5%ba%a6%e5%88%86%e6%ae%b5%e4%b8%8e%e7%b2%97%e7%b2%92%e5%ba%a6%e5%88%86%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>迄今为止，我们的大多数示例都集中在只有几个分段（即代码、栈、堆）的系统上；我们可以将这种分段视为<strong>粗粒度分段</strong>，因为它将地址空间分割成相对较大、较粗的块。然而，一些早期的系统（如 Multics）更加灵活，允许地址空间由大量较小的段组成，称为<strong>细粒度分段</strong>。</p><p>支持多分段需要更多硬件支持，在内存中存储某种<strong>分段表</strong>。这种段表通常支持创建大量的段，从而使系统能够以比我们迄今为止讨论的更灵活的方式使用段。例如，早期的机器（如 Burroughs B5000）支持数千个分段，并期望编译器将代码和数据切分成独立的分段，然后操作系统和硬件将支持这些分段。当时的想法是，通过细化分段，操作系统可以更好地了解哪些分段正在使用，哪些没有使用，从而更有效地利用主内存。</p><h2 id=操作系统支持 class=heading-element><span>6 操作系统支持</span>
<a href=#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%94%af%e6%8c%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>您现在应该对分段的工作原理有一个基本的了解。当系统运行时，地址空间的各个部分会被重新定位到物理内存中，因此，相对于整个地址空间仅使用单个基址/边界对的更简单方法，可以节省大量物理内存。具体来说，栈和堆之间所有未使用的空间都不需要分配在物理内存中，从而允许我们将更多的地址空间放入物理内存中。</p><p>然而，分段引发了许多新问题。我们将首先描述必须解决的新操作系统问题。</p><p>第一个是旧的：操作系统在上下文切换时应该做什么？现在您应该有一个很好的猜测：必须保存和恢复段寄存器。显然，每个进程都有自己的虚拟地址空间，操作系统必须确保在让进程再次运行之前正确设置这些寄存器。</p><p>第二个也是更重要的问题是管理物理内存中的可用空间。当创建新的地址空间时，操作系统必须能够在物理内存中为其段找到空间。以前，我们假设每个地址空间的大小相同，因此物理内存可以被认为是进程可以容纳的一堆插槽。现在，每个进程有多个段，每个段可能是不同的尺寸。</p><p>出现的普遍问题是物理内存很快就会充满可用空间的小孔，使得分配新段或增加现有段变得困难。我们称这个问题为外部碎片；如下图所示（左）。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/memory_compaction_example.png alt=image-20240330210048642 style=zoom:67%><p>在示例中，一个进程出现并希望分配一个 20KB 的段。在该示例中，有 24KB 空闲空间，但不是在一个连续的段中（而是在三个不连续的块中）。因此，操作系统无法满足 20KB 请求。</p><p>该问题的一种解决方案是通过重新<strong>排列</strong>现有段来压缩物理内存。例如，操作系统可以停止正在运行的进程，将其数据复制到一个连续的内存区域，更改其段寄存器值以指向新的物理位置，从而拥有大量可用的可用内存。通过这样做，操作系统使新的分配请求能够成功。然而，压缩的成本很高，且因为复制段是内存密集型的，并且通常会占用相当多的处理器时间。如上图所示（右），可查看压缩物理内存后的结果。</p><p>一种更简单的方法是使用<strong>空闲列表管理算法</strong>，该算法尝试保持大范围的内存可用于分配。人们实际上已经采用了数百种方法，包括经典算法，例如<strong>最佳适应</strong>（保留可用空间列表并返回满足请求者所需分配的最接近大小的算法）、<strong>最差适应、首次适应</strong>，以及更复杂的方案，如<strong>伙伴算法</strong> 。但不幸的是，无论算法多么聪明，外部碎片仍然存在；因此，一个好的算法只是尝试将其最小化。</p><blockquote><center>TIP：如果存在 1000 种解决方案，那么没有一个是最好的解决方案</center><p>存在如此多不同的算法来尝试最大限度地减少外部碎片这一事实表明了一个更强有力的潜在事实：没有一种“最佳”方法可以解决问题。因此，我们选择合理的东西，并希望它足够好。唯一真正的解决方案是完全避免这个问题，永远不要以可变大小的块分配内存。</p></blockquote><h2 id=总结 class=heading-element><span>7 总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>分段解决了许多问题，并帮助我们构建更有效的内存虚拟化。除了动态重定位之外，分段还可以通过避免地址空间的逻辑段之间潜在的巨大内存浪费来更好地支持稀疏地址空间。它也很快，因为进行算术分段所需的操作很容易并且非常适合硬件；地址转换费用很少。还出现了一个附带好处：代码共享。如果代码放置在单独的段中，则这样的段可能会在多个正在运行的程序之间共享。</p><p>然而，正如我们所知，在内存中分配可变大小的段会导致一些我们希望克服的问题。如上所述，第一个是外部碎片。因为段是可变的，所以可用内存被分成奇数大小的块，因此满足内存分配请求可能很困难。人们可以尝试使用智能算法或定期压缩内存，但问题是根本性的且难以避免。</p><p>第二个也许更重要的问题是分段仍然不够灵活，无法支持我们完全通用的稀疏地址空间。例如，如果我们在一个逻辑段中有一个大但很少使用的堆，则整个堆必须仍然驻留在内存中才能被访问。换句话说，如果我们的地址空间使用方式模型与底层分段的设计支持方式不完全匹配，分段就不能很好地工作。因此我们需要寻找一些新的解决方案。</p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ class=collection-nav-item rel=prev title=地址转换><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>地址转换</span>
</a><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ class=collection-nav-item rel=next title=空闲空间管理><span>空闲空间管理</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-07-28 11:19:19">更新于 2024-07-28&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/11.%E6%AE%B5/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_develop/_system/ostep/11.%e6%ae%b5.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/Lruihao/hugo-blog/edit/docs/content/posts/_develop/_system/ostep/11.%e6%ae%b5.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/Lruihao/hugo-blog/issues/new?title=[BUG]%20%E6%AE%B5&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E6%AE%B5%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/11.%E6%AE%B5/%7c%0A%7cFilename%7chttps://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_develop/_system/ostep/11.%e6%ae%b5.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/11.%E6%AE%B5/ data-title=段 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/11.%E6%AE%B5/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/11.%E6%AE%B5/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/11.%E6%AE%B5/ data-title=段><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/11.%E6%AE%B5/ data-title=段><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ class=post-nav-item rel=prev title=空闲空间管理><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>空闲空间管理</a>
<a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ class=post-nav-item rel=next title=地址转换>地址转换<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=Lruihao/hugo-blog data-repo-id="MDEwOlJlcG9zaXRvcnk0MDQzNDY3MDk=" data-category=General data-category-id=DIC_kwDOGBnXVc4CApHL data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.129.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"6BN9L31BND",algoliaIndex:"index",algoliaSearchKey:"03440c0c020a6c0fe73d00bf65b88c2b",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>