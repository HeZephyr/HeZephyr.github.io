<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>空闲空间管理 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="1 假设
  
    
  
本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。
我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，void *malloc(size t size) 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 C 语言中的 void 指针）。补充例程 void free(void *ptr) 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。"><meta name=keywords content='OS'><meta itemprop=name content="空闲空间管理"><meta itemprop=description content="1 假设 本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。
我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，void *malloc(size t size) 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 C 语言中的 void 指针）。补充例程 void free(void *ptr) 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。"><meta itemprop=datePublished content="2024-04-25T22:38:12+00:00"><meta itemprop=dateModified content="2024-10-15T13:58:47+00:00"><meta itemprop=wordCount content="6256"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="空闲空间管理"><meta property="og:description" content="1 假设 本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。
我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，void *malloc(size t size) 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 C 语言中的 void 指针）。补充例程 void free(void *ptr) 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-25T22:38:12+00:00"><meta property="article:modified_time" content="2024-10-15T13:58:47+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="空闲空间管理"><meta name=twitter:description content="1 假设 本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。
我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，void *malloc(size t size) 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 C 语言中的 void 指针）。补充例程 void free(void *ptr) 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/><link rel=prev href=https://hezephyr.github.io/posts/11.%E6%AE%B5/><link rel=next href=https://hezephyr.github.io/posts/13.%E9%A1%B5/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"空闲空间管理","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":6256,"url":"https:\/\/hezephyr.github.io\/posts\/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86\/","datePublished":"2024-04-25T22:38:12+00:00","dateModified":"2024-10-15T13:58:47+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>空闲空间管理</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><span class=active title=空闲空间管理>空闲空间管理</span></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/11.%E6%AE%B5/ class=collection-nav-item rel=prev title=段><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>12/39</span><a href=/posts/13.%E9%A1%B5/ class=collection-nav-item rel=next title=页><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>空闲空间管理</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-04-25 22:38:12"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-04-25>2024-04-25</time></span>&nbsp;<span title="更新于 2024-10-15 13:58:47"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-10-15>2024-10-15</time></span>&nbsp;<span title="6256 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 6300 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 13 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=空闲空间管理>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#假设>假设</a></li><li><a href=#低级机制>低级机制</a><ol><li><a href=#分割与合并>分割与合并</a></li><li><a href=#跟踪分配区域的大小>跟踪分配区域的大小</a></li><li><a href=#嵌入空闲列表>嵌入空闲列表</a></li><li><a href=#增加堆>增加堆</a></li></ol></li><li><a href=#管理空闲空间基本策略>管理空闲空间：基本策略</a><ol><li><a href=#最佳适应算法>最佳适应算法</a></li><li><a href=#最差适应算法>最差适应算法</a></li><li><a href=#首次适应算法>首次适应算法</a></li><li><a href=#循环首次适应算法>循环首次适应算法</a></li><li><a href=#四种算法实例对比>四种算法实例对比</a></li></ol></li><li><a href=#其他方法>其他方法</a><ol><li><a href=#隔离列表slab分配器>隔离列表：slab分配器</a></li><li><a href=#伙伴分配器>伙伴分配器</a></li><li><a href=#其他方法-1>其他方法</a></li></ol></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><h2 id=假设 class=heading-element><span>1 假设</span>
<a href=#%e5%81%87%e8%ae%be class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。</p><p>我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，<code>void *malloc(size t size)</code> 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 C 语言中的 void 指针）。补充例程 <code>void free(void *ptr)</code> 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。</p><p>该库管理的空间历史上称为堆，用于管理堆中空闲空间的通用数据结构是某种<strong>空闲列表</strong>。该结构包含对托管内存区域中所有空闲空间块的引用。当然，该数据结构本身不必是列表，而只是某种用于跟踪可用空间的数据结构。</p><p>我们进一步假设我们主要关注<strong>外部碎片</strong>。分配器当然也可能存在<strong>内部碎片</strong>的问题；如果分配器分配的内存块大于请求的内存块，则此类块中任何未请求的（因此未使用的）空间都被视为内部碎片（因为浪费发生在分配的单元内），并且是空间浪费的一种情况。然而，为了简单起见，并且因为它是两种类型的碎片中更有趣的一种，所以我们将主要关注外部碎片。</p><p>我们还假设一旦内存被分发给客户端，它就不能被重新定位到内存中的另一个位置。例如，如果程序调用 malloc() 并获得一个指向堆内某个空间的指针，则该内存区域本质上由程序“拥有”（并且不能由库移动），直到程序通过相应的free()调用返回它为止。因此，不可能压缩可用空间，而压缩有助于消除碎片。然而，在实现分段时，可以在操作系统中使用压缩来处理碎片。</p><p>最后，我们假设分配器管理一个连续的字节区域。在某些情况下，分配者可能会要求该区域增长；例如，当空间不足时，用户级内存分配库可能会调用内核来增加堆（通过 sbrk 等系统调用）。然而，为了简单起见，我们假设该区域在其整个生命周期中都是单一的固定大小。</p><h2 id=低级机制 class=heading-element><span>2 低级机制</span>
<a href=#%e4%bd%8e%e7%ba%a7%e6%9c%ba%e5%88%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=分割与合并 class=heading-element><span>2.1 分割与合并</span>
<a href=#%e5%88%86%e5%89%b2%e4%b8%8e%e5%90%88%e5%b9%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>空闲列表包含一组元素，这些元素描述堆中仍剩余的空闲空间。因此，假设有以下 30 字节堆：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/30-byte-heap.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/30-byte-heap.png?size=small" data-sub-html="<h2>image-20240401091750499</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/30-byte-heap.png alt=image-20240401091750499 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/30-byte-heap.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/30-byte-heap.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/30-byte-heap.png?size=large 2x" data-title=image-20240401091750499 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>该堆的空闲列表上有两个元素。一个条目描述第一个 10 字节空闲段（字节 0-9），一个条目描述另一个空闲段（字节 20-29）：</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-two-example-1.png alt=image-20240401091903934 style=zoom:67%><p>如上所述，任何大于 10 字节的请求都会失败（返回 NULL），只是没有该大小的连续内存块可用。任何一个空闲块都可以轻松满足对该大小（10 字节）的请求。但如果请求的内容小于 10 个字节，会发生什么情况？</p><p>假设我们只请求一个字节的内存。在这种情况下，分配器将执行称为<strong>分割</strong>的操作：它将找到可以满足请求的空闲内存块并将其分割为两部分。它将返回给调用者的第一个块；第二块将保留在列表中。因此，在上面的示例中，如果发出了 1 个字节的请求，并且分配器决定使用列表中两个元素中的第二个来满足请求，则对 malloc() 的调用将返回 20（分配器的地址）。 1 字节分配区域），列表最终将如下所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-split-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-split-1.png?size=small" data-sub-html="<h2>image-20240401092401528</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-split-1.png alt=image-20240401092401528 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-split-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-split-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-split-1.png?size=large 2x" data-title=image-20240401092401528 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>从图中可以看到列表基本保持完整；唯一的变化是空闲区域现在从 21 而不是 20 开始，并且该空闲区域的长度现在仅为 9。因此，当请求小于任何特定空闲块的大小时，分配器通常会使用分割方法。许多分配器中都有一个推论机制，称为空闲空间合并。再次以上面的例子为例（空闲 10 个字节，已用 10 个字节，还有另外一个空闲 10 个字节）。</p><p>给定这个（很小的）堆，当应用程序调用 free(10) 时会发生什么，从而返回堆中间的空间？如果我们只是简单地将这个可用空间添加回我们的列表中而不需要太多思考，我们最终可能会得到一个如下所示的列表：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-but-no-coalescing.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-but-no-coalescing.png?size=small" data-sub-html="<h2>image-20240401092831460</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-but-no-coalescing.png alt=image-20240401092831460 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-but-no-coalescing.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-but-no-coalescing.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-but-no-coalescing.png?size=large 2x" data-title=image-20240401092831460 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>虽然整个堆现在是空闲的，但它似乎被分为三个块，每个块 10 字节。因此，如果用户请求 20 个字节，简单的列表遍历将找不到这样的空闲块，并返回失败。</p><p>为了避免这个问题，分配器所做的就是在释放一块内存时合并可用空间。这个想法很简单：当返回内存中的空闲块时，仔细查看要返回的块的地址以及附近的空闲空间块；如果新释放的空间紧邻一个（或两个，如本示例中所示）现有空闲块，请将它们合并为一个更大的空闲块。因此，通过合并，我们的最终列表应该如下所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/after-coalescing-free-chunks.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/after-coalescing-free-chunks.png?size=small" data-sub-html="<h2>image-20240401093107278</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/after-coalescing-free-chunks.png alt=image-20240401093107278 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/after-coalescing-free-chunks.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/after-coalescing-free-chunks.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/after-coalescing-free-chunks.png?size=large 2x" data-title=image-20240401093107278 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>事实上，这就是在进行任何分配之前堆列表最初的样子。通过合并，分配器可以更好地确保大的空闲范围可供应用程序使用。</p><h3 id=跟踪分配区域的大小 class=heading-element><span>2.2 跟踪分配区域的大小</span>
<a href=#%e8%b7%9f%e8%b8%aa%e5%88%86%e9%85%8d%e5%8c%ba%e5%9f%9f%e7%9a%84%e5%a4%a7%e5%b0%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>您可能已经注意到 <code>free(void *ptr)</code> 的接口不采用大小参数；因此，假设给定一个指针，malloc 库可以快速确定正在释放的内存区域的大小，从而将空间合并回空闲列表中。</p><p>为了完成此任务，大多数分配器在<code>header</code>块中存储一些额外信息，该<code>header</code>块保存在内存中，通常就在分配的内存块之前。让我们再看一个例子，如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/header-block-example-1.png alt=image-20240401093603438 style=zoom:67%><p>在此示例中，我们正在检查由 ptr 指向的大小为 20 字节的已分配块；想象一下用户调用 malloc() 并将结果存储在 ptr 中，例如 ptr = malloc(20);</p><p><code>header</code>至少包含分配区域的大小（在本例中为 20）；它还可能包含用于加速释放的附加指针、用于提供附加完整性检查的幻数以及其他信息。让我们假设一个简单的标头，其中包含区域的大小和一个幻数，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>__header_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>magic</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>header_t</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>上面的示例如下图所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Specific-Contents-of-the-Header.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Specific-Contents-of-the-Header.png?size=small" data-sub-html="<h2>image-20240401094058832</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Specific-Contents-of-the-Header.png alt=image-20240401094058832 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Specific-Contents-of-the-Header.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Specific-Contents-of-the-Header.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Specific-Contents-of-the-Header.png?size=large 2x" data-title=image-20240401094058832 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>当用户调用 <code>free(ptr)</code>，然后库使用简单的指针算术来确定标头的开始位置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>header_t</span> <span class=o>*</span><span class=n>hptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>header_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>assert</span><span class=p>(</span><span class=n>hptr</span><span class=o>-&gt;</span><span class=n>magic</span> <span class=o>==</span> <span class=mi>1234567</span> <span class=o>&amp;&amp;</span> <span class=err>“</span><span class=n>Heap</span> <span class=n>is</span> <span class=n>corrupt</span><span class=err>”</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span></span></span></code></pre></td></tr></table></div></div><p>获得这样一个指向<code>header</code>的指针后，库可以轻松确定幻数是否与预期值匹配作为健全性检查（<code>assert(hptr->magic == 1234567)</code>），并通过简单的数学运算（即，将<code>header</code>的大小添加到区域的大小）计算新释放区域的总大小。请注意最后一句中的小但关键的细节：空闲区域的大小是<code>header</code>的大小加上分配给用户的空间的大小。因此，当用户请求 N 字节的内存时，库不会搜索大小为 N 的空闲块；相反，它会搜索大小为 N 加上<code>header</code>大小的空闲块。</p><h3 id=嵌入空闲列表 class=heading-element><span>2.3 嵌入空闲列表</span>
<a href=#%e5%b5%8c%e5%85%a5%e7%a9%ba%e9%97%b2%e5%88%97%e8%a1%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>到目前为止，我们已经将简单的空闲列表视为一个概念实体；它只是一个描述堆中空闲内存块的列表。但是我们如何在空间空间本身内构建这样的列表呢？</p><p>在更典型的列表中，分配新节点时，只需在需要该节点的空间时调用 malloc() 即可。不幸的是，在内存分配库中，你不能这样做！相反，您需要在可用空间本身内构建列表。如果这听起来有点奇怪，请不要担心；是的，但并不奇怪到你做不到！</p><p>假设我们有一个 4096 字节的内存块需要管理（即堆为 4KB）。要将其作为空闲列表进行管理，我们首先必须初始化该列表；最初，列表应该有一个条目，大小为 4096（减去<code>header</code>大小）。以下是链表节点的描述：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>__node_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>__node_t</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>node_t</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>现在让我们看一些初始化堆并将空闲列表的第一个元素放入该空间的代码。我们假设堆是在通过调用系统调用 mmap() 获得的一些可用空间内构建的；这不是构建此类堆的唯一方法，但在本例中对我们很有帮助。这是代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// mmap() returns a pointer to a chunk of free space
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>node_t</span> <span class=o>*</span><span class=n>head</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=o>|</span><span class=n>PROT_WRITE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>MAP_ANON</span><span class=o>|</span><span class=n>MAP_PRIVATE</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>head</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>=</span> <span class=mi>4096</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>node_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>运行这段代码后，列表的状态是只有一个条目，大小为 4088。是的，这是一个很小的堆，但它为我们提供了一个很好的例子。</p><p><code>head</code>指针包含该范围的起始地址；我们假设它是 16KB（尽管任何虚拟地址都可以）。从视觉上看，堆看起来就像下面这样。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-With-One-Free-Chunk.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-With-One-Free-Chunk.png?size=small" data-sub-html="<h2>image-20240401100756548</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-With-One-Free-Chunk.png alt=image-20240401100756548 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-With-One-Free-Chunk.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-With-One-Free-Chunk.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-With-One-Free-Chunk.png?size=large 2x" data-title=image-20240401100756548 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>现在，我们假设请求一块内存，大小为 100 字节。为了服务这个请求，库将首先找到一个足够大的块来容纳该请求；因为只有一个空闲块（大小：4088），所以将选择该块。然后，该块将被分割成两部分：一个足够大以服务请求（和<code>header</code>，如上所述），以及剩余的空闲块。假设有一个 8 字节的<code>header</code>（整数大小和整数幻数），堆中的空间现在看起来如下图所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-After-One-Allocation.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-After-One-Allocation.png?size=small" data-sub-html="<h2>image-20240401101321526</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-After-One-Allocation.png alt=image-20240401101321526 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-After-One-Allocation.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-After-One-Allocation.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Heap-After-One-Allocation.png?size=large 2x" data-title=image-20240401101321526 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>因此，在请求 100 字节时，库从现有的一个空闲块中分配了 108 字节，返回一个指向它的指针（上图中标记为 ptr），将<code>header</code>信息存储在分配的空间之前，以便之后供<code>free()</code>使用，并将链表中的一个空闲节点缩小到 3980 字节（4088 减 108）。</p><p>现在让我们看看有 3 个分配区域的堆，每个区域 100 个字节（或 108 个字节，包括<code>header</code>）。该堆的可视化如下图所示。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Three-Chunks-Allocated.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Three-Chunks-Allocated.png?size=small" data-sub-html="<h2>image-20240401101639936</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Three-Chunks-Allocated.png alt=image-20240401101639936 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Three-Chunks-Allocated.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Three-Chunks-Allocated.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Three-Chunks-Allocated.png?size=large 2x" data-title=image-20240401101639936 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>正如您在其中看到的，堆的前 324 字节现已分配，因此我们在该空间中看到三个<code>header</code>以及调用程序正在使用的三个 100 字节区域。空闲列表仍然无趣：只是一个节点（由<code>head</code>指向），但在三个分割之后现在大小只有 3764 字节。但是当调用程序通过 free() 返回一些内存时会发生什么？</p><p>在此示例中，应用程序通过调用 free(16500)（值16500是通过将内存区域的起始地址16384与前一个块的108相加以及此块头部的8字节来得到的。） 返回已分配内存的中间块。该值在上图中由指针 sptr 显示。</p><p>库立即计算出空闲区域的大小，然后将空闲块添加回空闲列表。假设我们在空闲列表的头部插入，空间现在看起来如下图所示。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Two-Chunks-Allocated.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Two-Chunks-Allocated.png?size=small" data-sub-html="<h2>image-20240401102604114</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Two-Chunks-Allocated.png alt=image-20240401102604114 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Two-Chunks-Allocated.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Two-Chunks-Allocated.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Free-Space-With-Two-Chunks-Allocated.png?size=large 2x" data-title=image-20240401102604114 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>现在，我们有了一个以小空闲块（100 字节，由列表首部指向）和大空闲块（3764 字节）开始的列表。我们的列表终于多了一个元素！是的，空闲空间是支离破碎的，这是一种不幸但常见的现象。</p><p>最后一个例子：现在让我们假设最后两个正在使用的块已被释放。如果不进行合并，您最终可能会得到一个高度碎片化的空闲列表，如下图所示。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Non-Coalesced-Free-List.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Non-Coalesced-Free-List.png?size=small" data-sub-html="<h2>image-20240401103155029</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Non-Coalesced-Free-List.png alt=image-20240401103155029 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Non-Coalesced-Free-List.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Non-Coalesced-Free-List.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Non-Coalesced-Free-List.png?size=large 2x" data-title=image-20240401103155029 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>从图中可以看出，我们现在一团糟！为什么？很简单，我们忘记<strong>合并</strong>列表。虽然所有的内存都是空闲的，但它却被分割成碎片，因此不是完整的内存，而是呈现出碎片化的内存。解决方案很简单：遍历列表并<strong>合并</strong>相邻块；完成后，堆将再次完整。</p><h3 id=增加堆 class=heading-element><span>2.4 增加堆</span>
<a href=#%e5%a2%9e%e5%8a%a0%e5%a0%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>我们应该讨论许多分配库中的最后一种机制。具体来说，如果堆空间不足该怎么办？最简单的方法就是失败。在某些情况下，这是唯一的选择，因此返回 NULL 是一种值得尊敬的方法。</p><p>大多数传统分配器都从一个小堆开始，然后在内存耗尽时向操作系统请求更多内存。通常，这意味着它们进行某种系统调用（例如，大多数 UNIX 系统中的 sbrk）来增加堆，然后从那里分配新的块。为了服务 sbrk 请求，操作系统查找空闲物理页，将它们映射到请求进程的地址空间，然后返回新堆末尾的值；此时，可以使用更大的堆，并且可以成功地处理请求，如下图所示。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/growing-the-heap-example-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/growing-the-heap-example-1.png?size=small" data-sub-html="<h2>image-20240401103722105</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/growing-the-heap-example-1.png alt=image-20240401103722105 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/growing-the-heap-example-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/growing-the-heap-example-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/growing-the-heap-example-1.png?size=large 2x" data-title=image-20240401103722105 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=管理空闲空间基本策略 class=heading-element><span>3 管理空闲空间：基本策略</span>
<a href=#%e7%ae%a1%e7%90%86%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e5%9f%ba%e6%9c%ac%e7%ad%96%e7%95%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=最佳适应算法 class=heading-element><span>3.1 最佳适应算法</span>
<a href=#%e6%9c%80%e4%bd%b3%e9%80%82%e5%ba%94%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>最佳适应算法</strong>的策略非常简单：首先，搜索空闲列表并找到与请求大小一样大或更大的空闲内存块。然后，返回该组候选者中最小的那个；这就是所谓的最佳适应块（也可以称为最小适应）。遍历一次空闲列表就足以找到要返回的正确块。</p><p>最佳适应背后的直觉很简单：通过返回接近用户要求的块，最佳适应尝试减少浪费的空间。然而，这是有代价的；当对正确的空闲块执行详尽的搜索时，幼稚的实现会带来严重的性能损失。</p><h3 id=最差适应算法 class=heading-element><span>3.2 最差适应算法</span>
<a href=#%e6%9c%80%e5%b7%ae%e9%80%82%e5%ba%94%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>最差适应算法</strong>与最佳适应算法相反；找到最大的块并返回请求的数量；将剩余的（大）块保留在空闲列表中。因此，最差适应尝试留下大块，而不是最佳适应方法可能产生的大量小块。然而，再次需要对可用空间进行全面搜索，因此这种方法的成本可能很高。更糟糕的是，大多数研究表明它的性能很差，导致过多的碎片，同时仍然具有很高的开销。</p><h3 id=首次适应算法 class=heading-element><span>3.3 首次适应算法</span>
<a href=#%e9%a6%96%e6%ac%a1%e9%80%82%e5%ba%94%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><strong>首次适应算法</strong>只需找到第一个足够大的区块，并将请求的大小返回给用户。与之前一样，剩余的空闲空间将保留给后续请求。</p><p>首次适应算法的优点是速度快，无需穷举搜索所有空闲空间，但有时会用小对象污染空闲列表的开头部分。因此，分配器如何管理空闲列表的顺序就成了一个问题。一种方法是使用基于地址的排序；通过保持列表按空闲空间的地址排序，凝聚变得更容易，碎片也会减少。</p><h3 id=循环首次适应算法 class=heading-element><span>3.4 循环首次适应算法</span>
<a href=#%e5%be%aa%e7%8e%af%e9%a6%96%e6%ac%a1%e9%80%82%e5%ba%94%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>循环首次适应算法并不总是在列表的开头开始首次适应搜索，而是保留一个额外的指针，指向列表中最后一次查找的位置。这个想法是在整个列表中更均匀地分布对可用空间的搜索，从而避免列表开头的分割。这种方法的性能与首次适应算法非常相似，因为再次避免了穷举搜索。</p><h3 id=四种算法实例对比 class=heading-element><span>3.5 四种算法实例对比</span>
<a href=#%e5%9b%9b%e7%a7%8d%e7%ae%97%e6%b3%95%e5%ae%9e%e4%be%8b%e5%af%b9%e6%af%94 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>以下是上述策略的一些示例。设想一个空闲列表，其中包含三个元素，大小分别为 10、30 和 20（这里我们将忽略<code>headers</code>和其他细节，而只关注策略的运作方式）：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-of-three-element.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-of-three-element.png?size=small" data-sub-html="<h2>image-20240401105255868</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-of-three-element.png alt=image-20240401105255868 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-of-three-element.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-of-three-element.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-of-three-element.png?size=large 2x" data-title=image-20240401105255868 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>假设分配请求大小为 15。最佳适应算法会搜索整个列表并发现 20 是最适合的，因为它是可以容纳请求的最小可用空间。生成的空闲列表：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/best-fit-example-1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/best-fit-example-1.png?size=small" data-sub-html="<h2>image-20240401105402994</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/best-fit-example-1.png alt=image-20240401105402994 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/best-fit-example-1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/best-fit-example-1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/best-fit-example-1.png?size=large 2x" data-title=image-20240401105402994 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>正如本例中发生的情况，也是最佳适应方法经常发生的情况，现在剩下了一个小的空闲块。最差拟合方法与此类似，但它找到的是最大的块，在本例中为 30。结果列表如下：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Result-of-Worst-fit.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Result-of-Worst-fit.png?size=small" data-sub-html="<h2>image-20240401105610470</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Result-of-Worst-fit.png alt=image-20240401105610470 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Result-of-Worst-fit.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Result-of-Worst-fit.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Result-of-Worst-fit.png?size=large 2x" data-title=image-20240401105610470 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>在本例中，首次适应算法与最差适应算法执行相同的操作，也是查找可以满足请求的第一个空闲块。区别在于搜索成本；最佳算法和最差算法都会浏览整个列表； 首次适应算法 仅检查空闲块，直到找到适合的块，从而降低搜索成本。</p><h2 id=其他方法 class=heading-element><span>4 其他方法</span>
<a href=#%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=隔离列表slab分配器 class=heading-element><span>4.1 隔离列表：slab分配器</span>
<a href=#%e9%9a%94%e7%a6%bb%e5%88%97%e8%a1%a8slab%e5%88%86%e9%85%8d%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>一种已经存在一段时间的有趣方法是使用<strong>隔离列表</strong>。基本思想很简单：如果特定应用程序发出一个（或几个）常见大小的请求，则保留一个单独的列表来管理该大小的对象；所有其他请求都转发到更通用的内存分配器。</p><p>这种方法的好处是显而易见的。通过将一块内存专用于特定大小的请求，碎片就不再是一个问题。此外，当分配和释放请求的大小合适时，可以非常快速地处理它们，因为不需要复杂的列表搜索。</p><p>但这种方法也会给系统带来新的复杂性。例如，与通用内存池相比，应该将多少内存专门用于服务给定大小的特殊请求的内存池？一个特殊的分配器，由超级工程师 Jeff Bonwick 设计的<strong>slab 分配器</strong>（设计用于 Solaris 内核），以一种相当好的方式处理这个问题。</p><p>具体来说，当内核启动时，它会为可能被频繁请求的内核对象（例如锁、文件系统 inode 等）分配一些对<strong>象缓存</strong>。因此，对象缓存都是给定大小的隔离空闲列表，并快速服务内存分配和空闲请求。当给定的缓存可用空间不足时，它会从更通用的内存分配器请求一些内存块（slab）（请求的总量是页面大小和相关对象的倍数）。相反，当给定slab内的对象的引用计数全部变为零时，通用分配器可以从专用分配器中回收它们，这通常在VM系统需要更多内存时执行。</p><p>通过将列表上的空闲对象保持在预初始化状态，slab 分配器还超越了大多数隔离列表方法。 Bonwick 表明数据结构的初始化和销毁代价高昂 ，通过将特定列表中的已释放对象保持在其初始化状态，slab 分配器因此避免了每个对象的频繁初始化和销毁周期，从而显着降低了开销。</p><h3 id=伙伴分配器 class=heading-element><span>4.2 伙伴分配器</span>
<a href=#%e4%bc%99%e4%bc%b4%e5%88%86%e9%85%8d%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>由于合并对于分配器至关重要，因此设计了一些方法来简化合并。<strong>二进制伙伴分配器</strong>就是一个很好的例子。</p><p>在这样的系统中，空闲内存首先在概念上被认为是大小为 $2^N$ 的大空间。当发出内存请求时，对可用空间的搜索会递归地将可用空间一分为二，直到找到足够大以容纳请求的块（进一步分成两部分将导致空间太小）。此时，所请求的块就返回给用户了。以下是在搜索 7KB 块时划分 64KB 可用空间的示例：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/64KB-free-space-for-7KB-request.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/64KB-free-space-for-7KB-request.png?size=small" data-sub-html="<h2>image-20240401111614025</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/64KB-free-space-for-7KB-request.png alt=image-20240401111614025 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/64KB-free-space-for-7KB-request.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/64KB-free-space-for-7KB-request.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/64KB-free-space-for-7KB-request.png?size=large 2x" data-title=image-20240401111614025 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>在示例中，最左边的 8KB 块被分配（如较深的蓝色阴影所示）并返回给用户；请注意，该方案可能会受到<strong>内部碎片</strong>的影响，因为您只能给出两倍大小的块。</p><p>伙伴分配的美妙之处在于释放该块时发生的情况。当将8KB块返回到空闲列表时，分配器检查“伙伴”8KB是否空闲；如果是，它将把两个块合并成一个 16KB 的块。然后分配器检查 16KB 块的伙伴是否仍然空闲；如果是这样，它将合并这两个块。这种递归合并过程沿着树继续进行，要么恢复整个可用空间，要么在发现伙伴正在使用时停止。</p><p>伙伴分配工作如此顺利的原因是确定特定块的伙伴很简单。想想上面空闲空间中块的地址。如果您仔细思考，您会发现每个好友对的地址仅相差一位；哪一位由好友树中的级别决定。这样您就对二进制好友分配方案的工作原理有了基本的了解。</p><h3 id=其他方法-1 class=heading-element><span>4.3 其他方法</span>
<a href=#%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>上述许多方法的一个主要问题是它们缺乏<strong>扩展性</strong>。具体来说，搜索列表可能会非常慢。因此，高级分配器使用更复杂的数据结构来解决这些成本，以简单性换取性能。例如平衡二叉树、展开树或部分排序树等。</p><p>鉴于现代系统通常具有多个处理器并运行多线程工作负载，因此在基于多处理器的系统上花费大量精力使分配器正常工作也就不足为奇了。</p><p><a href=https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/ target=_blank rel="external nofollow noopener noreferrer">Understanding glibc malloc<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/11.%E6%AE%B5/ class=collection-nav-item rel=prev title=段><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>段</span>
</a><a href=/posts/13.%E9%A1%B5/ class=collection-nav-item rel=next title=页><span>页</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-10-15 13:58:47">更新于 2024-10-15&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/12.%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_develop/_system/ostep/12.%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/12.%e7%a9%ba%e9%97%b2%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ data-title=空闲空间管理 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ data-title=空闲空间管理><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ data-title=空闲空间管理><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/13.%E9%A1%B5/ class=post-nav-item rel=prev title=页><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>页</a>
<a href=/posts/11.%E6%AE%B5/ class=post-nav-item rel=next title=段>段<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.135.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>