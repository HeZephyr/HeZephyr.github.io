<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>信号量 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="1 信号量：定义 信号量是一个具有整数值的对象，我们可以使用两个例程对其进行操作；在 POSIX 标准中，这些例程是 sem_wait() 和 sem_post()。因为信号量的初始值决定了它的行为，所以在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，代码所下示。 1 2 3 #include <semaphore.h> sem_t s; sem_init(&amp;s, 0, 1); 在代码，我们声明了一个信号量 s 并通过"><meta name=keywords content='OS'><meta itemprop=name content="信号量"><meta itemprop=description content="1 信号量：定义 信号量是一个具有整数值的对象，我们可以使用两个例程对其进行操作；在 POSIX 标准中，这些例程是 sem_wait() 和 sem_post()。因为信号量的初始值决定了它的行为，所以在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，代码所下示。 1 2 3 #include <semaphore.h> sem_t s; sem_init(&amp;s, 0, 1); 在代码，我们声明了一个信号量 s 并通过"><meta itemprop=datePublished content="2024-05-11T20:53:31+00:00"><meta itemprop=dateModified content="2024-07-28T11:19:19+00:00"><meta itemprop=wordCount content="8152"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="信号量"><meta property="og:description" content="1 信号量：定义 信号量是一个具有整数值的对象，我们可以使用两个例程对其进行操作；在 POSIX 标准中，这些例程是 sem_wait() 和 sem_post()。因为信号量的初始值决定了它的行为，所以在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，代码所下示。 1 2 3 #include <semaphore.h> sem_t s; sem_init(&amp;s, 0, 1); 在代码，我们声明了一个信号量 s 并通过"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-11T20:53:31+00:00"><meta property="article:modified_time" content="2024-07-28T11:19:19+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="信号量"><meta name=twitter:description content="1 信号量：定义 信号量是一个具有整数值的对象，我们可以使用两个例程对其进行操作；在 POSIX 标准中，这些例程是 sem_wait() 和 sem_post()。因为信号量的初始值决定了它的行为，所以在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，代码所下示。 1 2 3 #include <semaphore.h> sem_t s; sem_init(&amp;s, 0, 1); 在代码，我们声明了一个信号量 s 并通过"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/><link rel=prev href=https://hezephyr.github.io/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/><link rel=next href=https://hezephyr.github.io/posts/25.%E5%B9%B6%E5%8F%91bug/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"信号量","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/24.%E4%BF%A1%E5%8F%B7%E9%87%8F\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":8152,"url":"https:\/\/hezephyr.github.io\/posts\/24.%E4%BF%A1%E5%8F%B7%E9%87%8F\/","datePublished":"2024-05-11T20:53:31+00:00","dateModified":"2024-07-28T11:19:19+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/Lruihao/hugo-blog title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>信号量</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><span class=active title=信号量>信号量</span></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ class=collection-nav-item rel=prev title=条件变量><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>24/39</span><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ class=collection-nav-item rel=next title=并发bug><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>信号量</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-05-11 20:53:31"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-11>2024-05-11</time></span>&nbsp;<span title="更新于 2024-07-28 11:19:19"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-07-28>2024-07-28</time></span>&nbsp;<span title="8152 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 8200 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 17 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=信号量>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#信号量定义>信号量：定义</a></li><li><a href=#二进制信号量锁>二进制信号量（锁）</a></li><li><a href=#用于排序的信号量>用于排序的信号量</a></li><li><a href=#生产者消费者有界缓冲区问题>生产者/消费者（有界缓冲区）问题</a><ol><li><a href=#首次尝试>首次尝试</a></li><li><a href=#一个解决方案添加互斥>一个解决方案：添加互斥</a></li><li><a href=#避免死锁>避免死锁</a></li><li><a href=#可行的解决方案>可行的解决方案</a></li></ol></li><li><a href=#读者写者锁>读者—写者锁</a></li><li><a href=#哲学家就餐问题>哲学家就餐问题</a><ol><li><a href=#基本介绍>基本介绍</a></li><li><a href=#残缺的解决方案>残缺的解决方案</a></li><li><a href=#解决方案打破依赖>解决方案：打破依赖</a></li></ol></li><li><a href=#如何实现信号量>如何实现信号量</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><h2 id=信号量定义 class=heading-element><span>1 信号量：定义</span>
<a href=#%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%ae%9a%e4%b9%89 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>信号量是一个具有整数值的对象，我们可以使用两个例程对其进行操作；在 POSIX 标准中，这些例程是 <code>sem_wait()</code> 和 <code>sem_post()</code>。因为信号量的初始值决定了它的行为，所以在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，代码所下示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>sem_t</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>在代码，我们声明了一个信号量 <code>s</code> 并通过将 1 作为第三个参数传递来将其初始化值为 1。在我们将看到的所有示例中，<code>sem_init()</code> 的第二个参数都将设置为 0；**这表明信号量在同一进程中的线程之间共享。**有关信号量其他用法的详细信息（即如何使用它们来同步不同进程之间的访问），请参阅手册页：<code>man sem_init</code>，这需要第二个参数的不同值。</p><p>信号量初始化后，我们可以调用两个函数之一与之交互：<code>sem_wait()</code> 或 <code>sem_post()</code>。这两个函数的行为如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sem_wait</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Decrement the value of semaphore s by one
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If the value becomes negative, the calling thread will block until it becomes positive
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Once the value becomes positive, the thread will continue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sem_post</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Increment the value of semaphore s by one
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If there are one or more threads waiting (i.e., the semaphore was previously negative),
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// wake one of the waiting threads
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>目前，我们不关心这些例程的实施，这显然需要一些小心；当多个线程调用 <code>sem_wait()</code> 和 <code>sem_post()</code> 时，显然需要管理这些临界区。我们现在将重点讨论如何使用这些原语；稍后我们可能会讨论它们是如何构建的。</p><p>我们应该在这里讨论接口的几个重要方面。</p><ul><li>首先，我们可以看到 <code>sem_wait()</code> 要么立即返回（因为当我们调用 <code>sem_wait()</code> 时信号量的值为 1 或更高），要么导致调用者暂停执行以等待后续的操作。当然，多个调用线程可能会调用 <code>sem_wait()</code>，因此所有线程都会排队等待被唤醒。</li><li>其次，我们可以看到 <code>sem_post()</code> 不会像 <code>sem_wait()</code> 那样等待某些特定条件成立。相反，它只是增加信号量的值，然后，如果有一个线程等待被唤醒，则唤醒其中一个线程。</li><li>第三，信号量的值，当为负时，等于等待线程的数量。虽然信号量的用户一般看不到这个值，但这个不变量还是值得了解的，也许它能帮助你记住信号量的功能。</li></ul><p>（暂时）不用担心信号量内可能出现的竞争条件；假设它们所做的操作是原子执行的。我们很快就会使用锁和条件变量来做到这一点。</p><h2 id=二进制信号量锁 class=heading-element><span>2 二进制信号量（锁）</span>
<a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%bf%a1%e5%8f%b7%e9%87%8f%e9%94%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>我们现在准备使用信号量。我们的第一个用途将是我们已经熟悉的：使用信号量作为锁。代码片段如下；其中，您会看到我们只是用 <code>sem_wait()/sem post()</code> 包围感兴趣的临界区。然而，使这项工作成功的关键是信号量 <code>m</code> 的初始值（代码中初始化为 X）。 X 应该是什么？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span> <span class=c1>// Initialize semaphore to X; what should X be?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Critical section here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>回顾上面 <code>sem_wait()</code> 和 <code>sem_post()</code> 例程的定义，我们可以看到初始值应该是 1。</p><p>为了清楚起见，让我们想象有两个线程的场景。第一个线程（线程0）调用<code>sem_wait()</code>；它首先会递减信号量的值，将其更改为 0。然后，仅当该值不大于或等于 0 时才会等待。因为该值为 0，所以 <code>sem_wait()</code> 将简单地返回，并且调用线程将继续，线程 0 现在可以自由进入临界区。如果当线程 0 在临界区内时没有其他线程尝试获取锁，则当它调用 <code>sem_post()</code> 时，它只会将信号量的值恢复为 1（并且不会唤醒正在等待的线程，因为没有） 。下图显示了该场景的踪迹。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=small" data-sub-html="<h2>image-20240410161246190</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png alt=image-20240410161246190 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Single_Thread_Using_A_Semaphore.png?size=large 2x" data-title=image-20240410161246190 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>当线程 0 “持有锁”（即，它已调用 <code>sem_wait()</code> 但尚未调用 <code>sem_post()</code>），并且另一个线程（线程 1）尝试通过调用 <code>sem_wait</code> 进入临界区时，会出现更有趣的情况。在这种情况下，线程 1 会将信号量的值递减至 $-1$，从而等待（使其自身进入睡眠状态并放弃处理器）。当线程 0 再次运行时，它最终会调用 <code>sem_post()</code>，将信号量的值递增回零，然后唤醒等待线程（线程 1），线程 1 就能够为自己获取锁。当线程 1 完成时，它将再次增加信号量的值，再次将其恢复为 1。</p><p>下图显示了此示例的踪迹。除了线程操作外，图中还显示了每个线程的<strong>调度器状态</strong>：运行、就绪（即可运行但未运行）和休眠。请特别注意，线程 1 在试图获取已持有的锁时进入了睡眠状态；只有当线程 0 再次运行时，线程 1 才能被唤醒并再次运行。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=small" data-sub-html="<h2>image-20240410161839026</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png alt=image-20240410161839026 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread_Trace_Two_Threads_Using_A_Semaphore.png?size=large 2x" data-title=image-20240410161839026 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>如果你想通过自己的示例来解决这个问题，可以尝试多个线程排队等待锁的场景。在这种跟踪过程中，semaphore 的值会是多少？</p><p>因此，我们可以将 semaphores 用作锁。由于锁只有两种状态（持有和未持有），因此我们有时将用作锁的信号量称为二进制信号量。需要注意的是，如果你只是以这种二进制方式使用一个信号量，那么它的实现方式可能比我们在这里介绍的通用信号量更简单。</p><h2 id=用于排序的信号量 class=heading-element><span>3 用于排序的信号量</span>
<a href=#%e7%94%a8%e4%ba%8e%e6%8e%92%e5%ba%8f%e7%9a%84%e4%bf%a1%e5%8f%b7%e9%87%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>信号量对于对并发程序中的事件进行排序也很有用。例如，线程可能希望等待列表变为非空，以便可以从中删除元素。在这种使用模式中，我们经常发现一个线程等待某件事发生，而另一个线程使某件事发生，然后发出信号表明它已经发生，从而唤醒等待的线程。因此，我们使用信号量作为<strong>排序</strong>原语（类似于我们之前使用<strong>条件变量</strong>）。</p><p>下面是一个简单的例子。设想一个线程创建了另一个线程，然后想等待它完成执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>child</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span> <span class=c1>// Signal here: child is done
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span> <span class=c1>// What should X be?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent: begin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>child</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span> <span class=c1>// Wait here for child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent: end</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>当这个程序运行时，我们希望看到以下内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nl>parent</span><span class=p>:</span> <span class=n>begin</span>
</span></span><span class=line><span class=cl><span class=n>child</span>
</span></span><span class=line><span class=cl><span class=nl>parent</span><span class=p>:</span> <span class=n>end</span></span></span></code></pre></td></tr></table></div></div><p>那么问题来了，如何使用信号量来达到这样的效果？事实证明，答案相对容易理解。正如您在代码中看到的，父线程只需调用 <code>sem_wait()</code> ，则子线程 调用<code>sem_post()</code> ，等待子线程完成执行的条件变为 true。然而，这就提出了一个问题：这个信号量的初始值应该是多少？</p><p>答案当然是信号量的值应该设置为0。有两种情况需要考虑。首先，我们假设父线程创建了子线程，但子线程尚未运行（即，它位于就绪队列中但未运行）。在这种情况下，如下图所示，父线程将子线程调用 <code>sem_post()</code> 之前调用 <code>sem_wait()</code>；我们希望父线程等待子线程运行起来。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20(Case%201).png?size=small" data-sub-html="<h2>image-20240410163051099</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png alt=image-20240410163051099 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%201%29.png?size=large 2x" data-title=image-20240410163051099 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>发生这种情况的唯一方法是信号量的值不大于 0；因此，0 是初始值。父进程运行，将信号量递减（至 -1），然后等待（睡眠）。当子进程最终运行时，它将调用 <code>sem_post()</code>，将信号量的值增加到 0，并唤醒父进程，然后父进程将从 <code>sem_wait()</code> 返回并完成程序。</p><p>第二种情况发生在子线程在父线程有机会调用<code>sem_wait()</code> 之前运行完成时，运行跟踪如下图所示。在这种情况下，子线程将首先调用 <code>sem_post()</code>，从而将信号量的值从 0 增加到 1。当父线程有机会运行时，它将调用 <code>sem_wait()</code> 并发现信号量的值为 1；因此，父线程将递减该值（到 0）并从 <code>sem_wait()</code> 返回，无需等待，也达到了预期的效果。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20(Case%202).png?size=small" data-sub-html="<h2>image-20240410163202016</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png alt=image-20240410163202016 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Thread%20Trace%3A%20Parent%20Waiting%20For%20Child%20%28Case%202%29.png?size=large 2x" data-title=image-20240410163202016 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=生产者消费者有界缓冲区问题 class=heading-element><span>4 生产者/消费者（有界缓冲区）问题</span>
<a href=#%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%9c%89%e7%95%8c%e7%bc%93%e5%86%b2%e5%8c%ba%e9%97%ae%e9%a2%98 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=首次尝试 class=heading-element><span>4.1 首次尝试</span>
<a href=#%e9%a6%96%e6%ac%a1%e5%b0%9d%e8%af%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>我们解决这个问题的首次尝试引入了两个信号量：<code>empty</code> 和 <code>full</code>，线程将分别使用它们来指示缓冲区条目何时被清空或填满。下面是解决生产者和消费者问题的首次尝试代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>MAX</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>fill</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>use</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>put</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=p>[</span><span class=n>fill</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>        <span class=c1>// Line F1: Place value in the buffer at the current fill index
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fill</span> <span class=o>=</span> <span class=p>(</span><span class=n>fill</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>MAX</span><span class=p>;</span>     <span class=c1>// Line F2: Move the fill index to the next position in a circular buffer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=n>use</span><span class=p>];</span>       <span class=c1>// Line G1: Retrieve the value from the buffer at the current use index
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>use</span> <span class=o>=</span> <span class=p>(</span><span class=n>use</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>MAX</span><span class=p>;</span>       <span class=c1>// Line G2: Move the use index to the next position in a circular buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>                  <span class=c1>// Return the retrieved value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>empty</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>full</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>producer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span>        <span class=c1>// Line P1: Wait for at least one empty buffer slot
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>put</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>                  <span class=c1>// Line P2: Produce an item and place it in the buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span>         <span class=c1>// Line P3: Signal that a buffer slot has been filled
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>tmp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>tmp</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span>         <span class=c1>// Line C1: Wait for at least one filled buffer slot
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>tmp</span> <span class=o>=</span> <span class=nf>get</span><span class=p>();</span>             <span class=c1>// Line C2: Consume an item from the buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span>        <span class=c1>// Line C3: Signal that a buffer slot has been emptied
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MAX</span><span class=p>);</span>    <span class=c1>// MAX buffers are empty to begin with...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>       <span class=c1>// ... and 0 are full
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在这个示例中，生产者首先等待缓冲区变空，然后将数据放入缓冲区，而消费者同样等待缓冲区被填满，然后才使用缓冲区。让我们先假设 <code>MAX=1</code>（数组中只有一个缓冲区），看看这样是否可行。</p><p>再假设有两个线程，一个生产者，一个消费者。让我们看看在单 CPU 上的具体情况。假设消费者先运行。因此，消费者将运行代码中的 C1 行，调用 <code>sem_wait(&amp;full)</code>。由于 <code>full</code> 的初始化值为 0，因此调用将递减 <code>full</code>（至 -1），阻塞消费者，并等待另一个线程按预期在 <code>full</code> 上调用 <code>sem_post()</code>。</p><p>假设生产者随后运行。它将运行到 P1 行，从而调用 <code>sem_wait(&amp;empty)</code> 例程。与消费者不同，生产者将继续运行这一行，因为 empty 已被初始化为 MAX 值（在本例中为 1）。因此，empty 将被递减为 0，生产者将把一个数据值放入缓冲区的第一个入口（P2 行）。然后，生产者将继续运行到 P3 行，并调用 <code>sem_post(&amp;full)</code>，将 <code>full</code> 信号量的值从 -1 改为 0，并唤醒消费者（例如，将其从阻塞状态转为就绪状态）。</p><p>在这种情况下，可能会发生两种情况。如果生产者继续运行，它将循环并再次运行 P1 行。如果生产者被中断，消费者开始运行，它将调用 <code>sem_wait(&amp;full)</code>（C1 行），发现缓冲区确实已满，从而消耗掉缓冲区。无论哪种情况，我们都实现了所需的行为。</p><p>你可以用更多线程（例如多个生产者和多个消费者）来尝试这个例子。它应该仍然有效。</p><p>现在让我们假设 MAX 大于 1（比如 <code>MAX = 10</code>）。在这个例子中，我们假设有多个生产者和多个消费者。现在我们遇到了一个问题：竞争条件。仔细看看<code> put()</code> 和<code>get()</code> 代码。想象一下，两个生产者（$P_a$ 和 $P_b$）同时调用 <code>put()</code>。假设生产者 $P_a$ 首先运行，并开始填充第一个缓冲区条目（F1 行的 <code>fill = 0</code>）。$P_a$ 还没来得及将<code>fill</code>计数器递增到 1，就被中断了。生产者 $P_b$ 开始运行，并在第 F1 行将其数据放入缓冲区的第 0 个元素，这意味着那里的旧数据被覆盖！这是不允许的；我们不希望生产者的任何数据丢失。</p><h3 id=一个解决方案添加互斥 class=heading-element><span>4.2 一个解决方案：添加互斥</span>
<a href=#%e4%b8%80%e4%b8%aa%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%b7%bb%e5%8a%a0%e4%ba%92%e6%96%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>正如你所看到的，我们在这里忘记了互斥。缓冲区的填充和缓冲区索引的递增是一个临界区，因此必须小心保护。因此，让我们使用我们的二进制信号量并添加一些锁，代码如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>empty</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>full</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>producer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line P0 (NEW LINE)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span> <span class=c1>// Line P1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>put</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// Line P2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span> <span class=c1>// Line P3
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line P4 (NEW LINE)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line C0 (NEW LINE)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span> <span class=c1>// Line C1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=nf>get</span><span class=p>();</span> <span class=c1>// Line C2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span> <span class=c1>// Line C3
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line C4 (NEW LINE)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MAX</span><span class=p>);</span> <span class=c1>// MAX buffers are empty to begin with...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// ... and 0 are full
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// mutex=1 because it is a lock (NEW LINE)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=避免死锁 class=heading-element><span>4.3 避免死锁</span>
<a href=#%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>现在，我们在代码的整个 <code>put()/get()</code> 部分添加了一些锁，如 NEW LINE 注释所示。这似乎是个正确的想法，但却行不通。为什么？死锁。为什么会出现死锁？想象一下两个线程，一个生产者，一个消费者。消费者先运行。它获取了<code>mutex</code>（C0 行），然后在<code>full</code>信号量上调用 <code>sem_wait()</code>（C1 行）；由于还没有数据，这个调用会导致消费者阻塞，从而占用 CPU；但重要的是，消费者仍然持有锁。</p><p>然后生产者运行。如果它能运行，就能唤醒消费者线程，一切都会好起来。不幸的是，它做的第一件事就是调用二进制 <code>mutex</code>信号量（P0 行）上的 <code>sem_wait()</code>。该锁已被锁定。因此，生产者现在也只能等待。</p><p>这里有一个简单的循环。消费者持有<code>mutex</code>，正在等待某人发出<code>full</code>的信号。生产者可以发出<code>full</code>的信号，但也在等待<code>mutex</code>。因此，生产者和消费者都在互相等待：这就是典型的死锁。</p><h3 id=可行的解决方案 class=heading-element><span>4.4 可行的解决方案</span>
<a href=#%e5%8f%af%e8%a1%8c%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>要解决这个问题，我们只需缩小锁的范围。下面代码显示了正确的解决方案。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>empty</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>full</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>producer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span> <span class=c1>// Line P1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line P1.5 (MOVED MUTEX HERE...)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>put</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// Line P2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line P2.5 (... AND HERE)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span> <span class=c1>// Line P3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>);</span> <span class=c1>// Line C1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line C1.5 (MOVED MUTEX HERE...)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=nf>get</span><span class=p>();</span> <span class=c1>// Line C2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>// Line C2.5 (... AND HERE)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span> <span class=c1>// Line C3
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MAX</span><span class=p>);</span> <span class=c1>// MAX buffers are empty to begin with...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>full</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// ... and 0 are full
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// mutex=1 because it is a lock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>正如你所看到的，我们只需将<code>mutex</code>获取和释放移到临界区附近；而<code>full</code>等待<code>empty</code>空等待以及信号代码则留在外部。这就是一个简单而有效的有界缓冲区，是多线程程序中常用的模式。</p><h2 id=读者写者锁 class=heading-element><span>5 读者—写者锁</span>
<a href=#%e8%af%bb%e8%80%85%e5%86%99%e8%80%85%e9%94%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>另一个经典问题源于人们对更灵活的锁定原语的渴望，即不同的数据结构访问可能需要不同类型的锁定。举例来说，假设有许多并发的列表操作，包括插入和简单的查找。插入操作会改变 list 的状态（因此传统的临界区是合理的），而查找操作只是读取数据结构；只要我们能保证没有插入操作正在进行，我们就能允许许多查找操作并发进行。我们现在要开发的支持这种操作的特殊类型锁被称为读写锁。这种锁的代码如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_rwlock_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=n>lock</span><span class=p>;</span> <span class=c1>// binary semaphore (basic lock)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>sem_t</span> <span class=n>writelock</span><span class=p>;</span> <span class=c1>// used to allow ONE writer or MANY readers 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>readers</span><span class=p>;</span> <span class=c1>// count of readers reading in critical section
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=kt>rwlock_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rwlock_init</span><span class=p>(</span><span class=kt>rwlock_t</span> <span class=o>*</span><span class=n>rw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rw</span><span class=o>-&gt;</span><span class=n>readers</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// Initialize lock semaphore with value 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>writelock</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// Initialize writelock semaphore with value 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rwlock_acquire_readlock</span><span class=p>(</span><span class=kt>rwlock_t</span> <span class=o>*</span><span class=n>rw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// Lock the critical section
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rw</span><span class=o>-&gt;</span><span class=n>readers</span><span class=o>++</span><span class=p>;</span> <span class=c1>// Increment the number of readers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>readers</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>writelock</span><span class=p>);</span> <span class=c1>// First reader acquires writelock, preventing writers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// Unlock the critical section
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rwlock_release_readlock</span><span class=p>(</span><span class=kt>rwlock_t</span> <span class=o>*</span><span class=n>rw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// Lock the critical section
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rw</span><span class=o>-&gt;</span><span class=n>readers</span><span class=o>--</span><span class=p>;</span> <span class=c1>// Decrement the number of readers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>readers</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>writelock</span><span class=p>);</span> <span class=c1>// Last reader releases writelock, allowing writers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// Unlock the critical section
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rwlock_acquire_writelock</span><span class=p>(</span><span class=kt>rwlock_t</span> <span class=o>*</span><span class=n>rw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>writelock</span><span class=p>);</span> <span class=c1>// Acquire writelock, preventing other readers and writers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>rwlock_release_writelock</span><span class=p>(</span><span class=kt>rwlock_t</span> <span class=o>*</span><span class=n>rw</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rw</span><span class=o>-&gt;</span><span class=n>writelock</span><span class=p>);</span> <span class=c1>// Release writelock, allowing other readers and writers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>代码非常简单。如果某个线程想要更新相关数据结构，它应该调用一对新的同步操作：<code>rwlock_acquire_writelock()</code>（获取写锁）和 <code>rwlock_release_ writelock()</code>（释放写锁）。在内部，这些操作只是使用<code>writelock</code>信号量来确保只有单个写者可以获取锁，从而进入临界区更新相关数据结构。</p><p>更有趣的是一对获取和释放读锁的例程。在获取读取锁时，读者首先获取锁，然后递增 <code>readers</code> 变量，以跟踪当前数据结构中有多少个读者。当第一个读者获得锁时，<code>rwlock_acquire_readlock()</code> 中的重要步骤就开始了；在这种情况下，读者也会通过调用<code>writelock</code>信号量上的 <code>sem_wait()</code> 来获得写锁，然后通过调用 <code>sem_post()</code> 来释放锁。</p><p>因此，一旦一个读者获得了读锁，就会允许更多读者也获得读锁；但是，任何希望获得写锁的线程都必须等到所有读者都读完；最后一个退出临界区的线程会调用 <code>writelock</code> 信号量上的<code>sem_post()</code>，从而让等待的写者获得写锁。</p><p>这种方法有效（如预期），但也有一些负面影响，特别是在公平性方面。特别是，读者饿死写者是相对容易的。对于这个问题存在更复杂的解决方案；也许你能想到更好的实现？提示：考虑一下一旦写者正在等待，您需要做什么来防止更多的读取者进入锁。</p><p>读者饿死写者的问题可以通过修改读者和写者的优先级策略来解决。具体思路如下：</p><ol><li><strong>增加写者优先策略</strong>：让写者优先于读者获取锁，这样当有写者等待时，新到来的读者需要等待写者完成后才能进入临界区。</li><li><strong>写者优先锁设计</strong>：引入一个额外的变量或信号量来表示写者是否在等待，如果有写者等待，读者需要等待写者完成后才能获取锁。</li></ol><p>最后，应该注意的是，应该谨慎使用读写锁。它们通常会增加更多的开销（特别是对于更复杂的实现），因此与仅使用简单且快速的锁定原语相比，最终不会提高性能。不管怎样，它们再次展示了我们如何以有趣且有用的方式使用信号量。</p><blockquote><center>TIP：简单而愚蠢的方法可能更好（希尔定律）</center><p>你永远不应该低估这样一种观念：简单而愚蠢的方法可能是最好的方法。对于锁定，有时简单的自旋锁效果最好，因为它易于实现且速度快。虽然读/写锁之类的东西听起来很酷，但它们很复杂，而复杂可能意味着缓慢。因此，总是先尝试简单而愚蠢的方法。这种追求简单的想法在很多地方都可以找到。早期的一个来源是 Mark Hill 的论文，该论文研究了如何为 CPU 设计缓存。 Hill 发现简单的直接映射缓存比花哨的集合关联设计效果更好（原因之一是在缓存中，更简单的设计可以实现更快的查找）。正如希尔简洁地总结他的工作：“大而笨更好。”因此，我们将类似的建议称为希尔定律。</p></blockquote><h2 id=哲学家就餐问题 class=heading-element><span>6 哲学家就餐问题</span>
<a href=#%e5%93%b2%e5%ad%a6%e5%ae%b6%e5%b0%b1%e9%a4%90%e9%97%ae%e9%a2%98 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=基本介绍 class=heading-element><span>6.1 基本介绍</span>
<a href=#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>Dijkstra 提出并解决的一个最著名的并发问题被称为 &ldquo;哲学家就餐问题&rdquo;。这个问题之所以有名，是因为它很有趣，在智力上也有点意思；然而，它的实际效用却很低。</p><p>问题的基本设置是这样的，如下图所示：假设有五位 &ldquo;哲学家 &ldquo;围坐在一张桌子旁。每对 &ldquo;哲学家 &ldquo;之间有一把叉子（因此一共有五把叉子）。哲学家们有思考的时候，不需要叉子，也有吃饭的时候。为了吃饭，哲学家需要两把叉子，左边的和右边的。对这些叉子的争夺以及随之而来的同步问题，正是我们在并发编程中要研究的问题。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=small" data-sub-html="<h2>image-20240410212019871</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png alt=image-20240410212019871 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/The_Dining_Philosophers.png?size=large 2x" data-title=image-20240410212019871 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>这是每个哲学家的基本循环：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>think</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>getforks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>eat</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>putforks</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>那么，关键的挑战是编写例程 <code>getforks()</code> 和 <code>putforks()</code>，这样就不会出现死锁，不会有哲学家挨饿而永远吃不到东西，并且并发性很高（即，许多哲学家可以同时吃饭）尽可能）。</p><p>我们将使用一些辅助函数来找到解决方案，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>left</span><span class=p>(</span><span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>p</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>right</span><span class=p>(</span><span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>p</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=mi>5</span><span class=p>;</span> <span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>当哲学家 $p$ 希望引用他们左边的叉子时，他们只需调用 <code>left(p)</code>。类似地，通过调用 <code>right(p)</code> 来引用哲学家 $p$ 右边的叉子；其中的模运算符处理最后一个哲学家 ($p=4$) 试图抓住他们右边的叉子（叉子 0）的情况。</p><p>我们还需要一些信号量来解决这个问题。假设我们有五个，每个叉子一个：<code>sem_t forks[5]</code>。</p><h3 id=残缺的解决方案 class=heading-element><span>6.2 残缺的解决方案</span>
<a href=#%e6%ae%8b%e7%bc%ba%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>我们尝试第一个解决方案。假设我们将每个信号量（在 <code>forks</code> 数组中）初始化为值 1。还假设每个哲学家都知道自己的数字 (<code>p</code>)。因此，我们可以编写 <code>getforks()</code> 和 <code>putforks()</code> 例程，代码如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getforks</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>left</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_wait</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>right</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>putforks</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_post</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>left</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sem_post</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>right</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这个（残缺的）解决方案背后的直觉如下。为了获得叉子，我们只需抓住每个叉子上的“锁”：首先是左边的，然后是右边的。当我们吃完后，我们就释放它们。很简单，不是吗？不幸的是，在这种情况下，简单就意味着破碎。</p><p>如果每个哲学家碰巧在任何哲学家抓住右边的叉子之前抓住了他们左边的叉子，那么每个哲学家都会永远拿着一把叉子并等待另一把叉子。具体来说，哲学家0抓叉子0，哲学家1抓叉子1，哲学家2抓叉子2，哲学家3抓叉子3，哲学家4抓叉子4；所有的叉子都已获得，所有的哲学家都在等待另一位哲学家拥有的叉子。我们很快就会更详细地研究死锁；目前，可以肯定地说这不是一个有效的解决方案。</p><h3 id=解决方案打破依赖 class=heading-element><span>6.3 解决方案：打破依赖</span>
<a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%89%93%e7%a0%b4%e4%be%9d%e8%b5%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>要解决这个问题，最简单的方法就是改变至少一位哲学家获取分叉的方式；事实上，Dijkstra 本人就是这样解决这个问题的。具体来说，假设哲学家 4（编号最高者）以不同的顺序获取分叉。代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getforks</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>right</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>left</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>left</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sem_wait</span><span class=p>(</span><span class=n>forks</span><span class=p>[</span><span class=nf>right</span><span class=p>(</span><span class=n>p</span><span class=p>)]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由于最后一位哲学家会先抓右边，然后再抓左边，因此不会出现每位哲学家都抓到一个叉子，却只能等待另一个叉子的情况；等待的循环被打破了。</p><p>像这样的 &ldquo;著名 &ldquo;问题还有很多，比如抽烟者问题或睡觉的理发师问题。它们中的大多数只是思考并发问题的借口；其中有些问题的名字很吸引人。如果你有兴趣了解更多，或者只是想多练习并发思维，可以去查查这些问题。</p><h2 id=如何实现信号量 class=heading-element><span>7 如何实现信号量</span>
<a href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%bf%a1%e5%8f%b7%e9%87%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>最后，让我们使用低级同步原语、锁和条件变量来构建我们自己的信号量版本，称为<code>Zemaphores</code>。这个任务相当简单，代码如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>__Zem_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>               <span class=c1>// Value of the semaphore
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>pthread_cond_t</span> <span class=n>cond</span><span class=p>;</span>    <span class=c1>// Condition variable for signaling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>pthread_mutex_t</span> <span class=n>lock</span><span class=p>;</span>   <span class=c1>// Mutex for protecting shared data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>Zem_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Initializes the semaphore with the specified initial value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Zem_init</span><span class=p>(</span><span class=n>Zem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>        <span class=c1>// Set initial value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Cond_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>cond</span><span class=p>);</span>     <span class=c1>// Initialize condition variable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>    <span class=c1>// Initialize mutex
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Decrements the value of the semaphore (waits if the value is zero)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Zem_wait</span><span class=p>(</span><span class=n>Zem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>          <span class=c1>// Lock the mutex
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>        <span class=c1>// Wait while value is less than or equal to 0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>Cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span> <span class=c1>// Wait on the condition variable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>-&gt;</span><span class=n>value</span><span class=o>--</span><span class=p>;</span>                    <span class=c1>// Decrement the value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>        <span class=c1>// Unlock the mutex
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Increments the value of the semaphore and signals waiting threads
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Zem_post</span><span class=p>(</span><span class=n>Zem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>          <span class=c1>// Lock the mutex
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span><span class=o>-&gt;</span><span class=n>value</span><span class=o>++</span><span class=p>;</span>                    <span class=c1>// Increment the value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>cond</span><span class=p>);</span>         <span class=c1>// Signal waiting threads
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>        <span class=c1>// Unlock the mutex
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>从代码中可以看出，我们只使用了一把锁和一个条件变量，再加上一个状态变量来跟踪信号量的值。</p><ul><li><code>Zem_t</code>结构体定义了一个信号量，其中包含了一个整数值 <code>value</code> 用于表示信号量的状态，一个条件变量 <code>cond</code> 用于线程间的同步通信，以及一个互斥锁 <code>lock</code> 用于保护共享数据。</li><li><code>Zem_init</code> 函数用于初始化信号量，将初始值赋给 <code>value</code>，并分别初始化条件变量和互斥锁。</li><li><code>Zem_wait</code> 函数用于等待信号量，首先获取互斥锁，然后在一个循环中检查 <code>value</code> 是否小于等于 0，如果是则等待条件变量，直到被唤醒后再次检查。一旦 <code>value</code> 大于 0，就将其减一并释放互斥锁。</li><li><code>Zem_post</code> 函数用于释放信号量，首先获取互斥锁，然后将 <code>value</code> 加一，以及唤醒等待在条件变量上的线程，最后释放互斥锁。</li></ul><p>我们的 Zemaphore 和 Dijkstra 定义的纯信号量之间的一个细微差别是，我们不保持信号量的值（当为负时）反映等待线程的数量这一不变式；事实上，该值永远不会低于零。此行为更容易实现并且与当前的 Linux 实现相匹配。</p><blockquote><center>TIP：小心泛化</center><p>因此，泛化的抽象技术在系统设计中非常有用，其中一个好的想法可以变得稍微更广泛，从而解决更大类别的问题。然而，泛化时要小心；正如Lampson警告我们的那样，“不要泛化；泛化通常是错误的”。</p><p>人们可以将信号量视为锁和条件变量的泛化；然而，是否需要这样的泛化？而且，考虑到在信号量之上实现条件变量的困难，也许这种泛化并不像您想象的那么普遍。</p></blockquote></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ class=collection-nav-item rel=prev title=条件变量><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>条件变量</span>
</a><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ class=collection-nav-item rel=next title=并发bug><span>并发bug</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-07-28 11:19:19">更新于 2024-07-28&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_develop/_system/ostep/24.%e4%bf%a1%e5%8f%b7%e9%87%8f.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/Lruihao/hugo-blog/edit/docs/content/posts/_develop/_system/ostep/24.%e4%bf%a1%e5%8f%b7%e9%87%8f.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/Lruihao/hugo-blog/issues/new?title=[BUG]%20%E4%BF%A1%E5%8F%B7%E9%87%8F&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E4%BF%A1%E5%8F%B7%E9%87%8F%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/%7c%0A%7cFilename%7chttps://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_develop/_system/ostep/24.%e4%bf%a1%e5%8f%b7%e9%87%8f.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ data-title=信号量 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ data-title=信号量><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ data-title=信号量><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ class=post-nav-item rel=prev title=并发bug><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>并发bug</a>
<a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ class=post-nav-item rel=next title=条件变量>条件变量<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=Lruihao/hugo-blog data-repo-id="MDEwOlJlcG9zaXRvcnk0MDQzNDY3MDk=" data-category=General data-category-id=DIC_kwDOGBnXVc4CApHL data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.129.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"6BN9L31BND",algoliaIndex:"index",algoliaSearchKey:"03440c0c020a6c0fe73d00bf65b88c2b",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>