<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>数据完整性和保护 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="1 磁盘故障模式 磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。 但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分"><meta name=keywords content='OS'><meta itemprop=name content="数据完整性和保护"><meta itemprop=description content="1 磁盘故障模式 磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。 但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分"><meta itemprop=datePublished content="2024-05-11T21:35:46+00:00"><meta itemprop=dateModified content="2024-07-28T11:19:19+00:00"><meta itemprop=wordCount content="6411"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="数据完整性和保护"><meta property="og:description" content="1 磁盘故障模式 磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。 但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-11T21:35:46+00:00"><meta property="article:modified_time" content="2024-07-28T11:19:19+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="数据完整性和保护"><meta name=twitter:description content="1 磁盘故障模式 磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。 但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/><link rel=prev href=https://hezephyr.github.io/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/><link rel=next href=https://hezephyr.github.io/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据完整性和保护","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":6411,"url":"https:\/\/hezephyr.github.io\/posts\/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4\/","datePublished":"2024-05-11T21:35:46+00:00","dateModified":"2024-07-28T11:19:19+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users-viewfinder fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/Lruihao/hugo-blog title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>数据完整性和保护</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ title=地址转换>地址转换</a></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><span class=active title=数据完整性和保护>数据完整性和保护</span></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ class=collection-nav-item rel=prev title=基于闪存的SSD><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>36/39</span><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ class=collection-nav-item rel=next title=分布式系统><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>数据完整性和保护</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-05-11 21:35:46"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-11>2024-05-11</time></span>&nbsp;<span title="更新于 2024-07-28 11:19:19"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-07-28>2024-07-28</time></span>&nbsp;<span title="6411 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 6500 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 13 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=数据完整性和保护>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#磁盘故障模式>磁盘故障模式</a></li><li><a href=#处理静默扇区错误lse>处理静默扇区错误（LSE）</a></li><li><a href=#检测损坏校验和>检测损坏：校验和</a><ol><li><a href=#基本介绍>基本介绍</a></li><li><a href=#常用校验和函数>常用校验和函数</a></li><li><a href=#校验和布局>校验和布局</a></li><li><a href=#使用校验和>使用校验和</a></li></ol></li><li><a href=#一个新问题错误写入>一个新问题：错误写入</a></li><li><a href=#最后一个问题写入丢失>最后一个问题：写入丢失</a></li><li><a href=#扫描>扫描</a></li><li><a href=#校验和的开销>校验和的开销</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><h2 id=磁盘故障模式 class=heading-element><span>1 磁盘故障模式</span>
<a href=#%e7%a3%81%e7%9b%98%e6%95%85%e9%9a%9c%e6%a8%a1%e5%bc%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>磁盘并不完美，并且可能会出现故障（有时）。在早期的 RAID 系统中，故障模型非常简单：要么整个磁盘正常工作，要么完全故障，并且检测此类故障非常简单。这种磁盘故障的故障停止模型使得构建 RAID 相对简单。</p><p>但现代磁盘所表现出的还有其他类型的故障模式。具体来说，如 Bairavasundaram 等人经过详细研究 ，现代磁盘有时看起来大部分工作正常，但在成功访问一个或多个块时遇到问题。具体来说，有两种类型的单块故障很常见且值得考虑：<font color=red>静默扇区错误 (LSE) 和块损坏</font>。我们现在将更详细地讨论每一个。</p><p>当磁盘扇区（或扇区组）受到某种损坏时，就会出现 LSE。例如，如果磁盘磁头由于某种原因（<strong>磁头撞击</strong>，正常运行中不应该发生的情况）接触到磁盘表面，可能会损坏磁盘表面，导致位无法读取。宇宙射线也会使位翻转，导致内容错误。幸运的是，硬盘会使用<strong>磁盘内纠错码 (ECC)</strong> 来确定块中的磁盘位是否正确，并在某些情况下对其进行修复；如果位不正确，而硬盘又没有足够的信息来修复错误，则在请求读取时磁盘会返回错误信息。</p><p>还有一种情况是，磁盘块损坏的方式无法被磁盘本身检测到。例如，存在漏洞的磁盘固件可能会将块写入错误位置；在这种情况下，磁盘 ECC 显示块内容正常，但从客户端的角度来看，随后访问时会返回错误的块。同样，当数据块通过故障总线从主机传输到磁盘时，也可能会损坏数据块；磁盘会存储损坏的数据，但这些数据并不是客户想要的。这类故障特别隐蔽，因为它们是<strong>静默故障</strong>；磁盘在返回故障数据时不会显示问题。</p><p>Prabhakaran 等人将这种更现代的磁盘故障观点称为部分故障磁盘故障模型。在这种观点中，磁盘仍有可能全部失效（就像传统的故障-停止模型中的情况一样）；但是，磁盘也有可能看似正常工作，但有一个或多个区块变得不可访问（即 LSE）或包含错误的内容（即损坏）。因此，在访问看似正常工作的磁盘时，偶尔会在尝试读取或写入给定块时返回错误（<strong>非静默部分故障</strong>），偶尔也会简单地返回错误数据（<strong>静默部分故障</strong>）。</p><p>这两类故障都比较罕见，但究竟有多罕见呢？下图总结了两份 Bairavasundaram 研究报告的部分结论。</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=small" data-sub-html="<h2>image-20240422202738169</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png alt=image-20240422202738169 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Frequency_Of_LSEs_And_Block_Corruption.png?size=large 2x" data-title=image-20240422202738169 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>该图显示了在研究过程中（约 3 年，超过 150 万台硬盘）至少出现过一次 LSE 或块损坏的硬盘百分比。该图将结果进一步细分为 &ldquo;廉价 &ldquo;硬盘（通常为 SATA 硬盘）和 &ldquo;昂贵 &ldquo;硬盘（通常为 SCSI 或光纤通道硬盘）。正如您所看到的，虽然购买更好的硬盘降低了这两类问题的发生频率（大约降低了一个数量级），但它们仍然经常发生，因此您需要仔细考虑如何在存储系统中处理它们。</p><p>关于 LSE 的一些其他发现包括：</p><ul><li>具有多个 LSE 的昂贵驱动器与较便宜的驱动器一样可能产生额外错误；</li><li>对于大多数驱动器，第二年的年错误率会增加；</li><li>LSE 数量随着磁盘大小的增加而增加；</li><li>大多数磁盘具有LSE 少于 50 个；</li><li>具有 LSE 的磁盘更有可能产生额外的 LSE；</li><li>存在大量的空间和时间局部性；</li><li>磁盘清理很有用（大多数 LSE 都是通过这种方式找到的） 。</li></ul><p>关于损坏的一些发现：</p><ul><li>同一驱动器类别中不同驱动器型号的损坏几率差异很大；</li><li>型号之间的老化影响不同；</li><li>工作负载和磁盘大小对损坏影响很小</li><li>大多数损坏的磁盘只有少数损坏；</li><li>损坏在磁盘内或 RAID 中的磁盘之间不是独立的；</li><li>存在空间局部性和一些时间局部性</li><li>与LSE 的相关性很弱</li></ul><p><font color=red>一个可靠的存储系统，需要有检测和恢复 LSE 和块损坏的机制</font></p><h2 id=处理静默扇区错误lse class=heading-element><span>2 处理静默扇区错误（LSE）</span>
<a href=#%e5%a4%84%e7%90%86%e9%9d%99%e9%bb%98%e6%89%87%e5%8c%ba%e9%94%99%e8%af%aflse class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>考虑到这两种新的部分磁盘故障模式，我们现在应该尝试看看我们可以对它们做些什么。让我们首先解决两者中较容易的一个，即静默扇区错误。</p><blockquote><p>关键问题：存储系统应如何处理静默扇区错误？需要多少额外的机制来处理这种形式的部分故障？</p></blockquote><p>事实证明，静默扇区错误的处理相当简单，因为它们（根据定义）很容易检测到。当存储系统尝试访问块并且磁盘返回错误时，存储系统应该简单地使用它所拥有的任何冗余机制来返回正确的数据。例如，</p><ul><li>在镜像 RAID 中，系统应该访问备用副本；</li><li>在基于奇偶校验的 RAID-4 或 RAID-5 系统中，系统应从奇偶校验组中的其他块重建该块。</li></ul><p>因此，诸如 LSE 等容易检测到的问题可以通过标准冗余机制轻松恢复。</p><p>LSE的不断增多影响了多年来RAID设计。在RAID-4/5系统中，当整个磁盘故障和LSE同时发生时，会出现一个特别有趣的问题。具体而言，在整个磁盘失败时，RAID尝试通过读取奇偶校验组中所有其他磁盘并重新计算缺失值来<strong>重建</strong>该磁盘（比如说，到一个热备用上）。如果在重建过程中，在任何其他一块磁盘上遇到LSE，则会出现问题：无法成功完成重建。</p><p>为了解决这个问题，一些系统增加了额外的冗余度。例如，NetApp的<strong>RAID-DP</strong>相当于两块奇偶校验硬盘而不是一块。当在重建过程中发现LSE时，额外的奇偶校验有助于重构丢失的数据块。正如始终如此地存在成本那样，在每条条带保持两块奇偶校验硬盘更昂贵；然而，NetApp <strong>WAFL</strong>文件系统的日志结构化性质在许多情况下可以减轻这种成本。剩下的成本是空间方面，在第二个奇偶校验区块形式上需要额外一块硬盘。</p><h2 id=检测损坏校验和 class=heading-element><span>3 检测损坏：校验和</span>
<a href=#%e6%a3%80%e6%b5%8b%e6%8d%9f%e5%9d%8f%e6%a0%a1%e9%aa%8c%e5%92%8c class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=基本介绍 class=heading-element><span>3.1 基本介绍</span>
<a href=#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>现在让我们解决更具挑战性的问题，即通过数据损坏导致的静默故障。当数据损坏导致磁盘返回坏数据时，我们如何防止用户获得坏数据？</p><blockquote><p>关键问题：鉴于此类故障的隐匿性，存储系统可以采取哪些措施来检测何时发生损坏？需要什么技术？如何有效地实施它们？</p></blockquote><p>与静默扇区错误不同，损坏检测是一个关键问题。客户端如何知道某个块已经坏了？一旦知道某个特定块损坏，<strong>恢复就与以前相同</strong>：您需要该块的其他副本（希望是一个未损坏的副本！）。因此，我们在这里重点关注<strong>检测技术</strong>。</p><p>现代存储系统用于保持数据完整性的主要机制称为<strong>校验和</strong>。<font color=red>校验和只是一个函数的结果，该函数将一块数据（例如 4KB 块）作为输入，并根据所述数据计算函数，生成数据内容的小摘要（例如 4 或 8 字节），该摘要称为校验和。</font>这种计算的目标是使系统能够通过将校验和与数据一起存储来检测数据是否已被损坏或更改，然后在<strong>以后访问时确认数据的当前校验和与原始存储值相匹配</strong>。</p><h3 id=常用校验和函数 class=heading-element><span>3.2 常用校验和函数</span>
<a href=#%e5%b8%b8%e7%94%a8%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%87%bd%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>许多不同的函数用于计算校验和，它们的强度（即，它们在保护数据完整性方面的能力）和速度（即，它们的计算速度）各不相同。这里出现了系统中常见的权衡：通常，获得的保护越多，成本就越高。</p><p>有些人使用的一种简单的校验和函数是基于异或 (XOR) 的。对于基于 XOR 的校验和，校验和是通过对正在校验和的数据块的每个块进行异或来计算的，从而生成表示整个块的 XOR 的单个值。</p><p>为了更具体地说明这一点，假设我们正在 16 字节的块上计算 4 字节的校验和（这个块当然太小，不能真正成为磁盘扇区或块，但它将用于示例）。 16 个数据字节（十六进制）如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>365e c4cd ba14 8a92 ecef 2c3a 40be f666</span></span></code></pre></td></tr></table></div></div><p>如果用二进制表示，我们会得到以下结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0011 0110 0101 1110 1100 0100 1100 1101
</span></span><span class=line><span class=cl>1011 1010 0001 0100 1000 1010 1001 0010
</span></span><span class=line><span class=cl>1110 1100 1110 1111 0010 1100 0011 1010
</span></span><span class=line><span class=cl>0100 0000 1011 1110 1111 0110 0110 0110</span></span></code></pre></td></tr></table></div></div><p>由于我们以每行 4 个字节为一组排列数据，因此很容易看出校验和的结果：在每列上执行 XOR 即可得到最终的校验和值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0010 0000 0001 1011 1001 0100 0000 0011</span></span></code></pre></td></tr></table></div></div><p>结果（十六进制）为<code>0x201b9403</code>。 XOR 是一种合理的校验和方法，但有其局限性。例如，<font color=red>如果每个校验和单元中同一位置的两个位发生变化，则校验和将无法检测到损坏。</font>为此，人们研究了其他校验和函数。</p><p>另一种基本的校验函数是加法。这种方法的优点是速度快；计算时只需对每块数据执行 2 的补码加法，忽略溢出。它可以检测到数据的许多变化，但如果数据发生移位等情况，则效果不佳。</p><p>Fletcher校验和是一种略微复杂的算法，以John G. Fletcher的名字命名。它的计算非常简单，只需计算两个校验字节 $s_1$ 和 $s_2$。具体来说，假设数据块 $D$ 由字节 $d_1 \dots d_n$ 组成；$s_1$ 的定义如下：$s_1 = (s_1 + d_i) \mod 255$（对所有 $d_i$ 进行计算）；$s_2$ 的定义如下：$s_2 = (s_2 + s_1) \mod 255$（同样对所有 $d_i$ 进行计算）。Fletcher 校验和与 CRC 几乎一样强（见下文），能检测出所有单bit、双bit错误和许多突发错误。</p><p>最后一种常用的校验和称为<strong>循环冗余校验（CRC）</strong>。假设要计算数据块 D 的校验和，只需将 D 视为一个大的二进制数（毕竟只是一串bit），然后除以一个约定的值（$k$）。除数的余数就是 CRC 的值。事实证明，我们可以相当高效地实现这种二进制模运算，因此 CRC 在网络中也很流行。</p><p>无论使用哪种方法，显而易见的是，没有完美的校验和：<font color=red>两个内容不相同的数据块有可能具有完全相同的校验和，这就是所谓的冲突。</font>这个事实应该是直观的：毕竟，计算校验和是把一个大的东西（如 4KB），生成一个小得多的摘要（如 4 或 8 字节）。因此，在选择一个好的校验和函数时，我们试图找到一个既能尽量减少冲突几率，又能保持计算简便的函数。</p><h3 id=校验和布局 class=heading-element><span>3.3 校验和布局</span>
<a href=#%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%b8%83%e5%b1%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>现在您已经了解了如何计算校验和，接下来我们来分析如何在存储系统中使用校验和。我们必须解决的第一个问题是校验和的布局，即校验和应该如何存储在磁盘上？</p><p>最基本的方法只是存储每个磁盘扇区（或块）的校验和。给定一个数据块 D，让我们调用该数据的校验和 <code>C(D)</code>。因此，如果没有校验和，磁盘布局如下所示：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=small" data-sub-html="<h2>image-20240422211734250</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png alt=image-20240422211734250 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_Without_Checksum.png?size=large 2x" data-title=image-20240422211734250 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>使用校验和时，布局会为每个块添加一个校验和：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=small" data-sub-html="<h2>image-20240422211817034</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png alt=image-20240422211817034 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example.png?size=large 2x" data-title=image-20240422211817034 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>由于校验和通常很小（如 8 字节），而磁盘只能以扇区大小的块（512 字节）或其倍数写入，因此出现的一个问题是如何实现上述布局。硬盘制造商采用的一种解决方案是用 520 字节扇区格式化硬盘；每个扇区额外的 8 字节可用于存储校验和。</p><p>对于不具备这种功能的磁盘，文件系统必须想办法将校验和存储到 512 字节的块中。其中一种方法如下：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=small" data-sub-html="<h2>image-20240422211938622</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png alt=image-20240422211938622 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Layout_With_Checksum_Example_1.png?size=large 2x" data-title=image-20240422211938622 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>在此方案中，$n$ 个校验和一起存储在一个扇区中，后面是 $n$ 个数据块，然后是下一个的 $n$ 个块的另一个校验和扇区，依此类推。这种方法的优点是可以在所有磁盘上工作，但效率可能较低；例如，如果文件系统想要覆盖块<code>D1</code>，则必须读入包含<code>C(D1)</code>的校验和扇区，更新其中的<code>C(D1)</code>，然后写出校验和扇区和新的数据块<code>D1</code>（因此，一次读取和两次写入）。早期的方法（每个扇区一个校验和）仅执行一次写入。</p><h3 id=使用校验和 class=heading-element><span>3.4 使用校验和</span>
<a href=#%e4%bd%bf%e7%94%a8%e6%a0%a1%e9%aa%8c%e5%92%8c class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在确定了校验和布局之后，我们就可以着手了解如何使用校验和了。读取数据块 D 时，客户端（即文件系统或存储控制器）也会从磁盘读取其校验和$C_s(D)$，我们称之为<strong>存储校验和</strong>（因此使用了下标 $C_s$）。然后，客户端对检索到的数据块 D 计算校验和，我们称之为<strong>计算校验和</strong> $C_c(D)$。此时，客户端会比较存储的校验和与计算的校验和；如果两者相等（即 $C_s(D) == C_c(D)$），则数据很可能没有损坏，因此可以安全地返回给用户。如果它们不匹配（即 $C_s(D) != C_c(D)$），这意味着数据在存储后发生了变化（因为存储的校验和反映的是数据当时的值）。在这种情况下，我们的校验和帮助我们检测到了数据损坏。</p><p>有了损坏，我们自然会问该如何处理？如果存储系统有冗余副本，答案很简单：尝试使用它。如果存储系统没有这样的副本，答案很可能是返回错误。不管是哪种情况，都要认识到损坏检测并不是灵丹妙药；如果没有其他办法获取未损坏的数据，那就只能走霉运了。</p><h2 id=一个新问题错误写入 class=heading-element><span>4 一个新问题：错误写入</span>
<a href=#%e4%b8%80%e4%b8%aa%e6%96%b0%e9%97%ae%e9%a2%98%e9%94%99%e8%af%af%e5%86%99%e5%85%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>上述基本方案在一般的块损坏情况下效果很好。然而，现代磁盘有几种不同寻常的故障模式，需要不同的解决方案。</p><p>第一种故障模式称为<strong>误写</strong>。磁盘和 RAID 控制器会出现这种情况，它们会将数据正确写入磁盘，只是写错了位置。在单磁盘系统中，这意味着磁盘将数据块 $D_x$ 写入的地址不是 $x$，而是 $y$（从而 &ldquo;破坏 &ldquo;了 $D_y$）；此外，在多磁盘系统中，控制器也可能将 $D_{i,x}$ 写入的地址不是磁盘 $i$ 的 $x$，而是其他磁盘 $j$。因此关键问题是：</p><blockquote><p>存储系统或磁盘控制器应如何检测错误写入？校验和需要哪些附加功能？</p></blockquote><p>答案很简单：在每个校验和中增加一点信息。在这种情况下，增加一个**物理标识符（物理 ID）**是非常有用的。例如，如果现在存储的信息包含校验和 $C(D)$以及块的磁盘编号和扇区编号，那么客户端就很容易确定正确的信息是否存在于特定位置。具体来说，如果客户端读取的是磁盘 $10$ 上的块 $4$（$D_{10,4}$），则存储的信息应包括该磁盘编号和扇区偏移量，如下图所示。如果信息不匹配，就说明发生了错误写入，此时就会检测到损坏。下面是双磁盘系统中添加信息的示例。请注意，该图和之前的其他图一样，并不是按比例绘制的，因为校验和通常很小（如 8 字节），而数据块却大得多（如 4 KB 或更大）：</p><p><a class=lightgallery href="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=large" data-thumbnail="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=small" data-sub-html="<h2>image-20240422213501062</h2>"><img loading=lazy src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png alt=image-20240422213501062 srcset="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=small, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=medium 1.5x, https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Solve_Error_Write_Example.png?size=large 2x" data-title=image-20240422213501062 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>从磁盘上的格式可以看出，磁盘上现在有相当多的冗余信息：对于每个块，磁盘编号在每个数据块内重复出现，而相关块的偏移量也保留在数据块本身旁边。冗余信息的存在不足为奇，因为冗余是错误检测（在本例中）和恢复（在其他情况下）的关键。虽然完美的磁盘并不严格需要一点额外的信息，但如果出现问题，这些信息却能帮助检测出问题所在。</p><h2 id=最后一个问题写入丢失 class=heading-element><span>5 最后一个问题：写入丢失</span>
<a href=#%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98%e5%86%99%e5%85%a5%e4%b8%a2%e5%a4%b1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>不幸的是，错误写入并不是我们要解决的最后一个问题。具体来说，一些现代存储设备还存在一个称为<strong>写入丢失</strong>的问题，当设备通知上层写入已完成但实际上从未被持久化时，就会发生这种情况；因此，剩下的是块的旧内容而不是更新的新内容。</p><p>这里明显的问题是：上面的任何校验和策略（例如基本校验和或物理标识）是否有助于检测丢失的写入？不幸的是，答案是否定的：旧块可能有匹配的校验和，并且上面使用的物理 ID（磁盘号和块偏移量）也将是正确的。</p><p>因此，我们的最后一个关键问题是：</p><blockquote><p>存储系统或磁盘控制器应如何检测丢失的写入？校验和还需要哪些附加功能？</p></blockquote><p>有许多可能的解决方案可以帮助。一种经典方法是执行<strong>写入验证</strong>或<strong>写入后读取</strong>；通过在写入后立即读回数据，系统可以确保数据确实到达磁盘表面。然而，这种方法非常慢，<font color=red>完成写入所需的 I/O 数量会增加一倍</font>。</p><p>有些系统在系统的其他地方添加校验和来检测丢失的写入。例如，Sun 的 Zettabyte 文件系统 (ZFS) 在每个文件系统inode中包含一个校验和，并为文件中包含的每个块提供间接块。因此，即使对块本身的写入丢失，inode 内的校验和也不会与旧数据匹配。只有当对inode和数据的写入同时丢失时，这种方案才会失败，这是一种不太可能（但不幸的是，有可能！）的情况。</p><h2 id=扫描 class=heading-element><span>6 扫描</span>
<a href=#%e6%89%ab%e6%8f%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>说了这么多，你可能会问：这些校验和什么时候会被检查？当然，在应用程序访问数据时会进行一定量的校验，但大多数数据很少被访问，因此会保持未校验状态。对于可靠的存储系统来说，未校验的数据是有问题的，因为bit损坏最终会影响特定数据的所有副本。</p><p>为了解决这个问题，许多系统都采用了各种形式的磁盘扫描。通过定期读取系统中的每个块，并检查校验和是否仍然有效，磁盘系统可以降低某个数据项的所有副本损坏的几率。典型的系统每晚或每周安排一次扫描。</p><h2 id=校验和的开销 class=heading-element><span>7 校验和的开销</span>
<a href=#%e6%a0%a1%e9%aa%8c%e5%92%8c%e7%9a%84%e5%bc%80%e9%94%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在结束之前，我们现在讨论使用校验和进行数据保护的一些开销。正如计算机系统中常见的那样，有两种不同类型的开销：空间和时间。</p><p>空间开销有两种形式。</p><ul><li>第一个是<strong>在磁盘（或其他存储介质）本身上</strong>；每个存储的校验和都会占用磁盘空间，无法再用于存储用户数据。典型的比率可能是每 4 KB 数据块 8 字节校验和，磁盘空间开销为 0.19%。</li><li>第二种类型的空间开销来自<strong>系统的内存</strong>。访问数据时，内存中必须有空间用于存放校验和以及数据本身。但是，如果系统只是检查校验和，然后在完成后将其丢弃，则这种开销是短暂的，不必担心。只有当校验和保存在内存中（为了防止内存损坏的额外保护级别），这个小开销才会被观察到。</li></ul><p>虽然空间开销很小，但校验和引起的时间开销可能非常明显。至少，CPU 必须计算每个块的校验和，无论是在存储数据时（以确定存储的校验和的值）还是在访问数据时（再次计算校验和并将其与存储的校验和进行比较）。许多使用校验和（包括网络栈）的系统采用的一种<font color=red>减少 CPU 开销的方法是将数据复制和校验和合并为一项简化的活动；因为无论如何都需要复制（例如，将数据从内核页缓存复制到用户缓冲区），因此组合复制/校验和可能非常有效。</font></p><p>除了 CPU 开销之外，某些校验和方案还会产生额外的 I/O 开销，特别是当校验和与数据分开存储时（因此需要额外的 I/O 来访问它们），以及后台扫描所需的任何额外 I/O。前者可以通过设计来减少；后者可以进行调整，从而限制其影响，或许可以通过控制此类扫描活动的发生时间来实现（如半夜）。</p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ class=collection-nav-item rel=prev title=基于闪存的SSD><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>基于闪存的SSD</span>
</a><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ class=collection-nav-item rel=next title=分布式系统><span>分布式系统</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-07-28 11:19:19">更新于 2024-07-28&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_develop/_system/ostep/36.%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7%e5%92%8c%e4%bf%9d%e6%8a%a4.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/Lruihao/hugo-blog/edit/docs/content/posts/_develop/_system/ostep/36.%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7%e5%92%8c%e4%bf%9d%e6%8a%a4.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/Lruihao/hugo-blog/issues/new?title=[BUG]%20%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/%7c%0A%7cFilename%7chttps://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_develop/_system/ostep/36.%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7%e5%92%8c%e4%bf%9d%e6%8a%a4.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ data-title=数据完整性和保护 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ data-title=数据完整性和保护><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ data-title=数据完整性和保护><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ class=post-nav-item rel=prev title=分布式系统><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>分布式系统</a>
<a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ class=post-nav-item rel=next title=基于闪存的SSD>基于闪存的SSD<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=Lruihao/hugo-blog data-repo-id="MDEwOlJlcG9zaXRvcnk0MDQzNDY3MDk=" data-category=General data-category-id=DIC_kwDOGBnXVc4CApHL data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.129.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"6BN9L31BND",algoliaIndex:"index",algoliaSearchKey:"03440c0c020a6c0fe73d00bf65b88c2b",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>