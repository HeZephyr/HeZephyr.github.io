<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>地址转换 | ZephyrHe</title><meta name=author content="HeZephyr">
<meta name=author-link content="https://github.com/HeZephyr"><meta name=description content="虚拟化内存使用的通用技术被称为基于硬件的地址转换，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。操作系统必须在关键点参与设置硬件，以便进行正确的转换；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。
所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 CPU（或多个 CPU）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。"><meta name=keywords content='OS'><meta itemprop=name content="地址转换"><meta itemprop=description content="虚拟化内存使用的通用技术被称为基于硬件的地址转换，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。操作系统必须在关键点参与设置硬件，以便进行正确的转换；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。
所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 CPU（或多个 CPU）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。"><meta itemprop=datePublished content="2024-04-25T22:37:32+00:00"><meta itemprop=dateModified content="2024-11-04T12:07:21+00:00"><meta itemprop=wordCount content="5036"><meta itemprop=image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta itemprop=keywords content="OS"><meta property="og:url" content="https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"><meta property="og:site_name" content="ZephyrHe"><meta property="og:title" content="地址转换"><meta property="og:description" content="虚拟化内存使用的通用技术被称为基于硬件的地址转换，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。操作系统必须在关键点参与设置硬件，以便进行正确的转换；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。
所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 CPU（或多个 CPU）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-25T22:37:32+00:00"><meta property="article:modified_time" content="2024-11-04T12:07:21+00:00"><meta property="article:tag" content="OS"><meta property="og:image" content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hezephyr.github.io/images/apple-devices-preview.webp"><meta name=twitter:title content="地址转换"><meta name=twitter:description content="虚拟化内存使用的通用技术被称为基于硬件的地址转换，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。操作系统必须在关键点参与设置硬件，以便进行正确的转换；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。
所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 CPU（或多个 CPU）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。"><meta name=application-name content="Zephyr's Blog"><meta name=apple-mobile-web-app-title content="Zephyr's Blog"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/><link rel=prev href=https://hezephyr.github.io/posts/09.%E5%86%85%E5%AD%98api/><link rel=next href=https://hezephyr.github.io/posts/11.%E6%AE%B5/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"地址转换","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hezephyr.github.io\/posts\/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hezephyr.github.io\/images\/apple-devices-preview.webp","width":2880,"height":1508}],"genre":"posts","keywords":"OS","wordcount":5036,"url":"https:\/\/hezephyr.github.io\/posts\/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\/","datePublished":"2024-04-25T22:37:32+00:00","dateModified":"2024-11-04T12:07:21+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/hezephyr.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"HeZephyr"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=ZephyrHe><img loading=lazy src=/images/logo.png alt=ZephyrHe data-title=ZephyrHe width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>HeZephyr</span></a><span class=header-subtitle>贺志飞的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comments fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-signature fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/HeZephyr/HeZephyr.github.io title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" aria-current=page>地址转换</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details collection-details open"><div class="details-summary collection-summary"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i>
<span class=collection-name data-collections=合集>OSTEP</span>
<span class=collection-count>39</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content collection-content"><nav><ul class=collection-list><li class=collection-item><a href=/posts/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/ title=进程介绍>进程介绍</a></li><li class=collection-item><a href=/posts/02.%E8%BF%9B%E7%A8%8Bapi/ title=进程API>进程API</a></li><li class=collection-item><a href=/posts/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/ title=有限直接执行>有限直接执行</a></li><li class=collection-item><a href=/posts/04.cpu%E8%B0%83%E5%BA%A6/ title=CPU调度>CPU调度</a></li><li class=collection-item><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li><li class=collection-item><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li class=collection-item><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li class=collection-item><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li class=collection-item><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li class=collection-item><span class=active title=地址转换>地址转换</span></li><li class=collection-item><a href=/posts/11.%E6%AE%B5/ title=段>段</a></li><li class=collection-item><a href=/posts/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/ title=空闲空间管理>空闲空间管理</a></li><li class=collection-item><a href=/posts/13.%E9%A1%B5/ title=页>页</a></li><li class=collection-item><a href=/posts/14.%E5%BF%AB%E8%A1%A8/ title=快表>快表</a></li><li class=collection-item><a href=/posts/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8/ title=高级页表>高级页表</a></li><li class=collection-item><a href=/posts/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2/ title=页面交换>页面交换</a></li><li class=collection-item><a href=/posts/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5/ title=交换策略>交换策略</a></li><li class=collection-item><a href=/posts/18.%E5%AE%8C%E6%95%B4vm%E7%B3%BB%E7%BB%9F/ title=完整VM系统>完整VM系统</a></li><li class=collection-item><a href=/posts/19.%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/ title=并发和线程>并发和线程</a></li><li class=collection-item><a href=/posts/20.%E7%BA%BF%E7%A8%8Bapi/ title=线程API>线程API</a></li><li class=collection-item><a href=/posts/21.%E9%94%81/ title=锁>锁</a></li><li class=collection-item><a href=/posts/22.%E9%94%81%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=锁定数据结构>锁定数据结构</a></li><li class=collection-item><a href=/posts/23.%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ title=条件变量>条件变量</a></li><li class=collection-item><a href=/posts/24.%E4%BF%A1%E5%8F%B7%E9%87%8F/ title=信号量>信号量</a></li><li class=collection-item><a href=/posts/25.%E5%B9%B6%E5%8F%91bug/ title=并发bug>并发bug</a></li><li class=collection-item><a href=/posts/26.%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91/ title=基于事件的并发>基于事件的并发</a></li><li class=collection-item><a href=/posts/27.io%E8%AE%BE%E5%A4%87/ title=IO设备>IO设备</a></li><li class=collection-item><a href=/posts/28.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8/ title=硬盘驱动器>硬盘驱动器</a></li><li class=collection-item><a href=/posts/29.%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97/ title=廉价磁盘冗余阵列>廉价磁盘冗余阵列</a></li><li class=collection-item><a href=/posts/30.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/ title=文件和目录>文件和目录</a></li><li class=collection-item><a href=/posts/31.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/ title=文件系统实现>文件系统实现</a></li><li class=collection-item><a href=/posts/32.%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=快速文件系统>快速文件系统</a></li><li class=collection-item><a href=/posts/33.fsck%E5%92%8C%E6%97%A5%E5%BF%97/ title=FSCK和日志>FSCK和日志</a></li><li class=collection-item><a href=/posts/34.%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=日志结构文件系统>日志结构文件系统</a></li><li class=collection-item><a href=/posts/35.%E5%9F%BA%E4%BA%8E%E9%97%AA%E5%AD%98%E7%9A%84ssd/ title=基于闪存的SSD>基于闪存的SSD</a></li><li class=collection-item><a href=/posts/36.%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E4%BF%9D%E6%8A%A4/ title=数据完整性和保护>数据完整性和保护</a></li><li class=collection-item><a href=/posts/37.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ title=分布式系统>分布式系统</a></li><li class=collection-item><a href=/posts/38.%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=网络文件系统>网络文件系统</a></li><li class=collection-item><a href=/posts/39.andrew%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ title=Andrew文件系统>Andrew文件系统</a></li></ul><div class=collection-nav-simple><a href=/posts/09.%E5%86%85%E5%AD%98api/ class=collection-nav-item rel=prev title=内存API><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i></a><span class=text-secondary>10/39</span><a href=/posts/11.%E6%AE%B5/ class=collection-nav-item rel=next title=段><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></nav></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>地址转换</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/HeZephyr title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://cn.gravatar.com/avatar/65f6ab71abcb9d540eb32a2704884927?s=32&amp;d=mp" alt=HeZephyr data-title=HeZephyr width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;HeZephyr</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/ class=post-category title="分类 - 系统架构"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 系统架构</a> 和 <a href=/collections/ostep/ class=post-collection title="合集 - OSTEP"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> OSTEP</a></span></div><div class=post-meta-line><span title="发布于 2024-04-25 22:37:32"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-04-25>2024-04-25</time></span>&nbsp;<span title="更新于 2024-11-04 12:07:21"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-11-04>2024-11-04</time></span>&nbsp;<span title="5036 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5100 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 11 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=地址转换>
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#假设第一次尝试>假设（第一次尝试）</a></li><li><a href=#例子>例子</a></li><li><a href=#动态基于硬件重定位>动态（基于硬件）重定位</a></li><li><a href=#内存虚拟化的操作系统问题>内存虚拟化的操作系统问题</a></li><li><a href=#总结>总结</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub与CSDN，持续更新，求关注、求 star、求订阅！」"><p>虚拟化内存使用的通用技术被称为<font color=red>基于硬件的地址转换</font>，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。<font color=red>操作系统必须在关键点参与设置硬件，以便进行正确的转换</font>；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。</p><p>所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 CPU（或多个 CPU）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。</p><h2 id=假设第一次尝试 class=heading-element><span>1 假设（第一次尝试）</span>
<a href=#%e5%81%87%e8%ae%be%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%b0%9d%e8%af%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ol><li>用户地址空间在内存中是连续的</li><li>用户地址空间小于物理内存（最大64KB）</li><li>每个地址空间具有相同的大小（最大16KB）</li></ol><h2 id=例子 class=heading-element><span>2 例子</span>
<a href=#%e4%be%8b%e5%ad%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>我们看一个简单的例子。假设有一个进程，其地址空间如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/example-1-address-space.png alt=image-20240330155414617 style=zoom:67%><p>我们要研究的是一个简短的代码序列：从内存中加载一个值，将其增加 3，然后将该值存储回内存中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>3000</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// this is the line of code we are interested in
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span></span></span></code></pre></td></tr></table></div></div><p>编译器将这行代码转换为汇编语言，可能看起来像这样（在 x86 汇编语言中）。在 Linux 上使用 objdump 或在 Mac 上使用 otool 来反汇编它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>128:</span> <span class=nf>movl</span> <span class=mi>0x0</span><span class=p>(</span><span class=nv>%ebx</span><span class=p>),</span> <span class=nv>%eax</span> <span class=c1>;load 0+ebx into eax
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>132:</span> <span class=nf>addl</span> <span class=no>$0x03</span><span class=p>,</span> <span class=nv>%eax</span> <span class=c1>;add 3 to eax register
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>135:</span> <span class=nf>movl</span> <span class=nv>%eax</span><span class=p>,</span> <span class=mi>0x0</span><span class=p>(</span><span class=nv>%ebx</span><span class=p>)</span> <span class=err>;</span><span class=no>store</span> <span class=no>eax</span> <span class=no>back</span> <span class=no>to</span> <span class=no>mem</span></span></span></code></pre></td></tr></table></div></div><p>这段代码相对简单；它假定 x 的地址已放入寄存器 ebx 中，然后使用 movl 指令（用于“长字”移动）将该地址处的值加载到通用寄存器 eax 中。下一条指令将 eax 加 3，最后一条指令将 eax 中的值存储回内存中的同一位置。</p><p>在上图中，观察代码和数据在进程地址空间中的布局方式；三指令代码序列位于地址 128（在靠近顶部的代码段中），变量 x 的值位于地址 15 KB（在靠近底部的堆栈中）。图中，x的初始值为3000，如其在堆栈中的位置所示。当这些指令运行时，从进程的角度来看，会发生以下内存访问。</p><ol><li>取地址 128 的指令</li><li>执行该指令（从地址 15 KB 加载）</li><li>取地址 132 的指令 - 执行该指令（无内存引用）</li><li>取地址 135 的指令</li><li>执行该指令（存储到地址 15 KB）</li></ol><p>从程序的角度来看，它的地址空间从地址0开始，最大增长到16KB；它生成的所有内存引用都应该在这些范围内。然而，为了虚拟化内存，操作系统希望将进程放置在物理内存中的其他位置，而不一定是地址0。因此，我们遇到了问题：如何以对进程透明的方式在内存中重新定位该进程？当实际上地址空间位于其他物理地址时，我们如何提供从 0 开始的虚拟地址空间的假象？</p><p>下图展示了进程的地址空间放入内存后物理内存可能是什么样子。在图中，您可以看到操作系统为自己使用物理内存的第一个插槽，并且它已将上例中的进程重新定位到从物理内存地址 32 KB 开始的插槽中。另外两个插槽是空闲的（16 KB-32 KB 和 48 KB-64 KB）。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/A-Single-Relocated-Process.png alt=image-20240330160829720 style=zoom:67%><h2 id=动态基于硬件重定位 class=heading-element><span>3 动态（基于硬件）重定位</span>
<a href=#%e5%8a%a8%e6%80%81%e5%9f%ba%e4%ba%8e%e7%a1%ac%e4%bb%b6%e9%87%8d%e5%ae%9a%e4%bd%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>为了对基于硬件的地址转换有一定的了解，我们首先讨论它的第一个版本。 1950 年代末的第一台分时机中引入了一个简单的概念，称为<strong>基数和边界</strong>；该技术也称为动态重定位；我们将交替使用这两个术语。</p><p>具体来说，每个 CPU 中我们需要两个硬件寄存器：一个称为<strong>基址寄存器</strong>，另一个称为<strong>边界寄存器</strong>（有时称为限制寄存器）。这个基址和边界对将允许我们将地址空间放置在物理内存中的任何位置，并同时确保进程只能访问自己的地址空间。</p><p>在此设置中，每个程序都被编写和编译，就好像它被加载到地址零一样。但是，当程序开始运行时，操作系统会决定应将其加载到物理内存中的何处，并将基址寄存器设置为该值。</p><p>在上面的示例中，操作系统决定在物理地址 32 KB 处加载进程，从而将基址寄存器设置为该值，如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/Base-and-Bounds-Registers.png alt=image-20240330161356604 style=zoom:67%><p>当进程运行时，有趣的事情开始发生。现在，当进程生成任何内存引用时，处理器会按以下方式对其进行转换：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>physical</span> <span class=n>address</span> <span class=o>=</span> <span class=n>virtual</span> <span class=n>address</span> <span class=o>+</span> <span class=n>base</span></span></span></code></pre></td></tr></table></div></div><p>进程生成的每个内存引用都是一个虚拟地址；硬件依次将基址寄存器的内容添加到该地址，结果是内存系统的物理地址。</p><p>为了更好地理解这一点，让我们追踪一下执行单个指令时会发生什么。具体来说，让我们看一下前面序列中的一条指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>asm 128: movl 0x0(%ebx), %eax</span></span></code></pre></td></tr></table></div></div><p>程序计数器 (PC) 设置为 128；当硬件需要取该指令时，首先将该值与基址寄存器值32 KB（32768）相加，得到物理地址32896；然后硬件从该物理地址获取指令。</p><p>接下来，处理器开始执行指令。在某个时刻，进程会从虚拟地址 15 KB 发出加载，处理器将其获取并再次添加到基址寄存器 (32 KB)，从而获得 47 KB 的最终物理地址，从而获得所需的内容。</p><p>将虚拟地址转换为物理地址正是我们所说的地址转换技术；也就是说，硬件获取进程认为它正在引用的虚拟地址，并将其转换为数据实际驻留的物理地址。因为这种地址重定位发生在运行时，并且即使在进程开始运行后我们也可以移动地址空间，所以该技术通常称为动态重定位。</p><p>现在您可能会问：边界（限制）寄存器发生了什么，起到了什么作用？毕竟，这不是基数和边界方法吗？它的确是。正如您可能已经猜到的，边界寄存器是为了帮助保护。具体来说，处理器会首先检查内存引用是否在范围内，以确保它是合法的；在上面的简单示例中，边界寄存器将始终设置为 16 KB。如果进程生成的虚拟地址大于边界，或者为负数，CPU 将引发异常，并且该进程可能会被终止。因此，<strong>边界的目的是确保进程生成的所有地址都是合法的并且在进程的“边界”内。</strong></p><p>我们应该注意，基址寄存器和边界寄存器是保存在芯片上的硬件结构（每个 CPU 一对）。有时人们将处理器中帮助进行地址转换的部分称为<strong>内存管理单元（MMU）</strong>；随着我们开发更复杂的内存管理技术，我们将为 MMU 添加更多电路。如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/MMU-CPU.png alt=image-20240330162215655 style=zoom:67%><p>为了更详细地理解通过基址和边界进行的地址转换，让我们来看一个例子。想象一下，一个地址空间大小为 4 KB的进程被加载到物理地址 16 KB。下面是一些地址转换的结果：</p><table><thead><tr><th style=text-align:center>Virtual Address</th><th style=text-align:center>Physical Address</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>16 KB</td></tr><tr><td style=text-align:center>1 KB</td><td style=text-align:center>17 KB</td></tr><tr><td style=text-align:center>3000</td><td style=text-align:center>19384</td></tr><tr><td style=text-align:center>4400</td><td style=text-align:center>Fault (Out of Bounds)</td></tr></tbody></table><p>从示例中可以看出，只需将基地址与虚拟地址相加（可以正确地将其视为地址空间的偏移量），就可以轻松得到物理地址。只有当虚拟地址 &ldquo;过大 &ldquo;或为负数时，结果才会是一个错误，从而引发异常。</p><h2 id=内存虚拟化的操作系统问题 class=heading-element><span>4 内存虚拟化的操作系统问题</span>
<a href=#%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%8c%96%e7%9a%84%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e9%97%ae%e9%a2%98 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>正如硬件提供了支持动态重定位的新功能一样，操作系统现在也有必须处理的新问题；硬件支持和操作系统管理的结合导致了简单虚拟内存的实现。具体来说，有几个关键时刻，操作系统必须参与其中，以实现我们的虚拟内存的基址和边界版本。</p><p>首先，操作系统必须在创建进程时采取行动，为其在内存中的地址空间找到空间。幸运的是，考虑到我们假设每个地址空间（a）小于物理内存的大小以及（b）相同的大小，这对于操作系统来说非常容易；它可以简单地将物理内存视为一组插槽，并跟踪每个插槽是否空闲或正在使用。创建新进程时，操作系统必须搜索数据结构（通常称为空闲列表）来为新地址空间找到空间，然后将其标记为已使用。对于可变大小的地址空间，情况会更加复杂。</p><p>让我们看一个例子。如下图所示，您可以看到操作系统为自己使用物理内存的第一个插槽，并且它已将上面示例中的进程重新定位到从物理内存地址 32 KB 开始的插槽中。另外两个插槽是空闲的（16 KB-32 KB 和 48 KB-64 KB）；因此，空闲列表应该由这两个条目组成。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/find-a-room-for-space.png alt=image-20240330183212194 style=zoom:67%><p>第二，当进程终止时（即，当它正常退出或由于行为不当而被强制终止时），操作系统必须做一些工作，回收其所有内存以供其他进程或操作系统使用。进程终止后，操作系统会将其内存放回到空闲列表中，并根据需要清理任何关联的数据结构，如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/free-list-result.png alt=image-20240330183416066 style=zoom:67%><p>第三，当发生上下文切换时，操作系统还必须执行一些额外的步骤。毕竟，每个 CPU 上只有一对基址和边界寄存器，并且每个正在运行的程序的值都不同，因为每个程序都加载到内存中不同的物理地址。因此，操作系统在进程之间切换时必须保存和恢复基址和边界对。</p><p>具体来说，当操作系统决定停止运行某个进程时，它必须将基址寄存器和边界寄存器的值保存到内存中的某些每个进程的结构中，例如<strong>进程结构或进程控制块 (PCB)</strong>。同样，当操作系统恢复正在运行的进程（或第一次运行它）时，它必须将 CPU 上的基数和边界值设置为该进程的正确值，如下图所示。</p><img src=https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/save-and-restore.png alt=image-20240330183535861 style=zoom:67%><p>我们应该注意到，当进程停止（即不运行）时，操作系统可以很容易地将地址空间从内存中的一个位置移动到另一个位置。要移动进程的地址空间，操作系统首先会对进程取消调度；然后，操作系统会将地址空间从当前位置复制到新位置；最后，操作系统会更新（进程结构中的）保存基址寄存器，使其指向新位置。当进程恢复时，它的（新）基址寄存器会被恢复，然后它又开始运行，全然不顾它的指令和数据现在在内存中一个全新的位置。</p><p>第四，如上所述，操作系统必须提供<strong>异常处理程序</strong>或调用函数；操作系统在启动时（通过特权指令）安装这些处理程序。例如，如果一个进程试图访问超出其边界的内存，CPU 就会引发异常；操作系统必须做好准备，在出现这种异常时采取行动。操作系统的通常反应是敌意：它可能会终止违规进程。操作系统应高度保护它所运行的机器，因此它不会善待试图访问内存或执行不该执行指令的进程。</p><p>下表以时间轴的形式展示了硬件与操作系统之间的交互。表中显示了操作系统在启动时为准备使用机器所做的工作，以及进程（进程 A）开始运行时发生的情况；请注意其内存转换是如何在没有操作系统干预的情况下由硬件处理的。此时，操作系统必须介入，终止进程并清理 B 的内存，将其从进程表中删除。从表中可以看出，我们仍然遵循<strong>有限直接执行</strong>的基本方法。在大多数情况下，操作系统只需适当设置硬件，让进程直接在 CPU 上运行；只有当进程出现异常时，操作系统才会介入。</p><table><thead><tr><th>OS @ boot (kernel mode)</th><th>Hardware</th><th>Program (user mode)</th></tr></thead><tbody><tr><td>初始化中断表</td><td>记住系统调用处理程序、定时器处理程序 、非法内存访问处理程序、非法指令处理程序&mldr;&mldr;的地址</td><td>-</td></tr><tr><td>启动中断定时器</td><td>启动计时器；X 毫秒后中断</td><td>-</td></tr><tr><td>初始化进程表；初始化空闲列表</td><td>-</td><td>-</td></tr><tr><td><strong>OS @ run (kernel mode)</strong></td><td><strong>Hardware</strong></td><td><strong>Program (user mode)</strong></td></tr><tr><td>启动进程 A： 分配进程表中的条目；为进程分配内存；设置基准/边界寄存器 ；从中断返回（进入 A）</td><td>-</td><td>-</td></tr><tr><td></td><td>恢复 A 的寄存器；移动到用户模式；跳转到 A 的（初始）PC</td><td>进程 A 运行；取指令</td></tr><tr><td></td><td>转换虚拟地址并执行提取</td><td>执行指令</td></tr><tr><td></td><td>如果是显式加载/存储：确保地址在边界内；转换虚拟地址并执行加载/存储</td><td></td></tr><tr><td></td><td>定时器中断转入内核模式；跳转到中断处理程序</td><td></td></tr><tr><td>处理中断； 调用 switch() 例程 ；将 regs(A) 保存到 proc-struct(A)（包括基址/边界） ；从 proc-struct(B)（包括基址/边界）恢复 regs(B) ；从中断返回 (进入B）</td><td></td><td></td></tr><tr><td></td><td>恢复B的寄存器；转移到用户模式； 跳转到B的PC</td><td></td></tr><tr><td></td><td></td><td>进程B运行；执行错误加载</td></tr><tr><td></td><td>加载越界；转入内核模式，跳转到中断处理程序</td><td></td></tr><tr><td>处理中断；决定终止进程 B；释放 B 的内存；释放 B 在进程表中的条目</td><td></td><td></td></tr></tbody></table><h2 id=总结 class=heading-element><span>5 总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在本章中，我们用虚拟内存中使用的一种特定机制（即<strong>地址转换</strong>）扩展了有限直接执行的概念。通过地址转换，操作系统可以控制进程的每次内存访问，确保访问不超出地址空间的范围。硬件支持是这项技术高效的关键，它能为每次访问快速执行转换，将虚拟地址（进程对内存的看法）转换为物理地址（实际看法）。所有这些都是以对被重定位的进程透明的方式进行的，进程根本不知道其内存引用正在被转换，这就造成了一种奇妙的错觉。</p><p>我们还看到了一种特殊形式的虚拟化，即基址边界虚拟化或动态重定位。基址边界虚拟化相当高效，因为只需要多一点硬件逻辑，就能在虚拟地址中添加一个基址寄存器，并检查进程生成的地址是否在边界内。基址边界虚拟化还能提供保护；操作系统和硬件相结合，确保任何进程都无法在自身地址空间之外生成内存引用。保护无疑是操作系统最重要的目标之一；如果没有保护，操作系统就无法控制机器（如果进程可以随意覆盖内存，它们就能轻易做出一些令人讨厌的事情，比如覆盖中断表并接管系统）。</p><p>不过，这种简单的动态重定位技术确实存在效率低下的问题。例如，如上图所示，重定位后的进程使用的物理内存从 32 KB 增加到 48 KB，但由于进程堆栈和堆并不太大，两者之间的所有空间都被浪费掉了。这种浪费通常被称为<font color=red>内部碎片</font>，因为分配单元内部的空间没有被全部使用（即被碎片化），从而造成浪费。在我们目前的方法中，虽然可能有足够的物理内存来容纳更多进程，但我们目前只能将地址空间放置在固定大小的插槽中，因此可能会出现内部碎片。因此，我们需要更复杂的机制来更好地利用物理内存，避免内部碎片。</p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/ title=地址空间>地址空间</a></li><li><a href=/posts/07.%E5%A4%9Acpu%E8%B0%83%E5%BA%A6/ title=多CPU调度>多CPU调度</a></li><li><a href=/posts/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6/ title=比例份额调度>比例份额调度</a></li><li><a href=/posts/09.%E5%86%85%E5%AD%98api/ title=内存API>内存API</a></li><li><a href=/posts/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/ title=多级反馈队列>多级反馈队列</a></li></ul><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img loading=lazy src=/images/alipay.png alt="HeZephyr 支付宝" data-title="HeZephyr 支付宝" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.jpg alt="HeZephyr 微信" data-title="HeZephyr 微信" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span data-animation>微信</span></div></div></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/ostep/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・OSTEP</span></span></a> 39</div><div class=collection-nav><a href=/posts/09.%E5%86%85%E5%AD%98api/ class=collection-nav-item rel=prev title=内存API><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>内存API</span>
</a><a href=/posts/11.%E6%AE%B5/ class=collection-nav-item rel=next title=段><span>段</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-11-04 12:07:21">更新于 2024-11-04&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/10.%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/HeZephyr/HeZephyr.github.io/edit/docs/content/posts/_develop/_system/ostep/10.%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/HeZephyr/HeZephyr.github.io/issues/new?title=[BUG]%20%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%7c%0A%7cURL%7chttps://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/%7c%0A%7cFilename%7chttps://github.com/HeZephyr/HeZephyr.github.io/blob/docs/content/posts/_develop/_system/ostep/10.%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ data-title=地址转换 data-hashtags=OS><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ data-hashtag=OS><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ data-title=地址转换><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://hezephyr.github.io/posts/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/ data-title=地址转换><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/os/ class=post-tag title="标签 - OS">OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/11.%E6%AE%B5/ class=post-nav-item rel=prev title=段><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>段</a>
<a href=/posts/09.%E5%86%85%E5%AD%98api/ class=post-nav-item rel=next title=内存API>内存API<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=HeZephyr/HeZephyr.github.io data-repo-id=R_kgDOMb2HgQ data-category=General data-category-id=DIC_kwDOMb2Hgc4ChPAb data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.136.5"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.9-RC"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2020 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/HeZephyr target=_blank rel="external nofollow noopener noreferrer">HeZephyr</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-first"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/HeZephyr title="View on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/js/flyfish.js defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:50},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!1,left:"$",right:"$"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{algoliaAppID:"LKM6MKQ6NB",algoliaIndex:"index",algoliaSearchKey:"c9bb91e3a1318f3c9efae98daa87bca5",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2020-06-10T15:42:01+08:00",version:"v0.3.9-RC",watermark:{colspacing:30,content:'<img style="height: 0.85rem;" src="/logo.png" alt="logo" /> 贺志飞',enable:!0,fontfamily:"LiuJianMaoCao-Regular, 钟齐流江毛草",fontsize:1.1,height:20,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>